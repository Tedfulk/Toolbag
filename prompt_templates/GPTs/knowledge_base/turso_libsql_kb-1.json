[
  {
    "title": "Create Group Token | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/mint-token",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APICreate Group Token Create Group Token Create an auth token for a group. The returned token: Can't be retrieved again; there is no record kept of it by Turso Can't be revoked individually. User Groups​ POST /v1/groups/:group/auth/tokens Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Query String Parameters​ Parameter Required Description expiration no Duration of the token until expiration as parsed by go-str2duration, or never (default); for example: 1w2d6h3ns (1 week 2 days 6 hours and 3 nanoseconds) authorization no Level of access granted to the bearer of the token; read-only or full-access (default) Example​ curl  --request POST  --location 'https://api.turso.tech/v1/groups/some_group/auth/tokens?expiration=1d&authorization=read-only'  --header 'Authorization: Bearer TOKEN' { \"jwt\": \"TOKEN\" } Organization Groups​ POST /v1/organizations/:organization/groups/:group/auth/tokens Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description organization string The organization name. Query String Parameters​ Parameter Required Description expiration no Duration of the token until expiration as parsed by go-str2duration, or never (default); for example: 1w2d6h3ns (1 week 2 days 6 hours and 3 nanoseconds) authorization no Level of access granted to the bearer of the token; read-only or full-access (default) Example​ curl  --request POST  --location 'https://api.turso.tech/v1/organizations/some_org/groups/some_group/auth/tokens?expiration=1d&authorization=read-only'  --header 'Authorization: Bearer TOKEN' { \"jwt\": \"TOKEN\" } Previous Remove location from a group Next Invalidate Group Tokens User Groups Headers Query String Parameters Example Organization Groups Headers Path Parameters Query String Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Remove location from a group | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/remove-location",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APIRemove location from a group Remove location from a group Remove a location from a group for a specific user or organization. User Groups​ DELETE /v1/groups/:group/locations/:location Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description group string The group name. location string The three letter location code to be removed from the group. Example​ curl  --location --request DELETE 'https://api.turso.tech/v1/groups/default/locations/bos'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"foo\", \"locations\": [\"fra\", \"lhr\"], \"primary\": \"fra\" } } Organization Groups​ DELETE /v1/organizations/:organization/groups/:group/locations/:location Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description organization string The organization name. group string The group name. location string The three letter location code to be added to the group. Example​ curl  --location --request DELETE 'https://api.turso.tech/v1/organizations/some_org/groups/default/locations/bos'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"default\", \"locations\": [\"fra\", \"lhr\", \"bos\"], \"primary\": \"fra\" } } Previous Add location to a group Next Create Group Token User Groups Headers Path Parameters Example Organization Groups Headers Path Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Add location to a group | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/add-location",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APIAdd location to a group Add location to a group Add a location to a group for a specific user or organization. User Groups​ POST /v1/groups/:group/locations/:location Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description group string The group name. location string The three letter location code to be added to the group. Example​ curl  --location --request POST 'https://api.turso.tech/v1/groups/default/locations/bos'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"default\", \"locations\": [\"fra\", \"lhr\", \"bos\"], \"primary\": \"fra\" } } Organization Groups​ POST /v1/organizations/:organization/groups/:group/locations/:location Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description organization string The organization name. group string The group name. location string The three letter location code to be added to the group. Example​ curl  --location --request POST 'https://api.turso.tech/v1/organizations/some_org/groups/default/locations/bos'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"default\", \"locations\": [\"fra\", \"lhr\", \"bos\"], \"primary\": \"fra\" } } Previous Delete Group Next Remove location from a group User Groups Headers Path Parameters Example Organization Groups Headers Path Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Delete Group | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/delete-group",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APIDelete Group Delete Group Delete a group for a specific user or organization. User Groups​ DELETE /v1/groups/:group Headers​ Header Example Description Accept application/json The data requested should be JSON. Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description group string The group name. Example​ curl  --location --request DELETE 'https://api.turso.tech/v1/groups/group2'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"foo\", \"locations\": [\"fra\"], \"primary\": \"fra\" } } Organization Groups​ DELETE /v1/organizations/:organization/groups/:group Headers​ Header Example Description Accept application/json The data requested should be JSON. Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description organization string The organization name. group string The group name. Example​ curl  --location --request DELETE 'https://api.turso.tech/v1/organizations/some_org/groups/group2'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"locations\": [\"lhr\"], \"name\": \"group2\", \"primary\": \"lhr\" } } Previous Retrieve Group Next Add location to a group User Groups Headers Path Parameters Example Organization Groups Headers Path Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Retrieve Group | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/retrieve-group",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APIRetrieve Group Retrieve Group Returns a single group and its locations by name for a specific user or organization. User Groups​ GET /v1/groups/:group Headers​ Header Example Description Accept application/json The data requested should be JSON. Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description group string The group name. Example​ curl  --location 'https://api.turso.tech/v1/groups/default'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"default\", \"locations\": [\"fra\"], \"primary\": \"fra\" } } Organization Groups​ GET /v1/organizations/:organization/groups/:group Headers​ Header Example Description Accept application/json The data requested should be JSON. Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description organization string The organization name. group string The group name. Example​ curl  --location --request POST 'https://api.turso.tech/v1/organizations/some_org/groups/default'  --header 'Authorization: Bearer TOKEN' { \"group\": { \"name\": \"default\", \"locations\": [\"fra\"], \"primary\": \"fra\" } } Previous Create Group Next Delete Group User Groups Headers Path Parameters Example Organization Groups Headers Path Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Create Group | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/create-group",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APICreate Group Create Group Create a group for a specific user or organization. User Groups​ POST /v1/groups Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Content-Type application/json The data sent must be JSON. Request Body​ Field Type Description name string The group name. location [location] A valid supported location name. Example​ curl  --location 'https://api.turso.tech/v1/groups'  --header 'Authorization: Bearer TOKEN'  --header 'Content-Type: application/json'  --data '{ \"name\": \"group2\", \"location\": \"lhr\" }' { \"group\": { \"locations\": [\"lhr\"], \"name\": \"group2\", \"primary\": \"lhr\" } } Organization Groups​ POST /v1/organizations/:organization/groups Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Content-Type application/json The data sent must be JSON. Path Parameters​ Parameter Type Description organization string The organization name. Request Body​ Field Type Description name string The group name. location [location] A valid supported location name. Example​ curl  --location 'https://api.turso.tech/v1/organizations/some_org/groups'  --header 'Authorization: Bearer TOKEN'  --header 'Content-Type: application/json'  --data '{ \"name\": \"group2\", \"location\": \"lhr\" }' { \"group\": { \"locations\": [\"lhr\"], \"name\": \"group2\", \"primary\": \"lhr\" } } Previous List Groups Next Retrieve Group User Groups Headers Request Body Example Organization Groups Headers Path Parameters Request Body Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "List Groups | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/list-groups",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APIList Groups List Groups Returns a list of groups and the assigned locations. User Groups​ GET /v1/groups Headers​ Header Example Description Accept application/json The data requested should be JSON. Authorization Bearer TOKEN The platform or user auth TOKEN. Example​ curl  --location 'https://api.turso.tech/v1/groups'  --header 'Authorization: Bearer TOKEN' { \"groups\": [ { \"locations\": [\"bos\", \"lhr\"], \"name\": \"default\", \"primary\": \"lhr\" } ] } Organization Groups​ GET /v1/organizations/:organization/groups This endpoint retrieves groups that are specific to an organization. Headers​ Header Example Description Accept application/json The data requested should be JSON. Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Header Type Description organization string The organization name. Example​ curl  --location 'https://api.turso.tech/v1/organizations/some_org/groups'  --header 'Authorization: Bearer TOKEN' { \"groups\": [ { \"locations\": [\"lhr\"], \"name\": \"default\", \"primary\": \"lhr\" } ] } Previous Groups API Next Create Group User Groups Headers Example Organization Groups Headers Path Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Wait for an instance to become ready in a logical database | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/instance/wait-instance-ready-in-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Wait for an instance to become ready in a logical database Summary​ Description: Waits for an instance to be able to receive a query. Typically invoked immediately after an instance is created to know when it's ready for use. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. The instance is identified by the name it was assigned by the API at the time it was created. Path: /v1/organizations/:org_slug/databases/:db_name/instances/:instance_name/wait Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the logical database db_name Name of the logical database containing the instance instance_name Name of the database instance to wait for Output​ None. The API sends an empty response with HTTP status 200 when the instance is ready to receive queries. Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/instances/my-instance/wait\" Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Destroy an instance in a logical database | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/instance/destroy-instance-in-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Get all instances in a logical database Get an instance in a logical database Create an instance in a logical database Destroy an instance in a logical database Groups API Integration with Postgres Turso Platform REST APIDatabase instance APIDestroy an instance in a logical database Destroy an instance in a logical database Summary​ Description: Destroys an instance in a logical database in an organization. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The named instance must already exist in the named database. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. The instance is identified by the name it was assigned by the API at the time it was created. Analogous CLI command: turso db destroy [db_name] --instance [instance_name] INFO The CLI allows you to destroy instances by their location with the command turso db destroy [db_name] --location [location_code], but the API does not offer this function directly. The implementation of the CLI first gets a list of database instances, then destroys the individual instances that match the provided location code. Path: /v1/organizations/:org_slug/databases/:db_name/instances/:instance_name Method: DELETE Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the logical database db_name Name of the logical database containing the instance instance_name Name of the database instance to destroy Output​ JSON body properties: Property Type Description instance string The name of the destroyed instance Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/instances/my-instance\" { \"instance\": \"my-instance\" } Previous Create an instance in a logical database Next Groups API Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Create an instance in a logical database | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/instance/create-instance-in-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Get all instances in a logical database Get an instance in a logical database Create an instance in a logical database Destroy an instance in a logical database Groups API Integration with Postgres Turso Platform REST APIDatabase instance APICreate an instance in a logical database Create an instance in a logical database Summary​ Description: Creates an instance in a logical database in an organization. The first instance created becomes the primary instance for that database and can't be destroyed later. Each instance must be provisioned in a location identified with a location code. Get a list of location codes using the Location API. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. Analogous CLI command: turso db replicate [db_name] [location] Path: /v1/organizations/:org_slug/databases/:db_name/instances Method: POST Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the logical database db_name Name of the logical database to contain the new instance JSON body properties: Property Required Description location yes The location code for the location of the instance image no Type of database image to use; latest (default) or canary Output​ JSON body properties: Property Type Description instance object A database instance object that describes the newly created instance. Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/instances\"  -d '{\"location\": \"ord\", \"image\": \"latest\"}' { \"instance\": { \"uuid\": \"a3446118-ea9d-11ed-a213-a2c7dbd646dc\", \"name\": \"my-instance\", \"type\": \"primary\", \"region\": \"sjc\", \"hostname\": \"3287469dae4185-my-db-my-org.turso.io\" }, \"password\": \"[password]\", \"username\": \"[username]\" } Previous Get an instance in a logical database Next Destroy an instance in a logical database Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get an instance in a logical database | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/instance/get-instance-in-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Get all instances in a logical database Get an instance in a logical database Create an instance in a logical database Destroy an instance in a logical database Groups API Integration with Postgres Turso Platform REST APIDatabase instance APIGet an instance in a logical database Get an instance in a logical database Summary​ Description: Returns all instances in a logical database in an organization. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The named instance must already exist in the named database. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. Analogous CLI command: turso db show [db_name] Path: /v1/organizations/:org_slug/databases/:db_name/instances/:instance_name Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the logical database db_name Name of the logical database containing the instances instance_name Name of the instance to get Output​ JSON body properties: Property Type Description instance object A database instance object Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/instances/my-instance\" { \"instance\": { \"uuid\": \"424a1738-cef9-11ed-b40d-c68341370672\", \"name\": \"my-instance\", \"type\": \"primary\", \"region\": \"ord\", \"hostname\": \"e784ee57c52d83-my-db-my-org.turso.io\" } } Previous Get all instances in a logical database Next Create an instance in a logical database Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get all instances in a logical database | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/instance/get-instances-in-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Get all instances in a logical database Get an instance in a logical database Create an instance in a logical database Destroy an instance in a logical database Groups API Integration with Postgres Turso Platform REST APIDatabase instance APIGet all instances in a logical database Get all instances in a logical database Summary​ Description: Returns all instances in a logical database in an organization. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. Analogous CLI command: turso db show [db_name] Path: /v1/organizations/:org_slug/databases/:db_name/instances Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the logical database db_name Name of the logical database containing the instances Output​ JSON body properties: Property Type Description instances array An array of database instance objects with all instances. Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/instances\" { \"instances\": [ { \"uuid\": \"424a1738-cef9-11ed-b40d-c68341370672\", \"name\": \"my-instance\", \"type\": \"primary\", \"region\": \"ord\", \"hostname\": \"e784ee57c52d83-my-db-my-org.turso.io\" }, { \"uuid\": \"cc93f685-1785-11ee-8e67-ee1bce83c37e\", \"name\": \"my-replica\", \"type\": \"replica\", \"region\": \"phx\", \"hostname\": \"17811114a90e89-my-db-my-org.turso.io\" } ] } Previous Database instance API Next Get an instance in a logical database Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get the current month's usage for a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/get-usage-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIGet the current month's usage for a logical database in an organization Get the current month's usage for a logical database in an organization Summary​ Description: Returns usage statistics for the current calendar month that are used for purpose of billing and monthly limits. Usage is reported per individual database instance. Any instance that contributed to the usage for the calendar month is present in the output, even if that instance was deleted. To get more information about each instance, given their IDs in the output, make another request to get the logical database. To learn more about how usage is measured, read the technical billing documentation. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso db inspect [db_name] Path: /v1/organizations/:org_slug/databases/:db_name/usage Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the databases db_name Name of the logical database to get Output​ JSON body properties: Property Type Description database object A logical database usage object instances object Deprecated - do not use total object Deprecated - do not use Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/usage\" { \"database\": { \"uuid\": \"0c3b1c40-04a5-11ee-897e-ea9ebfc69781\", \"instances\": [ { \"uuid\": \"0d2a4482-04a5-11ee-897e-ea9ebfc69781\", \"usage\": { \"rows_read\": 11, \"rows_written\": 1, \"storage_bytes\": 28672 } }, { \"uuid\": \"b1d366e4-08ad-11ee-b472-02aae2e52fd2\", \"usage\": { \"rows_read\": 0, \"rows_written\": 0, \"storage_bytes\": 20480 } } ], \"usage\": { \"rows_read\": 11, \"rows_written\": 1, \"storage_bytes\": 53248 } } } Previous Invalidate all auth tokens for a logical database in an organization Next Database instance API Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Invalidate all auth tokens for a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/invalidate-all-tokens-for-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIInvalidate all auth tokens for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Summary​ Description: Invalidates all auth tokens previously minted for a logical database in an organization. This is achieved by randomly changing the signing key for the database so that tokens signed with the prior key are no longer valid. CAUTION This operation cannot be reverted. A short downtime is required to complete the changes. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso db tokens invalidate [db_name] Path: /v1/organizations/:org_slug/databases/:db_name/auth/rotate Method: POST Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the database db_name Name of the logical database Output​ None. Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/auth/rotate\" Previous Mint an auth token for a logical database in an organization Next Get the current month's usage for a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Mint an auth token for a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/mint-token-for-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIMint an auth token for a logical database in an organization Mint an auth token for a logical database in an organization Summary​ Description: Mints an auth token for client access to a logical database in an organization. The returned token: Can't be retrieved again; there is no record kept of it by Turso Can't be revoked individually. All previously minted tokens can be invalidated. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso db tokens create [db_name] Path: /v1/organizations/:org_slug/databases/:db_name/auth/tokens Method: POST Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the database db_name Name of the logical database Query string parameters: Parameter Required Description expiration no Duration of the token until expiration as parsed by go-str2duration, or never (default); for example: \"1w2d6h3ns\" (1 week 2 days 6 hours and 3 nanoseconds) authorization no Level of access granted to the bearer of the token; read-only or full-access (default) Output​ JSON body properties: Property Type Description jwt string An auth token with the requested access to the logical database Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/auth/tokens?expiration=1d&authorization=read-only\" { \"jwt\": \"AUTH-TOKEN-STRING\" } Previous Destroy a logical database in an organization Next Invalidate all auth tokens for a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Destroy a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/destroy-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIDestroy a logical database in an organization Destroy a logical database in an organization Summary​ Description: Destroys a logical database (and all of its instances) in an organization. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. Analogous CLI command: turso db destroy [db_name] Path: /v1/organizations/:org_slug/databases/:db_name Method: DELETE Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the database db_name Name of the logical database to destroy Output​ JSON body properties: Property Type Description database string The name of the logical database that was destroyed Example​ curl  -X DELETE  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db\" { \"database\": \"my-db\" } Previous Update the version of all instances of a logical database in an organization Next Mint an auth token for a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Create a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/create-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APICreate a logical database in an organization Create a logical database in an organization Summary​ Description: Creates a logical database in an organization. Returns a logical database object that describes the newly created database. The result of this operation is an empty logical database with no instances. The database is not useful until an instance is created with the Database instance API. The first created instance becomes the primary for the logical database. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso db create [db_name] INFO turso db create automatically creates the primary instance using the closest (or specified location) after creating the logical database. This function is not provided by the API, and you must use the Database instance API to create the first instance yourself in the location you specify. INFO turso db create with no arguments creates a database with a random name, but the API does not offer this function. The CLI is randomly generating the name itself and passing that to the API in the request body using the name property. Path: /v1/organizations/:org_slug/databases Method: POST Inputs​ Path parameters: Parameter Description org_slug Slug of the organization to contain the database JSON body properties: Property Required Description name yes Slug of the logical database to create; must be unique among all of the user's databases image no Type of database image to use; latest (default) or canary group no The name of the group to add this database to. Defaults to default Output​ JSON body properties: Property Type Description database object A logical database object describing the newly created database. Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases\"  -d '{\"name\": \"my-db\", \"image\": \"latest\"}' { \"database\": { \"Name\": \"my-db\", \"Hostname\": \"my-db-my-org.turso.io\", \"IssuedCertLimit\": 0, \"IssuedCertCount\": 0, \"DbId\": \"444f7e33-ea1d-11ed-afb4-d228a44fc89f\" }, \"password\": \"[password]\", \"username\": \"[username]\" } Previous Get a logical database in an organization Next Update the version of all instances of a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Update the version of all instances of a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/update-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIUpdate the version of all instances of a logical database in an organization Update the version of all instances of a logical database in an organization Summary​ Description: Updates the version of libSQL server of all instances of a logical database in an organization. This operation causes some amount of downtime to occur during the update process. The version of libSQL server is taken from the latest built docker image. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. The logical database is identified by the name it was given at creation. Analogous CLI command: turso db update [db_name] Path: /v1/organizations/:org_slug/databases/:db_name/update Method: POST Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the database db_name Name of the logical database whose instance to update Output​ None. The API sends an empty response with HTTP status 200 when the update is complete. Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db/update\" Previous Create a logical database in an organization Next Destroy a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get a logical database in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/get-database-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIGet a logical database in an organization Get a logical database in an organization Summary​ Description: Returns a named logical databases in an organization. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The named logical database must already exist in the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso db show [db_name] Path: /v1/organizations/:org_slug/databases/:db_name Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the databases db_name Name of the logical database to get Output​ JSON body properties: Property Type Description database object A logical database object Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases/my-db\" { \"database\": { \"Name\": \"my-db\", \"Hostname\": \"my-db-my-org.turso.io\", \"IssuedCertLimit\": 0, \"IssuedCertCount\": 0, \"DbId\": \"416756c4-cef9-11ed-b40d-c68341370672\", \"regions\": [ \"ord\" ], \"primaryRegion\": \"ord\", \"type\": \"logical\" } } Previous Get all logical databases in an organization Next Create a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get all logical databases in an organization | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/get-databases-in-org",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database APIGet all logical databases in an organization Get all logical databases in an organization Summary​ Description: Returns a list of all logical databases in an organization. Requirements: The caller must provide an authentication token. The authenticated user must be a member of the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso db list Path: /v1/organizations/:org_slug/databases Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization containing the databases Output​ JSON body properties: Property Type Description databases array An array of logical database objects with all databases. Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/databases\" { \"databases\": [ { \"Name\": \"my-db\", \"Hostname\": \"my-db-my-org.turso.io\", \"IssuedCertLimit\": 0, \"IssuedCertCount\": 0, \"DbId\": \"416756c4-cef9-11ed-b40d-c68341370672\", \"regions\": [ \"ord\" ], \"primaryRegion\": \"ord\", \"type\": \"logical\" }, { \"Name\": \"t\", \"Hostname\": \"t-my-org.turso.io\", \"IssuedCertLimit\": 0, \"IssuedCertCount\": 0, \"DbId\": \"e4a94d21-e2aa-11ed-bb4f-2ae75da7784d\", \"regions\": [ \"ord\" ], \"primaryRegion\": \"ord\", \"type\": \"logical\" } ] } Previous Logical database API Next Get a logical database in an organization Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get all supported locations | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/location/get-locations",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Get all supported locations Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APILocation APIGet all supported locations Get all supported locations Summary​ Description: Returns all supported database instance deployment locations. The three letter codes in the response can be used wherever a \"location code\" is accepted by the Database instance API. Requirements: The caller must provide an authentication token. Analogous CLI command: turso db locations INFO The Turso CLI suggests a default location near the user, which is not part of this API. The CLI uses https://region.turso.io/ to get the most most suitable default. Path: /v1/locations Method: GET Output​ JSON body properties: Property Description locations An object whose properties are locations codes and values are display names of those locations Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/locations\" { \"locations\": { \"ams\": \"Amsterdam, Netherlands\", \"arn\": \"Stockholm, Sweden\", \"bog\": \"Bogotá, Colombia\", \"bos\": \"Boston, Massachusetts (US)\", \"cdg\": \"Paris, France\", \"den\": \"Denver, Colorado (US)\", \"dfw\": \"Dallas, Texas (US)\", \"ewr\": \"Secaucus, NJ (US)\", \"fra\": \"Frankfurt, Germany\", \"gdl\": \"Guadalajara, Mexico\", \"gig\": \"Rio de Janeiro, Brazil\", \"gru\": \"São Paulo, Brazil\", \"hkg\": \"Hong Kong, Hong Kong\", \"iad\": \"Ashburn, Virginia (US)\", \"jnb\": \"Johannesburg, South Africa\", \"lax\": \"Los Angeles, California (US)\", \"lhr\": \"London, United Kingdom\", \"mad\": \"Madrid, Spain\", \"mia\": \"Miami, Florida (US)\", \"nrt\": \"Tokyo, Japan\", \"ord\": \"Chicago, Illinois (US)\", \"otp\": \"Bucharest, Romania\", \"qro\": \"Querétaro, Mexico\", \"scl\": \"Santiago, Chile\", \"sea\": \"Seattle, Washington (US)\", \"sin\": \"Singapore, Singapore\", \"sjc\": \"San Jose, California (US)\", \"syd\": \"Sydney, Australia\", \"waw\": \"Warsaw, Poland\", \"yul\": \"Montreal, Canada\", \"yyz\": \"Toronto, Canada\" } } Previous Location API Next Logical database API Summary Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get all organization members | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/organization/get-organization-members",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Get all organizations for the user Get all organization members Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIOrganization APIGet all organization members Get all organization members Summary​ Description: Returns all of the members of an organization. Requirements: The caller must provide an authentication token. The authenticated user must be the owner of the named organization. The organization is identified by the unique slug string it was assigned during creation. Analogous CLI command: turso org list members Path: /v1/organizations/:org_slug/members Method: GET Inputs​ Path parameters: Parameter Description org_slug Slug of the organization from which to get members Output​ JSON body properties: Property Type Description members array An array of organization member objects Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations/my-org/members\" { \"members\": [ { \"role\": \"owner\", \"username\": \"MyGitHubName\" }, { \"role\": \"member\", \"username\": \"OthersGitHubName\" } ] } Previous Get all organizations for the user Next Location API Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Validate a token for a user | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/auth/validate-token-for-user",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Get all Platform API tokens for a user Mint a Platform API token for a user Revoke a Platform API token for a user Validate a token for a user Organization API Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIAuthentication APIValidate a token for a user Validate a token for a user Summary​ Description: Validates a platform token. Requirements: The caller must provide an authentication token. Path: /v1/auth/validate Method: GET Output​ JSON body properties: Property Type Description exp number The time of expiration for the provided token in unix epoch seconds, or -1 if there is no expiration Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/auth/validate\" { \"exp\": 999 } Previous Revoke a Platform API token for a user Next Organization API Summary Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get all organizations for the user | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/organization/get-organizations-for-user",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Get all organizations for the user Get all organization members Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIOrganization APIGet all organizations for the user Get all organizations for the user Summary​ Description: Returns all organizations for which the authenticated user is a member. Requirements: The caller must provide an authentication token. Analogous CLI command: turso org list Path: /v1/organizations Method: GET Output​ JSON body properties: Property Type Description organizations array An array of organization objects Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/organizations\" { \"organizations\": [ { \"name\": \"personal\", \"slug\": \"your-username\", \"type\": \"personal\" }, { \"name\": \"my-org\", \"slug\": \"my-org\", \"type\": \"team\" } ] } Previous Organization API Next Get all organization members Summary Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Revoke a Platform API token for a user | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/auth/revoke-token-for-user",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Get all Platform API tokens for a user Mint a Platform API token for a user Revoke a Platform API token for a user Validate a token for a user Organization API Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIAuthentication APIRevoke a Platform API token for a user Revoke a Platform API token for a user Summary​ Description: Revokes (deletes) a Platform API token of the given name for the authenticated user. Requirements: The caller must provide an authentication token. Analogous CLI command: turso auth api-tokens revoke [token_name] Path: /v1/auth/api-tokens/:token_name Method: DELETE Inputs​ Path parameters: Parameter Description token_name Name of the token to revoke Output​ JSON body properties: Property Type Description token string The name of the token that was revoked Example​ curl  -X DELETE  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/auth/api-tokens/my-token\" { \"token\": \"my-token\" } Previous Mint a Platform API token for a user Next Validate a token for a user Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get all Platform API tokens for a user | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/auth/get-tokens-for-user",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Get all Platform API tokens for a user Mint a Platform API token for a user Revoke a Platform API token for a user Validate a token for a user Organization API Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIAuthentication APIGet all Platform API tokens for a user Get all Platform API tokens for a user Summary​ Description: Returns a list of all Turso Platform API tokens for the authenticated user. For security purposes, the list does not contain the actual token values. Requirements: The caller must provide an authentication token. Analogous CLI command: turso auth api-tokens list Path: /v1/auth/api-tokens Method: GET Output​ JSON body properties: Property Type Description tokens array An array of Platform API token objects for the user. Example​ curl  -X GET  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/auth/api-tokens\" { \"tokens\": [ { \"name\": \"token1\", \"id\": \"SYzcpe3jEe2We-rqOx4wmQ\" }, { \"name\": \"token2\", \"id\": \"wPvoKe3qEe2We-rqOx4wmQ\" } ] } Previous Authentication API Next Mint a Platform API token for a user Summary Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Mint a Platform API token for a user | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/auth/mint-token-for-user",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Get all Platform API tokens for a user Mint a Platform API token for a user Revoke a Platform API token for a user Validate a token for a user Organization API Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIAuthentication APIMint a Platform API token for a user Mint a Platform API token for a user Summary​ Description: Mints (creates) a new Platform API token for the authenticated user. Returns a Platform API token object that describes the newly created token. CAUTION The response of this call contains the token value to use in future API calls. Once you receive this value, save it somewhere secure. For security reasons, the Authentication API will not give back the token value when listing tokens for the user. Requirements: The caller must provide an authentication token. Analogous CLI command: turso auth api-tokens mint [token_name] Path: /v1/auth/api-tokens/:token_name Method: POST Inputs​ Path parameters: Parameter Description token_name Name of the token to mint; must be unique among all tokens for the user Output​ JSON body properties: Property Type Description token object A Platform API token object describing the newly created token. Example​ curl  -X POST  -H \"Authorization: Bearer $TURSO_TOKEN\"  \"$TURSO_BASE_URL/v1/auth/api-tokens/my-token\" { \"id\": \"6FnEr-6fEe2rsyLfpvsWuA\", \"name\": \"my-token\", \"token\": \"token-value\" } Previous Get all Platform API tokens for a user Next Revoke a Platform API token for a user Summary Inputs Output Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 8: Deploying the app to Cloudflare Workers | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-08-deploying-to-cloudflare",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 8: Deploying the app to Cloudflare Workers Step 8: Deploying the app to Cloudflare Workers After having built our Mug Store app, we can then proceed to the next step which is making it accessible to users. Our app already has the necessary Cloudflare Worker configuration for deployment set. This was done automatically while the Remix project was being scaffolded. We can make modifications to things such as the app name by making changes inside the wrangler.toml file. Here is the guiding documentation to understand the configurations that can be set inside this file. After everything is set up, run the following command to deploy the Mug Store e-commerce store to Cloudflare Workers. npm run deploy When the command runs successfully, you should see a log output close to the following. Uploading 19 new assets... Uploaded 100% [19 out of 19] ↗️ Done syncing assets Your worker has access to the following bindings: - Vars: - TURSO_DB_URL: \"...\" - ITEMS_PER_PAGE: 20 Total Upload: 2545.15 KiB / gzip: 618.44 KiB Uploaded the-mug-store (25.54 sec) Published the-mug-store (1.79 sec) Current Deployment ID: 4341d6a9-008e-4113-bc4c-653fc24a3456 You can then visit the published url shown in the log above to see a live demo of the e-commerce store. For more information on the stack choice used in this tutorial you can visit the following links: Remix Turso Cloudflare Workers Drizzle Previous Step 7: Checking out and placing orders Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 6: Adding the shopping cart | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-06-shopping-cart",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 6: Adding the shopping cart Step 6: Adding the shopping cart Let’s implement the cart for the Mug Store app so that users can hold items that they would like to finally purchase. All the items that a user adds to the cart are stored in the cartItems table inside our Turso database, this is a good practice since the user can resume their shopping session even when they hop onto another device. Start off by creating a cart page cart._index.tsx file inside the routes directory. The Drizzle query that we’ll need to run on the loader function of this page is as follows. /app/routes/cart._index.tsx const cartItems = await db.query.cartItems.findMany({ where: (cartItems, { eq }) => eq(cartItems.userId, userId), columns: { count: true, id: true, }, with: { product: true, }, }); Then on the page component, get the loader data and list the cart items. /app/routes/cart._index.tsx {cartData.cartItems.length ? ( cartData.cartItems?.map((item: CartItem) => ( )) ) : ( Your cart is empty, continue shopping! )} Here is the component we are using to list items within the cart. /app/components/CartPageItem.tsx import { useFetcher } from \"@remix-run/react\"; import type { CartItem } from \"~/lib/types\"; export const CartPageItem = (props: CartItem) => { const itemFetcher = useFetcher(); return ( ![]({props.product.image) ### [{props.product.name}]({`/product/${props.product.id}`}) **x({props.count})** ${(props.product.price * props.count).toFixed(2)} {props.product.description} {(itemFetcher.state === \"submitting\" || itemFetcher.state === \"loading\") && itemFetcher.formData?.get(\"product_id\") === props.product.id ? ( ) : ( )} ); }; The mini-cart​ It is also a good practice to make the cart accessible from all points within an e-commerce website, we will do so by adding a mini-cart that can be accessed from the navigation bar. In the first section of this tutorial we added a placeholder for the space that the cart component was going to reside, we are going to make use of this space. Add a new Cart.tsx component inside app/components and paste the following code into it. /app/components/Cart.tsx import { useEffect, useState } from \"react\"; import { useFetcher } from \"@remix-run/react\"; import type { CartItem } from \"~/lib/types\"; import { CartIcon } from \"./Icon\"; import { CartListItem } from \"./CartListItem\"; export const Cart = () => { const cartItemsFetcher = useFetcher(); const [showCart, setShowCart] = useState(false); const toggleCart = () => { setShowCart((s) => !s); }; useEffect(() => { cartItemsFetcher.submit( {}, { action: \"/manage-cart\", method: \"get\", } ); }, []); return ( {cartItemsFetcher.data && cartItemsFetcher.data.cartItems ? cartItemsFetcher.data.cartItems.length : 0} {showCart && ( Close cart {cartItemsFetcher.data && cartItemsFetcher.data.cartItems && cartItemsFetcher.data.cartItems.length ? ( cartItemsFetcher.data.cartItems.map((item: CartItem) => ( )) ) : ( Your cart is empty, continue shopping! )} [View my cart ( {cartItemsFetcher.data && cartItemsFetcher.data.cartItems ? cartItemsFetcher.data.cartItems.length : 0} )](/cart) [Checkout](/checkout) [Continue shopping](/) )} ); }; We can now replace the placeholder text \"CART_ICON\" we used previously within the component with the component. Inside the cart component we use state to toggle the mini-cart component into and out of view. The rest of the component’s logic will be covered in the section that follows. Observing the cart component’s code, you should see that we are using another component . Add this component to the project by creating a CartListItem.tsx file inside the components directory, and paste the following code into it. /app/components/CartListItem.tsx import { useFetcher } from \"@remix-run/react\"; import type { CartItem } from \"~/lib/types\"; import { DeleteIcon, LoadingIcon } from \"./Icon\"; import { resizeImage } from \"~/lib/utils\"; export const CartListItem = (props: CartItem) => { const itemFetcher = useFetcher(); return ( ![]({resizeImage(props.product.image,) ### {props.product.name} **x({props.count})** {(itemFetcher.state === \"submitting\" || itemFetcher.state === \"loading\") && itemFetcher.formData?.get(\"product_id\") === props.product.id ? ( ) : ( )} ); }; We’ll also talk more about this component in the next section. Managing cart items​ Since cart management can be done from different points within the app (the cart page, mini-cart component, checkout page), let’s create a Remix resource route that will handle some CRUD requests to our database concerning cart items. Add a Remix resource route file manage-cart.ts under app/routes and inside it paste the following code. /app/routes/manage-cart.ts import { v4 as uuidv4 } from \"uuid\"; import { type ActionArgs, type LoaderArgs, json, redirect, } from \"@remix-run/cloudflare\"; import { and, eq } from \"drizzle-orm\"; import { cartItems } from \"drizzle/schema\"; import { requireUserId } from \"~/lib/session.server\"; import { buildDbClient } from \"~/lib/client\"; export async function loader({ request, context }: LoaderArgs) { const db = buildDbClient(context); const userId = await requireUserId( { request, redirectTo: \"/account/login\" }, context ); if (!userId) { return { cartItems: [], }; } const cartItems = await db.query.cartItems.findMany({ where: (cartItems, { eq }) => eq(cartItems.userId, userId), columns: { count: true, id: true, }, with: { product: true, }, }); return { cartItems, }; } export async function action({ request, context }: ActionArgs): Promise | TypedResponse | null> { const formData = await request.formData(); const { _action, ...values } = Object.fromEntries(formData); const userId = await requireUserId( { request, redirectTo: \"/account/login\" }, context ); if (userId === undefined) { const searchParams = new URLSearchParams([ [\"error\", \"Log in to add items to cart\"], ]); return redirect(`/account/login?${searchParams}`); } const productId = values.product_id as string; const quantity = values.quantity; const db = buildDbClient(context); if (_action === \"addToCart\") { const cartItem = await db.query.cartItems.findFirst({ where: (cartItems, { eq, and }) => and(eq(cartItems.productId, productId), eq(cartItems.userId, userId)), }); if (cartItem) { const append = await db .update(cartItems) .set({ count: cartItem.count + 1 }) .where( and(eq(cartItems.productId, productId), eq(cartItems.userId, userId)) ) .returning() .get(); return json(append); } else { const id = uuidv4(); const cartInsertionResponse = await db .insert(cartItems) .values({ id, productId, userId, count: (quantity || 1) as number, }) .returning() .get(); return json(cartInsertionResponse); } } if (_action === \"deleteCartItem\") { const deleted = await db .delete(cartItems) .where(eq(cartItems.productId, productId)) .returning() .get(); return json(deleted); } return null; } In the manage-cart.ts resource route, you’ll find a loader function that queries our Turso database and returns the cart items belonging to the authenticated user. In the mini-cart component, you can see a cartItemsFetcher which is updated whenever changes are detected in our app by leveraging the useEffect hook. It consumes the data from the loader within the manage-cart.ts resource route and updates the listed cart items. For cart items management, the action function set within the resource route handles such requests. This action handles cart item data addition, modification, and deletion. After having added this resource route, we can proceed to creating the components that expose its functionalities to the user. Adding items to the cart​ Let's implement the feature that adds items to the cart inside the product details page. Create the product details it by adding a mug.$id.tsx file under the routes directory. In this page, we first check whether a product id $id has been passed as a route parameter within the page's URL, we then check if a product with that id exists inside the database, if not we throw a 404 error, else we pass the product's date to the page component. Here is the code to the loader function within the product details page. /app/routes/mug.$id.tsx export const loader: LoaderFunction = async ({ params, context, }: LoaderArgs) => { const db = buildDbClient(context); const { id } = params; if (!id) { throw new Response(\"Not Found\", { status: 404, statusText: \"Product id not found!\", }); } const product = await db .select() .from(products) .where(eq(products.id, id)) .get(); if (!product) { throw new Response(\"Not Found\", { status: 404, statusText: \"Product not found!\", }); } return { product: product as unknown as Product, }; }; Here is the page's component code with the markup of the form that's responsible for triggering the action that add's an item to the cart. /app/routes/mug.$id.tsx export default function () { const pageData = useLoaderData(); const triggerAction = useFetcher(); return ( <> Add to Cart{\" \"} {(triggerAction.state === \"submitting\" || triggerAction.state === \"loading\") && triggerAction.formData?.get(\"product_id\") === pageData.product.id && triggerAction.formData?.get(\"_action\") === \"addToCart\" && \"...\"} ) } As we have it in the manage-cart resource route, the cart item being submitted is either updated when it’s detected as a duplicate or added as a new item if it does not exist in the user’s cart. For the full component markup, you can view it over here. By the end of this step, here's a demonstration of what we expect the cart within our website to function. Next, let's manage customer checking out and order placement. Previous Step 5: User authentication Next Step 7: Checking out and placing orders The mini-cart Managing cart items Adding items to the cart Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 7: Checking out and placing orders | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-07-checking-out",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 7: Checking out and placing orders Step 7: Checking out and placing orders After users have selected items they want to buy and placed them in the cart, we then expect them to check out. To facilitate this inside the app, let’s create the checkout page by adding a checkout._index.tsx file under app/routes. For the loader, we are trying to get the same data as we did in the cart page, only that here we need the user information too. The user data is used to pre-fill some fields on the checkout form. /app/routes/checkout._index.tsx cartItems = await db.query.cartItems.findMany({ where: (cartItems, { eq }) => eq(cartItems.userId, userId), columns: { count: true, id: true }, with: { product: true, user: true }, }); return { cartItems, userData: cartItems[0].user, }; We then get the loader data and lay out the cart items and checkout information on the page component. Here is the page markup for the checkout page component. After having registered a user and added some items to the cart, this is what you should see when you visit the checkout page. After having provided the required payment, contact, and billing information, the user will submit the checkout form by clicking the “Pay Now” button. Clinking the \"Pay Now\" button prompts the submission of the checkout form data to the checkout page's action that validates submitted data, handles the creation of new orders, and returns the correct message depending on the action being successful or not. Here is the page action that handles order placement. /app/routes/checkout._index.tsx export const action = async ({ request, context, }: ActionArgs): Promise< { status: string; message: string; data: any } | Response > => { const userId = await requireUserId( { request, redirectTo: \"/account/login\" }, context ); if (userId === undefined) { return redirect(\"/account/login\"); } else { const formData = await request.formData(); const values = Object.fromEntries(formData); // Validate submitted data const db = buildDbClient(context); try { const cartItemsData = await db.query.cartItems.findMany({ where: (cartItems, { eq }) => eq(cartItems.userId, userId), columns: { count: true, id: true, }, with: { product: true, user: true, }, }); if (!cartItemsData.length) { return { status: \"error\", message: \"Add something to your cart first\", data: null, }; } const amount = cartItemsData.reduce( ( accumulator: number, currentVal: { count: number; product: { price: number } } ) => accumulator + currentVal.count * currentVal.product.price, 0 ); const calculatedShippingFees = 0; const discountAmount = 0; const finalAmount = amount + calculatedShippingFees - discountAmount; const newOrder = await db .insert(orders) .values({ id: uuidv4(), userId, customerName: `${values.firstName} ${values.lastName}`, amount, shippingFees: calculatedShippingFees, discountAmt: discountAmount, finalAmount, shippingAddress: `${values.zipCode} ${values.country}`, }) .returning() .get(); for (const item of cartItemsData) { const orderItemData = { id: uuidv4(), orderId: newOrder.id, productId: item.product.id, count: item.count, }; await db.insert(orderItems).values(orderItemData).run(); await db.delete(cartItems).where(eq(cartItems.id, item.id)).run(); } return { status: \"success\", message: \"Order placed!\", data: true, }; } catch (error) { // TODO: Catch error and notify user return { status: \"failure\", message: \"Could not create an order!\", data: null, }; } } }; Note: There is no payment integration in this tutoria that would be implemented here. You can plug in one on your own. After having added all of the essential features to our e-commerce store, next, we'll be deploying the site to Cloudflare workers. Previous Step 6: Adding the shopping cart Next Step 8: Deploying the app to Cloudflare Workers Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 5: User authentication | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-05-user-authentication",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 5: User authentication Step 5: User authentication All user related features such as the cart and addition of items into it, placing orders, and checking-out to be added into our Mugs Store app will be guarded behind an authentication wall. Let’s implement user authentication within the app before proceeding to working on these features. We are going to use cookie-based sessions for user authentication within the app and luckily Remix provides us the createCookieSessionStorage helper just for this. Create a session.ts file inside /app and add the following code into it. /app/session.tsx import { AppLoadContext, createCookieSessionStorage, } from \"@remix-run/cloudflare\"; type SessionData = { userId: string; }; type SessionFlashData = { error: string; }; export function cookieSessionCreation(context: AppLoadContext) { const { getSession, commitSession, destroySession } = createCookieSessionStorage({ // a Cookie from `createCookie` or the CookieOptions to create one cookie: { name: \"__session\", httpOnly: true, maxAge: 7 * 60 * 60, path: \"/\", sameSite: \"lax\", secrets: [context.env?.SESSION_SECRET], secure: true, }, }); return { getSession, commitSession, destroySession }; } The createCookieSessionStorage function provides us with utility functions that enable us to manage cookie sessions within our Remix app. For the SESSION_SECRET we are using a randomly generated string which we then store as a secret environment variable just as we did with the database auth token previously. The next step would be the addition of the registration and login pages. Start by creating two files account.login.tsx and account.register.tsx inside the app/routes directory. We are going to hash user passwords before storing them to our database using bcrypt, hence, install the bcrypt npm package to our app by running the following command. npm install bcryptjs User registration​ Within the user registration page /account.login.tsx we’ll simply be submitting user information to a page action that takes care of form data validation, storage of the data to the database, and redirection of the user to the login page when correct information is provided, otherwise it will give us an error message. Create a dedicated utility file that will handle the session logic for the user authentication flow within our app. Name the file session.server.ts and place it under app/lib. Within this file, we’ll add the user registration function register() that validates the user data being submitted to the database via the registration page action and creates new records or returns coherent error messages back to the registration page. Then, import and use the register() function within the page action. You can view all of the user registration page code on GitHub. Authenticating users​ To authenticate users, add a login() function inside the app/lib/session.server.ts file which will handle the assessment of the user’s auth credentials submitted through the login page form and the initialization of an authenticated session. Here’s the code for the login() function. /app/lib/session.server.ts export interface LoginCredentials { email: string; password: string; } export async function login( { email, password }: LoginCredentials, serverContext: AppLoadContext ) { const db = buildDbClient(serverContext); const user = await db.query.users.findFirst({ where: (users, { eq }) => eq(users.email, email), with: { password: true, }, }); if (user !== undefined) { const isValidPassword = bcrypt.compareSync( password, user.password.hash ); return !isValidPassword ? null : user; } return null; } Next, create another utility function that will handle the creation of a successfully authenticated user’s session leveraging the cookieSessionCreation() helper we created earlier. Add the following function inside the app/lib/session.server.ts file. /app/lib/session.server.ts export async function createUserSession( userId: string, redirectUrl: string, serverContext: AppLoadContext ) { const { getSession, commitSession } = cookieSessionCreation(serverContext); const session = await getSession(); session.set(\"userId\", userId); return redirect(redirectUrl, { headers: { \"Set-Cookie\": await commitSession(session), }, }); } We can then import and use these two functions within the login page’s action as follows to fully implement user authentication. /app/routes/account.login.ts const user = await login(values as unknown as LoginCredentials, context); if (!user) return json( { ok: false, message: \"Wrong credentials!\" }, { status: 400, statusText: \"Wrong credentials!\" } ); return createUserSession(user.id, \"/account/dashboard\", context); Then, inside the page component we can initiate a new Fetcher and create a login form as follows. /app/routes/account.login.ts const loginFetcher = useFetcher(); return ( Sign in [Create an account](/account/register) ); You can view the complete login page code on GitHub. Adding authentication page guards​ Since the pages we are going to add next need authenticated user access, we’ll need to redirect any unauthenticated access attempts to the log-in page. Create a requireUseId() function inside lib/session.server.ts that will check to see if an authenticated session exists, if not it will redirect the user to the log-in page. /app/lib/session.server.ts export async function requireUserId( { request, redirectTo = new URL(request.url).pathname, }: { request: Request; redirectTo?: string; }, serverContext: AppLoadContext ) { const { getSession } = cookieSessionCreation(serverContext); const session = await getSession(request.headers.get(\"Cookie\")); const userId = session.get(\"userId\"); if (!userId) { const searchParams = new URLSearchParams([[\"redirectTo\", redirectTo]]); redirect(`/account/login?${searchParams}`); } return userId; } We can then import and call this function at the top of the loader functions of all the pages we want to guard against unauthorized access. Code to add to the loaders of all guarded pages import { requireUserId } from \"~/lib/session.server\"; export async function loader({ request, context }: LoaderArgs): Promise { const db = buildDbClient(context); const userId = await requireUserId( { request, redirectTo: \"/account/login\" }, context ); if (userId === undefined) { return redirect(\"/account/login\"); } else { // The rest of the page's loader logic } } The user dashboard and logging out​ We are going to add a user dashboard where at the very minimum the user's order history will be listed. Also, we need to be able to log the authenticated users out of our app, and we are going to implement this feature right in the dashboard page. Since we’ve set up Drizzle schema relations, getting the orders based on a user is a very easy task, all we need to do is perform a findFirst query on the users table listing the users orders in the returned data. Create an accounts.dashboard.tsx page inside app/routes and within the page’s loader, query and return the user’s details as follows. /app/routes/accounts.dashboard.tsx const user = await db.query.users.findFirst({ where: (users, { eq }) => eq(users.id, userId), with: { orders: true, }, }); return { user }; We can then get this data in the dashboard page component and list the user’s orders as follows. /app/routes/account.dashboard.tsx const { user } = useLoaderData(); return ( th>Total Cost {user.orders.map((order: Order) => ( ))} Date Shipping to {formatDate(order.orders.createdAt)} {order.orders.finalAmount}$ {order.orders.shippingAddress} ) The formatDate() function called in the above code is simply a date formatting utility function exported from the app/lib/utils.ts. /app/lib/utils.ts export function formatDate(date: number) { const day = new Date(date * 1000); const formattedDate = Intl.DateTimeFormat(\"en-US\", { day: \"numeric\", month: \"short\", year: \"numeric\", }).format(day); return formattedDate; } To log users out, add the following page action to account.dashboard.tsx file. /app/routes/account.dashboard.tsx export const action: ActionFunction = async ({ request, context, }: ActionArgs) => { const userId = await requireUserId( { request, redirectTo: \"/account/login\" }, context ); if (userId !== undefined) { return destroyUserSession(userId, \"/account/login\", context); } }; Within this loader function, we are simply destroying the previously created user authenticated session. Add a fetcher form to trigger this action inside the page. const logOutFetcher = useFetcher(); return ( Log Out ) Create some users to test this part of the website and verify if everything works. Here is what the user dashboard should look like when opened after a user is authenticated. After having set up user authentication we can then proceed to adding the pages and features that are dependent on it. Previous Step 4: Listing store items Next Step 6: Adding the shopping cart User registration Authenticating users Adding authentication page guards The user dashboard and logging out Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 4: Listing store items | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-04-listing-products",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 4: Listing store items Step 4: Listing store items The Mug Store app has two product listing pages, the home page / that lists featured products and categories, and the mugs page /mugs that list all mugs within pages. The home page​ For the website’s home page we have featured products and categories sections that in a real-world scenario we’d like to show products based on certain metrics. For a simple demonstration we’ll just fetch items from the products and categories table respectively. Here’s the home page’s loader function. /app/routes/_index.tsx export const loader: LoaderFunction = async ({ context }: LoaderArgs) => { const db = buildDbClient(context); const featuredProducts = await db.query.products.findMany({ columns: { description: false, categoryId: false, }, }); const featuredCategories = await db.query.categories.findMany(); return { featuredProducts: featuredProducts as unknown as Product[], featuredCategories: featuredCategories as unknown as Category[], }; }; We are going to present products using independent cards, hence, add a Product.tsx component under app/components with the following code. /app/components/Product.tsx import { resizeImage } from \"~/lib/utils\"; import type { Product } from \"~/lib/types\"; export interface ProductCardProps { product: Product; } export const ProductCard = (props: ProductCardProps) => { return ( [![]({resizeImage(props.product.image,)]({`/mug/${props.product.id}`}) [ ### {props.product.name} ]({`/mug/${props.product.id}`}) ${props.product.price} ); }; Here is the code to the resizeImage() function imported into the product card component. /app/lib/utils.ts export function resizeImage(url: string, height: number, width: number) { return url.replace(//v[0-9]+/, `/c_lfill,g_center,h_${height},w_${width}`); } This utility function placed inside the app/lib/utils.ts file simply modifies the dimensions of the image to be displayed We can then use the product card to list products throughout the website. Having added a loader to our home page, we can then consume the data from it inside the page component by adding the following line of code before the page’s markup. /app/routes/_index.tsx export default function Index() { const { featuredCategories, featuredProducts } = useLoaderData(); return (); // markup } Finally, update the page’s markup laying out the product and categories sections. /app/routes/_index.tsx ### Featured Products {featuredProducts.length ? ( {featuredProducts.map((product: Product) => ( ))} ) : ( There are no available products, please check back later! )} In the above markup, we are only showing the markup responsible for listing the featured products. Open the file on GitHub to see all of the code. By the end of these changes, the home page should look like this. The product listing page​ Inside the mugs page /mugs we will be listing all of the products within the app’s database, breaking down pages using a fixed item count, in this case 20 items per page. Add the following environment variable inside wrangler.toml to set this up. wrangler.toml ITEMS_PER_PAGE=20 For the page’s pagination, create the dedicated component for that feature by adding a Pagination.tsx file under app/components, add the code found within this file into it. Create the mugs page by adding a mugs.($pageNum).tsx file under /app/routes. Within the mugs page loader function, we are first getting the count of all items that exist within our database, then use that number to determine the total number of pages that our data can be grouped into, finally, we return the items that are expected to be shown within the requested page by checking the page number pageNum param passed in the url. /app/routes/mugs.($pageNum).tsx export const loader: LoaderFunction = async ({ params, context, }: LoaderArgs) => { const db = buildDbClient(context); const { pageNum } = params; const allProducts = await db.query.products.findMany({ columns: { name: true, }, }); const itemsCount = allProducts.length; const itemsPerPage = context.env?.ITEMS_PER_PAGE || 20; const totalPages = Math.ceil((itemsCount as number) / itemsPerPage); let currentPage = 1, offset = 0; if (pageNum !== undefined) { currentPage = parseInt(pageNum); offset = currentPage === 1 ? 0 : (currentPage - 1) * itemsPerPage; } const products = await db.query.products.findMany({ offset: offset, limit: itemsPerPage, }); return { products: products as unknown as Product[], pageInfo: { currentPage, totalPages, }, }; }; Finally, get the products and pagination data from the loader and list the products within the page’s UI with the pagination component at the bottom. /app/routes/mugs.($pageNum).tsx export default function Mugs() { const { products, pageInfo } = useLoaderData(); return ( <> {!products.length ? ( There are no available products, please check back later! ) : ( {products && products.length ? ( products.map((product: Product) => ( )) ) : ( No items )} )} ); } Here is a presentation of the mugs page with ITEMS_PER_PAGE set to 4. Next, well look into authenticating users so that they can use the store's guarded features. Previous Step 3: Configuring Drizzle Next Step 5: User authentication The home page The product listing page Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 3: Configuring Drizzle | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-03-configuring-drizzle",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 3: Configuring Drizzle Step 3: Configuring Drizzle As prescribed earlier we are going to use Drizzle to handle our database schema and build queries in our app. Run the following commands to install its dependencies in the Remix project. npm install drizzle-orm @libsql/client npm install -D drizzle-kit dotenv tsx Note: The dotenv npm package added above is going to help us use environment variables stored within the .env file within our Drizzle code. We’ll use the tsx package to execute TypeScript files mainly within package.json scripts. Then, create a /drizzle directory at the project’s root. We are going to place our app’s database schema and store Drizzle migrations inside this directory. Create a .env file at the project’s root and add the database credentials obtained in the previous section. .env TURSO_DB_URL= TURSO_DB_AUTH_TOKEN= Note: Do not stage .env files to your version control systems. Our e-commerce database is going to have the following tables. categories - Stores the products’ categories products - Stores the website’s products users - Stores customer information passwords - Stores customer passwords cart_items - Stores items added to cart by customers orders - Stores the order information created by customers order_items - Stores the products belonging to orders Create a schema.ts file under /drizzle and add the following code as the database schema. /drizzle/schema.ts import { relations, sql } from \"drizzle-orm\"; import { index, integer, real, sqliteTable, text, uniqueIndex, } from \"drizzle-orm/sqlite-core\"; export const categories = sqliteTable( \"categories\", { id: text(\"id\").primaryKey(), name: text(\"name\"), image: text(\"image\"), }, (categories) => ({ nameIdx: index(\"name_idx\").on(categories.name), }) ); export const categoriesRelations = relations(categories, ({ many }) => ({ products: many(products), })); export const products = sqliteTable( \"products\", { id: text(\"id\").primaryKey(), name: text(\"name\").notNull(), description: text(\"description\").notNull(), price: real(\"price\").notNull(), categoryId: integer(\"category_id\") .notNull() .references(() => categories.id), image: text(\"image\"), createdAt: integer(\"created_at\").default(sql`(cast (unixepoch () as int))`), updatedAt: integer(\"updated_at\").default(sql`(cast (unixepoch () as int))`), }, (products) => ({ idIdx: uniqueIndex(\"id_idx\").on(products.id), priceIdx: index(\"price_idx\").on(products.price), categoryIdIdx: index(\"category_id_idx\").on(products.categoryId), }) ); export const productsRelations = relations(products, ({ one }) => ({ user: one(categories, { fields: [products.categoryId], references: [categories.id], }), })); export const users = sqliteTable( \"users\", { id: text(\"id\").primaryKey(), firstName: text(\"firstName\").notNull(), lastName: text(\"lastName\").notNull(), email: text(\"email\").notNull(), address: text(\"address\"), phone: text(\"phone\"), avatar: text(\"avatar\"), createdAt: integer(\"created_at\").default(sql`(cast (unixepoch () as int))`), updatedAt: integer(\"updated_at\").default(sql`(cast (unixepoch () as int))`), }, (users) => ({ emailIdx: uniqueIndex(\"email_idx\").on(users.email), firstNameLastNameAddressIdx: index(\"first_name_last_name_address_idx\").on( users.firstName, users.lastName, users.address ), }) ); export const usersRelations = relations(users, ({ one, many }) => ({ password: one(passwords, { fields: [users.id], references: [passwords.userId], }), cartItems: many(cartItems), orders: many(orders), })); export const passwords = sqliteTable(\"passwords\", { hash: text(\"hash\").notNull(), userId: text(\"user_id\") .notNull() .references(() => users.id), }); export const passwordsRelations = relations(passwords, ({ one }) => ({ user: one(users, { fields: [passwords.userId], references: [users.id], }), })); export const cartItems = sqliteTable( \"cart_items\", { id: text(\"id\").primaryKey(), count: integer(\"count\").notNull().default(1), userId: text(\"user_id\") .notNull() .references(() => users.id), productId: text(\"product_id\") .notNull() .references(() => products.id), createdAt: integer(\"created_at\").default(sql`(cast (unixepoch () as int))`), updatedAt: integer(\"updated_at\").default(sql`(cast (unixepoch () as int))`), }, (cartItems) => ({ userIdProductIdx: uniqueIndex(\"cart_items_user_id_product_id_idx\").on( cartItems.id ), productIdx: index(\"cart_items_product_id_idx\").on(cartItems.productId), }) ); export const cartItemsRelations = relations(cartItems, ({ one }) => ({ user: one(users, { fields: [cartItems.userId], references: [users.id], }), product: one(products, { fields: [cartItems.productId], references: [products.id], }), })); export const orders = sqliteTable(\"orders\", { id: text(\"id\").primaryKey(), customerName: text(\"customer_name\").notNull(), amount: real(\"amount\").notNull(), shippingFees: real(\"shipping_fees\").notNull(), discountAmt: integer(\"discount_amt\").notNull().default(0), finalAmount: integer(\"final_amount\").notNull(), shippingAddress: text(\"shipping_address\").notNull(), paid: integer(\"paid\").notNull().default(0), userId: text(\"user_id\").notNull(), createdAt: integer(\"created_at\").default(sql`(cast (unixepoch () as int))`), updatedAt: integer(\"updated_at\").default(sql`(cast (unixepoch () as int))`), }); export const ordersRelations = relations(orders, ({ one, many }) => ({ user: one(users, { fields: [orders.userId], references: [users.id], }), items: many(orderItems), })); export const orderItems = sqliteTable( \"order_items\", { id: text(\"id\").primaryKey(), count: integer(\"count\").notNull().default(1), orderId: text(\"order_id\") .notNull() .references(() => orders.id), productId: text(\"product_id\") .notNull() .references(() => products.id), createdAt: integer(\"created_at\").default(sql`(cast (unixepoch () as int))`), updatedAt: integer(\"updated_at\").default(sql`(cast (unixepoch () as int))`), }, (orderItems) => ({ orderIdProductIdIdx: uniqueIndex(\"order_items_order_id_product_id_idx\").on( orderItems.orderId, orderItems.productId ), productIdx: index(\"order_items_product_id_idx\").on(orderItems.productId), }) ); export const orderItemsRelations = relations(orderItems, ({ one }) => ({ order: one(orders, { fields: [orderItems.orderId], references: [orders.id], }), product: one(products, { fields: [orderItems.productId], references: [products.id], }), })); The above code shows the Drizzle database schema for our app including the indexes and relations for some of the tables Add the following SQL generation script inside package.json. package.json \"generate\": \"drizzle-kit generate:sqlite --out ./drizzle/migrations --breakpoints --schema=./drizzle/schema.ts\" Then, create the database migration file by running npm run generate. You should then see the migration files generated inside a newly created drizzle/migrations directory which was passed as the --out path on the above script To migrate the schema to Turso, first create a migrate.ts file under /drizzle, then add the following code in it. /drizzle/migrate.ts import \"dotenv/config\"; import { migrate } from \"drizzle-orm/libsql/migrator\"; import { drizzle } from \"drizzle-orm/libsql\"; import { createClient } from \"@libsql/client\"; export const client = createClient({ url: process.env.TURSO_DB_URL as string, authToken: process.env.TURSO_DB_AUTH_TOKEN as string, }); export const db = drizzle(client); async function main() { try { await migrate(db, { migrationsFolder: \"drizzle/migrations\", }); console.log(\"Tables migrated!\"); process.exit(0); } catch (error) { console.error(\"Error performing migration: \", error); process.exit(1); } } main(); Create the following package.json script to streamline the schema migration task. package.json \"migrate\": \"tsx drizzle/migrate\", Then, Run the migration task npm run migrate. If everything went well, you should see the following log output. > @ migrate /the-mug-store > tsx drizzle/migrate Tables migrated! Finally, create a client.ts file under a new app/lib directory and add the following code. /app/lib/client.ts import { drizzle } from \"drizzle-orm/libsql\"; import { createClient } from \"@libsql/client/http\"; import * as schema from \"../../drizzle/schema\"; import type { AppLoadContext } from \"@remix-run/cloudflare\"; interface Env { TURSO_DB_AUTH_TOKEN?: string; TURSO_DB_URL?: string; } export function buildDbClient(context: AppLoadContext) { const url = (context.env as unknown as Env).TURSO_DB_URL?.trim(); if (url === undefined) { throw new Error(\"TURSO_DB_URL is not defined\"); } const authToken = (context.env as unknown as Env).TURSO_DB_AUTH_TOKEN?.trim(); if (authToken === undefined) { throw new Error(\"TURSO_DB_AUTH_TOKEN is not defined\"); } return drizzle(createClient({ url, authToken }), { schema }); } buildDbClient() is the Drizzle instance initialization function for our app. We are passing the worker’s context serverContext as an argument so as to get the environment variables from Cloudflare workers. Previewing the Turso database using Drizzle​ To preview the Turso database visually, add the Drizzle configuration file at the project’s root drizzle.config.ts and inside it add the following configuration. /drizzle.config.ts import type { Config } from \"drizzle-kit\"; import * as dotenv from \"dotenv\"; dotenv.config(); export default { schema: \"./drizzle/schema.ts\", out: \"./drizzle/migrations\", driver: \"turso\", dbCredentials: { url: process.env.TURSO_DB_URL as string, authToken: process.env.TURSO_DB_AUTH_TOKEN as string, }, } satisfies Config; Add a new \"studio\" script inside package.json. package.json \"studio\": \"drizzle-kit studio --port 3333\" Then, run npm run studio and open localhost:3333 to preview the database. You should then see the following preview. Seeding data into the database​ Inside the final project repository there is database demo data seeding code as can be viewed here. To use it, make sure to first install the uuid and lorem-ipsum npm packages. Create another package.json script to streamline the database seeding task. \"db:seed\": \"tsx drizzle/seed\" Afterwards, run npm run db:seed to seed some data into the database. Since we now know our database schema, let’s finalize this section by documenting our app’s data types. Under app/lib add a types.ts file with the following code. /app/lib/types.ts export interface Product { id: string; name: string; description: string; price: number; categoryId: string; image: string; createdAt: string; } export interface Category { id: string; name: string; } export interface User { id: string; firstName: string; lastName: string; email: string; address: string; avatar: string; createdAt: number; } export interface CartItem { id: string; user: User; product: Product; count: number; } export interface Cart { user: User; items: CartItem[]; show: boolean; } export interface Order { id: number; amount: number; shippingFees: number; discount: number; finalAmount: number; paid: boolean; user: User; shippingAddress: string; createdAt: number; } In the next step we are going to see how the store items can be listed within our app. Previous Step 2: Setting up Turso Next Step 4: Listing store items Previewing the Turso database using Drizzle Seeding data into the database Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 1: Setting up the project | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-01-setting-up-the-project",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 1: Setting up the project Step 1: Setting up the project Before getting started, make sure that you satify the following pre-requisites: You need the latest LTS version of Node.js to work with node packages. The Turso CLI installed in your system to create databases. A Cloudflare account and wrangler installed to deploy the website. Here’s what the e-commerce store we are building will look like when completed. Creating a Remix app​ Create a new Remix app by running the following command on your terminal. npx create-remix@latest the-mug-store When prompted for the \"type of app\" you want to create, choose \"Just the basics\", choose \"Cloudflare workers\" as where you want to deploy the app, and \"TypeScript\" as the language to use while creating the app. On completion, the above command should create a new Remix app with the following directory tree. Remix project directory structure ├── README.md ├── app │ ├── entry.client.tsx │ ├── entry.server.tsx │ ├── root.tsx │ └── routes │ └── _index.tsx ├── package.json ├── public │ └── favicon.ico ├── remix.config.js ├── remix.env.d.ts ├── server.ts ├── tsconfig.json └── wrangler.toml Here is a gist of some of the above files and what they do: entry.client.tsx: This is the browser’s entry point which is also responsible for hydrating the markup generated by the server. entry.server.tsx: This is where Remix handles the generation of the HTTP responses for the app. remix.config.js: This file contains some build and development configuration options. It does not run on the server. root.tsx: This file is the principal layout file of the Remix app. wrangler.toml: This is the Cloudflare wrangler project configuration file. cd into the project and run npm install to install the project’s dependencies. Next, run npm run dev to deploy and preview the Remix app locally. You should see the following. (If any missing dependency errors are thrown at you, just install them and run npm run dev once more) Since we are going to use TailwindCSS to style the website, follow the steps provided here to set that up. Use this Tailwind configuration file and run the following command to install some Tailwind dependencies. npm i -D @tailwindcss/forms @tailwindcss/typography Restart the dev server to proceed. Setting up the UI​ Add the site’s navigation header and footer by creating two components Footer.tsx and Header.tsx under a app/components directory. Add the following code to these two components. /app/components/Footer.tsx export const Footer = () => { return ( Built with ♡ in{\" \"} [Remix](https://remix.run/) {\" \"} &{\" \"} [Turso](https://turso.tech/) {\". Hosted on \"} [Cloudflare Workers](https://developers.cloudflare.com/workers/) ); }; /app/components/Header.tsx export const Header = () => { return ( * [{\" \"} All Mugs{\" \"}](/mugs) [The M🍵g Store](/ \"Turix Store\") * CART_ICON * [](/account/dashboard \"account\") ); }; Next, update the app’s layout app/root.tsx, adding these two components to it by replacing the component with the following markup. /app/root.tsx Do not forget to import the components at the top of the file. /app/root.tsx import { Header } from \"./components/Header\"; import { Footer } from \"./components/Footer\"; Note: Since the header component /app/components/Header.tsx imports a component, one we have yet to set up, use the text CART_ICON in its place for now. Add the following custom styles to the app/tailwind.css file. /app/tailwind.css @layer base { .header .logo a { display: inline-block; } .header li a { @apply text-white px-4 flex space-x-1 justify-center items-center; } @media (min-width: 450px) { .header li { display: inline-block; } } @media (min-width: 768px) { .header { padding: 20px 70px; } } } Create an Icon.tsx component that will be used to house all the icons that we’ll use within the app. Add the following code to the component. /app/components/Icon.tsx interface CartIconProps { color: string | undefined; } export const CartIcon = (props: CartIconProps) => ( ); export const AccountIcon = (props: CartIconProps) => ( ); export const LoadingIcon = () => ( ); export const DeleteIcon = () => ( ); By now, this should be the app’s preview. Trying to access the \"All mugs\" page on the navigation bar would take us to a 404 page since we have yet to set that page up. Before working on our pages, let’s set up the app’s database. Previous Creating an e-commerce store with Remix, Turso, Drizzle, and Cloudflare Workers Next Step 2: Setting up Turso Creating a Remix app Setting up the UI Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 2: Setting up Turso | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/step-02-setting-up-turso",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & TursoStep 2: Setting up Turso Step 2: Setting up Turso Proceeding to setting up a database for the app, run the following command to create a new Turso database. turso db create the-mug-store Next, get and set up the database credentials so that the data within Turso can be consumed by our app. For the database url run the following command. turso db show the-mug-store --url Inside the Cloudflare wrangler configuration file wrangler.toml add a new [vars] section and list the database url as follows. wrangler.toml [vars] TURSO_DB_URL = \"YOUR-DATABASE-URL\" In this section of the Cloudflare workers configuration file, we list the environment variables that we don’t consider as sensitive within our app. For the database auth token, run the following command. turso db tokens create the-mug-store Since the auth token is a sensitive environment variable “secret” we store it by using the wrangler CLI, or directly on the project’s dashboard on Cloudflare. But, to do so we first need to grant the wrangler app permissions to use our Cloudflare account, we do that by running the wrangler login command. The following tab will be opened on our browser after running the last command. Click on “Allow” on the resulting permissions page to proceed. Then, on the terminal run wrangler secret put TURSO_DB_AUTH_TOKEN , and paste the database auth token we obtained above when prompted. For local development, create a .dev.vars file at the project’s root directory and add the TURSO_DB_AUTH_TOKEN key assigning it the obtained token. .dev.vars TURSO_DB_AUTH_TOKEN = \"YOUR-DATABASE-TOKEN\" Next up, we'll be setting up Drizzle for simplified database queries within the app. Previous Step 1: Setting up the project Next Step 3: Configuring Drizzle Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Rust SDK | Turso",
    "url": "https://docs.turso.tech/libsql/client-access/rust-sdk",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client accessRust SDK Rust SDK Installation​ Add the libsql-client crate to your project using cargo: $ cargo add libsql-client For CloudFlare Workers code that compiles to WASM, you must use a special configuration: $ cargo add libsql-client --no-default-features -F workers_backend Initialization​ Call the Client::from_config function to create a new Client object: let client = libsql_client::Client::from_config(libsql_client::Config { url: url::Url::parse(\"libsql://localhost:8080\").unwrap(), auth_token: None, }) .await .unwrap(); Example data set​ All of the examples in this section assume tables and data established by these statements: create table example_users ( uid text primary key, email text ); create table example_scores ( uid text, level integer, score integer, primary key (uid, level) ); insert into example_users values ('uid1', 'foo@bar.com'); insert into example_users values ('uid2', 'baz@bar.com'); insert into example_scores values ('uid1', 1, 100); insert into example_scores values ('uid1', 2, 95); Execute a single statement​ SQL string argument​ let rs = client.execute(\"select * from example_users\").await?; // rs is a ResultSet object containing rows and columns Positional placeholders​ Create a new Statement using Statement::with_args and use the args macro to specify the values to bind to the placeholders. use libsql_client::{Statement, args}; let rs = client .execute(Statement::with_args( \"select score from example_scores where uid = ? and level = ?\", args!(\"uid1\", 2), )) .await?; // rs is a ResultSet object containing rows and columns Execute a batch of statements​ INFO Be sure to read the common section on batches for libSQL clients to understand their behavior. use libsql_client::{Statement, args}; let rss = client .batch([ Statement::with_args( \"insert into example_users values (?, ?)\", args!(\"uid3\", \"uid3@turso.tech\"), ), Statement::with_args( \"insert into example_scores values (?, ?, ?)\", args!(\"uid3\", 1, 200), ), ]) .await?; // rss is a Vec containing results from all the queries Interactive transactions​ INFO Be sure to read the common section on interactive transactions for libSQL clients to understand their behavior. The following code uses an interactive transaction to update a user’s level score, but only if it’s greater than the one that currently exists: use libsql_client::{Statement, args}; let uid = \"uid1\"; let level = 1; let new_score = 200; let transaction = client.transaction().await?; let rs = transaction .execute(Statement::with_args( \"select score from example_scores where uid = ? and level = ?\", args!(uid, level), )) .await?; let old_score = rs.rows.first().map(|row| &row.values[0]); let old_score = match old_score { Some(Value::Integer { value: i }) => *i, _ => 0, }; if new_score > old_score { transaction .execute(Statement::with_args( \"update example_scores set score = ? where uid = ? and level = ?\", args!(new_score, uid, level), )) .await?; } transaction.commit().await?; ResultSet​ A ResultSet struct contains values for the rows and columns returned by a query. pub struct ResultSet { pub columns: Vec, pub rows: Vec, pub rows_affected: u64, pub last_insert_rowid: Option, } Each row is contained in a Row struct that provides the values of the row available by column index. pub struct Row { pub values: Vec, } Each Value can be one of the types supported by SQLite: pub enum Value { Null, Integer { value: i64, }, Float { value: f64, }, Text { value: String, }, Blob { value: Vec, }, } Your code will need to make an assumption or a decision about the type of each value found in a Row. The following code examines the first Value in the first Row of a ResultSet and sets up a match for how to interpret it: let row = rs.rows.first().expect(\"one row\"); let value = &row.values[0]; match value { Value::Null => todo!(), Value::Integer { value } => todo!(), Value::Float { value } => todo!(), Value::Text { value } => todo!(), Value::Blob { value } => todo!(), }; If your code is expecting a Text type (containing a Rust &String), then you could express that assumption like this: if let Value::Text { value } = value { println!(\"Text value as &String: {value}\"); } else { return Err(\"Expected a Text value\".into()); } Previous JavaScript & TypeScript SDK Next Python SDK Installation Initialization Example data set Execute a single statement SQL string argument Positional placeholders Execute a batch of statements Interactive transactions ResultSet Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "JavaScript & TypeScript SDK | Turso",
    "url": "https://docs.turso.tech/libsql/client-access/javascript-typescript-sdk",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client accessJavaScript & TypeScript SDK JavaScript & TypeScript SDK The JavaScript SDK comes with TypeScript bindings and supports environments where either language can be used. Both ESM and CJS modules are provided. Example on this page show TypeScript. The following runtime environments are known to be compatible: Node.js version 12 or later Deno CloudFlare Workers Netlify Edge Functions Installation​ Add the @libsql/client package to your project using npm or a package manager of your choice: $ npm install @libsql/client Initialization​ Choose the correct import for your environment​ There are two ways to import the client code. When running in a Node.js or compatible environment, use the standard import: import { createClient } from \"@libsql/client\"; Or, when running in a JavaScript environment without Node.js APIs (for example, Cloudflare Workers or browsers): import { createClient } from \"@libsql/client/web\"; The @libsql/client import allows for local testing using SQLite database files using the exact same API as libSQL remote databases. You can switch between local files and a remote database easily by changing the URL used to initialize the SDK. Use a file: URL to direct the SDK to a local SQLite database file. NOTE The alternate @libsql/client/web import does not support local file URLs. Create a database client object for local and remote access​ For local and remote access, call the createClient factory function and invoke it with your database URL and database client authentication token obtained using the Turso CLI: const client = createClient({ url: \"libsql://your-database.turso.io\", authToken: \"your-auth-token\" }); The authToken property is only required when using a remote database instance managed by Turso. Create a database client object for hybrid access (embedded replica)​ INFO Support for hybrid access with embedded replicas requires version 0.3.5 or later of the SDK. For hybrid access using an embedded replica, call the createClient factory function and invoke it with your database URL, database client authentication token obtained using the Turso CLI, and local database replica file: const client = createClient({ url: \"file:path/to/db-file\", syncUrl: \"libsql://your-database.turso.io\", authToken: \"your-auth-token\" }); // Synchronize the embedded replica with the remote database await client.sync(); For additional information about how embedded replicas work with the SDKs provided for all languages, see the common section on embedded replicas. Client capability summary​ With the returned libSQL Client object you can call: Method Description execute() Execute a single statement batch() Execute a batch of statements transaction() Start an interactive transaction sync() Synchronize the embedded replica from the remote database (hybrid access only) Example data set​ All of the examples in this section assume tables and data established by these statements: create table example_users ( uid text primary key, email text ); create table example_scores ( uid text, level integer, score integer, primary key (uid, level) ); insert into example_users values ('uid1', 'foo@bar.com'); insert into example_users values ('uid2', 'baz@bar.com'); insert into example_scores values ('uid1', 1, 100); insert into example_scores values ('uid1', 2, 95); Execute a single statement​ You can execute a single statement with the execute() method of a Client object. execute() returns a promise that becomes resolved with a ResultSet object, or rejected with an error. SQL string argument​ Pass a single string to execute() to invoke a SQL statement in the SQLite dialect. try { const rs = await client.execute(\"select * from example_users\"); // rs.columns == [ 'uid', 'email' ] // rs.rows[0] == [ 'uid1', 'foo@bar.com' ] // rs.rows[1] == [ 'uid2', 'baz@bar.com' ] } catch (e) { console.error(e); } Positional placeholders​ libSQL supports positional placeholders using the same syntax as SQLite. Pass an object with sql and args properties to execute(). The sql property must be a string containing placeholders, and the args property must be an array of values to bind to the placeholders. try { const rs = await client.execute({ sql: \"select score from example_scores where uid = ? and level = ?\", args: [ \"uid1\", 2 ] }); // rs.columns == [ 'score' ] // rs.rows[0] == [ 95 ] } catch (e) { console.error(e); } Named placeholders​ libSQL supports named placeholders using the same syntax as SQLite. Pass an object with sql and args properties to execute(). sql must be a string containing placeholders, and args must be an object whose properties match the names of the placeholders, and whose values will be bound to the placeholders. try { const rs = await client.execute({ sql: \"insert into example_scores values (:uid, :level, :score)\", args: { uid: \"uid2\", level: 1, score: 50 } }); // rs.columns = [] // rs.rows = [] // rs.rowsAffected == 1 } catch (e) { console.error(e); } In the above example, there are placeholders for uid, level, and score using the prefix character :. The values of the matching properties of args are bound to each placeholder. libSQL supports the same named placeholder prefix characters as SQLite: :, @, and $. Batches and interactive transactions​ Batches and interactive transactions provide a way to execute multiple statements atomically, internally using a SQLite transaction. They both require a mode to be specified to indicate what sort of operations can be executed. The mode is specified as a string in the first argument of the call to batch() or transaction(). Mode SQLite command Description write BEGIN IMMEDIATE The transaction may execute statements that read and write data. Write transactions executed on a replica are forwarded to the primary instance, and can't operate in parallel. read BEGIN TRANSACTION READONLY The transaction may only execute statements that read data (select). Read transactions can occur on replicas, and can operate in parallel with other read transactions. deferred BEGIN DEFERRED The transaction starts in read mode, then changes to write as soon as a write statement is executed. This mode change may fail if there is a write transaction currently executing on the primary. In general: You should prefer to use a read batch or transaction when possible in order to achieve the best latency with replicas, since they don't require interaction with the primary instance. You should be prepared to handle random failures with deferred transactions when a change in mode is required. The probability of such an error becomes more likely as the write load on the primary instance increases. Execute a batch of statements​ INFO Be sure to read the common section on batches for libSQL clients to understand their behavior. To execute multiple statements in a transaction, use the batch() method on the client object, passing it a transaction mode and array of statements. The array may contain any type of statement that is also accepted by execute(). batch() returns a promise that becomes fulfilled with an array of ResultSet objects (one for each statement), or an error. The following code uses a write batch to insert a row for uid3 in two different tables using a transaction that commits them both at the same time. try { const rss = await client.batch([ { sql: \"insert into example_users values (?, ?)\", args: [ \"uid3\", \"uid3@turso.tech\" ] }, { sql: \"insert into example_scores values (?, ?, ?)\", args: [ \"uid3\", 1, 200 ] } ], \"write\"); // rss[0].columns = [] // rss[0].rows = [] // rss[0].rowsAffected == 1 // // rss[1].columns = [] // rss[1].rows = [] // rss[1].rowsAffected == 1 } catch (e) { console.error(e); } Interactive transactions​ INFO Be sure to read the common section on interactive transactions for libSQL clients to understand their behavior. Use the transaction() method on the client object to start an interactive transaction, passing it the mode of the transaction. The returned Transaction object provides the following methods: Method Description execute() Similar to the normal client execute(), except within the context of the transaction commit() Commits all the write statements in the transaction rollback() Rolls back the entire transaction close() Immediately stops the transaction - must be called if the transaction was not committed or rolled back in order to free resources The following code uses a write transaction to update a user’s level score, but only if it’s greater than the one that currently exists: try { const uid = \"uid1\"; const level = 1; const newScore = 200; const transaction = await client.transaction(\"write\"); const rs = await transaction.execute({ sql: \"select score from example_scores where uid = ? and level = ?\", args: [ uid, level ] }); // rs.columns == [ 'score' ] // rs.rows[0]['score'] == 1000 const oldScore = rs.rows[0][\"score\"] as number; if (newScore > oldScore) { await transaction.execute({ sql: \"update example_scores set score = ? where uid = ? and level = ?\", args: [ newScore, uid, level ] }) } await transaction.commit(); } catch (e) { console.error(e); } ResultSet​ Database queries always yield a ResultSet object. This object has the following properties: Property Type Description rows Array An array of Row objects containing the row values, empty for write operations columns Array An array of strings with the names of the columns in the order they appear in each Row, empty for write operations rowsAffected number The number of rows affected by a write statement, 0 otherwise lastInsertRowid bigint | undefined The rowid of a newly inserted row, or undefined if there is none for the statement A Row object contains the values of a row in a ResultSet. It can be indexed by either an integer column index or the name of the column. Each element of a Row can have one of the following types, depending on the source of data: null string number ArrayBuffer (for blobs) const rs = await client.execute({ sql: \"select level, score from example_scores where uid = ?\", args: [ \"uid1\" ] }); for (const row of rs.rows) { // Can index row by column number const level1 = row[0] as number; const score1 = row[1] as number; // Can also index row by column name const level2 = row[\"level\"] as number; const score2 = row[\"score\"] as number; } DANGER With TypeScript, casting row values without first checking their types might result in errors at runtime. Check the type of any values before casting them unless you are absolutely certain of their type. Previous Client SDKs Next Rust SDK Installation Initialization Choose the correct import for your environment Create a database client object for local and remote access Create a database client object for hybrid access (embedded replica) Client capability summary Example data set Execute a single statement SQL string argument Positional placeholders Named placeholders Batches and interactive transactions Execute a batch of statements Interactive transactions ResultSet Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Invalidate Group Tokens | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/invalidate-tokens",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups APIInvalidate Group Tokens Invalidate Group Tokens Invalidate all auth tokens for a group. User Groups​ POST /v1/groups/:group/auth/rotate Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Example​ curl  --request POST --location 'https://api.turso.tech/v1/groups/some_group/auth/rotate'  --header 'Authorization: Bearer TOKEN' Note: The response body is empty but returns HTTP status 200 for successful rotations. Organization Groups​ POST /v1/organizations/:organization/groups/:group/auth/rotate Headers​ Header Example Description Authorization Bearer TOKEN The platform or user auth TOKEN. Path Parameters​ Parameter Type Description organization string The organization name. Example​ curl  --request POST  --location 'https://api.turso.tech/v1/organizations/some_org/groups/some_group/auth/rotate'  --header 'Authorization: Bearer TOKEN' Note: The response body is empty but returns HTTP status 200 for successful rotations. Previous Create Group Token Next Integration with Postgres User Groups Headers Example Organization Groups Headers Path Parameters Example Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Groups API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/groups/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API List Groups Create Group Retrieve Group Delete Group Add location to a group Remove location from a group Create Group Token Invalidate Group Tokens Integration with Postgres Turso Platform REST APIGroups API Groups API The Groups API lets you create a group for a collection of databases that share the same location(s). Operations​ All operations require authentication. List groups Create group Retrieve group Delete group Add location Remove location Mint token Invalidate tokens Objects​ Group object​ Property Type Description name string The name of the group. locations array[string] An array of the locations (three letter codes) assigned to the group. primary string[string] The primary location (three letter code) assigned to the group. Previous Destroy an instance in a logical database Next List Groups Operations Objects Group object Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Database instance API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/instance/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Get all instances in a logical database Get an instance in a logical database Create an instance in a logical database Destroy an instance in a logical database Groups API Integration with Postgres Turso Platform REST APIDatabase instance API Database instance API Summary​ The Database instance API allows you to work with Turso database instances. Before using this API, you must already have a logical database created by the Turso CLI or the Logical database API Operations​ All operations require authentication. Get all instances in a logical database Create an instance in a logical database Destroy an instance in a logical database Wait for an instance to become ready in a logical database Objects​ Database instance object​ Property Type Description uuid string UUID, unique among all instances name string Given name (human readable) type string \"primary\" or \"replica\" region string Location code hostname string The DNS hostname used for client connections; used to build libsql and https URLs Previous Get the current month's usage for a logical database in an organization Next Get all instances in a logical database Summary Operations Objects Database instance object Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Logical database API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/database/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Get all logical databases in an organization Get a logical database in an organization Create a logical database in an organization Update the version of all instances of a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Get the current month's usage for a logical database in an organization Database instance API Groups API Integration with Postgres Turso Platform REST APILogical database API Logical database API Summary​ The Logical database API allows you to work with Turso logical databases within an organization. Each database must be contained within an organization. Every GitHub account has a personal organization with a name based on the GitHub account name. Team organizations are created and managed with the Turso CLI or the Organization API. After creating a logical database, use the Database instance API to add and remove instances within that logical database. Operations​ All operations require authentication. Get all logical databases in an organization Create a logical database in an organization Destroy a logical database in an organization Mint an auth token for a logical database in an organization Invalidate all auth tokens for a logical database in an organization Objects​ Logical database object​ Property Type Description Name string Name of the logical database, unique among all databases in an organization Hostname string The DNS hostname used for client connections; used to build libsql and https URLs IssuedCertLimit number IssuedCertCount number DbId string UUID of the logical database regions string array List of location codes for all instances of this logical database primaryRegion string Location code for the primary instance type string \"logical\" Any username and password values associated with a database are deprecated and should not be used by consumers of this API. Logical database usage object​ Property Type Description uuid string UUID of the logical database instances array List of database instance usage objects of instances contributing usage for the current month Database instance usage object​ Property Type Description uuid string UUID of the database instance usage object Usage object describing the usage of this instance for the current month Usage object​ Property Type Description rows_read number The number of row reads incurred during a monthly billing period rows_written number The number of row writes incurred during a monthly billing period storage_bytes number The total amount of storage used Previous Get all supported locations Next Get all logical databases in an organization Summary Operations Objects Logical database object Logical database usage object Database instance usage object Usage object Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Location API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/location/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Get all supported locations Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APILocation API Location API Summary​ The Location API allows you to discover supported locations for Turso database instances. Operations​ All operations require authentication. Get all supported locations Previous Get all organization members Next Get all supported locations Summary Operations Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Organization API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/organization/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Get all organizations for the user Get all organization members Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIOrganization API Organization API Summary​ The Organization API allows you to work with Turso organizations, which enable team access to the databases contained within them. Operations​ All operations require authentication. Get all organizations for the user Get all organization members The Organization API only allows reading organization data. Use the Turso CLI to create and modify organizations. Objects​ Organization object​ Property Type Description name string The given name of the organization slug string The slug used to identify the organization in API calls; generated by the API based on the name provided during creation type string personal or team Organization member object​ Property Type Description username string The GitHub user name of the org member role string owner (creator) or member Previous Validate a token for a user Next Get all organizations for the user Summary Operations Objects Organization object Organization member object Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Authentication API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/auth/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Get all Platform API tokens for a user Mint a Platform API token for a user Revoke a Platform API token for a user Validate a token for a user Organization API Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST APIAuthentication API Authentication API Summary​ The Authentication API allows you to work with platform authentication tokens for use with all of the Turso Platform APIs. The minted tokens never expire, they can only be revoked. Operations​ All operations require authentication. Get all Platform API tokens for a user Mint a Platform API token for a user Revoke a Platform API token for a user Validate a Platform API token for a user Objects​ Platform API token object​ Property Type Description id string Unique ID, generated by the platform. name string Given name. token string Token string. Only appears in the object returned when minting a new token. Previous Turso Platform REST API Next Get all Platform API tokens for a user Summary Operations Objects Platform API token object Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Turso CLI in review | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/turso-cli-review",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughTurso CLI in review Turso CLI in review Congratulations, you’ve finished the Turso CLI tutorial! You should now be able to effectively use most of the functionality provided by the CLI. Commands you learned​ turso auth signup​ This starts the signup process that allows the CLI to work with Turso databases. turso auth login​ This starts the authentication process, similar to turso auth signup. Since the authentication token you receive expires after 7 days, you must run this periodically to continue working with your databases. turso db locations​ This lists all supported locations, highlighting your current default location. turso db create​ This creates a new logical database in a placement group. A default placement group is created if one doesn't yet exist. turso db show​ This shows details for a specific logical database, including its URL and all of the instances in all locations. turso db list​ This lists all of the logical databases associated with the account that’s currently logged in. turso db shell​ This starts an interactive shell to issue SQL statements against your database. By default it uses the primary, and you can also point it to a replica using its URL. turso group locations add​ This adds a new location to a placement group, replicating all of the databases in that group to that location. turso db inspect​ This shows current database usage for billing purposes. turso db destroy​ This destroys a specific replica by name, or all replicas in a named location, or the entire database. turso auth logout​ This removes the authentication token previously provided by turso auth login, requiring you to log in again to continue working with your databases. Built-in help​ The CLI has help available. The following command summarizes the top-level commands available: turso help For each specific command, you can add the --help flag to get details on all the sub-commands and flags. For example: turso db --help turso db create --help Reference documentation​ To learn about additional the functionality of the CLI, consult its reference documentation. Previous Step 8: Log out of the CLI Commands you learned turso auth signup turso auth login turso db locations turso db create turso db show turso db list turso db shell turso group locations add turso db inspect turso db destroy turso auth logout Built-in help Reference documentation Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 8: Log out of the CLI | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-08-log-out",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 8: Log out of the CLI Step 8: Log out of the CLI To log out, use the following command: turso auth logout This removes the persisted authentication token you received from the last invocation of turso auth signup or turso auth login. To continue working with any databases you created previously, run turso auth login using the same GitHub account. Previous Step 7: Destroy the logical database Next Turso CLI in review Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 7: Destroy the logical database | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-07-destroy-logical-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 7: Destroy the logical database Step 7: Destroy the logical database The CLI can destroy the entire logical database, including the primary and all of its replicas with the following command: turso db destroy my-db This is a very dangerous command since it deletes all data in the database and cannot be reversed. The CLI will interactively prompt you to ask if it’s OK to do so: Database my-db, and all its data will be destroyed. Are you sure you want to do this? [y/n]: Type “y” + return to continue destroying the database. Notes about destroying logical databases: There is no recovery from a destroyed logical database. You can bypass the interactive prompt for use with automated scripts using the --yes flag. Previous Step 6: Inspect database usage Next Step 8: Log out of the CLI Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 6: Inspect database usage | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-06-inspect-database-usage",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 6: Inspect database usage Step 6: Inspect database usage New Turso accounts, are automatically subscribed to the free Starter plan, which has limits to its monthly usage. Run the following command to see your account's current usage among all of its databases as it relates to your plan limits: turso plan show You can see per-database usage with the following command: turso db inspect my-db The output looks similar to the following: Total space used: 40 KiB Number of rows read: 13 Number of rows written: 1 Add the --verbose flag to the command to see a detailed breakdown of usage per table, index, and location. NOTE Internally, Turso uses the SQLite dbstat virtual table to calculate usage among all user-defined tables and indexes. Previous Step 5: Replicate the database to another location Next Step 7: Destroy the logical database Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 5: Replicate the database to another location | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-05-replicate-database-another-location",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 5: Replicate the database to another location Step 5: Replicate the database to another location NOTE In step 3, you created a database in a placement group named \"default\" with a primary location near you. The placement group defines the set of locations where the database is replicated. When you create additional databases in this group it will also exist in the same set of locations, all hosted by the same hardware at those locations. Replicate a database by adding a location to its placement group​ You can add and remove replica locations easily with the Turso CLI. Adding a location to a placement group automatically replicates all of the databases in that group to the new location. Adding replica locations reduces latency for database queries that originate in places near those locations. This is why Turso is referred to as an \"edge\" database - you can better serve users who are geographically distributed by placing copies of data closer to them. Add a new location in Tokyo, Japan (nrt) to your \"default\" group with the following command: turso group locations add default nrt Understand billing for placement groups​ Adding a location to a placement group incurs the cost of one location for the purpose of billing. On the free starter plan, you have an allowance of three locations to use for creating multiple placement groups or adding replica locations to a group. Right now, your \"default\" placement group costs two locations: one for the primary location near you, and one for the replica location in Tokyo. If you add a new logical database to this placement group, it will not incur the cost of another location for billing. All of the databases in a placement group are hosted together on the same hardware. On the free starter plan, you have an allowance of 500 logical databases. Viewing replica information​ You can see the list of locations for the \"default\" placement group: turso group locations list default You can also see the list of locations for a specific logical database using the show command you used earlier: turso db show my-db Name: my-db URL: libsql://my-db-[my-github-name].turso.io ID: [UUID] Group: default Version: [version] Locations: [location], nrt Size: 8.2 kB Database Instances: NAME TYPE LOCATION [loc] primary [loc] nrt replica nrt Previous Step 4: Make queries with the shell Next Step 6: Inspect database usage Replicate a database by adding a location to its placement group Understand billing for placement groups Viewing replica information Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 4: Make queries with the shell | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-04-make-queries-with-shell",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 4: Make queries with the shell Step 4: Make queries with the shell The output of turso db create in the last step shows a command to run to start an interactive shell: turso db shell my-db Connected to my-db at libsql://my-db-[my-github-name].turso.io Welcome to Turso SQL shell! Type \".quit\" to exit the shell and \".help\" to list all available commands. → See that the shell is working with a simple \"hello world\" SQL statement: → select \"hello world\" as message; MESSAGE hello world NOTE The shell requires that SQL commands terminate with a semicolon. If you enter a string that does not, the shell will continue accepting lines of SQL input until a terminating semicolon is provided. NOTE Turso is backed by libSQL, which is a fork of SQLite, so you must provide SQL commands in the SQLite dialect. Create and populate a table, and view its contents by copying the following SQL statements into the shell: → create table users (id text, email text); → insert into users values (\"001\", \"test@foo.com\"); → select * from users; ID EMAIL 001 test@foo.com Run .help to see a list of shell commands. You can see the commands .tables and .schema and use them to inspect the structure of the database: → .tables users → .schema CREATE TABLE users (id text, email text) .quit or CTRL-d ends the shell. → .quit Previous Step 3: Create a logical database Next Step 5: Replicate the database to another location Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 2: Sign up for Turso | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-02-sign-up",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 2: Sign up for Turso Step 2: Sign up for Turso A GitHub account is required to sign up using the Turso CLI. Start the process with the following command: turso auth signup The CLI launches your default browser and asks to log in with GitHub. The first time you log in, you are asked to grant the GitHub Turso app some permissions to your account. Accept this in order to continue. (If desired, you can revoke those permissions later in the GitHub settings for your account.) After the login process completes, the CLI receives a token that identifies you, and stores it in a local file. On macOS, the file is located in $HOME/Library/Application Support/turso. On Linux, it’s $HOME/.config/turso. Some things to note about this token: Do not share this token with anyone you don’t trust fully, as they can use it to work with Turso on your behalf. The token is passed along with all backend API requests made by the CLI while logged in. You can print it using the command turso auth token. It expires after 7 days. After that, you must log in again with turso auth login. Previous Step 1: Installation Next Step 3: Create a logical database Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 3: Create a logical database | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-03-create-database",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 3: Create a logical database Step 3: Create a logical database When creating a logical database, Turso requires a location for the primary instance. By default, it will select a default location based on your physical location as suggested by your IP address. To see all locations supported by Turso, run the following command: turso db locations Your default location appears highlighted in the list. To create a database using the default location with the name my-db: turso db create my-db It takes a few moments to create the database, then generates output similar to the following (with replacements for the parts that may vary): Created group default at [your location] in 9 seconds. Created database my-db at group default in 6 seconds. Start an interactive SQL shell with: turso db shell my-db To see information about the database, including a connection URL, run: turso db show my-db To get an authentication token for the database, run: turso db tokens create my-db NOTE You can override the default location using the --location flag. NOTE You'll see that Turso created both a \"group\" and a \"database\" for you. All databases exist within a container called a \"placement group\". It's not important to understand right now, but we'll come back to that later. As suggested by the output, you can view information about the database using: turso db show my-db The output looks similar to the following: Name: my-db URL: libsql://my-db-[my-github-name].turso.io ID: [UUID] Group: default Version: [version] Locations: [location] Size: 8.2 kB Database Instances: NAME TYPE LOCATION [loc] primary [loc] Note the following in the above output: Database URLs use a custom libsql scheme, and are composed using a combination of the name of the database and your GitHub ID. The URL is the logical database URL that you provide to libSQL client libraries to query the database. This URL automatically forwards the client to the instance with the lowest latency. The primary instance has a random name that was assigned by the CLI. To see a list of all logical databases associated with the account that's currently logged in: turso db list Previous Step 2: Sign up for Turso Next Step 4: Make queries with the shell Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Step 1: Installation | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli/step-01-installation",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthroughStep 1: Installation Step 1: Installation macOS instructions​ To install the Turso CLI on macOS, we recommend that you use Homebrew: brew install tursodatabase/tap/turso The formula includes an executable with autocompletion scripts for bash, fish, and zsh. If you don't use Homebrew, you can use the following command to execute a shell script that installs the CLI: curl -sSfL https://get.tur.so/install.sh | bash Linux instructions​ Run the following command to execute a shell script that installs the CLI: curl -sSfL https://get.tur.so/install.sh | bash Windows instructions​ Installing the Turso CLI on Windows requires that you have WSL installed. You run the scripted install within a WSL shell. For example, run the following command in PowerShell to start a WSL shell: wsl You can then use the following command to execute a shell script that installs the CLI: curl -sSfL https://get.tur.so/install.sh | bash Verify the installation​ INFO If you used the scripted installer, the CLI is installed in a directory called .turso in your home directory. The shell script will attempt to add that to your shell’s PATH. You will need to start a new shell to see the change, or add it manually to the current shell by running the source command printed by the installer. Run the following command to make sure the Turso CLI is in your PATH: turso --version You will need Turso CLI version 0.85.0 or later for this tutorial. Previous Get started with the Turso CLI Next Step 2: Sign up for Turso macOS instructions Linux instructions Windows instructions Verify the installation Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Setup guide | Turso",
    "url": "https://docs.turso.tech/libsql/server/setup",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Setup guide Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK libSQL serverSetup guide Setup guide Obtain a libSQL server binary​ This guide assumes that you have a libSQL server binary to work with. Read the libSQL server BUILD-RUN doc on GitHub to discover your options for building or downloading libSQL server. The examples in this guide assume that the libSQL server binary sqld is in your shell PATH, but that is not a requirement to use it effectively. Required libSQL server configurations​ libSQL server operates with three required configurations, each with a default: Mode (standalone, primary, or replica) Default: standalone Network address for HTTP clients (IP address and port) Default: IP address 127.0.0.1 port 8080 Database directory path on a writable filesystem Default: \"data.sqld\" in the current directory Network access for HTTP clients is configured with the command line flag --http-listen-addr [addr], where addr is specified using IP address and port formatted as IP:PORT. The database directory path is configured with the command line flag --db-path [path/to/dir]. Mode is discussed further in the sections below. Running libSQL server​ Run a libSQL server instance in standalone mode​ Running the sqld executable with no arguments starts libSQL server with the default configurations. To provide those defaults explicitly on the command line: sqld  --http-listen-addr 127.0.0.1:8080  --db-path data.sqld See the section Querying libSQL server below for options to query the running server using the URL for HTTP clients. Run multiple libSQL server instances with replication​ NOTE This section shows how to run separate primary and replica server instances on the same local machine. This requires the configuration of different ports and database directories for both instances. In a production environment, where each instance would normally be deployed to different machines, this is not necessary. The examples in the remainder of this page assume the following shell variables have been established, with configurations for both a primary and replica instance: export SQLD_PRIMARY_HTTP_ADDR=127.0.0.1:8080 export SQLD_PRIMARY_GRPC_ADDR=127.0.0.1:5000 export SQLD_PRIMARY_DB_PATH=primary.sqld export SQLD_REPLICA1_HTTP_ADDR=127.0.0.1:8081 export SQLD_REPLICA1_DB_PATH=replica1.sqld NOTE Only the primary instance must listen on a network address (the “GRPC” address), and the replicas must connect to it. This guide refers to these socket connections between primary and replica as “GRPC replication channels”. To start the primary instance, use the --grpc-listen-addr command line flag to specify the network address for the replica channel: sqld  --http-listen-addr $SQLD_PRIMARY_HTTP_ADDR  --grpc-listen-addr $SQLD_PRIMARY_GRPC_ADDR  --db-path $SQLD_PRIMARY_DB_PATH To start the replica instance on the same machine, use the --primary-grpc-url command line flag to indicate the replication channel to the primary (specified using an HTTP URL): sqld  --http-listen-addr $SQLD_REPLICA1_HTTP_ADDR  --primary-grpc-url http://$SQLD_PRIMARY_GRPC_ADDR  --db-path $SQLD_REPLICA1_DB_PATH You can query each instance separately using its client URL. Read-only queries are serviced by each instance. Queries that write data on a replica get forwarded to the primary before getting replicated back to all replicas. Assuming fast network speeds, clients on each instance always should see the same tables and data. Secure the GRPC replication channel using TLS​ By default, the replication channels between primary and replica instances are not secure. In an environment where security between instances is required, you can configure the channels to use TLS. NOTE The examples here use temporary certificates for development purposes only. In a production environment, you should use certificates signed in a way that suits your needs. You can create certificates for development using the provided Python script. To use it, run the following shell commands: $ pip install cryptography $ python gen_certs.py The output of the script indicates the files created for the certificate authority, client, and server in the current directory: stored cert 'ca' into 'ca_cert.pem' stored private key 'ca' into 'ca_key.pem' stored cert 'server' into 'server_cert.pem' stored private key 'server' into 'server_key.pem' stored cert 'client' into 'client_cert.pem' stored private key 'client' into 'client_key.pem' Note the expiration date on the certificates in the output. With these files, you can start the primary instance with additional flags to add TLS to the GRPC replication channel: sqld  --http-listen-addr $SQLD_PRIMARY_HTTP_ADDR  --grpc-listen-addr $SQLD_PRIMARY_GRPC_ADDR  --db-path $SQLD_PRIMARY_DB_PATH  --grpc-tls  --grpc-ca-cert-file ca_cert.pem  --grpc-cert-file server_cert.pem  --grpc-key-file server_key.pem And start a replica instance similarly: sqld  --http-listen-addr $SQLD_REPLICA1_HTTP_ADDR  --primary-grpc-url http://$SQLD_PRIMARY_GRPC_ADDR  --db-path $SQLD_REPLICA1_DB_PATH  --primary-grpc-tls  --primary-grpc-ca-cert-file ca_cert.pem  --primary-grpc-cert-file client_cert.pem  --primary-grpc-key-file client_key.pem Querying libSQL server​ Once you have a running instance, you can query it using the following tools: The Turso CLI The libSQL client SDKs You can use the Turso CLI to start a shell that queries an instance running locally on the default IP address and port using a URL: turso db shell http://127.0.0.1:8080 You can use the JavaScript client library to query it from your code by providing it the URL: const client = createClient({ url: \"http://127.0.0.1:8080\" }) // Now use client.execute() and other APIs to query libSQL server The client libraries for other languages have similar means of providing the URL. Previous libSQL technical reference Next Client SDKs Obtain a libSQL server binary Required libSQL server configurations Running libSQL server Run a libSQL server instance in standalone mode Run multiple libSQL server instances with replication Secure the GRPC replication channel using TLS Querying libSQL server Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Go SDK | Turso",
    "url": "https://docs.turso.tech/libsql/client-access/go-sdk",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client accessGo SDK Go SDK The Go SDK is implemented as a driver for the standard Go database/sql package. You can read more about how to install it and open a connection to your Turso database using the documentation in the README on GitHub. Note that you must provide a client authentication token in the query string of the URL you receive from the Turso CLI. Previous Python SDK Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Python SDK | Turso",
    "url": "https://docs.turso.tech/libsql/client-access/python-sdk",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client accessPython SDK Python SDK The Python SDK comes with APIs for both synchronous and asynchronous code. Installation​ Add the libsql-client module to your project using pip: $ pip install libsql-client Initialization​ Import the module using libsql_client: import libsql_client If you want to use the synchronous API, use the create_client_sync function: client = libsql_client.create_client_sync( url=\"libsql://your-database.turso.io\" auth_token=\"your-auth-token\" ) If you want to use the asynchronous API, use the create_client function along with asyncio and async/await syntax: client = libsql_client.create_client( url=\"libsql://your-database.turso.io\" auth_token=\"your-auth-token\" ) NOTE Do not use await with create_client(). Only the database operations require that. The auth_token parameter is only required when using a remote database instance managed by Turso. In either case, the returned object exposes an identical API, though they are are defined with different classes. The synchronous client is a thin wrapper around the asynchronous client. The examples on this page use the synchronous API. The equivalent async code can be easily derived from that by applying async and await. For example, a synchronous call to the client's execute() method takes this form: with client: result_set = client.execute(\"...\") # Work with query results While an asynchronous call takes this form: async with client: result_set = await client.execute(\"...\") # Work with query results In both cases above, the with keyword is used to close the client after the work is complete. If you want to work with the client object across functions, you should call close() on it after you're done with the client to clean up the resources it uses. Example data set​ All of the examples in this section assume tables and data established by these statements: create table example_users ( uid text primary key, email text ); create table example_scores ( uid text, level integer, score integer, primary key (uid, level) ); insert into example_users values ('uid1', 'foo@bar.com'); insert into example_users values ('uid2', 'baz@bar.com'); insert into example_scores values ('uid1', 1, 100); insert into example_scores values ('uid1', 2, 95); Execute a single statement​ SQL string argument​ You can execute a single statement with the execute() method of a Client object. It returns a ResultSet object containing the results of the query. rs = client.execute(\"select * from users\") # rs.columns == ('uid', 'email') # rs.rows[0] == ('uid1', 'foo@bar.com') # rs.rows[1] == ('uid2', 'baz@bar.com') Positional placeholders​ libSQL supports positional placeholders using the same syntax as SQLite. Pass two parameters, with the first (stmt) being the SQL string with placeholders, and the second (args) being a list of values to bind to the placeholders. rs = client.execute( \"select score from example_scores where uid = ? and level = ?\", [ \"uid1\", 2 ] ) # rs.columns == ('score',) # rs.rows[0] == (95,) Named placeholders​ libSQL supports named placeholders using the same syntax as SQLite. Pass two parameters, with the first (stmt) must be the SQL string with placeholders, and the second (args) must be a dictionary whose keys match the names of the placeholders, and whose values will be bound to the placeholders. rs = client.execute( \"insert into example_scores values (:uid, :level, :score)\", { \"uid\": \"uid2\", \"level\": 1, \"score\": 50 } ) # rs.columns == () # rs.rows == [] # rs.rows_affected == 1 In the above example, there are placeholders for uid, level, and score using the prefix character :. The values of the matching properties of args are bound to each placeholder. libSQL supports the same named placeholder prefix characters as SQLite: :, @, and $. Execute a batch of statements​ INFO Be sure to read the common section on batches for libSQL clients to understand their behavior. To execute multiple statements in a transaction, use the batch() method on the client object, passing it an list of statements. The list may contain any type of statement that is also accepted by execute(). batch() returns a list of ResultSet objects (one for each statement). The following code inserts a row for uid3 in two different tables using a transaction that commits them both at the same time. rss = client.batch([ libsql_client.Statement( \"insert into example_users values (?, ?)\", [ \"uid3\", \"uid3@turso.tech\" ] ), libsql_client.Statement( \"insert into example_scores values (?, ?, ?)\", [ \"uid3\", 1, 200 ] ), ]) # rss[0].columns == () # rss[0].rows == [] # rss[0].rows_affected == 1 # rss[1].columns == () # rss[1].rows == [] # rss[1].rows_affected == 1 Interactive transactions​ INFO Be sure to read the common section on interactive transactions for libSQL clients to understand their behavior. Use the transaction() method on the client object to create a Transaction object to issue read and write statements to be executed atomically. It provides the following methods: Method Description execute() Similar to the normal client execute(), except within the context of the transaction commit() Commits all the write statements in the transaction rollback() Rolls back the entire transaction close() Immediately stops the transaction; must be called if the transaction was not committed or rolled back in order to free resources. Use with on the transaction object to ensure this happens automatically. This is always synchronous even with the async API. The following code uses an interactive transaction to update a user’s level score, but only if it’s greater than the one that currently exists: uid = \"uid1\" level = 1 new_score = 200 with client.transaction() as transaction: rs = transaction.execute( \"select score from example_scores where uid = ? and level = ?\", [ uid, level ] ) # rs.columns == ('score',) # rs.rows[0] == (200,) old_score = rs.rows[0][\"score\"] if new_score > old_score: transaction.execute( \"update example_scores set score = ? where uid = ? and level = ?\", [ new_score, uid, level ] ) transaction.commit() ResultSet​ Database queries always yield a ResultSet object. This object has the following attribute: Attribute Type Description rows List[Row] A list of Row objects containing the row values, empty for write operations columns Tuple[str, ...] An tuple of strings with the names of the columns in the order they appear in each Row, empty for write operations rows_affected int The number of rows affected by a write statement, 0 otherwise last_insert_rowid Optional[int] The rowid of a newly inserted row, if there was one A ResultSet can also be used as a Sequence of Row objects. The following are all valid on a ResultSet rs: rs[0] to get the first row len(rs) to get the number of rows for row in rs to iterate the rows A Row object is a Sequence that contains the values of a row in a ResultSet. It can be indexed by either an integer column index or the name of the column. Each element of a Row can have one of the following types, depending on the source of data: None (for SQL NULL) str int float bytes (for blobs) rs = client.execute( \"select level, score from example_scores where uid = ?\", [ \"uid1\" ] ) for row in rs.rows: # Can index row by column number level1 = row[0] score1 = row[1] # Can also index row by column name level2 = row[\"level\"] score2 = row[\"score\"] Previous Rust SDK Next Go SDK Installation Initialization Example data set Execute a single statement SQL string argument Positional placeholders Named placeholders Execute a batch of statements Interactive transactions ResultSet Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Rust SDK | Turso",
    "url": "https://docs.turso.tech/libsql/client-access/rust-sdk",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client accessRust SDK Rust SDK Installation​ Add the libsql-client crate to your project using cargo: $ cargo add libsql-client For CloudFlare Workers code that compiles to WASM, you must use a special configuration: $ cargo add libsql-client --no-default-features -F workers_backend Initialization​ Call the Client::from_config function to create a new Client object: let client = libsql_client::Client::from_config(libsql_client::Config { url: url::Url::parse(\"libsql://localhost:8080\").unwrap(), auth_token: None, }) .await .unwrap(); Example data set​ All of the examples in this section assume tables and data established by these statements: create table example_users ( uid text primary key, email text ); create table example_scores ( uid text, level integer, score integer, primary key (uid, level) ); insert into example_users values ('uid1', 'foo@bar.com'); insert into example_users values ('uid2', 'baz@bar.com'); insert into example_scores values ('uid1', 1, 100); insert into example_scores values ('uid1', 2, 95); Execute a single statement​ SQL string argument​ let rs = client.execute(\"select * from example_users\").await?; // rs is a ResultSet object containing rows and columns Positional placeholders​ Create a new Statement using Statement::with_args and use the args macro to specify the values to bind to the placeholders. use libsql_client::{Statement, args}; let rs = client .execute(Statement::with_args( \"select score from example_scores where uid = ? and level = ?\", args!(\"uid1\", 2), )) .await?; // rs is a ResultSet object containing rows and columns Execute a batch of statements​ INFO Be sure to read the common section on batches for libSQL clients to understand their behavior. use libsql_client::{Statement, args}; let rss = client .batch([ Statement::with_args( \"insert into example_users values (?, ?)\", args!(\"uid3\", \"uid3@turso.tech\"), ), Statement::with_args( \"insert into example_scores values (?, ?, ?)\", args!(\"uid3\", 1, 200), ), ]) .await?; // rss is a Vec containing results from all the queries Interactive transactions​ INFO Be sure to read the common section on interactive transactions for libSQL clients to understand their behavior. The following code uses an interactive transaction to update a user’s level score, but only if it’s greater than the one that currently exists: use libsql_client::{Statement, args}; let uid = \"uid1\"; let level = 1; let new_score = 200; let transaction = client.transaction().await?; let rs = transaction .execute(Statement::with_args( \"select score from example_scores where uid = ? and level = ?\", args!(uid, level), )) .await?; let old_score = rs.rows.first().map(|row| &row.values[0]); let old_score = match old_score { Some(Value::Integer { value: i }) => *i, _ => 0, }; if new_score > old_score { transaction .execute(Statement::with_args( \"update example_scores set score = ? where uid = ? and level = ?\", args!(new_score, uid, level), )) .await?; } transaction.commit().await?; ResultSet​ A ResultSet struct contains values for the rows and columns returned by a query. pub struct ResultSet { pub columns: Vec, pub rows: Vec, pub rows_affected: u64, pub last_insert_rowid: Option, } Each row is contained in a Row struct that provides the values of the row available by column index. pub struct Row { pub values: Vec, } Each Value can be one of the types supported by SQLite: pub enum Value { Null, Integer { value: i64, }, Float { value: f64, }, Text { value: String, }, Blob { value: Vec, }, } Your code will need to make an assumption or a decision about the type of each value found in a Row. The following code examines the first Value in the first Row of a ResultSet and sets up a match for how to interpret it: let row = rs.rows.first().expect(\"one row\"); let value = &row.values[0]; match value { Value::Null => todo!(), Value::Integer { value } => todo!(), Value::Float { value } => todo!(), Value::Text { value } => todo!(), Value::Blob { value } => todo!(), }; If your code is expecting a Text type (containing a Rust &String), then you could express that assumption like this: if let Value::Text { value } = value { println!(\"Text value as &String: {value}\"); } else { return Err(\"Expected a Text value\".into()); } Previous JavaScript & TypeScript SDK Next Python SDK Installation Initialization Example data set Execute a single statement SQL string argument Positional placeholders Execute a batch of statements Interactive transactions ResultSet Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "JavaScript & TypeScript SDK | Turso",
    "url": "https://docs.turso.tech/libsql/client-access/javascript-typescript-sdk",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client accessJavaScript & TypeScript SDK JavaScript & TypeScript SDK The JavaScript SDK comes with TypeScript bindings and supports environments where either language can be used. Both ESM and CJS modules are provided. Example on this page show TypeScript. The following runtime environments are known to be compatible: Node.js version 12 or later Deno CloudFlare Workers Netlify Edge Functions Installation​ Add the @libsql/client package to your project using npm or a package manager of your choice: $ npm install @libsql/client Initialization​ Choose the correct import for your environment​ There are two ways to import the client code. When running in a Node.js or compatible environment, use the standard import: import { createClient } from \"@libsql/client\"; Or, when running in a JavaScript environment without Node.js APIs (for example, Cloudflare Workers or browsers): import { createClient } from \"@libsql/client/web\"; The @libsql/client import allows for local testing using SQLite database files using the exact same API as libSQL remote databases. You can switch between local files and a remote database easily by changing the URL used to initialize the SDK. Use a file: URL to direct the SDK to a local SQLite database file. NOTE The alternate @libsql/client/web import does not support local file URLs. Create a database client object for local and remote access​ For local and remote access, call the createClient factory function and invoke it with your database URL and database client authentication token obtained using the Turso CLI: const client = createClient({ url: \"libsql://your-database.turso.io\", authToken: \"your-auth-token\" }); The authToken property is only required when using a remote database instance managed by Turso. Create a database client object for hybrid access (embedded replica)​ INFO Support for hybrid access with embedded replicas requires version 0.3.5 or later of the SDK. For hybrid access using an embedded replica, call the createClient factory function and invoke it with your database URL, database client authentication token obtained using the Turso CLI, and local database replica file: const client = createClient({ url: \"file:path/to/db-file\", syncUrl: \"libsql://your-database.turso.io\", authToken: \"your-auth-token\" }); // Synchronize the embedded replica with the remote database await client.sync(); For additional information about how embedded replicas work with the SDKs provided for all languages, see the common section on embedded replicas. Client capability summary​ With the returned libSQL Client object you can call: Method Description execute() Execute a single statement batch() Execute a batch of statements transaction() Start an interactive transaction sync() Synchronize the embedded replica from the remote database (hybrid access only) Example data set​ All of the examples in this section assume tables and data established by these statements: create table example_users ( uid text primary key, email text ); create table example_scores ( uid text, level integer, score integer, primary key (uid, level) ); insert into example_users values ('uid1', 'foo@bar.com'); insert into example_users values ('uid2', 'baz@bar.com'); insert into example_scores values ('uid1', 1, 100); insert into example_scores values ('uid1', 2, 95); Execute a single statement​ You can execute a single statement with the execute() method of a Client object. execute() returns a promise that becomes resolved with a ResultSet object, or rejected with an error. SQL string argument​ Pass a single string to execute() to invoke a SQL statement in the SQLite dialect. try { const rs = await client.execute(\"select * from example_users\"); // rs.columns == [ 'uid', 'email' ] // rs.rows[0] == [ 'uid1', 'foo@bar.com' ] // rs.rows[1] == [ 'uid2', 'baz@bar.com' ] } catch (e) { console.error(e); } Positional placeholders​ libSQL supports positional placeholders using the same syntax as SQLite. Pass an object with sql and args properties to execute(). The sql property must be a string containing placeholders, and the args property must be an array of values to bind to the placeholders. try { const rs = await client.execute({ sql: \"select score from example_scores where uid = ? and level = ?\", args: [ \"uid1\", 2 ] }); // rs.columns == [ 'score' ] // rs.rows[0] == [ 95 ] } catch (e) { console.error(e); } Named placeholders​ libSQL supports named placeholders using the same syntax as SQLite. Pass an object with sql and args properties to execute(). sql must be a string containing placeholders, and args must be an object whose properties match the names of the placeholders, and whose values will be bound to the placeholders. try { const rs = await client.execute({ sql: \"insert into example_scores values (:uid, :level, :score)\", args: { uid: \"uid2\", level: 1, score: 50 } }); // rs.columns = [] // rs.rows = [] // rs.rowsAffected == 1 } catch (e) { console.error(e); } In the above example, there are placeholders for uid, level, and score using the prefix character :. The values of the matching properties of args are bound to each placeholder. libSQL supports the same named placeholder prefix characters as SQLite: :, @, and $. Batches and interactive transactions​ Batches and interactive transactions provide a way to execute multiple statements atomically, internally using a SQLite transaction. They both require a mode to be specified to indicate what sort of operations can be executed. The mode is specified as a string in the first argument of the call to batch() or transaction(). Mode SQLite command Description write BEGIN IMMEDIATE The transaction may execute statements that read and write data. Write transactions executed on a replica are forwarded to the primary instance, and can't operate in parallel. read BEGIN TRANSACTION READONLY The transaction may only execute statements that read data (select). Read transactions can occur on replicas, and can operate in parallel with other read transactions. deferred BEGIN DEFERRED The transaction starts in read mode, then changes to write as soon as a write statement is executed. This mode change may fail if there is a write transaction currently executing on the primary. In general: You should prefer to use a read batch or transaction when possible in order to achieve the best latency with replicas, since they don't require interaction with the primary instance. You should be prepared to handle random failures with deferred transactions when a change in mode is required. The probability of such an error becomes more likely as the write load on the primary instance increases. Execute a batch of statements​ INFO Be sure to read the common section on batches for libSQL clients to understand their behavior. To execute multiple statements in a transaction, use the batch() method on the client object, passing it a transaction mode and array of statements. The array may contain any type of statement that is also accepted by execute(). batch() returns a promise that becomes fulfilled with an array of ResultSet objects (one for each statement), or an error. The following code uses a write batch to insert a row for uid3 in two different tables using a transaction that commits them both at the same time. try { const rss = await client.batch([ { sql: \"insert into example_users values (?, ?)\", args: [ \"uid3\", \"uid3@turso.tech\" ] }, { sql: \"insert into example_scores values (?, ?, ?)\", args: [ \"uid3\", 1, 200 ] } ], \"write\"); // rss[0].columns = [] // rss[0].rows = [] // rss[0].rowsAffected == 1 // // rss[1].columns = [] // rss[1].rows = [] // rss[1].rowsAffected == 1 } catch (e) { console.error(e); } Interactive transactions​ INFO Be sure to read the common section on interactive transactions for libSQL clients to understand their behavior. Use the transaction() method on the client object to start an interactive transaction, passing it the mode of the transaction. The returned Transaction object provides the following methods: Method Description execute() Similar to the normal client execute(), except within the context of the transaction commit() Commits all the write statements in the transaction rollback() Rolls back the entire transaction close() Immediately stops the transaction - must be called if the transaction was not committed or rolled back in order to free resources The following code uses a write transaction to update a user’s level score, but only if it’s greater than the one that currently exists: try { const uid = \"uid1\"; const level = 1; const newScore = 200; const transaction = await client.transaction(\"write\"); const rs = await transaction.execute({ sql: \"select score from example_scores where uid = ? and level = ?\", args: [ uid, level ] }); // rs.columns == [ 'score' ] // rs.rows[0]['score'] == 1000 const oldScore = rs.rows[0][\"score\"] as number; if (newScore > oldScore) { await transaction.execute({ sql: \"update example_scores set score = ? where uid = ? and level = ?\", args: [ newScore, uid, level ] }) } await transaction.commit(); } catch (e) { console.error(e); } ResultSet​ Database queries always yield a ResultSet object. This object has the following properties: Property Type Description rows Array An array of Row objects containing the row values, empty for write operations columns Array An array of strings with the names of the columns in the order they appear in each Row, empty for write operations rowsAffected number The number of rows affected by a write statement, 0 otherwise lastInsertRowid bigint | undefined The rowid of a newly inserted row, or undefined if there is none for the statement A Row object contains the values of a row in a ResultSet. It can be indexed by either an integer column index or the name of the column. Each element of a Row can have one of the following types, depending on the source of data: null string number ArrayBuffer (for blobs) const rs = await client.execute({ sql: \"select level, score from example_scores where uid = ?\", args: [ \"uid1\" ] }); for (const row of rs.rows) { // Can index row by column number const level1 = row[0] as number; const score1 = row[1] as number; // Can also index row by column name const level2 = row[\"level\"] as number; const score2 = row[\"score\"] as number; } DANGER With TypeScript, casting row values without first checking their types might result in errors at runtime. Check the type of any values before casting them unless you are absolutely certain of their type. Previous Client SDKs Next Rust SDK Installation Initialization Choose the correct import for your environment Create a database client object for local and remote access Create a database client object for hybrid access (embedded replica) Client capability summary Example data set Execute a single statement SQL string argument Positional placeholders Named placeholders Batches and interactive transactions Execute a batch of statements Interactive transactions ResultSet Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Creating an e-commerce store with Remix, Turso, Drizzle, and Cloudflare Workers | Turso",
    "url": "https://docs.turso.tech/tutorials/e-commerce-store-codelab/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Step 1: Setting up the project Step 2: Setting up Turso Step 3: Configuring Drizzle Step 4: Listing store items Step 5: User authentication Step 6: Adding the shopping cart Step 7: Checking out and placing orders Step 8: Deploying the app to Cloudflare Workers Using CloudFlare Workers and TypeScript Example apps and more E-commerce store with Remix, Drizzle & Turso Creating an e-commerce store with Remix, Turso, Drizzle, and Cloudflare Workers In this tutorial, we are going to learn how to build an e-commerce store “The Mugs Store” using the titled stack and afterwards deploy it to Cloudflare workers. The store builds upon the implementation that is listed on the Create a shopping cart using Qwik and Turso, with the addition of user authentication. We are using the stack in question (Cloudflare Workers and Turso) to build The \"Mugs Store\" since it makes for a good combination for an e-commerce website offering low-latency for all visitors as Cloudflare workers places the compute on the edge with a globally distributed network, and with Turso’s database replication, we get to place the site’s data where our users are. The complete source code to the project we will build in this tutorial can also be found on GitHub for reference. Remix is a full stack web framework that lets you focus on the user interface and work back through web standards and deliver a fast, slick, and resilient user experience. Turso is the distributed database based on libSQL, the open-contribution fork of SQLite. Drizzle is a TypeScript Object-Relational Mapping tool (ORM) with support for PostgreSQL, MySQL, and SQLite databases. The tutorial has been broken down to the following steps for readability. Setting up the project​ In this step, you'll be walked through creating a new Remix project and setting up some essential parts of the e-commerce store user interface (UI). Setting up Turso​ In this step, you'll be guided through creating a Turso database, acquiring the database credentials required by the libSQL client library, and adding them as the Remix app's environment variables. Configuring Drizzle​ In this step, you'll be guided through configuring Drizzle as the Remix app's object-relational mapping (ORM) tool. Listing store items​ In this step, you will be walked through implementing the store's product listing and it's associated components. User authentication​ In this step, we'll see how user authentication can be set up to guard some parts of the store that should only be accessible to registered users. Adding the shopping cart​ In this step, we'll go through setting up the store's cart page, a mini cart component that's accessible throughout the store, and implementing logic that will help us manage the items within the cart. Checking out and placing orders​ In this step, we will take care of checking out customers that have added items to their carts and want to place orders. Deploying the app to Cloudflare Workers​ In the final step we will go through the deployment of the e-commerce store to Cloudflare Workers. More resources​ Remix documentation Cloudflare Workers documentation Drizzle documentation Example apps and more on github.com/turso-extended Previous Fermyon Spin with Rust setup guide Next Step 1: Setting up the project Setting up the project Setting up Turso Configuring Drizzle Listing store items User authentication Adding the shopping cart Checking out and placing orders Deploying the app to Cloudflare Workers More resources Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Fermyon Spin with Rust setup guide | Turso",
    "url": "https://docs.turso.tech/tutorials/fermyon-spin-rust-setup-guide/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Fermyon Spin with Rust setup guide Fermyon Spin with Rust setup guide In this setup guide, you will deploy a simple route component to Fermyon Spin that queries a Turso database. The deployment is configured with variables whose values are obtained from the Turso CLI. Prerequisites​ A Fermyon Cloud account The Turso CLI installed on your machine (installation instructions) Rust toolchain installed using rustup (Homebrew installation will not work) Spin CLI installed Familiarity with Spin is suggested (follow the Spin quickstart) Check that the turso CLI is installed: $ turso --version Check that rust is installed using rustup: $ rustup --version rustup 1.26.0 (5af9b9484 2023-04-05) info: This is the version for the rustup toolchain manager, not the rustc compiler. info: The currently active `rustc` version is `rustc 1.70.0 (90c541806 2023-05-31)` You must have the wasm32-wasi toolchain support installed: $ rustup target add wasm32-wasi $ rustup target list | grep wasm32-wasi wasm32-wasi (installed) Check that the Spin CLI is installed: $ spin --version spin 1.3.0 (9fb8256 2023-06-12) Make sure you are already logged in to the CLI using spin login. 1. Create a Turso database​ Run the following Turso CLI command to create a new database named \"turso-fermyon\": $ turso db create turso-fermyon This tutorial does not cover populating or querying tables in the database. Instead, you will simply run a query that requires no tables. 2. Deploy a new spin app using the Rust template​ 2a. Create a new app using a template for Rust​ In a shell, change to a directory where you want to create a project. The Spin CLI will create another directory under it. Run the following Spin CLI command to create a new project using a template: $ spin new Select the \"http-rust\" template. When prompted, give the new application the name \"turso-fermyon\". Take all the other defaults by pressing enter at each prompt. Pick a template to start your application with: http-rust (HTTP request handler using Rust) Enter a name for your new application: turso-fermyon Description: HTTP base: / HTTP path: /... Spin creates a new directory with the in the current directory with the same name that you gave the application. Open src/lib.rs in a code editor. This contains minimal code to respond to an HTTP request at the route specified in spin.toml. It responds with the text \"Hello, Fermyon\". #[http_component] fn handle_turso_fermyon(req: Request) -> Result { println!(\"{:?}\", req.headers()); Ok(http::Response::builder() .status(200) .header(\"foo\", \"bar\") .body(Some(\"Hello, Fermyon\".into()))?) } 2b. Build the template app​ Build the template application as-is without any modifications to verify that it works. $ cd turso-fermyon $ spin build ... Finished building all Spin components The build process creates a file target/wasm32-wasi/release/turso_fermyon.wasm. This file is referenced in the project spin.toml as the component source to deploy. 2c. Run the template app locally​ Run the template app: $ spin up Logging component stdio to \".spin/logs/\" Serving http://127.0.0.1:3000 Available Routes: turso-fermyon: http://127.0.0.1:3000 (wildcard) The output contains a local URL you can use to invoke the route. Copy the URL and use curl to access it: $ curl http://127.0.0.1:3000 Hello, Fermyon It outputs the string \"Hello, Fermyon\". Stop the local Spin server with ctrl-C. 2c. Deploy the template app to Fermyon Cloud​ Deploy the template app: $ spin deploy Uploading turso-fermyon version 0.1.0+rb01010f5... Deploying... Waiting for application to become ready...... ready Available Routes: turso-fermyon: https://turso-fermyon-[RANDOM-CHARS].fermyon.app (wildcard) The output contains a remote URL you can use to invoke the route. It has random characters that are unique to your deployment. Copy the URL and use curl to access it: $ curl https://turso-fermyon-[RANDOM-CHARS].fermyon.app Hello, Fermyon 3. Add the libSQL Rust SDK​ Now that you've verified that you can run and deploy the application, the next step is to change the code add the libSQL client SDK for Rust used to query your Turso database. The libsql-client crate requires the feature spin_backend at installation, and no default features. Run the following command: $ cargo add  --git https://github.com/libsql/libsql-client-rs  --no-default-features -F spin_backend This adds the following line to your Cargo.toml in the [dependencies] table: libsql-client = { git = \"https://github.com/libsql/libsql-client-rs\", version = \"0.31.4\", default-features = false, features = [\"spin_backend\"] } NOTE You must install the client using the GitHub URL. The Spin SDK doesn't support installation of crates from crates.io as you would normally with a Rust program. 3a. Add configuration for Turso in spin.toml​ You can use Spin Application Variables and Secrets to configure values in a Spin app. Add the following lines to spin.toml above the [[component]] table to define two variables whose values will be used later in code: # The [variables] table must occur above the [[component]] table [variables] turso_url = { default = \"libsql://your-turso-database.turso.io\" } turso_auth_token = { required = true, secret = true } NOTE Above, turso_auth_token is defined as a secret variable that will eventually contain a database auth token that you will create later. You should not share this token with anyone you don't trust with full access to your database. Add the following lines to spin.toml below the [[component]] table to add the variables to the component config: # The [component.config] table must occur below the [[component]] table [component.config] turso_url = \"{{ turso_url }}\" turso_auth_token = \"{{ turso_auth_token }}\" Modify the value for allowed_http_hosts within the [[component]] table: # The following line must be modified under the [[component]] table allowed_http_hosts = [\"your-turso-database.turso.io\"] NOTE By default, Spin does not allow any outgoing network connections. In order to query your Turso database, allowed_http_hosts must contain the hostname of your database in order for Spin to allow network access to it. In the above configurations, \"your-turso-database.turso.io\" must be replaced by your Turso database hostname. Run the following Turso CLI command to get the libSQL URL for your database: $ turso db show turso-fermyon --url Copy the hostname part of the URL and paste it to the two places where you see \"your-turso-database.turso.io\" in spin.toml (both the turso_url variable and allowed_http_hosts). NOTE The turso_url variable must have the full URL of the database, including \"libsql://\". The allowed_http_hosts array just requires the hostname part of the URL. The entire spin.toml file will look something like this, with your database hostname substituted in the highlighted lines: spin.toml spin_manifest_version = \"1\" authors = [\"your-name \"] description = \"\" name = \"turso-fermyon\" trigger = { type = \"http\", base = \"/\" } version = \"0.1.0\" [variables] turso_url = { default = \"libsql://turso-fermyon-[your-github].turso.io\" } turso_auth_token = { required = true, secret = true } [[component]] id = \"turso-fermyon\" source = \"target/wasm32-wasi/release/turso_fermyon.wasm\" allowed_http_hosts = [\"turso-fermyon-[your-github].turso.io\"] [component.trigger] route = \"/...\" [component.build] command = \"cargo build --target wasm32-wasi --release\" watch = [\"src/**/*.rs\", \"Cargo.toml\"] [component.config] turso_url = \"{{ turso_url }}\" turso_auth_token = \"{{ turso_auth_token }}\" 3b. Add code to create a client object and query Turso in src/lib.rs​ Open src/lib.rs, delete all of the template code, and replace it with the following: use anyhow::Result; // Use the libsql_client module use libsql_client::{Config, SyncClient}; use spin_sdk::{ http::{Request, Response}, http_component, config, }; /// A simple Spin HTTP component. #[http_component] fn handle_turso_fermyon(_req: Request) -> Result { // Get component configuration for the Turso database let turso_url = config::get(\"turso_url\")?; let turso_auth_token = config::get(\"turso_auth_token\")?; // Create a SyncClient object for querying Turso let libsql_config = Config::new(turso_url.as_str())? .with_auth_token(turso_auth_token); let libsql_client = SyncClient::from_config(libsql_config)?; // Make a query that returns a ResultSet with one row with one column containing a string let rs = libsql_client.execute(\"select 'Hello, Turso'\")?; let message = rs.rows[0].values[0].to_string(); Ok(http::Response::builder() .status(200) .body(Some(message.into()))?) } The value of the turso_auth_token config variable will be specified when running and deploying the component. NOTE This code uses a version of the client SyncClient that offers a fully synchronous API. The libSQL Rust SDK also offers a client with an asynchronous API, but async functions are not yet supported by Spin. NOTE In order to keep this code sample small, it does no error checking at all. You may want to perform your own error checking wherever you see the ? operator. 4. Run the component locally with spin up​ Before running, you will need an auth token string for the turso_auth_token variable in the configuration and code you added in the prior step. Run the following Turso CLI command to get a database auth token: $ turso db tokens create turso-fermyon CAUTION Do not share this token with anyone that you do not trust with full access to your database. Copy the output and paste it into the following command to export a new shell environment variable: $ export SPIN_CONFIG_TURSO_AUTH_TOKEN=\"paste-your-token-here\" NOTE Spin environment variables always start with SPIN_CONFIG_, and the remainder of the env var name must match the variable defined in spin.toml. In this case, the shell environment variable SPIN_CONFIG_TURSO_AUTH_TOKEN contains the value for the turso_auth_token secret variable. Build and run the component locally using the Spin CLI: $ spin build && spin up The Spin CLI outputs the local URL you can use to invoke the component. Copy the URL and paste it on the curl command line: $ curl http://127.0.0.1:3000 Hello, Turso It outputs the message \"Hello, Turso\" generated by the select SQL statement in the code. Stop the local Spin server with ctrl-C. 5. Deploy and run the component on Fermyon Cloud​ Deploy the updated component using the Spin CLI, specifying the value of the turso_auth_token value using the shell environment variable defined in the prior step: $ spin deploy --variable turso_auth_token=\"$SPIN_CONFIG_TURSO_AUTH_TOKEN\" The CLI outputs the same remote URL that you got previously in step 2. Copy the URL and use curl to access it: $ curl https://turso-fermyon-[RANDOM-CHARS].fermyon.app Hello, Turso Congratulations, you have deployed a Spin application to Fermyon Cloud that queries Turso with the libSQL Rust SDK! 6. More resources​ Now that you know how to deploy a Fermyon Spin application using Turso, use the following resources to learn more about how Turso and the libSQL Rust SDK work. Turso documentation Turso CLI reference libSQL Rust SDK reference libsql-client crate Previous Vercel setup guide Next Creating an e-commerce store with Remix, Turso, Drizzle, and Cloudflare Workers Prerequisites 1. Create a Turso database 2. Deploy a new spin app using the Rust template 2a. Create a new app using a template for Rust 2b. Build the template app 2c. Run the template app locally 2c. Deploy the template app to Fermyon Cloud 3. Add the libSQL Rust SDK 3a. Add configuration for Turso in spin.toml 3b. Add code to create a client object and query Turso in src/lib.rs 4. Run the component locally with spin up 5. Deploy and run the component on Fermyon Cloud 6. More resources Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Vercel setup guide | Turso",
    "url": "https://docs.turso.tech/tutorials/vercel-setup-guide/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Vercel setup guide Vercel setup guide In this setup guide, we are deploying a web application made in Nuxt that’s using Turso as its database. The project being deployed is available on this GitHub repo. Prerequisites​ A Vercel account. The Turso CLI installed in your machine (installation instructions). 1. Set up the Turso database​ 1a. Create a new database​ Run the following CLI command: turso db create topwebframeworks 1b. Access the database using the shell.​ Run the following CLI command turso db shell topwebframeworks 1c. Define and populate the database​ Copy and paste the following SQL statements to the shell to create tables, indexes, and seed the database with sample data. -- create frameworks table create table frameworks ( id integer primary key, name varchar (50) not null, language varchar (50) not null, url text not null, stars integer not null ); -- \"name\" column unique index create unique index idx_frameworks_name on frameworks (name); -- \"url\" column unique index create unique index idx_frameworks_url on frameworks (url); -- seed some data insert into frameworks(name, language, url, stars) values(\"Vue.js\" , \"JavaScript\", \"\", 203000); insert into frameworks(name, language, url, stars) values(\"React\", \"JavaScript\", \"\", 206000); insert into frameworks(name, language, url, stars) values(\"Angular\", \"TypeScript\", \"\", 87400); insert into frameworks(name, language, url, stars) values(\"ASP.NET Core\", \"C#\", \"\", 31400); insert into frameworks(name, language, url, stars) values(\"Express\", \"JavaScript\", \"\", 60500); insert into frameworks(name, language, url, stars) values(\"Django\", \"Python\", \"\", 69800); insert into frameworks(name, language, url, stars) values(\"Ruby on Rails\", \"Ruby\", \"\", 52600); insert into frameworks(name, language, url, stars) values(\"Spring\", \"Java\", \"\", 51400); insert into frameworks(name, language, url, stars) values(\"Laravel\", \"PHP\", \"\", 73100); insert into frameworks(name, language, url, stars) values(\"Flask\", \"Python\", \"\", 62500); insert into frameworks(name, language, url, stars) values(\"Ruby\", \"Ruby\", \"\", 41000); insert into frameworks(name, language, url, stars) values(\"Symfony\", \"PHP\", \"\", 28200); insert into frameworks(name, language, url, stars) values(\"CodeIgniter\", \"PHP\", \"\", 18200); insert into frameworks(name, language, url, stars) values(\"CakePHP\", \"PHP\", \"\", 8600); insert into frameworks(name, language, url, stars) values(\"Qwik\", \"TypeScript\", \"\", 16400); 1d. Quit the shell​ Type the following at the shell prompt to terminate the shell: .quit 2. Deploy the app to Vercel​ 2a. Start a guided installation​ Click this button to start a guided deployment. It will copy the app’s source code into your GitHub and deploy it from there. NOTE If you would prefer to fork and deploy the source repo and configure the deployment manually, follow the manual installation instructions at the end of this page. The following instructions assume that you're using the above button to perform the deployment. 2b: Create a copy of the GitHub repository​ Vercel will create a copy of the GitHub repository containing the project’s source to your GitHub account to facilitate continuous integration. After filing up the project’s name and selecting the Git scope, click create to proceed. 2c: Provide the values for the project’s environment variables​ The app (Top Web Frameworks) requires two environment variables to facilitate the connection to the database created earlier: NUXT_TURSO_DB_URL and NUXT_TURSO_DB_AUTH_TOKEN. These values are required by the libSQL TypeScript client SDK to initialize the client and connect to the Turso database. Vercel prompts you for these variables after you complete the previous step. Get the value for NUXT_TURSO_DB_URL​ Run the following CLI command: turso db show topwebframeworks --url It outputs the URL for the database. Copy that string into the NUXT_TURSO_DB_URL variable. Get the value for NUXT_TURSO_DB_AUTH_TOKEN​ Run the following CLI command: turso db tokens create topwebframeworks It outputs a non-expiring authentication token that allows the libSQL client library used by the app to connect to the database. Copy the resulting string into the NUXT_TURSO_DB_AUTH_TOKEN variable. Deploy the app.​ Click the “Deploy” button to finalise the project’s deployment. When the project completes deploying, you’ll be redirected to the project deployment’s congratulatory page seen below. 3. Verify the app works​ In step 1, you  created and seeded the database with some data. You can view the deployed app by clicking the project’s screenshot at the end of step 2 to view the seeded data and verify that the app is correctly connected to Turso. Here onwards, Vercel will automate continuous deployments whenever you push to the created git repository’s production branch unless this setting is manually disabled. (Alternative) manual deployment​ To manually set up your project for deployment on Vercel, without the help of the “Vercel deploy button” in step 2, you can instead use the Vercel dashboard to manually pick your GitHub repo and configure its environment variables. The following instructions will walk you through this process using the same source repository. 1. Fork the repo​ Visit the project on GitHub and fork the repository to your account. 2. Add a new project on your Vercel dashboard​ Open your Vercel dashboard, select “Add New”, and pick “Project”. 3. Authorise Vercel​ If you’ve not authorised Vercel on your GitHub account you’ll be requested to provide such access. Likewise, at the repository level. 4. Pick your GitHub repository​ Next, pick the forked GitHub repository and import it. 5. Configure the site settings​ Set the site settings for your project on Vercel, including the project’s name, build, and output configurations. (For most frameworks, as is the case here, Vercel auto-detects and populates the default configuration for the project.) 6. Configure the app’s environment variables​ The app (Top Web Frameworks) requires two environment variables to facilitate the connection to the database created earlier: NUXT_TURSO_DB_URL and NUXT_TURSO_DB_AUTH_TOKEN. Expand the “Environment Variables” section on the site settings page. These values are required by the libSQL TypeScript client SDK to initialize the client and connect to the Turso database. 6a. Create an environment variable for NUXT_TURSO_DB_URL​ On the available environment section fields, add NUXT_TURSO_DB_URL as a new environment key. Run the following CLI command: turso db show topwebframeworks --url It outputs the URL for the database. Copy that string into the NUXT_TURSO_DB_URL variable, and click the “Add” button. 6b. Create an environment variable for NUXT_TURSO_DB_AUTH_TOKEN​ Add NUXT_TURSO_DB_AUTH_TOKEN as a new environment key. Run the following CLI command: turso db tokens create topwebframeworks -e none It outputs a non-expiring authentication token that allows the libSQL client library used by the app to connect to the database. The -e flag in the command is the short for --expiration. Copy the resulting string into the NUXT_TURSO_DB_AUTH_TOKEN variable, and click the “Add” button. 7. Deploy the site​ After the deployment is completed, you’ll be directed to a congratulatory page like the one below. 8. Preview the site after deployment​ Click the site preview screenshot on the previous step to see the deployed site. Previous Netlify setup guide Next Fermyon Spin with Rust setup guide Prerequisites 1. Set up the Turso database 1a. Create a new database 1b. Access the database using the shell. 1c. Define and populate the database 1d. Quit the shell 2. Deploy the app to Vercel 2a. Start a guided installation 2b: Create a copy of the GitHub repository 2c: Provide the values for the project’s environment variables 3. Verify the app works (Alternative) manual deployment 1. Fork the repo 2. Add a new project on your Vercel dashboard 3. Authorise Vercel 4. Pick your GitHub repository 5. Configure the site settings 6. Configure the app’s environment variables 7. Deploy the site 8. Preview the site after deployment Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Netlify setup guide | Turso",
    "url": "https://docs.turso.tech/tutorials/netlify-setup-guide/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Netlify setup guide Netlify setup guide In this setup guide, you will deploy a web application that uses Turso as its database. The deployment is configured with environment variables whose values are obtained from the Turso CLI. You can find the source code for the app on GitHub. Prerequisites​ A Netlify account The Turso CLI installed on your machine (installation instructions) 1. Set up the Turso database​ 1a. Create a new database​ Run the following CLI command: $ turso db create findmeon 1b. Access the database using the shell​ Run the following CLI command: $ turso db shell findmeon 1c. Define and populate the database​ Copy and paste the following SQL statements into the shell to create tables, indexes, and sample data: -- users table create table users( id integer primary key, email varchar(255) not null, full_name varchar(100) not null, username varchar(50) not null, created_at integer default (cast(unixepoch() as int)) ); -- links table create table links( id integer primary key, user_id integer not null, website varchar(100) not null, link text not null, created_at integer default (cast(unixepoch() as int)), foreign key(user_id) references users(id) ); -- unique index for the email row create unique index idx_users_email on users(email); -- unique index for the username row create unique index idx_users_username on users(username); -- a multicolumn index for the user_id and link columns create unique index idx_links_userid_link on links(user_id, link); -- create user: \"turso\" insert into users(id, email, full_name, username) values(1, \"no-reply@turso.tech\", \"Turso\", \"turso\"); -- add some links to \"turso\" insert into links(user_id, website, link) values(1, \"Twitter\", \"https://twitter.com/tursodatabase\"), (1, \"Linkedin\", \"https://www.linkedin.com/company/turso/\"), (1, \"GitHub\", \"https://github.com/chiselstrike/\"); 1d. Quit the shell​ Type the following at the shell prompt to terminate the shell: .quit 2. Deploy the app to Netlify​ 2a. Start a guided installation​ Click this button to start a guided deployment. It will automatically copy the app's source code into your personal GitHub and deploy it from there. NOTE If you would prefer to fork and deploy the source repo and configure the deployment manually, follow the manual installation instructions at the end of this page. The following instructions assume that you're using the above button to perform the deployment. 2b. Connect your Netlify account to your GitHub account​ Netlify will prompt you to log in with your GitHub account: 2c. Provide values for the project's environment variables​ The app (FindMeOn) requires two environment variables to enable it to connect to the database you created earlier: VITE_TURSO_DB_URL and VITE_TURSO_DB_AUTH_TOKEN. These values are required by the libSQL TypeScript client SDK to initialize the client and connect to the Turso database. Netlify prompts you for those values on the page you see after logging in. Get the value for VITE_TURSO_DB_URL​ Run the following CLI command: $ turso db show findmeon --url It outputs the URL for the database. Copy that string into the VITE_TURSO_DB_URL variable. Get the value for VITE_TURSO_DB_AUTH_TOKEN​ Run the following CLI command: $ turso db tokens create findmeon This creates a long-lived authentication token that allows the libSQL client library used by the app to connect to the database. Copy the string into the VITE_TURSO_DB_AUTH_TOKEN variable. Deploy the app​ Click the \"Save & Deploy\" button to finalize the project’s deployment. This will take you to the \"Site overview\" page on your Netlify dashboard which displays the deployment status of the project. Once deployment is complete, you can verify that the app works. 3. Verify the app works​ In step 1, you created and populated the database with some sample data. You can use the deployed app to view the sample data to verify that it's correctly connected to Turso. Using the deployment URL provided by Netlify, visit the path /u/turso under it. This page displays the user data from the users and links tables. (Alternative) manual installation​ If you want to deploy an app without the help of the \"Deploy to Netlify\" button in step 2, you can instead use the Netlify dashboard to manually specify your GitHub repo and configure its environment variables. The steps below walk you through this process using the same source repository. 1. Fork the repo​ Visit the project on GitHub and fork the repository to your own personal account. 2. Import the project in the Netlify dashboard​ Open your Netlify dashboard, add a new site, and import the existing project that you just forked. 3. Connect to a Git provider​ Choose GitHub from the list (if you forked the repo in step 1). 4. Pick your project’s repository​ Netlify provides a list of repositories in your account. Choose your fork from the list. 5. Configure site settings​ Configure the site settings for your project, including the production branch, build command, publish and base directory. (For most frameworks, Netlify automatically detects and sets this configuration.) 6. Configure the app's environment variables​ The app (FindMeOn) requires two environment variables to enable it to connect to the database you created earlier: VITE_TURSO_DB_URL and VITE_TURSO_DB_AUTH_TOKEN. These values are required by the libSQL TypeScript client SDK to initialize the client and connect to the Turso database. Click the \"Show advanced\" button on the site setting page. 6a. Create an environment variable for VITE_TURSO_DB_URL​ Use the \"New variable\" button to create a new environment variable called VITE_TURSO_DB_URL. Run the following CLI command: $ turso db show findmeon --url It outputs the URL for the database. Copy that string into the VITE_TURSO_DB_URL variable. 6b. Create an environment variable for VITE_TURSO_DB_AUTH_TOKEN​ Use the \"New variable\" button to create a new environment variable called VITE_TURSO_DB_AUTH_TOKEN. Run the following CLI command: $ turso db tokens create findmeon -e none This creates a long-lived authentication token that allows the libSQL client library used by the app to connect to the database. The -e flag in this command is short for --expiration. Copy the string into the VITE_TURSO_DB_AUTH_TOKEN variable. 7. Deploy the site​ 8. Preview the site after deployment​ Previous Turso CLI in review Next Vercel setup guide Prerequisites 1. Set up the Turso database 1a. Create a new database 1b. Access the database using the shell 1c. Define and populate the database 1d. Quit the shell 2. Deploy the app to Netlify 2a. Start a guided installation 2b. Connect your Netlify account to your GitHub account 2c. Provide values for the project's environment variables 3. Verify the app works (Alternative) manual installation 1. Fork the repo 2. Import the project in the Netlify dashboard 3. Connect to a Git provider 4. Pick your project’s repository 5. Configure site settings 6. Configure the app's environment variables 7. Deploy the site 8. Preview the site after deployment Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Integration with Postgres | Turso",
    "url": "https://docs.turso.tech/reference/postgres-integration",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres Integration with Postgres Integration with Postgres If you have an existing Postgres database and want to replicate some portion of it to Turso, you can do that using the pg_turso Postgres plugin. pg_turso allows you to configure specific tables and materialized views for replication. CAUTION pg_turso is currently experimental and not yet ready for production use. To work with pg_turso, you must: Build the plugin from source. Install the plugin using CREATE EXTENSION Choose tables and materialized views to replicate Choose a frequency at which updates are pushed to Turso Invoke a provided function to begin scheduling Data replicated to Turso must be considered read-only for database clients. Writes to Turso replicas are not reflected back into Postgres. Previous Invalidate Group Tokens Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Turso Platform REST API | Turso",
    "url": "https://docs.turso.tech/reference/platform-rest-api/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Authentication API Organization API Location API Logical database API Database instance API Groups API Integration with Postgres Turso Platform REST API Turso Platform REST API The Turso Platform REST API is used to perform actions on data and databases managed by Turso. The following groups of operations are available: Authentication Manage organizations Location discovery Manage logical databases Manage database instances Manage database groups The API is served using HTTPS from the host api.turso.tech. NOTE This API is used directly by the Turso CLI. However, the API does not operate exactly like the interface provided CLI. Each operation includes a reference to the analogous Turso CLI command, noting where there are significant differences in behavior. Conventions​ Request and response​ The API accepts variable inputs from placeholders in the URL path, the query string, and the HTTP body. HTTP request and response bodies are expressed as JSON objects unless otherwise specified. API errors yield an HTTP response body containing a JSON object with a string property named \"error\". Universal HTTP response codes​ Code Meaning 200 OK - operation completed successfully 401 Unauthorized - ensure that the auth token is present and valid 402 Payment required - organization feature is not part of account plan 409 Conflict - resource already exists About the examples in this documentation​ The examples use curl and assume the following shell variables were established ahead of time: export TURSO_BASE_URL=https://api.turso.tech export TURSO_TOKEN=[your-auth-token] For TURSO_TOKEN, read the section about authentication. Authentication​ The Turso Platform API requires that all requests include an authentication token that identifies a user account. Operations are performed on behalf of this user using the permissions granted to that user. The recommended way to authenticate with the platform API is using platform API tokens. You can also authenticate with user tokens from the Turso CLI. NOTE The platform and user tokens mentioned above are different from the database tokens used to allow client application access to the database for the purpose of performing database queries. They are not interchangeable. Platform API tokens​ You can mint a platform API token in two ways: Using the Authentication API Using the Turso CLI (turso auth api-tokens mint) User authentication tokens​ The Turso Platform API also recognizes tokens granted to a user when they log in to the Turso CLI using turso auth login. After logging in, run turso auth token to output the token string. These tokens expire after seven days, so they are not suitable for use with non-interactive applications. Provide a token to the API​ All HTTP requests must include the token string in the Authorization header. The header takes the following form: Authorization: Bearer [token] [token] is is a placeholder for either a platform or user token. Previous Data consistency Next Authentication API Conventions Request and response Universal HTTP response codes About the examples in this documentation Authentication Platform API tokens User authentication tokens Provide a token to the API Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Data consistency | Turso",
    "url": "https://docs.turso.tech/reference/data-consistency",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres Data consistency Data consistency Turso is built on top of libSQL, which is a fork of SQLite. SQLite, as an embedded database, offers a strictly serializable consistency model. However, libSQL, as a network-accessible and replicated database provided by libSQL server, can not offer such a strong guarantee. Connections​ There are two types of connections involved with libSQL server: The HTTP or websocket connection a client makes to a server instance. The underlying SQLite database connection established within the server. For the purpose of this documentation, a SQLite database connection is referred to as a process, which issues an ordered sequence of queries with results. Each database operation exposed by libSQL server (execute a statement, batch, or interactive transaction) is executed within a dedicated process, isolated from all other processes running concurrently. Read and write behavior​ On the primary instance​ All operations by processes connected to the primary are linearizable, forming a ordered sequence of completed operations (a history). All writes are serialized​ All write operations are fully serialized on the primary. When a transaction performs a write operation, all other write operations must wait for the transaction to complete in order to preserve this serialization. DANGER Take care when using an interactive transaction that perform a write operation. Since writes are fully serialized on the primary, a long-running or abandoned transaction will block all writes from other processes until libSQL aborts the transaction after a 5 second timeout. On the replicas​ Writes are forwarded to the primary​ All writes from a process connected to a replica are automatically forwarded to the primary and applied there. Changes to the primary are eventually pulled from each replica and made available locally. A process is guaranteed to see all writes that happened on the primary up until (at least) the last write performed by the process. There are no hard guarantees on how long it will take for a replica to observe a change from the primary, considering network latency and availability, and total load on the primary. Reads are local and not globally ordered​ All reads by a process come from the locally replicated database. Peer replicas are not necessarily all in sync with each other. Reads from different replicas can yield different data until each replica receives the latest changes from the primary. Furthermore, concurrent reads on a replica may observe snapshots of data from different points in time. Monotonic reads​ All database instances offer monotonic reads. A read operation will never appear to yield data older than a prior read on the same instance. Transactional consistency​ A transaction (batch or interactive transaction) is equivalent to a SQLite transaction and observes its semantics. During a transaction: All reads operations are guaranteed snapshot isolation. A transactional read will never yield changes from other processes. All write operations performed by a process are immediately visible to itself in a subsequent read operation. The writes are isolated from all other ongoing transactions. As such, libSQL transactions are considered serializable. Previous SQLite extensions Next Turso Platform REST API Connections Read and write behavior On the primary instance On the replicas Monotonic reads Transactional consistency Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "SQLite extensions | Turso",
    "url": "https://docs.turso.tech/reference/extensions",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres SQLite extensions SQLite extensions CAUTION SQLite extensions are an experimental feature in Turso. Your observations and feedback are welcome on our Discord. SQLite extensions add optional features, supported by the SQLite community, that can be used in queries handled by the SQLite query engine. The instances of libSQL server managed by Turso can be configured to enable a select few extensions. Enabling extensions​ Extensions are enabled using the --enable-extensions flag when creating a database with the Turso CLI. For example: $ turso db create my-db --enable-extensions Extensions can't be enabled for existing databases. List of extensions​ The following extensions are loaded into libSQL server for databases that have extensions enabled. Extension Purpose SQLean Crypto Hashing, message digest, encoding, and decoding SQLean Fuzzy Fuzzy string matching and phonetics SQLean Math Advanced mathematical calculations SQLean Regexp Regular expressions SQLean Stats Common statistical functions SQLean Text String manipulation (reverse, split) SQLean Unicode Case-insensitive string comparison for Unicode strings SQLean UUID Limited support for RFC 4122 compliant UUIDs Vector Similarity Search Vector search capabilities based on Faiss. NOTE SQLite maintains three official extensions that are enabled by default in Turso: JSON, FTS5 (full text search), and R*Tree (range queries). Previous Local development Next Data consistency Enabling extensions List of extensions Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Local development | Turso",
    "url": "https://docs.turso.tech/reference/local-development",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres Local development Local development A Turso database instance runs an open-source server called libSQL server. This server: Handles incoming client connections over HTTP and websockets Offers a JSON-based wire protocol for clients Connects the client to the embedded libSQL database engine (a fork of SQLite) to execute queries Manages the underlying database data in a SQLite database file Turso adds additional features and configurations on top of libSQL server: DNS and secure sockets with SSL Client authentication with database tokens provided by the Turso CLI World-wide instance location support Serverless instance scaling Automatic replication between instances For daily development, you might be satisfied with the core features provided by libSQL server, without the additional features offered by Turso. You might also want to avoid any costs incurred by working with server instances managed by Turso. For these cases, you have three supported options for building and testing client code written with the libSQL client SDKs: Read and write local SQLite data files directly Run libSQL server locally using the Turso CLI Build and run an instance of libSQL server locally Use local SQLite database files​ If you are building for an environment that offers read-write access to a local filesystem, using a SQLite database file is the easiest option. Some development environments for serverless backends don't offer access to a filesystem, such as Wrangler for Cloudflare Workers. Be sure to check the product documentation to find out if you have local filesystem access for your environment. The libSQL client libraries support the use of local SQLite database files to service queries without any intermediate service. To configure a libSQL client to use a local file, you must provide a file: URL to the SDK when creating a client instance. This URL replaces the libsql URL you get from the Turso CLI for the purpose of local development. For example, using the Python SDK: import libsql_client client = libsql_client.create_client_sync( url=\"file:///path/to/file\" ) And using the JavaScript SDK: import { createClient } from \"@libsql/client\"; const client = createClient({ url: \"file:///path/to/file\" }); INFO The JavaScript SDK only supports file URLs when using the default @libsql/client import (not the alternate web or http imports designed for some serverless backend environments). This works in Node.js-compatible environments that have access to the local filesystem. You can also use relative file paths in the form file:relative/path/to/file. Note that no authToken is required when connecting to a file URL. You may provide one, but it will have no effect on the client. Run libSQL server using the Turso CLI​ The Turso CLI can invoke libSQL server on your machine with the following command: $ turso dev It provides a URL that you can use to connect the Turso CLI shell and client code. Learn more about turso dev in the Turso CLI documentation. Build and run libSQL server separately​ You can build and run an instance of libSQL server on your local machine. There are multiple ways to do this, and they are covered in the documentation to build and run libSQL server. Using a local libSQL server instead of Turso​ Once you have a local libSQL server running, you can use an http or ws URL in place of your libsql URL to connect to it. For example, libSQL server runs by default on port 8080, so the URL for that is ws://127.0.0.1:8080. This URL replaces the libsql URL you get from the Turso CLI for the purpose of local development. libSQL server uses a dedicated directory to manage a SQLite database file along with other metadata. By default, the file lives in the relative path data.sqld/data where the server was started. About SQLite database files​ SQLite has a documented file format for its database files. It's not necessary to understand this format, but you can use any tool that understands these files in order to work with them outside of your code. In particular, SQLite provides a command line shell for this purpose. This shell can make it easier for you to create and populate a database for your local development without having to use a client SDK. SQLite does not have very flexible support for multiple processes. If you want to write to a database file manged by libSQL server or some other running process, you should first stop that process in order to avoid SQLITE_BUSY errors. Previous libSQL database URLs Next SQLite extensions Use local SQLite database files Run libSQL server using the Turso CLI Build and run libSQL server separately Using a local libSQL server instead of Turso About SQLite database files Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "libSQL database URLs | Turso",
    "url": "https://docs.turso.tech/reference/libsql-urls",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres libSQL database URLs libSQL database URLs Throughout this documentation, the Turso CLI, and the libSQL client SDKs, you will notice examples of URLs that start with libsql://. These URLs are recognized by libSQL and Turso tools with the following meaning. Database endpoint identification​ A libsql URL identifies a libSQL logical database running libSQL server. A logical database URL connects to an instance of the database (primary or replica) with the lowest latency to the machine making the connection. You can get the URL for a logical database using turso db list and turso db show. Logical database URLs have the following format: libsql://[DB-NAME]-[ORG-NAME].turso.io INFO Turso depends on the hosting service Fly.io to determine the lowest latency instance for a client connection. Typically, this will be the geographically closest instance to the machine running the client, though that may not always be the case. A client using a logical database URL might connect to different instances over time depending on how Fly.io observes network latency. Network protocol​ When provided with a libsql URL, libSQL client libraries are free to choose what they consider to be the best (or only) available protocol that works in the runtime environment where they are running. libSQL server supports both WebSockets and HTTP. Some cloud and edge function providers might not support WebSockets, with HTTP being the only working choice. It's possible that some SDK features might not be available depending on the chosen protocol. You should consult the SDK documentation for details. In the future, each SDK will expose a way to find out which protocol was chosen by the client object. In order to optimize the latency of your application, or use libSQL server instances other than those managed by Turso, you might want to choose a protocol. The protocol is selected using the scheme of the URL. libSQL clients generally support the following schemes: http, https, ws, wss. If you want to specify the use HTTPS, you can replace the libsql scheme of the URL with https. For example, a logical database URL that specifies https has the following format: https://[DB-NAME]-[ORG-NAME].turso.io INFO Turso databases support only the secure https and wss schemes. ws and http are typically only used when developing against a libSQL server instance running locally that can't be configured with an SSL certificate. The underlying data sent using WebSockets or HTTP is expressed as JSON. Documentation for this protocol and the structure of its messages is forthcoming. Latency optimization​ WebSockets tend to perform better when the client SDK can hold a socket open over time to handle multiple queries. However, HTTP tends to perform better for a single query since it requires fewer round trips between client and server. You should benchmark both options if there is any doubt which is better for your use case. Previous Turso CLI Next Local development Database endpoint identification Network protocol Latency optimization Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Turso CLI | Turso",
    "url": "https://docs.turso.tech/reference/turso-cli",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres Turso CLI Turso CLI The Turso CLI is the tool provided for managing Turso databases. If you are getting started for the first time, we recommend following along with the getting started tutorial, which walks you through the process of installation, authentication, creating a database, replicating it, querying it, and destroying it. Conventions​ The example commands on this page assume the following placeholders, expressed as shell variables: $GROUP_NAME: The name of a placement group to work with $DB_NAME: The name of the database that was specified or assigned during creation. $LOCATION_CODE: A three-letter location code that indicate the physical location of a database instance. The command turso db locations outputs a full list of supported location codes. Installation​ The Turso CLI has two installation options. Homebrew (macOS and Linux)​ There is a Homebrew formula that's installed with the following command: $ brew install tursodatabase/tap/turso The formula includes an executable with autocompletion scripts for bash, fish, and zsh. Scripted install​ If you prefer the manage the installation directly, run the following command to execute a shell script that downloads and installs the CLI: $ curl -sSfL https://get.tur.so/install.sh | bash The CLI is installed in a directory called .turso in your home directory. The shell script attempts to add that to your shell’s PATH configuration. You must start a new shell to see the change, or add it manually to the current shell. Verify the installation​ Run the following command to make sure the Turso CLI is in your PATH: $ turso --version Upgrade the CLI​ If Homebrew was used to install the CLI, use the following commands to update it: $ brew update $ brew upgrade If you used the scripted install, use the CLI itself to update: $ turso update Logging in to the CLI​ The Turso CLI requires a GitHub account for authentication. You must log in to be able to work with databases. All databases created while logged in with an account belong to that account and are controlled by it. There is currently no way to share database access with other accounts. Use the command turso auth login to start the login process. The command launches your default browser and prompts you to log in with GitHub. The first time, you are asked to grant the GitHub Turso app some permissions to your account. Accept this in order to continue. (If desired, you can revoke those permissions later in the GitHub settings for your account.) When the authentication process finishes, you are issued a user authentication token. This token identifies your account to Turso. The token expires after one week; afterward, you must log in again to get a new token. INFO The user auth tokens generated by the turso auth login command are different in purpose from database auth tokens for client access and platform API tokens. They are not interchangeable. Running locally​ If you are running the CLI on your local machine, the CLI receives this token as part of the login flow and stores it locally for future use. You can retrieve the persisted token string using: $ turso auth token Running remotely​ If you are running the CLI on a remote machine, it might not be able to launch a browser. In that case, use the URL provided by turso auth login with a browser you have access to in order to authenticate. The process ends with a page showing your token. You can put this string in the environment variable TURSO_API_TOKEN in a shell before running commands using a CLI that is not logged in. For example: $ export TURSO_API_TOKEN=[YOUR-TOKEN-STRING] $ turso db locations Manage placement groups and logical databases​ INFO When working with placement groups, note that they count toward the maximum database allowance in your billing plan, even if you haven’t yet created a database within the group. A placement group requires one database \"unit\" for each location in the group, and you must have that capacity available in your organization when you create a placement group or expand it to another location. Create a placement group​ To create a new placement group using a primary location with the lowest latency to the machine where the command is run: $ turso group create $GROUP_NAME You can specify the location using the --location flag, providing the location's three letter code. NOTE It costs one database from your billing plan’s allowance to create a placement group. NOTE Every placement group is assigned to an organization which is used for collaboration and billing. When you create a database, the CLI uses the current organization as the container. By default, the CLI assumes a personal organization with the same name as your GitHub username. Create a logical database within a group​ To create a new logical database with a random name in the named placement group: $ turso db create --group $GROUP_NAME To specify the name of the database: $ turso db create $DB_NAME --group $GROUP_NAME If you omit the --group flag: If you have only one placement group, it is used. If you don't have any placement groups, one is created using the name \"default\". Create a logical database using a SQLite database file​ To create a new logical database and seed it with the contents of an existing SQLite3-compatible database file, use the --from-file flag: $ turso db create $DB_NAME --group $GROUP_NAME --from-file $DB_FILE The file is limited to 2GB is size. Create a logical database using a SQLite database dump​ To create a new logical database and seed it with the contents of an existing SQLite database dump, use the --from-dump flag: $ turso db create $DB_NAME --group $GROUP_NAME --from-dump $SQL_FILE The file must be a text file with SQL commands. It is typically generated by the .dump command or the Turso CLI or SQLite CLI. Create a logical database by copying another logical database​ To create a new database with the same contents as an existing database in your organization: $ turso db create $DB_NAME --group $GROUP_NAME --from-db $OTHER_DB_NAME Create a logical database by copying another logical database at a point in time (restoring a backup)​ To create a new database with the same contents as an existing database in your organization, with contents specified from a specific point in time, use the --timestamp flag with --from-db: $ turso db create $DB_NAME --group $GROUP_NAME --from-db $OTHER_DB_NAME --timestamp $RFC3339 The --timestamp argument must be a timestamp with RFC3339 format (see timestamp examples). This can be used to eventually restore a database to contents from a particular point in time. After making a copy like this, you must delete the original database and recreate it with the contents of the newly created database. INFO The contents of the newly created database contains data strictly before the given timestamp. It also might be missing up to 15 seconds of data before the timestamp, depending on when Turso last created a periodic batch checkpoint. Replicate a database by adding a location to a group​ You can replicate a logical database by adding a location to its placement group. To add a location: $ turso group locations add $GROUP_NAME $LOCATION_CODE INFO It costs one database from your billing plan’s allowance to add a location to a placement group, no matter how many logical databases are contained within that group. Adding a replica location to a group effectively replicates all logical databases in that group, since they each share the same deployment and replication behavior on the same hardware. Client applications using a logical database URL are routed to the new location if it's observed to have the lowest latency among all available locations in the group. Similarly, you can remove a replica location from a placement group: $ turso group locations remove $GROUP_NAME $LOCATION_CODE INFO Removing a replica location is considered \"safe\" in that doesn't eliminate any of the data in any logical database. The primary location always retains a copy of everything. You can list the locations of a placement group using the list subcommand: $ turso group locations list $GROUP_NAME Destroy a logical database​ DANGER Destruction of a logical database cannot be reversed. All copies of data are deleted. The command prompts you to ensure this is really what you want. To destroy a logical database (from all locations, including the primary): $ turso db destroy $DB_NAME Destroy a placement group​ DANGER Destroying a placement group permanently deletes all copies of all databases in the group. To destroy an existing placement group: $ turso group destroy $GROUP_NAME Update the libSQL server version of a placement group​ To upgrade the version of libSQL server used for every logical database in a placement group: $ turso group update $GROUP_NAME This command causes a brief moment of downtime for each instance as the update happens. All existing connections are closed and must be reconnected. The libSQL client libraries do this automatically. To check the version of libSQL server for a logical database: $ turso db show $DB_NAME Database client authentication tokens​ Client access to query a Turso database from your application requires a database authentication token. Treat any database token as a secret for use only by your application backend. INFO The database auth tokens generated by the turso db tokens create command are different in purpose from the user auth tokens received from logging in to the CLI and platform API auth tokens. They are not interchangeable. Creating a database token​ To get a database auth token suitable for your app, run the following command: $ turso db tokens create $DB_NAME $DB_NAME is the name of your database. This command outputs an auth token string that you can use to configure the libSQL client library wherever it requires an \"auth token\" string. Database tokens are not individually recorded by Turso. You may create as many as you want. By default, these tokens never expire. Token expiration​ If you want to put a limit on how much time a database token is valid, use the --expiration flag to specify a duration in days. For example, for a 7-day token, run the following: $ turso db tokens create $DB_NAME --expiration 7d Read-only database tokens​ To generate an auth token that has read-only access to the database. $ turso db tokens create $DB_NAME --read-only Read-only tokens enable a client to run queries with select, but disallow update, insert, and delete commands. Invalidate database tokens​ If a database token is ever leaked, you can invalidate all prior tokens for your database with the following command: $ turso db tokens invalidate $DB_NAME This command restarts all of your database instances to use a new database token signing key for any new tokens you create afterward. Team collaboration with organizations​ Turso allows you to manage team database access and billing using a grouping mechanism called \"organizations\". By default, the CLI assumes a personal organization with the same name as your GitHub username. Create an organization​ You can create a new organization using the CLI with the command: $ turso org create $ORG_NAME When the organization is created with the CLI: The organization is assigned a \"slug\" string which uniquely identifies it, based on the provided name. Your account is assigned the \"owner\" role. Only one owner per organization is supported. The new organization becomes the current organization for future CLI commands. You can switch to another organization as needed. NOTE Organization slugs are globally unique. Creation of an organization fails in case its assigned slug already exists. List organizations​ To list organizations of which you are the owner or a member: $ turso org list Switch organizations​ To change the current organization for future CLI commands, including those that work with logical databases, provide its unique slug to the following command: $ turso org switch $ORG_SLUG The current organization is persisted in local storage. Delete an organization​ To delete an organization and all of its associated databases and billing information: $ turso org destroy $ORG_SLUG Your personal organization can't be destroyed. The CLI doesn't allow destroying an organization that is also the current organization. You must switch organizations if necessary. Manage members of an organization​ Members of an organization are able to fully control all databases contained within that organization. Only the owner is allow to access billing information. To add a member to the current organization: $ turso org members add $GITHUB_USERNAME Use the -a flag to add with the admin role. To list existing members: $ turso org members list To remove a member from the current organization: $ turso org members rm $GITHUB_USERNAME Invite members to an organization​ The owner of an organization can invite others to join. Sending an invitation requires an email address. It can be any email address, not necessarily linked to a GitHub account. To send the invitation: $ turso org members invite $EMAIL The recipient is asked to sign in to GitHub and accept the invitation to complete the process. Turso then uses the GitHub account's address for further email notifications. Use the -a flag to invite with the admin role. Manage billing​ The owner of an organization may manage billing information for the current organization using the following commands: Command Action turso plan show Shows the current payment plan and usage turso plan upgrade Upgrade the current plan (from starter to scaler) turso plan select Select a specific payment plan turso org billing Update credit card information A credit card is required to switch to the scaler plan. Credit card information is entered on a per-organization basis. The CLI launches a web browser to manage credit card information for the current organization. See the website for Turso pricing information. Platform API auth tokens​ The Turso CLI can mint tokens for authentication with the Turso Platform API. INFO The platform API auth tokens generated by the turso auth api-tokens command are different in purpose from database auth tokens for client access. They are not interchangeable. Mint a platform token​ To mint a new token with a given name: $ turso auth api-tokens mint $TOKEN_NAME The CLI outputs the string value of the token. DANGER Be sure to copy the token to a safe place immediately after minting. The CLI will not display its value again, and it is not recoverable. List platform tokens​ To list all tokens: $ turso auth api-tokens list Revoke a platform token​ To revoke a token with a given name: $ turso auth api-tokens revoke $TOKEN_NAME Inspect database usage​ Total database usage, measured for the purpose of billing, is aggregated across all logical databases associated with an account. Depending on your payment plan, limits are applied to the following usage stats: Total amount of storage Number of rows read Number of rows written Total number of database instances (primary and replicas) Total number of database locations used To see a summary for all databases for your account, use the following command: $ turso plan show You can get more detailed data about the current monthly usage of a single logical database using the following command: $ turso db inspect $DB_NAME It might take up to one minute for the output to reflect recent operations. You can show usage grouped per instance by running: $ turso db inspect $DB_NAME --verbose Database dump and load​ You can dump the entire contents of a Turso database using the following command: $ turso db shell $DB_NAME .dump > dumpfile.sql The file dumpfile.sql contains all of the SQL commands necessary to rebuild the database. libSQL and SQLite internal tables are not present. NOTE .dump is a command you can run in the interactive shell, but you should consider running it on the command line so its output can be easily saved in a file. After creating a dump file, you can then load the dumped data into a new database using the following command: $ turso db shell $NEW_DB_NAME < dumpfile.sql You can also create a new database using the contents of the dump file. Use libSQL server locally​ The Turso CLI can invoke libSQL server for use during local development instead of a managed Turso database. You must have the sqld binary in your shell PATH. To start the server on port 8080, run: $ turso dev This starts libSQL server using an in-memory database. To persist data in a SQLite database file, specify the path of the file: $ turso dev --db-file path/to/db-file The CLI outputs a URL you can use to connect to the local server. Use this URL instead of the Turso database libsql URL when building locally. This URL can be used with turso db shell and the libSQL client libraries. You can change the client access port with the --port flag. Get help​ The CLI offers help for all commands and subcommands. Run turso help to get a list of all commands. Use the --help flag to get help for a specific command or subcommand. For example: turso db --help. Local storage​ The CLI stores persistent data, including your auth token, in a file on your computer. On macOS, the containing folder is $HOME/Library/Application Support/turso. On Linux, it's $HOME/.turso. It's safe to delete this folder, since it can be restored by logging in to the CLI again. Previous Turso technical reference Next libSQL database URLs Conventions Installation Homebrew (macOS and Linux) Scripted install Verify the installation Upgrade the CLI Logging in to the CLI Running locally Running remotely Manage placement groups and logical databases Create a placement group Create a logical database within a group Replicate a database by adding a location to a group Destroy a logical database Destroy a placement group Update the libSQL server version of a placement group Database client authentication tokens Creating a database token Token expiration Read-only database tokens Invalidate database tokens Team collaboration with organizations Create an organization List organizations Switch organizations Delete an organization Manage members of an organization Invite members to an organization Manage billing Platform API auth tokens Mint a platform token List platform tokens Revoke a platform token Inspect database usage Database dump and load Use libSQL server locally Get help Local storage Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Client SDKs | Turso",
    "url": "https://docs.turso.tech/libsql/client-access",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK Client access Client SDKs libSQL provides client SDKs that work for a variety of use cases: Local access (in-memory, or using the same database file format as SQLite) Remote access using a libSQL server instance (including Turso) Hybrid access using an embedded replica of data primarily hosted by libSQL server SDKs are provided for the following languages: JavaScript & TypeScript Rust Python Go Access types​ Local access​ When building an application that uses a local database, the client libraries can act as a replacement for embedded SQLite (using the libSQL core library with native language bindings). The database can be in memory, or persisted to a file using the same database file format as SQLite. To use a libSQL client SDK for local database access, you must provide a file: URL with the path to the database file to use. The SDK attempts to create the file if it doesn’t exist. Remote access​ When building an application that uses a remote libSQL server (including Turso), you can use libSQL client libraries that communicate with the server over HTTP using a custom protocol (“hrana”). This is appropriate for code deployed to edge and serverless frameworks that act as an API gateway or middleware for a client application. To use a libSQL client SDK for remote database access, you must provide an http:, https:, or libsql: URL identifying the libSQL server to use. Turso databases​ For databases hosted by Turso, you must provide a libsql URL and authentication token. The URL for a database can be found using the Turso CLI: $ turso db show $DBNAME --url You can generate a new database client authentication token using the following command: $ turso db tokens create $DBNAME Hybrid access (embedded replica)​ INFO Hybrid access with embedded replicas is currently only supported for the JavaScript runtimes Node.js, Bun, and Deno with write access to a filesystem. Support for hybrid access requires version 0.3.5 or later of the JavaScript SDK. The libSQL client SDKs have the ability to maintain an embedded local copy of the data hosted by a remote libSQL server for fast read access without requiring network connectivity at the time of the query. Applications can request the latest updates from the remote server by simply calling a method. libSQL then figures out which changes on the remote server must be synchronized to the local replica. When the host application performs a write operation, it’s forwarded to the remote libSQL server for execution, similar to the way that all writes to a libSQL server replica are forwarded to the primary instance. Client SDK capabilities​ Batches​ With the libSQL client library, a batch is one or more SQL statements executed in order in an implicit transaction. The transaction is controlled by the libSQL backend. If all of the statements are successful, the transaction is committed. If any of the statements fail, the entire transaction is rolled back and no changes are made. Interactive transactions​ Interactive transactions allow you to execute a series of read and write statements in the context of a SQLite transaction. Reads and writes are all consistent within the scope of that transaction, unaffected by other client activity. The transaction API requires you to choose when to commit or roll back the transaction. DANGER Interactive transactions effectively lock the entire database for writing when a write is first performed, and until the transaction is committed or rolled back. libSQL aborts transactions after a 5 second timeout. Transactions may negatively impact overall database performance when used on high latency connections or with busy databases. Embedded replicas​ In order to use an embedded replica for hybrid access, the SDK must be initialized with three values: The URL of the remote database hosted by libSQL server An authentication token for that database (required only by Turso) The path to the local database file to be kept in sync with the remote database. The local database file is fully compatible with SQLite. CAUTION You should allow the libSQL SDK to create the local database files and perform write operations on them. Writes from other sources are not supported, and the data might be lost upon the next sync with the remote database. When you provide a path to the local database file, two other files appear alongside it with the same name as the database file you provide with \"-shm\" and \"-wal\" suffixes. These files should be considered part of the local database. If you need to relocate the embedded replica, these files should be moved along with the main database file. Previous Setup guide Next JavaScript & TypeScript SDK Access types Local access Remote access Hybrid access (embedded replica) Client SDK capabilities Batches Interactive transactions Embedded replicas Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Get started with the Turso CLI | Turso",
    "url": "https://docs.turso.tech/tutorials/get-started-turso-cli",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Step 1: Installation Step 2: Sign up for Turso Step 3: Create a logical database Step 4: Make queries with the shell Step 5: Replicate the database to another location Step 6: Inspect database usage Step 7: Destroy the logical database Step 8: Log out of the CLI Turso CLI in review Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Turso CLI walkthrough Get started with the Turso CLI The Turso CLI is the main interface to work with Turso databases. You can use it to create, destroy, replicate, and query a database. The following are requirements to get started with Turso using the CLI: macOS, Linux, or WSL A GitHub account Familiarity with a unix style command shell (e.g. bash) Turso requires that you log in using a GitHub account. Any databases you create while logged in effectively belong to that account. Follow along with the commands shown in this tutorial to learn about how the Turso CLI works. Previous Turso tutorials Next Step 1: Installation Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Third party developer tools | Turso",
    "url": "https://docs.turso.tech/3p-dev-tools",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Introduction Concepts Billing details 3p dev tools Tutorials Turso reference libSQL reference 3p dev tools Third party developer tools There are a number of tools supported by third party organizations that work with Turso and libSQL. Migration tools ORMs Query builders Compatibility libraries If you're interested in adding libSQL support to your own tool, please reach out to us to coordinate. Migration tools​ Atlas​ Atlas is an open-source tool for managing and migrating database schemas using modern DevOps principles. In order to work with a Turso database, you can simply provide it with a libsql+wss:// URL for your logical database wherever URLs are accepted by the Atlas CLI. You must also provide an auth token in the URL. For example: atlas schema inspect -u \"libsql+wss://?authToken=\" Go to Atlas documentation for Turso integration. ORMs​ Drizzle ORM​ Drizzle ORM is a TypeScript ORM for SQL databases designed with maximum type safety in mind. Drizzle supports libSQL, with an complete example that shows how to build a Hono server that: Declares a Drizzle schema for tables Uses a Zod validator with the schema to handle incoming JSON Uses the schema make queries with a type-safe, fluent API Switch seamlessly between SQLite local file and Turso remote database Go to the example for libSQL on the Drizzle GitHub. SQLAlchemy​ SQLAlchemy is the Python SQL toolkit and Object Relational Mapper that gives application developers the full power and flexibility of SQL. A dialect is provided for libSQL, which works with Turso. The only requirement for Turso is the construction of a URL in a special format that instructs SQLAlchemy to use this dialect, which is discussed in the README of the dialect repo. Go to the SQLAlchemy libSQL dialect repo on GitHub. Query builders​ Kysely​ Kysely is a type-safe and autocompletion-friendly TypeScript SQL query builder. libSQL provides a plugin (dialect) that allows you to take full advantage of the features of Kysely. Go to the Kysely libSQL dialect repo on GitHub. Knex.js​ Knex.js is a \"batteries included\" SQL query builder for a variety of databases, designed to be flexible, portable, and fun to use. It supports use of libSQL server instances in the same way that it supports local SQLite files by swapping the sqlite3 module with libsql-node-sqlite3. Go to example code in the libsql-node-sqlite3 README. Compatibility libraries​ libsql-node-sqlite3 (node-sqlite3 replacement)​ The sqlite3 node module is commonly used to access SQLite database files. libSQL provides a drop-in replacement module for this that exposes the same API, accessing a libSQL server instance instead. This replacement module can also be used with Knex.js. Go to the libsql-node-sqlite3 repo on GitHub. Previous Billing details Migration tools Atlas ORMs Drizzle ORM SQLAlchemy Query builders Kysely Knex.js Compatibility libraries libsql-node-sqlite3 (node-sqlite3 replacement) Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Billing details | Turso",
    "url": "https://docs.turso.tech/billing-details",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Introduction Concepts Billing details 3p dev tools Tutorials Turso reference libSQL reference Billing details Billing details Pricing tiers​ Turso has three pricing tiers: Starter (free, with limits) Scaler (monthly cost, with limits) Enterprise (unlimited) For a breakdown of what each plan costs and includes, see the pricing page. Usage-based billing model​ For the Starter and Scaler plans, Turso usage is limited monthly based on the following usage observations during each calendar month: Number of table rows read Number of table rows written Amount of total storage The accounting for this usage is based on SQLite internal implementation details. This documentation explains the usage patterns that affect the above metrics. In order to understand the usage of a particular database operation, you must first understand how SQLite implements that operation. Show current monthly usage​ You can use the Turso CLI to inspect usage statistics for a database for the current calendar month. Accounting for rows read​ A \"row read\" is more accurately described as a \"row scanned\" by SQLite during the process of executing a statement. There are two things to know as you observe the rows read metric provided by the Turso CLI: A SQL query may cause more rows to be scanned than are returned by that query. A SQL update statement incurs at least one row read for each row updated. Queries with aggregate functions​ Use of aggregate functions such as count, avg, min, max, and sum incur one row read for each table row considered in the aggregation. INFO You may want to optimize both the cost and performance of aggregation queries by using another table to store aggregate values, and keeping it up to date (using a transaction) as the original table is updated. Queries without a supporting index (full table scan)​ Any query that is not able to make use of an index on a table incurs one row read for each row in the table. Read some general advice on avoiding expensive table scans. Table joins, subqueries, and compound queries​ A query that consults multiple tables incurs one row read for each row that was considered from each table participating in the query. Row updates​ A SQL update command that changes row data incurs one read (in addition to one write) for each row updated. If the update uses a filter to choose rows to modify, and SQLite is unable to use an index to find those rows, it performs a full table scan, incurring one read for each row in the entire table, in addition to one row write for each row updated. ALTER TABLE row reads​ Use of an ALTER TABLE statement that effectively rewrites the contents of each row in a table requires a full table scan, which incurs one row read for each existing row in the table. An ALTER TABLE DROP COLUMN statement might not cause a full-table scan. An ALTER TABLE statement might also incur row writes. Adding an index to a table with existing rows​ Adding an index to a table requires a full table scan, and incurs one read for each row that currently exists in the table. SQLite system tables​ SQLite tables that are maintained internally, such as dbstat and tables prefixed with sqlite_ do not incur row reads when used in a query. Commands that incur no row reads​ If a command doesn't incur any row reads or row writes as part of its execution, the command instead incurs one row read. For example, select 1 incurs one row read. Accounting for rows written​ A \"row written\" includes both a newly inserted row and an update of a single existing row. ALTER TABLE row writes​ ALTER TABLE statements may incur one row write for each existing row if row data is modified during the operation. Read about how SQLite works for different types of alterations. An ALTER TABLE statement might also incur row reads. Aborted transactions​ A row inserted or updated during a transaction still incurs a row write even if the transaction isn't committed. Accounting for total storage​ The SQLite virtual table dbstat is used to determine the total space occupied by all tables and indexes. The smallest unit of measurement is a database file page of 4KB in size. INFO With SQLite databases, the VACUUM command is normally used to optimize storage. This command is currently disabled in Turso. In the future, we hope to provide a way for developers to compact the total storage of a database. Exceeding quotas​ For billing plans with monthly usage quotas for row reads, row writes, and total storage, a query that causes overage fails with the error code BLOCKED. Advice for reducing usage​ To minimize the incurred reads and writes on your database: Read about the SQLite query planner to understand how queries work. Use SQLite's EXPLAIN QUERY PLAN statement to understand if a query performs a full table scan, and if it's using the best available index to minimize reads. Ensure that every query that filters rows is able to use an index to find the relevant rows. Without an index, SQLite performs a table scan to find the rows, which costs one read for each existing row in the table. Add all required indexes at the time a table is created. Adding indexes to tables with existing rows incurs one read for each existing row. Report issues with billing​ If there is a question or problem with your bill or its accounting, contact support@turso.tech. Previous Concepts Next Third party developer tools Pricing tiers Usage-based billing model Show current monthly usage Accounting for rows read Queries with aggregate functions Queries without a supporting index (full table scan) Table joins, subqueries, and compound queries Row updates ALTER TABLE row reads Adding an index to a table with existing rows SQLite system tables Commands that incur no row reads Accounting for rows written ALTER TABLE row writes Aborted transactions Accounting for total storage Exceeding quotas Advice for reducing usage Report issues with billing Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Concepts | Turso",
    "url": "https://docs.turso.tech/concepts",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Introduction Concepts Billing details 3p dev tools Tutorials Turso reference libSQL reference Concepts Concepts In order to better understand how Turso works, please read through the following concepts that are used throughout this documentation. Location​ Turso databases are deployed using Fly.io, which allows Turso to host database instances in many locations around the world, each identified with a three letter code. When creating a logical database in a placement group with replica locations, you should consider which locations best support the code running any queries. In general, the physical distance between the code and the database determines the latency, so it's recommended to benchmark your location options for better performance. By default, when the Turso CLI needs a primary location for a new placement group, it will automatically choose a location based on the physical location of the machine where you run the CLI. The default can be overridden on the command line. Placement group​ Turso requires that all logical databases belong to a \"placement group\". These groups define how the databases in the group are deployed and replicated together in the same set of locations while also sharing the same managed hardware. In the Turso CLI, a placement group is abbreviated as \"group\". You might also hear this feature referred to as \"multitenancy\", where the tenants are databases you create that must share the same replication behavior and managed servers. Placement groups are configured with a single primary location and zero or more replica locations. Each logical database that you create within the placement group uses the same primary and replica locations - they are all \"placed\" together, each using the same replication behavior on the same hardware. However, each logical database within a placement group remains fully independent and isolated in every other way. Once a primary location is assigned to a placement group, it can't be moved to another location. However, replica locations can be added and removed as needed. Logical database​ A logical database is a collection of libSQL databases, each with a schema and data that exists in one primary location and zero or more replica locations for the placement group in which it was created. The schema and data are automatically replicated from the primary to all replicas in the group. A logical database has a unique libSQL URL that, when queried using the libSQL client SDKs, routes the client to the database instance at the location with the lowest latency, therefore minimizing the total round trip time for read operations. Instance​ A database instance is one component of a logical database in specific location. An instance is serviced by a managed installation of libSQL server running on a single machine. Database instances of multiple logical databases in the same placement group are handled by the same libSQL server process in the same hardware. There are two types of instances: primary and replica. Primary​ The primary instance of a logical database is the main source of data for the database. All changes to the logical database are handled by the primary, and those changes are synchronized to all replica instances. Replica​ A replica instance of a logical database contains a copy of all data from the primary, and is kept in sync with it as changes are made over time. Client applications can connect directly to a replica for read and write operations, but any writes are automatically forwarded to the primary. As such, read operations have minimized latency, but write operations must make another hop to the primary. Changes on the primary are then pushed to all replicas. The replicas provide snapshot isolation for read transactions. Previous Turso documentation Next Billing details Location Placement group Logical database Instance Primary Replica Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "libSQL technical reference | Turso",
    "url": "https://docs.turso.tech/libsql/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K libSQL introduction libSQL server Client access JavaScript & TypeScript SDK Rust SDK Python SDK Go SDK libSQL introduction libSQL technical reference This section of the documentation provides details on the tools, SDKs, and protocols used when working with libSQL. Component Source code TypeScript SDK GitHub Rust SDK GitHub Python SDK GitHub Go SDK GitHub libSQL server GitHub Next Setup guide Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Turso tutorials | Turso",
    "url": "https://docs.turso.tech/tutorials/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Tutorials introduction Turso CLI walkthrough Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide E-commerce store with Remix, Drizzle & Turso Using CloudFlare Workers and TypeScript Example apps and more Tutorials introduction Turso tutorials The following guides are available to help you learn how Turso works: Get started with the Turso CLI​ Follow a step-by-step walkthrough of the Turso CLI. You will learn how to log in, create a database, query it, and replicate it to other locations. Netlify setup guide​ This guide illustrates how to use Netlify environment variables to provide values required by the libSQL client library used in a web application deployment. Vercel setup guide​ This guide illustrates how to use Vercel environment variables to provide values required by the libSQL client library used in a web application deployment. Fermyon Spin with Rust setup guide​ This guide illustrates how to use Fermyon Spin variables to provide values required by the libSQL client library for Rust. Creating an e-commerce store with Remix, Turso, Drizzle, and Cloudflare Workers​ This tutorial guides you towards the creation of an e-commerce store using Remix, Turso, Drizzle, and deploying it to Cloudflare Workers. Using Turso with Cloudflare Workers and TypeScript​ This tutorial guides you through the process of creating a Cloudflare Worker with TypeScript and using that to query a Turso database. More resources​ Example apps and more on github.com/turso-extended Working with GraphQL and Turso using Edge Resolvers Next Get started with the Turso CLI Get started with the Turso CLI Netlify setup guide Vercel setup guide Fermyon Spin with Rust setup guide Creating an e-commerce store with Remix, Turso, Drizzle, and Cloudflare Workers Using Turso with Cloudflare Workers and TypeScript More resources Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Turso technical reference | Turso",
    "url": "https://docs.turso.tech/reference/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Reference introduction Turso CLI libSQL database URLs Local development SQLite extensions Data consistency Turso Platform REST API Integration with Postgres Reference introduction Turso technical reference This section of the documentation provides details on the tools, SDKs, and protocols used when working with Turso. Component Source code Turso CLI GitHub Platform REST API Not open source Turso is built upon libSQL, which provides open source, open contribution client and server components. Next Turso CLI Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  },
  {
    "title": "Turso documentation | Turso",
    "url": "https://docs.turso.tech/",
    "html": "Skip to main content Turso docs Home Tutorials Reference libSQL Website Dashboard Search ⌘ K Introduction Concepts Billing details 3p dev tools Tutorials Turso reference libSQL reference Introduction Turso documentation About Turso​ Turso is an edge-hosted, distributed database based on libSQL, an open-source and open-contribution fork of SQLite. It was designed to minimize query latency for applications where queries come from anywhere in the world. In particular, it works well with edge functions provided by cloud platforms such as CloudFlare, Netlify, and Vercel, by putting your data geographically close to the code that accesses it. Getting started​ Install and learn to use the Turso CLI Access Turso using the libSQL client libraries Follow along with Turso tutorials Learn more about Turso​ Watch this video presentation to learn more about the origin of Turso and libSQL, and the problems they were designed to solve. This presentation was given to collegiate level web development students, but is accessible to a wider audience. Next Concepts About Turso Getting started Learn more about Turso Turso: SQLite for the Edge Sign Up Star Our Repo Company About Investors Blog Community Turso Discord libSQL Discord Follow us on Twitter Schedule a Zoom Open Source Turso GitHub Turso extended GitHub libSQL GitHub Legal Privacy Policy Terms of Use Copyright © 2023 Turso, Inc. Built with Docusaurus."
  }
]