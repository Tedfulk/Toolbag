[
  {
    "title": "Intro, Installation, and First Steps - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/",
    "html": "Skip to content SQLModel Intro, Installation, and First Steps Type to start searching tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Type hints Intro Run the code Create a Project Make sure you have Python Create a Python virtual environment Install SQLModel Install DB Browser for SQLite Next Steps SQLModel Tutorial - User Guide Intro, Installation, and First StepsÂ¶ Type hintsÂ¶ If you need a refresher about how to use Python type hints (type annotations), check FastAPI's Python types intro. You can also check the mypy cheat sheet. SQLModel uses type annotations for everything, this way you can use a familiar Python syntax and get all the editor support possible, with autocompletion and in-editor error checking. IntroÂ¶ This tutorial shows you how to use SQLModel with all its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific needs. It is also built to work as a future reference. So you can come back and see exactly what you need. Run the codeÂ¶ All the code blocks can be copied and used directly (they are tested Python files). It is HIGHLY encouraged that you write or copy the code, edit it, and run it locally. Using it in your editor is what really shows you the benefits of SQLModel, seeing how much code it saves you, and all the editor support you get, with autocompletion and in-editor error checks, preventing lots of bugs. Running the examples is what will really help you understand what is going on. You can learn a lot more by running some examples and playing around with them than by reading all the docs here. Create a ProjectÂ¶ Please go ahead and create a directory for the project we will work on on this tutorial. What I normally do is that I create a directory named code inside my home/user directory. And inside of that I create one directory per project. So, for example: Tip Make sure you don't name it also sqlmodel, so that you don't end up overriding the name of the package. Make sure you have PythonÂ¶ Make sure you have an officially supported version of Python. You can check which version you have with: There's a chance that you have multiple Python versions installed. You might want to try with the specific versions, for example with: python3.12 python3.11 python3.10 python3.9 The code would look like this: If you have different versions and python3 is not the latest, make sure you use the latest version you have available. For example python3.9. If you don't have a valid Python version installed, go and install that first. Create a Python virtual environmentÂ¶ When writing Python code, you should always use virtual environments in one way or another. If you don't know what that is, you can read the official tutorial for virtual environments, it's quite simple. In very short, a virtual environment is a small directory that contains a copy of Python and all the libraries you need to run your code. And when you \"activate\" it, any package that you install, for example with pip, will be installed in that virtual environment. Tip There are other tools to manage virtual environments, like Poetry. And there are alternatives that are particularly useful for deployment like Docker and other types of containers. In this case, the \"virtual environment\" is not just the Python standard files and the installed packages, but the whole system. Go ahead and create a Python virtual environment for this project. And make sure to also upgrade pip. Here are the commands you could use: Linux, macOS, Linux in Windows Windows PowerShell Install SQLModelÂ¶ Now, after making sure we are inside of a virtual environment in some way, we can install SQLModel: As SQLModel is built on top of SQLAlchemy and Pydantic, when you install sqlmodel they will also be automatically installed. Install DB Browser for SQLiteÂ¶ Remember that SQLite is a simple database in a single file? For most of the tutorial I'll use SQLite for the examples. Python has integrated support for SQLite, it is a single file read and processed from Python. And it doesn't need an External Database Server, so it will be perfect for learning. In fact, SQLite is perfectly capable of handling quite big applications. At some point you might want to migrate to a server-based database like PostgreSQL (which is also free). But for now we'll stick to SQLite. Through the tutorial I will show you SQL fragments, and Python examples. And I hope (and expect ðŸ§) you to actually run them, and verify that the database is working as expected and showing you the same data. To be able to explore the SQLite file yourself, independent of Python code (and probably at the same time), I recommend you use DB Browser for SQLite. It's a great and simple program to interact with SQLite databases (SQLite files) in a nice user interface. Go ahead and Install DB Browser for SQLite, it's free. Next StepsÂ¶ Okay, let's get going! On the next section we'll start creating a database. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Release Notes - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/release-notes/",
    "html": "Skip to content SQLModel Release Notes Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Latest Changes Internal 0.0.14 Features 0.0.13 Fixes Refactors Upgrades Docs Internal 0.0.12 Features Internal 0.0.11 Features Docs Internal 0.0.10 Features Internal 0.0.9 Breaking Changes Features Fixes Upgrades Docs Internal 0.0.8 Fixes Docs 0.0.7 Features Fixes Docs Internal 0.0.6 Breaking Changes Docs 0.0.5 Features Docs Internal 0.0.4 0.0.3 0.0.2 0.0.1 Release NotesÂ¶ Latest ChangesÂ¶ InternalÂ¶ ðŸ‘· Fix GitHub Actions build docs filter paths for GitHub workflows. PR #738 by @tiangolo. 0.0.14Â¶ FeaturesÂ¶ âœ¨ Add support for Pydantic v2 (while keeping support for v1 if v2 is not available). PR #722 by @tiangolo including initial work in PR #699 by @AntonDeMeester. 0.0.13Â¶ FixesÂ¶ â™»ï¸ Refactor type generation of selects re-order to prioritize models to optimize editor support. PR #718 by @tiangolo. RefactorsÂ¶ ðŸ”‡ Do not raise deprecation warnings for execute as it's automatically used internally. PR #716 by @tiangolo. âœ… Move OpenAPI tests inline to simplify updating them with Pydantic v2. PR #709 by @tiangolo. UpgradesÂ¶ â¬†ï¸ Add support for Python 3.11 and Python 3.12. PR #710 by @tiangolo. DocsÂ¶ âœï¸ Fix typo, simplify single quote/apostrophe character in \"Sister Margaret's\" everywhere in the docs. PR #721 by @tiangolo. ðŸ“ Update docs for Decimal, use proper types. PR #719 by @tiangolo. ðŸ“ Add source examples for Python 3.9 and 3.10. PR #715 by @tiangolo. InternalÂ¶ ðŸ™ˆ Update gitignore, include all coverage files. PR #711 by @tiangolo. ðŸ”§ Update config with new pymdown extensions. PR #712 by @tiangolo. ðŸ”§ Update docs build setup, add support for sponsors, add sponsor GOVCERT.LU. PR #720 by @tiangolo. â¬† [pre-commit.ci] pre-commit autoupdate. PR #697 by @pre-commit-ci[bot]. ðŸ”§ Show line numbers in docs during local development. PR #714 by @tiangolo. ðŸ“ Update details syntax with new pymdown extensions format. PR #713 by @tiangolo. 0.0.12Â¶ FeaturesÂ¶ âœ¨ Upgrade SQLAlchemy to 2.0. PR #700 by @tiangolo including initial work in PR #563 by @farahats9. InternalÂ¶ â¬† [pre-commit.ci] pre-commit autoupdate. PR #686 by @pre-commit-ci[bot]. ðŸ‘· Upgrade latest-changes GitHub Action. PR #693 by @tiangolo. 0.0.11Â¶ FeaturesÂ¶ âœ¨ Add support for passing a custom SQLAlchemy type to Field() with sa_type. PR #505 by @maru0123-2004. You might consider this a breaking change if you were using an incompatible combination of arguments, those arguments were not taking effect and now you will have a type error and runtime error telling you that. âœ¨ Do not allow invalid combinations of field parameters for columns and relationships, sa_column excludes sa_column_args, primary_key, nullable, etc. PR #681 by @tiangolo. DocsÂ¶ ðŸŽ¨ Update inline source examples, hide # in annotations (from MkDocs Material). PR #677 by @Matthieu-LAURENT39. InternalÂ¶ â¬† Update coverage requirement from ^6.2 to >=6.2,<8.0. PR #663 by @dependabot[bot]. â¬† Update mkdocs-material requirement from 9.1.21 to 9.2.7. PR #675 by @dependabot[bot]. â¬†ï¸ Upgrade mypy manually. PR #684 by @tiangolo. â¬† Update black requirement from ^22.10.0 to >=22.10,<24.0. PR #664 by @dependabot[bot]. ðŸ‘· Update CI to build MkDocs Insiders only when the secrets are available, for Dependabot. PR #683 by @tiangolo. 0.0.10Â¶ FeaturesÂ¶ âœ¨ Add support for all Field parameters from Pydantic 1.9.0 and above, make Pydantic 1.9.0 the minimum required version. PR #440 by @daniil-berg. InternalÂ¶ ðŸ”§ Adopt Ruff for formatting. PR #679 by @tiangolo. 0.0.9Â¶ Breaking ChangesÂ¶ ðŸ—‘ï¸ Deprecate Python 3.6 and upgrade Poetry and Poetry Version Plugin. PR #627 by @tiangolo. FeaturesÂ¶ âœ¨ Raise a more clear error when a type is not valid. PR #425 by @ddanier. FixesÂ¶ ðŸ› Fix AsyncSession type annotations for exec(). PR #58 by @Bobronium. ðŸ› Fix allowing using a ForeignKey directly, remove repeated column construction from SQLModelMetaclass.__init__ and upgrade minimum SQLAlchemy to >=1.4.36. PR #443 by @daniil-berg. ðŸ› Fix enum type checks ordering in get_sqlalchemy_type. PR #669 by @tiangolo. ðŸ› Fix SQLAlchemy version 1.4.36 breaks SQLModel relationships (#315). PR #461 by @byrman. UpgradesÂ¶ â¬†ï¸ Upgrade support for SQLAlchemy 1.4.49, update tests. PR #519 by @sandrotosi. â¬† Raise SQLAlchemy version requirement to at least 1.4.29 (related to #434). PR #439 by @daniil-berg. DocsÂ¶ ðŸ“ Clarify description of in-memory SQLite database in docs/tutorial/create-db-and-table.md. PR #601 by @SimonCW. ðŸ“ Tweak wording in docs/tutorial/fastapi/multiple-models.md. PR #674 by @tiangolo. âœï¸ Fix contributing instructions to run tests, update script name. PR #634 by @PookieBuns. ðŸ“ Update link to docs for intro to databases. PR #593 by @abenezerBelachew. ðŸ“ Update docs, use offset in example with limit and where. PR #273 by @jbmchuck. ðŸ“ Fix docs for Pydantic's fields using le (lte is invalid, use le ). PR #207 by @jrycw. ðŸ“ Update outdated link in docs/db-to-code.md. PR #649 by @MatveyF. âœï¸ Fix typos found with codespell. PR #520 by @kianmeng. ðŸ“ Fix typos (duplication) in main page. PR #631 by @Mr-DRP. ðŸ“ Update release notes, add second author to PR. PR #429 by @br-follow. ðŸ“ Update instructions about how to make a foreign key required in docs/tutorial/relationship-attributes/define-relationships-attributes.md. PR #474 by @jalvaradosegura. ðŸ“ Update help SQLModel docs. PR #548 by @tiangolo. âœï¸ Fix typo in internal function name get_sqlachemy_type(). PR #496 by @cmarqu. âœï¸ Fix typo in docs. PR #446 by @davidbrochart. âœï¸ Fix typo in docs/tutorial/create-db-and-table.md. PR #477 by @FluffyDietEngine. âœï¸ Fix small typos in docs. PR #481 by @micuffaro. InternalÂ¶ â¬† [pre-commit.ci] pre-commit autoupdate. PR #672 by @pre-commit-ci[bot]. â¬† Bump dawidd6/action-download-artifact from 2.24.2 to 2.28.0. PR #660 by @dependabot[bot]. âœ… Refactor OpenAPI FastAPI tests to simplify updating them later, this moves things around without changes. PR #671 by @tiangolo. â¬† Bump actions/checkout from 3 to 4. PR #670 by @dependabot[bot]. ðŸ”§ Update mypy config, use strict = true instead of manual configs. PR #428 by @michaeloliverx. â¬†ï¸ Upgrade MkDocs Material. PR #668 by @tiangolo. ðŸŽ¨ Update docs format and references with pre-commit and Ruff. PR #667 by @tiangolo. ðŸŽ¨ Run pre-commit on all files and autoformat. PR #666 by @tiangolo. ðŸ‘· Move to Ruff and add pre-commit. PR #661 by @tiangolo. ðŸ› ï¸ Add CITATION.cff file for academic citations. PR #13 by @sugatoray. ðŸ‘· Update docs deployments to Cloudflare. PR #630 by @tiangolo. ðŸ‘·â€â™‚ï¸ Upgrade CI for docs. PR #628 by @tiangolo. ðŸ‘· Update CI debug mode with Tmate. PR #629 by @tiangolo. ðŸ‘· Update latest changes token. PR #616 by @tiangolo. â¬†ï¸ Upgrade analytics. PR #558 by @tiangolo. ðŸ”§ Update new issue chooser to point to GitHub Discussions. PR #546 by @tiangolo. ðŸ”§ Add template for GitHub Discussion questions and update issues template. PR #544 by @tiangolo. ðŸ‘· Refactor CI artifact upload/download for docs previews. PR #514 by @tiangolo. â¬† Bump actions/cache from 2 to 3. PR #497 by @dependabot[bot]. â¬† Bump dawidd6/action-download-artifact from 2.24.0 to 2.24.2. PR #493 by @dependabot[bot]. ðŸ”§ Update Smokeshow coverage threshold. PR #487 by @tiangolo. ðŸ‘· Move from Codecov to Smokeshow. PR #486 by @tiangolo. â¬† Bump actions/setup-python from 2 to 4. PR #411 by @dependabot[bot]. â¬† Update black requirement from ^21.5-beta.1 to ^22.10.0. PR #460 by @dependabot[bot]. âž• Add extra dev dependencies for MkDocs Material. PR #485 by @tiangolo. â¬† Update mypy requirement from 0.930 to 0.971. PR #380 by @dependabot[bot]. â¬† Update coverage requirement from ^5.5 to ^6.2. PR #171 by @dependabot[bot]. â¬† Bump codecov/codecov-action from 2 to 3. PR #415 by @dependabot[bot]. â¬† Bump actions/upload-artifact from 2 to 3. PR #412 by @dependabot[bot]. â¬† Update flake8 requirement from ^3.9.2 to ^5.0.4. PR #396 by @dependabot[bot]. â¬† Update pytest requirement from ^6.2.4 to ^7.0.1. PR #242 by @dependabot[bot]. â¬† Bump actions/checkout from 2 to 3.1.0. PR #458 by @dependabot[bot]. â¬† Bump dawidd6/action-download-artifact from 2.9.0 to 2.24.0. PR #470 by @dependabot[bot]. ðŸ‘· Update Dependabot config. PR #484 by @tiangolo. 0.0.8Â¶ FixesÂ¶ ðŸ› Fix auto detecting and setting nullable, allowing overrides in field. PR #423 by @JonasKs and @br-follow. â™»ï¸ Update expresion.py, sync from Jinja2 template, implement inherit_cache to solve errors like: SAWarning: Class SelectOfScalar will not make use of SQL compilation caching. PR #422 by @tiangolo. DocsÂ¶ ðŸ“ Adjust and clarify docs for docs/tutorial/create-db-and-table.md. PR #426 by @tiangolo. âœ Fix typo in docs/tutorial/connect/remove-data-connections.md. PR #421 by @VerdantFox. 0.0.7Â¶ FeaturesÂ¶ âœ¨ Allow setting unique in Field() for a column. PR #83 by @raphaelgibson. âœ¨ Update GUID handling to use stdlib UUID.hex instead of an int. PR #26 by @andrewbolster. âœ¨ Raise an exception when using a Pydantic field type with no matching SQLAlchemy type. PR #18 by @elben10. â¬† Upgrade constrain for SQLAlchemy = \">=1.4.17,<=1.4.41\". PR #371 by @RobertRosca. âœ¨ Add new Session.get() parameter execution_options. PR #302 by @tiangolo. FixesÂ¶ ðŸ› Fix type annotations for Model.parse_obj(), and Model.validate(). PR #321 by @phi-friday. ðŸ› Fix Select and SelectOfScalar to inherit cache to avoid warning: SAWarning: Class SelectOfScalar will not make use of SQL compilation caching. PR #234 by @rabinadk1. ðŸ› Fix handling validators for non-default values. PR #253 by @byrman. ðŸ› Fix fields marked as \"set\" in models. PR #117 by @statt8900. ðŸ› Fix Enum handling in SQLAlchemy. PR #165 by @chriswhite199. ðŸ› Fix setting nullable property of Fields that don't accept None. PR #79 by @van51. ðŸ› Fix SQLAlchemy version 1.4.36 breaks SQLModel relationships (#315). PR #322 by @byrman. DocsÂ¶ ðŸ“ Update docs for models for updating, id should not be updatable. PR #335 by @kurtportelli. âœ Fix broken variable/typo in docs for Read Relationships, hero_spider_boy.id => hero_spider_boy.team_id. PR #106 by @yoannmos. ðŸŽ¨ Remove unwanted highlight in the docs. PR #233 by @jalvaradosegura. âœ Fix typos in docs/databases.md and docs/tutorial/index.md. PR #35 by @prrao87. âœ Fix typo in docs/tutorial/relationship-attributes/define-relationships-attributes.md. PR #239 by @jalvaradosegura. âœ Fix typo in docs/tutorial/fastapi/simple-hero-api.md. PR #80 by @joemudryk. âœ Fix typos in multiple files in the docs. PR #400 by @VictorGambarini. âœ Fix typo in docs/tutorial/code-structure.md. PR #344 by @marciomazza. âœ Fix typo in docs/db-to-code.md. PR #155 by @gr8jam. âœ Fix typo in docs/contributing.md. PR #323 by @Fardad13. âœ Fix typo in docs/tutorial/fastapi/tests.md. PR #265 by @johnhoman. âœ Fix typo in docs/tutorial/where.md. PR #286 by @jalvaradosegura. âœ Fix typos in docs/tutorial/fastapi/update.md. PR #268 by @cirrusj. âœ Fix typo in docs/tutorial/fastapi/simple-hero-api.md. PR #247 by @hao-wang. âœ Fix typos in docs/tutorial/automatic-id-none-refresh.md, docs/tutorial/fastapi/update.md, docs/tutorial/select.md. PR #185 by @rootux. âœ Fix typo in docs/databases.md. PR #177 by @seandlg. âœ Fix typos in docs/tutorial/fastapi/update.md. PR #162 by @wmcgee3. âœ Fix typos in docs/tutorial/code-structure.md, docs/tutorial/fastapi/multiple-models.md, docs/tutorial/fastapi/simple-hero-api.md, docs/tutorial/many-to-many/index.md. PR #116 by @moonso. âœ Fix typo in docs/tutorial/fastapi/teams.md. PR #154 by @chrisgoddard. âœ Fix typo variable in example about relationships and back_populates, always use hero instead of owner. PR #120 by @onionj. âœ Fix typo in docs/tutorial/fastapi/tests.md. PR #113 by @feanil. âœ Fix typo in docs/tutorial/where.md. PR #72 by @ZettZet. âœ Fix typo in docs/tutorial/code-structure.md. PR #91 by @dhiraj. âœ Fix broken link to newsletter sign-up in docs/help.md. PR #84 by @mborus. âœ Fix typos in docs/tutorial/many-to-many/create-models-with-link.md. PR #45 by @xginn8. âœ Fix typo in docs/tutorial/index.md. PR #398 by @ryangrose. InternalÂ¶ â™» Refactor internal statements to simplify code. PR #53 by @yezz123. â™» Refactor internal imports to reduce redundancy. PR #272 by @aminalaee. â¬† Update development requirement for FastAPI from ^0.68.0 to ^0.68.1. PR #48 by @alucarddelta. âª Revert upgrade Poetry, to make a release that supports Python 3.6 first. PR #417 by @tiangolo. ðŸ‘· Add dependabot for GitHub Actions. PR #410 by @tiangolo. â¬†ï¸ Upgrade Poetry to version ==1.2.0b1. PR #303 by @tiangolo. ðŸ‘· Add CI for Python 3.10. PR #305 by @tiangolo. ðŸ“ Add Jina's QA Bot to the docs to help people that want to ask quick questions. PR #263 by @tiangolo. ðŸ‘· Upgrade Codecov GitHub Action. PR #304 by @tiangolo. ðŸ’š Only run CI on push when on master, to avoid duplicate runs on PRs. PR #244 by @tiangolo. ðŸ”§ Upgrade MkDocs Material and update configs. PR #217 by @tiangolo. â¬† Upgrade mypy, fix type annotations. PR #218 by @tiangolo. 0.0.6Â¶ Breaking ChangesÂ¶ SQLModel no longer creates indexes by default for every column, indexes are now opt-in. You can read more about it in PR #205. Before this change, if you had a model like this: from typing import Optional from sqlmodel import Field, SQLModel class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None ...when creating the tables, SQLModel version 0.0.5 and below, would also create an index for name, one for secret_name, and one for age (id is the primary key, so it doesn't need an additional index). If you depended on having an index for each one of those columns, now you can (and would have to) define them explicitly: class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str = Field(index=True) age: Optional[int] = Field(default=None, index=True) There's a high chance you don't need indexes for all the columns. For example, you might only need indexes for name and age, but not for secret_name. In that case, you could define the model as: class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) If you already created your database tables with SQLModel using versions 0.0.5 or below, it would have also created those indexes in the database. In that case, you might want to manually drop (remove) some of those indexes, if they are unnecessary, to avoid the extra cost in performance and space. Depending on the database you are using, there will be a different way to find the available indexes. For example, let's say you no longer need the index for secret_name. You could check the current indexes in the database and find the one for secret_name, it could be named ix_hero_secret_name. Then you can remove it with SQL: DROP INDEX ix_hero_secret_name or DROP INDEX ix_hero_secret_name ON hero; Here's the new, extensive documentation explaining indexes and how to use them: Indexes - Optimize Queries. DocsÂ¶ âœ¨ Document indexes and make them opt-in. Here's the new documentation: Indexes - Optimize Queries. This is the same change described above in Breaking Changes. PR #205 by @tiangolo. âœ Fix typo in FastAPI tutorial. PR #192 by @yaquelinehoyos. ðŸ“ Add links to the license file. PR #29 by @sobolevn. âœ Fix typos in docs titles. PR #28 by @Batalex. âœ Fix multiple typos and some rewording. PR #22 by @egrim. âœ Fix typo in docs/tutorial/automatic-id-none-refresh.md. PR #14 by @leynier. âœ Fix typos in docs/tutorial/index.md and docs/databases.md. PR #5 by @sebastianmarines. 0.0.5Â¶ FeaturesÂ¶ âœ¨ Add support for Decimal fields from Pydantic and SQLAlchemy. Original PR #103 by @robcxyz. New docs: Advanced User Guide - Decimal Numbers. DocsÂ¶ âœ Update decimal tutorial source for consistency. PR #188 by @tiangolo. InternalÂ¶ ðŸ”§ Split MkDocs insiders build in CI to support building from PRs. PR #186 by @tiangolo. ðŸŽ¨ Format expression.py and expression template, currently needed by CI. PR #187 by @tiangolo. ðŸ›Fix docs light/dark theme switcher. PR #1 by @Lehoczky. ðŸ”§ Add MkDocs Material social cards. PR #90 by @tiangolo. âœ¨ Update type annotations and upgrade mypy. PR #173 by @tiangolo. 0.0.4Â¶ ðŸŽ¨ Fix type detection of select results in PyCharm. PR #15 by @tiangolo. 0.0.3Â¶ â¬†ï¸ Update and relax specification range for sqlalchemy-stubs. PR #4 by @tiangolo. 0.0.2Â¶ This includes several small bug fixes detected during the first CI runs. ðŸ’š Fix CI installs and tests. PR #2 by @tiangolo. 0.0.1Â¶ First release. ðŸŽ‰ Made with Material for MkDocs Insiders"
  },
  {
    "title": "SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/databases/#sql-the-language",
    "html": "SQLModel Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes 404 - Not found Made with Material for MkDocs Insiders"
  },
  {
    "title": "Contributing - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/contributing/",
    "html": "Skip to content SQLModel Contributing Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Developing Poetry Poetry Shell Using your local SQLModel Format Docs Docs for tests Tests Thanks ContributingÂ¶ First, you might want to see the basic ways to help SQLModel and get help. DevelopingÂ¶ If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. PoetryÂ¶ SQLModel uses Poetry to build, package, and publish the project. You can learn how to install it in the Poetry docs. After having Poetry available, you can install the development dependencies: fast â†’ It will also create a virtual environment automatically and will install all the dependencies and your local SQLModel in it. Poetry ShellÂ¶ To use your current environment, and to have access to all the tools in it (for example pytest for the tests) enter into a Poetry Shell: fast â†’ That will set up the environment variables needed and start a new shell with them. Using your local SQLModelÂ¶ If you create a Python file that imports and uses SQLModel, and run it with the Python from your local Poetry environment, it will use your local SQLModel source code. And if you update that local SQLModel source code, when you run that Python file again, it will use the fresh version of SQLModel you just edited. Poetry takes care of making that work. But of course, it will only work in the current Poetry environment, if you install standard SQLModel in another environment (not from the source in the GitHub repo), that will use the standard SQLModel, not your custom version. FormatÂ¶ There is a script that you can run that will format and clean all your code: It will also auto-sort all your imports. DocsÂ¶ The documentation uses MkDocs with Material for MkDocs. All the documentation is in Markdown format in the directory ./docs. Many of the tutorials have blocks of code. In most of the cases, these blocks of code are actual complete applications that can be run as is. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./docs_src/ directory. And those Python files are included/injected in the documentation when generating the site. Docs for testsÂ¶ Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: It will serve the documentation on http://127.0.0.1:8008. That way, you can edit the documentation/source files and see the changes live. TestsÂ¶ There is a script that you can run locally to test all the code and generate coverage reports in HTML: This command generates a directory ./htmlcov/, if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing. ThanksÂ¶ Thanks for contributing! â˜• Made with Material for MkDocs Insiders"
  },
  {
    "title": "Help SQLModel - Get Help - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/help/",
    "html": "Skip to content SQLModel Help SQLModel - Get Help Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Subscribe to the FastAPI and Friends newsletter Star SQLModel in GitHub Watch the GitHub repository for releases Connect with the author Tweet about SQLModel Help others with questions in GitHub Understand the question Reproduce the problem Suggest solutions Ask to close Watch the GitHub repository Ask Questions Review Pull Requests Understand the problem Don't worry about style Check the code Tests Create a Pull Request Help Maintain SQLModel Join the chat Don't use the chat for questions Sponsor the author Sponsor the tools that power SQLModel Help SQLModel - Get HelpÂ¶ Do you like SQLModel? Would you like to help SQLModel, other users, and the author? Or would you like to get help with SQLModel? There are very simple ways to help (several involve just one or two clicks). And there are several ways to get help too. Subscribe to the FastAPI and Friends newsletterÂ¶ You can subscribe to the (infrequent) FastAPI and friends newsletter to stay updated about: News about FastAPI and friends, including SQLModel ðŸš€ Guides ðŸ“ Features âœ¨ Breaking changes ðŸš¨ Tips and tricks âœ… Star SQLModel in GitHubÂ¶ You can \"star\" SQLModel in GitHub (clicking the star button at the top right): https://github.com/tiangolo/sqlmodel. â­ï¸ By adding a star, other users will be able to find it more easily and see that it has been already useful for others. Watch the GitHub repository for releasesÂ¶ You can \"watch\" SQLModel in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/sqlmodel. ðŸ‘€ There you can select \"Releases only\". By doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of SQLModel with bug fixes and new features. Connect with the authorÂ¶ You can connect with me (SebastiÃ¡n RamÃ­rez / tiangolo), the author. You can: Follow me on GitHub. See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter. Tell me how you use SQLModel (I love to hear that). Hear when I make announcements or release new tools. Connect with me on Linkedin. Hear when I make announcements or release new tools (although I use Twitter more often ðŸ¤·â€â™‚). Read what I write (or follow me) on Dev.to or Medium. Read other ideas, articles, and read about tools I have created. Follow me to read when I publish something new. Tweet about SQLModelÂ¶ Tweet about SQLModel and let me and others know why you like it. ðŸŽ‰ I love to hear about how SQLModel is being used, what you have liked in it, in which project/company are you using it, etc. Help others with questions in GitHubÂ¶ You can try and help others with their questions in: GitHub Discussions GitHub Issues In many cases you might already know the answer for those questions. ðŸ¤“ Just remember, the most important point is: try to be kind. People come with their frustrations and in many cases don't ask in the best way, but try as best as you can to be kind. ðŸ¤— The idea is for the SQLModel community to be kind and welcoming. At the same time, don't accept bullying or disrespectful behavior towards others. We have to take care of each other. Here's how to help others with questions (in discussions or issues): Understand the questionÂ¶ Check if you can understand what is the purpose and use case of the person asking. Then check if the question (the vast majority are questions) is clear. In many cases the question asked is about an imaginary solution from the user, but there might be a better one. If you can understand the problem and use case better, you might be able to suggest a better alternative solution. If you can't understand the question, ask for more details. Reproduce the problemÂ¶ For most of the cases and most of the questions there's something related to the person's original code. In many cases they will only copy a fragment of the code, but that's not enough to reproduce the problem. You can ask them to provide a minimal, reproducible, example, that you can copy-paste and run locally to see the same error or behavior they are seeing, or to understand their use case better. If you are feeling too generous, you can try to create an example like that yourself, just based on the description of the problem. Just have in mind that this might take a lot of time and it might be better to ask them to clarify the problem first. Suggest solutionsÂ¶ After being able to understand the question, you can give them a possible answer. In many cases, it's better to understand their underlying problem or use case, because there might be a better way to solve it than what they are trying to do. Ask to closeÂ¶ If they reply, there's a high chance you would have solved their problem, congrats, you're a hero! ðŸ¦¸ Now, if that solved their problem, you can ask them to: In GitHub Discussions: mark the comment as the answer. In GitHub Issues: close the issue**. Watch the GitHub repositoryÂ¶ You can \"watch\" SQLModel in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/sqlmodel. ðŸ‘€ If you select \"Watching\" instead of \"Releases only\" you will receive notifications when someone creates a new issue or question. You can also specify that you only want to be notified about new issues, or discussions, or PRs, etc. Then you can try and help them solve those questions. Ask QuestionsÂ¶ You can create a new question in the GitHub repository, for example to: Ask a question or ask about a problem. Suggest a new feature. Note: if you do it, then I'm going to ask you to also help others. ðŸ˜‰ Review Pull RequestsÂ¶ You can help me review pull requests from others. Again, please try your best to be kind. ðŸ¤— Here's what to have in mind and how to review a pull request: Understand the problemÂ¶ First, make sure you understand the problem that the pull request is trying to solve. It might have a longer discussion in a GitHub Discussion or issue. There's also a good chance that the pull request is not actually needed because the problem can be solved in a different way. Then you can suggest or ask about that. Don't worry about styleÂ¶ Don't worry too much about things like commit message styles, I will squash and merge customizing the commit manually. Also don't worry about style rules, there are already automatized tools checking that. And if there's any other style or consistency need, I'll ask directly for that, or I'll add commits on top with the needed changes. Check the codeÂ¶ Check and read the code, see if it makes sense, run it locally and see if it actually solves the problem. Then comment saying that you did that, that's how I will know you really checked it. Info Unfortunately, I can't simply trust PRs that just have several approvals. Several times it has happened that there are PRs with 3, 5 or more approvals, probably because the description is appealing, but when I check the PRs, they are actually broken, have a bug, or don't solve the problem they claim to solve. ðŸ˜… So, it's really important that you actually read and run the code, and let me know in the comments that you did. ðŸ¤“ If the PR can be simplified in a way, you can ask for that, but there's no need to be too picky, there might be a lot of subjective points of view (and I will have my own as well ðŸ™ˆ), so it's better if you can focus on the fundamental things. TestsÂ¶ Help me check that the PR has tests. Check that the tests fail before the PR. ðŸš¨ Then check that the tests pass after the PR. âœ… Many PRs don't have tests, you can remind them to add tests, or you can even suggest some tests yourself. That's one of the things that consume most time and you can help a lot with that. Then also comment what you tried, that way I'll know that you checked it. ðŸ¤“ Create a Pull RequestÂ¶ You can contribute to the source code with Pull Requests, for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. Make sure to add tests. To add a new feature. Make sure to add tests. Make sure to add documentation if it's relevant. Help Maintain SQLModelÂ¶ Help me maintain SQLModel! ðŸ¤“ There's a lot of work to do, and for most of it, YOU can do it. The main tasks that you can do right now are: Help others with questions in GitHub (see the section above). Review Pull Requests (see the section above). Those two tasks are what consume time the most. That's the main work of maintaining SQLModel. If you can help me with that, you are helping me maintain SQLModel and making sure it keeps advancing faster and better. ðŸš€ Join the chatÂ¶ Join the ðŸ‘¥ FastAPI and Friends Discord chat server ðŸ‘¥ and hang out with others in the community. There's a #sqlmodel channel. Tip For questions, ask them in GitHub Discussions, there's a much better chance you will receive help there. Use the chat only for other general conversations. Don't use the chat for questionsÂ¶ Have in mind that as chats allow more \"free conversation\", it's easy to ask questions that are too general and more difficult to answer, so, you might not receive answers. In GitHub, the template will guide you to write the right question so that you can more easily get a good answer, or even solve the problem yourself even before asking. And in GitHub I can make sure I always answer everything, even if it takes some time. I can't personally do that with the chat. ðŸ˜… Conversations in the chat are also not as easily searchable as in GitHub, so questions and answers might get lost in the conversation. On the other side, there are thousands of users in the chat, so there's a high chance you'll find someone to talk to there, almost all the time. ðŸ˜„ Sponsor the authorÂ¶ You can also financially support the author (me) through GitHub sponsors. There you could buy me a coffee â˜•ï¸ to say thanks. ðŸ˜„ Sponsor the tools that power SQLModelÂ¶ As you have seen in the documentation, SQLModel stands on the shoulders of giants, Pydantic and SQLAlchemy. You can also sponsor: Samuel Colvin (Pydantic) SQLAlchemy Thanks! ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Decimal Numbers - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/advanced/decimal/",
    "html": "Skip to content SQLModel Decimal Numbers Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Decimal Numbers Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Decimal Types Decimals in SQLModel Create models with Decimals Select Decimal data Review the results SQLModel Advanced User Guide Decimal NumbersÂ¶ In some cases you might need to be able to store decimal numbers with guarantees about the precision. This is particularly important if you are storing things like currencies, prices, accounts, and others, as you would want to know that you wouldn't have rounding errors. As an example, if you open Python and sum 1.1 + 2.2 you would expect to see 3.3, but you will actually get 3.3000000000000003: >>> 1.1 + 2.2 3.3000000000000003 This is because of the way numbers are stored in \"ones and zeros\" (binary). But Python has a module and some types to have strict decimal values. You can read more about it in the official Python docs for Decimal. Because databases store data in the same ways as computers (in binary), they would have the same types of issues. And because of that, they also have a special decimal type. In most cases this would probably not be a problem, for example measuring views in a video, or the life bar in a videogame. But as you can imagine, this is particularly important when dealing with money and finances. Decimal TypesÂ¶ Pydantic has special support for Decimal types. When you use Decimal you can specify the number of digits and decimal places to support in the Field() function. They will be validated by Pydantic (for example when using FastAPI) and the same information will also be used for the database columns. Info For the database, SQLModel will use SQLAlchemy's DECIMAL type. Decimals in SQLModelÂ¶ Let's say that each hero in the database will have an amount of money. We could make that field a Decimal type using the condecimal() function: from decimal import Decimal from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) money: Decimal = Field(default=0, max_digits=5, decimal_places=3) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Here we are saying that money can have at most 5 digits with max_digits, this includes the integers (to the left of the decimal dot) and the decimals (to the right of the decimal dot). We are also saying that the number of decimal places (to the right of the decimal dot) is 3, so we can have 3 decimal digits for these numbers in the money field. This means that we will have 2 digits for the integer part and 3 digits for the decimal part. âœ… So, for example, these are all valid numbers for the money field: 12.345 12.3 12 1.2 0.123 0 ðŸš« But these are all invalid numbers for that money field: 1.2345 This number has more than 3 decimal places. 123.234 This number has more than 5 digits in total (integer and decimal part). 123 Even though this number doesn't have any decimals, we still have 3 places saved for them, which means that we can only use 2 places for the integer part, and this number has 3 integer digits. So, the allowed number of integer digits is max_digits - decimal_places = 2. Tip Make sure you adjust the number of digits and decimal places for your own needs, in your own application. ðŸ¤“ Create models with DecimalsÂ¶ When creating new models you can actually pass normal (float) numbers, Pydantic will automatically convert them to Decimal types, and SQLModel will store them as Decimal types in the database (using SQLAlchemy). # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\", money=1.1) hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\", money=0.001) hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, money=2.2) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Select Decimal dataÂ¶ Then, when working with Decimal types, you can confirm that they indeed avoid those rounding errors from floats: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Deadpond\") results = session.exec(statement) hero_1 = results.one() print(\"Hero 1:\", hero_1) statement = select(Hero).where(Hero.name == \"Rusty-Man\") results = session.exec(statement) hero_2 = results.one() print(\"Hero 2:\", hero_2) total_money = hero_1.money + hero_2.money print(f\"Total money: {total_money}\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Review the resultsÂ¶ Now if you run this, instead of printing the unexpected number 3.3000000000000003, it prints 3.300: Warning Although Decimal types are supported and used in the Python side, not all databases support it. In particular, SQLite doesn't support decimals, so it will convert them to the same floating NUMERIC type it supports. But decimals are supported by most of the other SQL databases. ðŸŽ‰ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Alternatives, Inspiration and Comparisons - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/alternatives/",
    "html": "Skip to content SQLModel Alternatives, Inspiration and Comparisons Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Alternatives, Inspiration and ComparisonsÂ¶ Coming soon... Made with Material for MkDocs Insiders"
  },
  {
    "title": "Models with Relationships in FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/relationships/",
    "html": "Skip to content SQLModel Models with Relationships in FastAPI Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Why Aren't We Getting More Data Don't Include All the Data What Data to Include Models with Relationships Inheritance and Type Annotations Data Models Without Relationship Attributes Reference to Other Models Update the Path Operations Check It Out in the Docs UI Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Models with Relationships in FastAPIÂ¶ If we go right now and read a single hero by ID, we get the hero data with the team ID. But we don't get any data about the particular team: We get a response of: { \"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\", \"age\": null, \"team_id\": 1, \"id\": 1, } And the same way, if we get a team by ID, we get the team data, but we don't get any information about this team's heroes: Here we get a response of: { \"name\": \"Preventers\", \"headquarters\": \"Sharp Tower\", \"id\": 2 } ...but no information about the heroes. Let's update that. ðŸ¤“ Why Aren't We Getting More DataÂ¶ First, why is it that we are not getting the related data for each hero and for each team? It's because we declared the HeroRead with only the same base fields of the HeroBase plus the id. But it doesn't include a field team for the relationship attribute. And the same way, we declared the TeamRead with only the same base fields of the TeamBase plus the id. But it doesn't include a field heroes for the relationship attribute. # Code above omitted ðŸ‘† class TeamBase(SQLModel): name: str = Field(index=True) headquarters: str # Code here omitted ðŸ‘ˆ class TeamRead(TeamBase): id: int # Code here omitted ðŸ‘ˆ class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") # Code here omitted ðŸ‘ˆ class HeroRead(HeroBase): id: int # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Now, remember that FastAPI uses the response_model to validate and filter the response data? In this case, we used response_model=TeamRead and response_model=HeroRead, so FastAPI will use them to filter the response data, even if we return a table model that includes relationship attributes: # Code above omitted ðŸ‘† @app.get(\"/heroes/{hero_id}\", response_model=HeroRead) def read_hero(*, session: Session = Depends(get_session), hero_id: int): hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") return hero # Code here omitted ðŸ‘ˆ @app.get(\"/teams/{team_id}\", response_model=TeamRead) def read_team(*, team_id: int, session: Session = Depends(get_session)): team = session.get(Team, team_id) if not team: raise HTTPException(status_code=404, detail=\"Team not found\") return team # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Don't Include All the DataÂ¶ Now let's stop for a second and think about it. We cannot simply include all the data, including all the internal relationships, because each hero has an attribute team with their team, and then that team also has an attribute heroes with all the heroes in the team, including this one. If we tried to include everything, we could make the server application crash trying to extract infinite data, going through the same hero and team over and over again internally, something like this: { \"name\": \"Rusty-Man\", \"secret_name\": \"Tommy Sharp\", \"age\": 48, \"team_id\": 1, \"id\": 1, \"team\": { \"name\": \"Preventers\", \"headquarters\": \"Sharp Tower\", \"id\": 2, \"heroes\": [ { \"name\": \"Rusty-Man\", \"secret_name\": \"Tommy Sharp\", \"age\": 48, \"team_id\": 1, \"id\": 1, \"team\": { \"name\": \"Preventers\", \"headquarters\": \"Sharp Tower\", \"id\": 2, \"heroes\": [ { \"name\": \"Rusty-Man\", \"secret_name\": \"Tommy Sharp\", \"age\": 48, \"team_id\": 1, \"id\": 1, \"team\": { \"name\": \"Preventers\", \"headquarters\": \"Sharp Tower\", \"id\": 2, \"heroes\": [ ...with infinite data here... ðŸ˜± ] } } ] } } ] } } As you can see, in this example, we would get the hero Rusty-Man, and from this hero we would get the team Preventers, and then from this team we would get its heroes, of course, including Rusty-Man... ðŸ˜± So we start again, and in the end, the server would just crash trying to get all the data with a \"Maximum recursion error\", we would not even get a response like the one above. So, we need to carefully choose in which cases we want to include data and in which not. What Data to IncludeÂ¶ This is a decision that will depend on each application. In our case, let's say that if we get a list of heroes, we don't want to also include each of their teams in each one. And if we get a list of teams, we don't want to get a list of the heroes for each one. But if we get a single hero, we want to include the team data (without the team's heroes). And if we get a single team, we want to include the list of heroes (without each hero's team). Let's add a couple more data models that declare that data so we can use them in those two specific path operations. Models with RelationshipsÂ¶ Let's add the models HeroReadWithTeam and TeamReadWithHeroes. We'll add them after the other models so that we can easily reference the previous models. # Code above omitted ðŸ‘† class HeroReadWithTeam(HeroRead): team: Optional[TeamRead] = None class TeamReadWithHeroes(TeamRead): heroes: List[HeroRead] = [] # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview These two models are very simple in code, but there's a lot happening here. Let's check it out. Inheritance and Type AnnotationsÂ¶ The HeroReadWithTeam inherits from HeroRead, which means that it will have the normal fields for reading, including the required id that was declared in HeroRead. And then it adds the new field team, which could be None, and is declared with the type TeamRead with the base fields for reading a team. Then we do the same for the TeamReadWithHeroes, it inherits from TeamRead, and declares the new field heroes, which is a list of HeroRead. Data Models Without Relationship AttributesÂ¶ Now, notice that these new fields team and heroes are not declared with Relationship(), because these are not table models, they cannot have relationship attributes with the magic access to get that data from the database. Instead, here these are only data models that will tell FastAPI which attributes to get data from and which data to get from them. Reference to Other ModelsÂ¶ Also, notice that the field team is not declared with this new TeamReadWithHeroes, because that would again create that infinite recursion of data. Instead, we declare it with the normal TeamRead model. And the same for TeamReadWithHeroes, the model used for the new field heroes uses HeroRead to get only each hero's data. This also means that, even though we have these two new models, we still need the previous ones, HeroRead and TeamRead, because we need to reference them here (and we are also using them in the rest of the path operations). Update the Path OperationsÂ¶ Now we can update the path operations to use the new models. This will tell FastAPI to take the object that we return from the path operation function (a table model) and access the additional attributes from them to extract their data. In the case of the hero, this tells FastAPI to extract the team too. And in the case of the team, to extract the list of heroes too. # Code above omitted ðŸ‘† @app.get(\"/heroes/{hero_id}\", response_model=HeroReadWithTeam) def read_hero(*, session: Session = Depends(get_session), hero_id: int): hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") return hero # Code here omitted ðŸ‘ˆ @app.get(\"/teams/{team_id}\", response_model=TeamReadWithHeroes) def read_team(*, team_id: int, session: Session = Depends(get_session)): team = session.get(Team, team_id) if not team: raise HTTPException(status_code=404, detail=\"Team not found\") return team # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Check It Out in the Docs UIÂ¶ Now let's try it out again in the docs UI. Let's try again with the same hero with ID 1: Now we get the team data included: { \"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\", \"age\": null, \"team_id\": 1, \"id\": 1, \"team\": { \"name\": \"Z-Force\", \"headquarters\": \"Sister Margaret's Bar\", \"id\": 1 } } And if we get now the team with ID 2: Now we get the list of heroes included: { \"name\": \"Preventers\", \"headquarters\": \"Sharp Tower\", \"id\": 2, \"heroes\": [ { \"name\": \"Rusty-Man\", \"secret_name\": \"Tommy Sharp\", \"age\": 48, \"team_id\": 2, \"id\": 2 }, { \"name\": \"Spider-Boy\", \"secret_name\": \"Pedro Parqueador\", \"age\": null, \"team_id\": 2, \"id\": 3 }, { \"name\": \"Tarantula\", \"secret_name\": \"Natalia Roman-on\", \"age\": 32, \"team_id\": 2, \"id\": 6 }, { \"name\": \"Dr. Weird\", \"secret_name\": \"Steve Weird\", \"age\": 36, \"team_id\": 2, \"id\": 7 }, { \"name\": \"Captain North America\", \"secret_name\": \"Esteban Rogelios\", \"age\": 93, \"team_id\": 2, \"id\": 8 } ] } RecapÂ¶ Using the same techniques to declare additional data models, we can tell FastAPI what data to return in the responses, even when we return table models. Here we almost didn't have to change the FastAPI app code, but of course, there will be cases where you need to get the data and process it in different ways in the path operation function before returning it. But even in those cases, you will be able to define the data models to use in response_model to tell FastAPI how to validate and filter the data. By this point, you already have a very robust API to handle data in a SQL database combining SQLModel with FastAPI, and implementing best practices, like data validation, conversion, filtering, and documentation. âœ¨ In the next chapter, I'll tell you how to implement automated testing for your application using FastAPI and SQLModel. âœ… Made with Material for MkDocs Insiders"
  },
  {
    "title": "Test Applications with FastAPI and SQLModel - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/tests/",
    "html": "Skip to content SQLModel Test Applications with FastAPI and SQLModel Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents FastAPI Application File Structure Testing FastAPI Applications Basic Tests Code Testing Database Override a Dependency Create the Engine and Session for Testing Import Table Models Memory Database Configure the In-Memory Database Boilerplate Code Pytest Fixtures Client Fixture Add More Tests Why Two Fixtures Add the Rest of the Tests Run the Tests Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Test Applications with FastAPI and SQLModelÂ¶ To finish this group of chapters about FastAPI with SQLModel, let's now learn how to implement automated tests for an application using FastAPI with SQLModel. âœ… Including the tips and tricks. ðŸŽ FastAPI ApplicationÂ¶ Let's work with one of the simpler FastAPI applications we built in the previous chapters. All the same concepts, tips and tricks will apply to more complex applications as well. We will use the application with the hero models, but without team models, and we will use the dependency to get a session. Now we will see how useful it is to have this session dependency. âœ¨ ðŸ‘€ Full file preview File StructureÂ¶ Now we will have a Python project with multiple files, one file main.py with all the application, and one file test_main.py with the tests, with the same ideas from Code Structure and Multiple Files. The file structure is: . â”œâ”€â”€ project â”œâ”€â”€ __init__.py â”œâ”€â”€ main.py â””â”€â”€ test_main.py Testing FastAPI ApplicationsÂ¶ If you haven't done testing in FastAPI applications, first check the FastAPI docs about Testing. Then, we can continue here, the first step is to install the dependencies, requests and pytest. Make sure you do it in the same Python environment. Basic Tests CodeÂ¶ Let's start with a simple test, with just the basic test code we need the check that the FastAPI application is creating a new hero correctly. from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from .main import app, get_session Import the app from the the main module. def test_create_hero(): # Some code here omitted, we will see it later ðŸ‘ˆ client = TestClient(app) We create a TestClient for the FastAPI app and put it in the variable client. response = client.post( Then we use use this client to talk to the API and send a POST HTTP operation, creating a new hero. \"/heroes/\", json={\"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\"} ) # Some code here omitted, we will see it later ðŸ‘ˆ data = response.json() Then we get the JSON data from the response and put it in the variable data. assert response.status_code == 200 Next we start testing the results with assert statements, we check that the status code of the response is 200. assert data[\"name\"] == \"Deadpond\" We check that the name of the hero created is \"Deadpond\". assert data[\"secret_name\"] == \"Dive Wilson\" We check that the secret_name of the hero created is \"Dive Wilson\". assert data[\"age\"] is None We check that the age of the hero created is None, because we didn't send an age. assert data[\"id\"] is not None We check that the hero created has an id created by the database, so it's not None. # Code below omitted ðŸ‘‡ Tip Check out the number bubbles to see what is done by each line of code. That's the core of the code we need for all the tests later. But now, we need to deal with a bit of logistics and details we are not paying attention to just yet. ðŸ¤“ Testing DatabaseÂ¶ This test looks fine, but there's a problem. If we run it, it will use the same production database that we are using to store our very important heroes, and we will end up adding unnecessary data to it, or even worse, in future tests we could end up removing production data. So, we should use an independent testing database, just for the tests. To do this, we need to change the URL used for the database. But when the code for the API is executed, it gets a session that is already connected to an engine, and the engine is already using a specific database URL. Even if we import the variable from the main module and change its value just for the tests, by that point the engine is already created with the original value. But all our API path operations get the session using a FastAPI dependency, and we can override dependencies in tests. Here's where dependencies start to help a lot. Override a DependencyÂ¶ Let's override the get_session() dependency for the tests. This dependency is used by all the path operations to get the SQLModel session object. We will override it to use a different session object just for the tests. That way we protect the production database and we have better control of the data we are testing. from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from .main import app, get_session Import the get_session dependency from the the main module. def test_create_hero(): # Some code here omitted, we will see it later ðŸ‘ˆ def get_session_override(): Define the new function that will be the new dependency override. return session This function will return a different session than the one that would be returned by the original get_session function. We haven't seen how this new session object is created yet, but the point is that this is a different session than the original one from the app. This session is attached to a different engine, and that different engine uses a different URL, for a database just for testing. We haven't defined that new URL nor the new engine yet, but here we already see the that this object session will override the one returned by the original dependency get_session(). app.dependency_overrides[get_session] = get_session_override Then, the FastAPI app object has an attribute app.dependency_overrides. This attribute is a dictionary, and we can put dependency overrides in it by passing, as the key, the original dependency function, and as the value, the new overriding dependency function. So, here we are telling the FastAPI app to use get_session_override instead of get_session in all the places in the code that depend on get_session, that is, all the parameters with something like: session: Session = Depends(get_session) client = TestClient(app) response = client.post( \"/heroes/\", json={\"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\"} ) app.dependency_overrides.clear() After we are done with the dependency override, we can restore the application back to normal, by removing all the values in this dictionary app.dependency_overrides. This way whenever a path operation function needs the dependency FastAPI will use the original one instead of the override. data = response.json() assert response.status_code == 200 assert data[\"name\"] == \"Deadpond\" assert data[\"secret_name\"] == \"Dive Wilson\" assert data[\"age\"] is None assert data[\"id\"] is not None # Code below omitted ðŸ‘‡ Tip Check out the number bubbles to see what is done by each line of code. Create the Engine and Session for TestingÂ¶ Now let's create that session object that will be used during testing. It will use its own engine, and this new engine will use a new URL for the testing database: sqlite:///testing.db So, the testing database will be in the file testing.db. from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from .main import app, get_session Here's a subtle thing to notice. Remember that Order Matters and we need to make sure all the SQLModel models are already defined and imported before calling .create_all(). IN this line, by importing something, anything, from .main, the code in .main will be executed, including the definition of the table models, and that will automatically register them in SQLModel.metadata. def test_create_hero(): engine = create_engine( Here we create a new engine, completely different from the one in main.py. This is the engine we will use for the tests. We use the new URL of the database for tests: sqlite:///testing.db And again, we use the connection argument check_same_thread=False. \"sqlite:///testing.db\", connect_args={\"check_same_thread\": False} ) SQLModel.metadata.create_all(engine) Then we call: SQLModel.metadata.create_all(engine) ...to make sure we create all the tables in the new testing database. The table models are registered in SQLModel.metadata just because we imported something from .main, and the code in .main was executed, creating the classes for the table models and automatically registering them in SQLModel.metadata. So, by the point we call this method, the table models are already registered there. ðŸ’¯ with Session(engine) as session: def get_session_override(): return session Now, back to the dependency override, it is just returning the same session object from outside, that's it, that's the whole trick. app.dependency_overrides[get_session] = get_session_override Here's where we create the custom session object for this test in a with block. It uses the new custom engine we created, so anything that uses this session will be using the testing database. client = TestClient(app) response = client.post( \"/heroes/\", json={\"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\"} ) app.dependency_overrides.clear() data = response.json() assert response.status_code == 200 assert data[\"name\"] == \"Deadpond\" assert data[\"secret_name\"] == \"Dive Wilson\" assert data[\"age\"] is None assert data[\"id\"] is not None By this point, the testing session with block finishes, and the session is closed, the file is closed, etc. Import Table ModelsÂ¶ Here we create all the tables in the testing database with: SQLModel.metadata.create_all(engine) But remember that Order Matters and we need to make sure all the SQLModel models are already defined and imported before calling .create_all(). In this case, it all works for a little subtlety that deserves some attention. Because we import something, anything, from .main, the code in .main will be executed, including the definition of the table models, and that will automatically register them in SQLModel.metadata. That way, when we call .create_all() all the table models are correctly registered in SQLModel.metadata and it will all work. ðŸ‘Œ Memory DatabaseÂ¶ Now we are not using the production database. Instead, we use a new testing database with the testing.db file, which is great. But SQLite also supports having an in memory database. This means that all the database is only in memory, and it is never saved in a file on disk. After the program terminates, the in-memory database is deleted, so it wouldn't help much for a production database. But it works great for testing, because it can be quickly created before each test, and quickly removed after each test. âœ… And also, because it never has to write anything to a file and it's all just in memory, it will be even faster than normally. ðŸŽ Other alternatives and ideas ðŸ‘€ Configure the In-Memory DatabaseÂ¶ Let's update our code to use the in-memory database. We just have to change a couple of parameters in the engine. from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from sqlmodel.pool import StaticPool Import StaticPool from sqlmodel, we will use it in a bit. from .main import app, get_session def test_create_hero(): engine = create_engine( \"sqlite://\", For the SQLite URL, don't write any file name, leave it empty. So, instead of: sqlite:///testing.db ...just write: sqlite:// This is enough to tell SQLModel (actually SQLAlchemy) that we want to use an in-memory SQLite database. connect_args={\"check_same_thread\": False}, poolclass=StaticPool, Remember that we told the low-level library in charge of communicating with SQLite that we want to be able to access the database from different threads with check_same_thread=False? Now that we use an in-memory database, we need to also tell SQLAlchemy that we want to be able to use the same in-memory database object from different threads. We tell it that with the poolclass=StaticPool parameter. !!! info You can read more details in the SQLAlchemy documentation about Using a Memory Database in Multiple Threads ) # Code below omitted ðŸ‘‡ Tip Check out the number bubbles to see what is done by each line of code. That's it, now the test will run using the in-memory database, which will be faster and probably safer. And all the other tests can do the same. Boilerplate CodeÂ¶ Great, that works, and you could replicate all that process in each of the test functions. But we had to add a lot of boilerplate code to handle the custom database, creating it in memory, the custom session, and the dependency override. Do we really have to duplicate all that for each test? No, we can do better! ðŸ˜Ž We are using pytest to run the tests. And pytest also has a very similar concept to the dependencies in FastAPI. Info In fact, pytest was one of the things that inspired the design of the dependencies in FastAPI. It's a way for us to declare some code that should be run before each test and provide a value for the test function (that's pretty much the same as FastAPI dependencies). In fact, it also has the same trick of allowing to use yield instead of return to provide the value, and then pytest makes sure that the code after yield is executed after the function with the test is done. In pytest, these things are called fixtures instead of dependencies. Let's use these fixtures to improve our code and reduce de duplicated boilerplate for the next tests. Pytest FixturesÂ¶ You can read more about them in the pytest docs for fixtures, but I'll give you a short example for what we need here. Let's see the first code example with a fixture: import pytest Import pytest. from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from sqlmodel.pool import StaticPool from .main import app, get_session @pytest.fixture(name=\"session\") Use the @pytest.fixture() decorator on top of the function to tell pytest that this is a fixture function (equivalent to a FastAPI dependency). We also give it a name of \"session\", this will be important in the testing function. def session_fixture(): Create the fixture function. This is equivalent to a FastAPI dependency function. In this fixture we create the custom engine, with the in-memory database, we create the tables, and we create the session. Then we yield the session object. engine = create_engine( \"sqlite://\", connect_args={\"check_same_thread\": False}, poolclass=StaticPool ) SQLModel.metadata.create_all(engine) with Session(engine) as session: yield session The thing that we return or yield is what will be available to the test function, in this case, the session object. Here we use yield so that pytest comes back to execute \"the rest of the code\" in this function once the testing function is done. We don't have any more visible \"rest of the code\" after the yield, but we have the end of the with block that will close the session. By using yield, pytest will: run the first part create the session object give it to the test function run the test function once the test function is done, it will continue here, right after the yield, and will correctly close the session object in the end of the with block. def test_create_hero(session: Session): Now, in the test function, to tell pytest that this test wants to get the fixture, instead of declaring something like in FastAPI with: session: Session = Depends(session_fixture) ...the way we tell pytest what is the fixture that we want is by using the exact same name of the fixture. In this case, we named it session, so the parameter has to be exactly named session for it to work. We also add the type annotation session: Session so that we can get autocompletion and inline error checks in our editor. def get_session_override(): return session Now in the dependency override function, we just return the same session object that came from outside it. The session object comes from the parameter passed to the test function, and we just re-use it and return it here in the dependency override. app.dependency_overrides[get_session] = get_session_override client = TestClient(app) response = client.post( \"/heroes/\", json={\"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\"} ) app.dependency_overrides.clear() data = response.json() assert response.status_code == 200 assert data[\"name\"] == \"Deadpond\" assert data[\"secret_name\"] == \"Dive Wilson\" assert data[\"age\"] is None assert data[\"id\"] is not None Tip Check out the number bubbles to see what is done by each line of code. pytest fixtures work in a very similar way to FastAPI dependencies, but have some minor differences: In pytest fixtures, we need to add a decorator of @pytest.fixture() on top. To use a pytest fixture in a function, we have to declare the parameter with the exact same name. In FastAPI we have to explicitly use Depends() with the actual function inside it. But apart from the way we declare them and how we tell the framework that we want to have them in the function, they work in a very similar way. Now we create lot's of tests and re-use that same fixture in all of them, saving us that boilerplate code. pytest will make sure to run them right before (and finish them right after) each test function. So, each test function will actually have its own database, engine, and session. Client FixtureÂ¶ Awesome, that fixture helps us prevent a lot of duplicated code. But currently, we still have to write some code in the test function that will be repetitive for other tests, right now we: create the dependency override put it in the app.dependency_overrides create the TestClient Clear the dependency override(s) after making the request That's still gonna be repetitive in the other future tests. Can we improve it? Yes! ðŸŽ‰ Each pytest fixture (the same way as FastAPI dependencies), can require other fixtures. So, we can create a client fixture that will be used in all the tests, and it will itself require the session fixture. import pytest from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from sqlmodel.pool import StaticPool from .main import app, get_session @pytest.fixture(name=\"session\") def session_fixture(): engine = create_engine( \"sqlite://\", connect_args={\"check_same_thread\": False}, poolclass=StaticPool ) SQLModel.metadata.create_all(engine) with Session(engine) as session: yield session @pytest.fixture(name=\"client\") Create the new fixture named \"client\". def client_fixture(session: Session): This client fixture, in turn, also requires the session fixture. def get_session_override(): Now we create the dependency override inside the client fixture. return session app.dependency_overrides[get_session] = get_session_override Set the dependency override in the app.dependency_overrides dictionary. client = TestClient(app) Create the TestClient with the FastAPI app. yield client yield the TestClient instance. By using yield, after the test function is done, pytest will come back to execute the rest of the code after yield. app.dependency_overrides.clear() This is the cleanup code, after yield, and after the test function is done. Here we clear the dependency overrides (here it's only one) in the FastAPI app. def test_create_hero(client: TestClient): Now the test function requires the client fixture. And inside the test function, the code is quite simple, we just use the TestClient to make requests to the API, check the data, and that's it. The fixtures take care of all the setup and cleanup code. response = client.post( \"/heroes/\", json={\"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\"} ) data = response.json() assert response.status_code == 200 assert data[\"name\"] == \"Deadpond\" assert data[\"secret_name\"] == \"Dive Wilson\" assert data[\"age\"] is None assert data[\"id\"] is not None Tip Check out the number bubbles to see what is done by each line of code. Now we have a client fixture that, in turn, uses the session fixture. And in the actual test function, we just have to declare that we require this client fixture. Add More TestsÂ¶ At this point, it all might seem like we just did a lot of changes for nothing, to get the same result. ðŸ¤” But normally we will create lots of other test functions. And now all the boilerplate and complexity is written only once, in those two fixtures. Let's add some more tests: # Code above omitted ðŸ‘† def test_create_hero(client: TestClient): response = client.post( \"/heroes/\", json={\"name\": \"Deadpond\", \"secret_name\": \"Dive Wilson\"} ) data = response.json() assert response.status_code == 200 assert data[\"name\"] == \"Deadpond\" assert data[\"secret_name\"] == \"Dive Wilson\" assert data[\"age\"] is None assert data[\"id\"] is not None def test_create_hero_incomplete(client: TestClient): # No secret_name response = client.post(\"/heroes/\", json={\"name\": \"Deadpond\"}) assert response.status_code == 422 def test_create_hero_invalid(client: TestClient): # secret_name has an invalid type response = client.post( \"/heroes/\", json={ \"name\": \"Deadpond\", \"secret_name\": {\"message\": \"Do you wanna know my secret identity?\"}, }, ) assert response.status_code == 422 # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip It's always good idea to not only test the normal case, but also that invalid data, errors, and corner cases are handled correctly. That's why we add these two extra tests here. Now, any additional test functions can be as simple as the first one, they just have to declare the client parameter to get the TestClient fixture with all the database stuff setup. Nice! ðŸ˜Ž Why Two FixturesÂ¶ Now, seeing the code, we could think, why do we put two fixtures instead of just one with all the code? And that makes total sense! For these examples, that would have been simpler, there's no need to separate that code into two fixtures for them... But for the next test function, we will require both fixtures, the client and the session. import pytest from fastapi.testclient import TestClient from sqlmodel import Session, SQLModel, create_engine from sqlmodel.pool import StaticPool from .main import Hero, app, get_session # Code here omitted ðŸ‘ˆ def test_read_heroes(session: Session, client: TestClient): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) session.add(hero_1) session.add(hero_2) session.commit() response = client.get(\"/heroes/\") data = response.json() assert response.status_code == 200 assert len(data) == 2 assert data[0][\"name\"] == hero_1.name assert data[0][\"secret_name\"] == hero_1.secret_name assert data[0][\"age\"] == hero_1.age assert data[0][\"id\"] == hero_1.id assert data[1][\"name\"] == hero_2.name assert data[1][\"secret_name\"] == hero_2.secret_name assert data[1][\"age\"] == hero_2.age assert data[1][\"id\"] == hero_2.id # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview In this test function, we want to check that the path operation to read a list of heroes actually sends us heroes. But if the database is empty, we would get an empty list, and we wouldn't know if the hero data is being sent correctly or not. But we can create some heroes in the testing database right before sending the API request. âœ¨ And because we are using the testing database, we don't affect anything by creating heroes for the test. To do it, we have to: import the Hero model require both fixtures, the client and the session create some heroes and save them in the database using the session After that, we can send the request and check that we actually got the data back correctly from the database. ðŸ’¯ Here's the important detail to notice: we can require fixtures in other fixtures and also in the test functions. The function for the client fixture and the actual testing function will both receive the same session. Add the Rest of the TestsÂ¶ Using the same ideas, requiring the fixtures, creating data that we need for the tests, etc., we can now add the rest of the tests. They look quite similar to what we have done up to now. # Code above omitted ðŸ‘† def test_read_hero(session: Session, client: TestClient): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") session.add(hero_1) session.commit() response = client.get(f\"/heroes/{hero_1.id}\") data = response.json() assert response.status_code == 200 assert data[\"name\"] == hero_1.name assert data[\"secret_name\"] == hero_1.secret_name assert data[\"age\"] == hero_1.age assert data[\"id\"] == hero_1.id def test_update_hero(session: Session, client: TestClient): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") session.add(hero_1) session.commit() response = client.patch(f\"/heroes/{hero_1.id}\", json={\"name\": \"Deadpuddle\"}) data = response.json() assert response.status_code == 200 assert data[\"name\"] == \"Deadpuddle\" assert data[\"secret_name\"] == \"Dive Wilson\" assert data[\"age\"] is None assert data[\"id\"] == hero_1.id def test_delete_hero(session: Session, client: TestClient): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") session.add(hero_1) session.commit() response = client.delete(f\"/heroes/{hero_1.id}\") hero_in_db = session.get(Hero, hero_1.id) assert response.status_code == 200 assert hero_in_db is None ðŸ‘€ Full file preview Run the TestsÂ¶ Now we can run the tests with pytest and see the results: RecapÂ¶ Did you read all that? Wow, I'm impressed! ðŸ˜Ž Adding tests to your application will give you a lot of certainty that everything is working correctly, as you intended. And tests will be notoriously useful when refactoring your code, changing things, adding features. Because tests can help catch a lot of errors that can be easily introduced by refactoring. And they will give you the confidence to work faster and more efficiently, because you know that you are checking if you are not breaking anything. ðŸ˜… I think tests are one of those things that bring your code and you as a developer to the next professional level. ðŸ˜Ž And if you read and studied all this, you already know a lot of the advanced ideas and tricks that took me years to learn. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced User Guide - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/advanced/",
    "html": "Skip to content SQLModel Advanced User Guide Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Decimal Numbers Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes SQLModel Advanced User Guide Advanced User GuideÂ¶ The Advanced User Guide is gradually growing, you can already read about some advanced topics. At some point it will include: How to use async and await with the async session. How to run migrations. How to combine SQLModel models with SQLAlchemy. ...and more. ðŸ¤“ Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI Path Operations for Teams - Other Models - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/teams/",
    "html": "Skip to content SQLModel FastAPI Path Operations for Teams - Other Models Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Add Teams Models Update Hero Models Relationship Attributes Path Operations for Teams Using Relationships Attributes Check the Docs UI Recap SQLModel Tutorial - User Guide FastAPI and Pydantic FastAPI Path Operations for Teams - Other ModelsÂ¶ Let's now update the FastAPI application to handle data for teams. This is very similar to the things we have done for heroes, so we will go over it quickly here. We will use the same models we used in previous examples, with the relationship attributes, etc. Add Teams ModelsÂ¶ Let's add the models for the teams. It's the same process we did for heroes, with a base model, a table model, and some other data models. We have a TeamBase data model, and from it, we inherit with a Team table model. Then we also inherit from the TeamBase for the TeamCreate and TeamRead data models. And we also create a TeamUpdate data model. from typing import List, Optional from fastapi import Depends, FastAPI, HTTPException, Query from sqlmodel import Field, Relationship, Session, SQLModel, create_engine, select class TeamBase(SQLModel): name: str = Field(index=True) headquarters: str class Team(TeamBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class TeamCreate(TeamBase): pass class TeamRead(TeamBase): id: int class TeamUpdate(SQLModel): name: Optional[str] = None headquarters: Optional[str] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We now also have relationship attributes. ðŸŽ‰ Let's now update the Hero models too. Update Hero ModelsÂ¶ # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) team: Optional[Team] = Relationship(back_populates=\"heroes\") class HeroRead(HeroBase): id: int class HeroCreate(HeroBase): pass class HeroUpdate(SQLModel): name: Optional[str] = None secret_name: Optional[str] = None age: Optional[int] = None team_id: Optional[int] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We now have a team_id in the hero models. Notice that we can declare the team_id in the HeroBase because it can be reused by all the models, in all the cases it's an optional integer. And even though the HeroBase is not a table model, we can declare team_id in it with the foreign key parameter. It won't do anything in most of the models that inherit from HeroBase, but in the table model Hero it will be used to tell SQLModel that this is a foreign key to that table. Relationship AttributesÂ¶ Notice that the relationship attributes, the ones with Relationship(), are only in the table models, as those are the ones that are handled by SQLModel with SQLAlchemy and that can have the automatic fetching of data from the database when we access them. # Code above omitted ðŸ‘† class TeamBase(SQLModel): name: str = Field(index=True) headquarters: str class Team(TeamBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class TeamCreate(TeamBase): pass class TeamRead(TeamBase): id: int class TeamUpdate(SQLModel): name: Optional[str] = None headquarters: Optional[str] = None class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) team: Optional[Team] = Relationship(back_populates=\"heroes\") class HeroRead(HeroBase): id: int class HeroCreate(HeroBase): pass class HeroUpdate(SQLModel): name: Optional[str] = None secret_name: Optional[str] = None age: Optional[int] = None team_id: Optional[int] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Path Operations for TeamsÂ¶ Let's now add the path operations for teams. These are equivalent and very similar to the path operations for the heroes we had before, so we don't have to go over the details for each one, let's check the code. # Code above omitted ðŸ‘† @app.post(\"/teams/\", response_model=TeamRead) def create_team(*, session: Session = Depends(get_session), team: TeamCreate): db_team = Team.model_validate(team) session.add(db_team) session.commit() session.refresh(db_team) return db_team @app.get(\"/teams/\", response_model=List[TeamRead]) def read_teams( *, session: Session = Depends(get_session), offset: int = 0, limit: int = Query(default=100, le=100), ): teams = session.exec(select(Team).offset(offset).limit(limit)).all() return teams @app.get(\"/teams/{team_id}\", response_model=TeamRead) def read_team(*, team_id: int, session: Session = Depends(get_session)): team = session.get(Team, team_id) if not team: raise HTTPException(status_code=404, detail=\"Team not found\") return team @app.patch(\"/teams/{team_id}\", response_model=TeamRead) def update_team( *, session: Session = Depends(get_session), team_id: int, team: TeamUpdate, ): db_team = session.get(Team, team_id) if not db_team: raise HTTPException(status_code=404, detail=\"Team not found\") team_data = team.model_dump(exclude_unset=True) for key, value in team_data.items(): setattr(db_team, key, value) session.add(db_team) session.commit() session.refresh(db_team) return db_team @app.delete(\"/teams/{team_id}\") def delete_team(*, session: Session = Depends(get_session), team_id: int): team = session.get(Team, team_id) if not team: raise HTTPException(status_code=404, detail=\"Team not found\") session.delete(team) session.commit() return {\"ok\": True} # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Using Relationships AttributesÂ¶ Up to this point, we are actually not using the relationship attributes, but we could access them in our code. In the next chapter, we will play more with them. Check the Docs UIÂ¶ Now we can check the automatic docs UI to see all the path operations for heroes and teams. RecapÂ¶ We can use the same patterns to add more models and API path operations to our FastAPI application. ðŸŽ‰ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Delete Data with FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/delete/",
    "html": "Skip to content SQLModel Delete Data with FastAPI Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Delete Path Operation Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Delete Data with FastAPIÂ¶ Let's now add a path operation to delete a hero. This is quite straightforward. ðŸ˜ Delete Path OperationÂ¶ Because we want to delete data, we use an HTTP DELETE operation. We get a hero_id from the path parameter and verify if it exists, just as we did when reading a single hero or when updating it, possibly raising an error with a 404 response. And if we actually find a hero, we just delete it with the session. # Code above omitted ðŸ‘† @app.delete(\"/heroes/{hero_id}\") def delete_hero(hero_id: int): with Session(engine) as session: hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") session.delete(hero) session.commit() return {\"ok\": True} # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview After deleting it successfully, we just return a response of: { \"ok\": true } RecapÂ¶ That's it, feel free to try it out in the interactive docs UI to delete some heroes. ðŸ’¥ Using FastAPI to read data and combining it with SQLModel makes it quite straightforward to delete data from the database. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Session with FastAPI Dependency - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/session-with-dependency/",
    "html": "Skip to content SQLModel Session with FastAPI Dependency Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Current Sessions Create a FastAPI Dependency Use the Dependency The with Block Update the Path Operations to Use the Dependency Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Session with FastAPI DependencyÂ¶ Before we keep adding things, let's change a bit how we get the session for each request to simplify our life later. Current SessionsÂ¶ Up to now, we have been creating a session in each path operation, in a with block. # Code above omitted ðŸ‘† @app.post(\"/heroes/\", response_model=HeroRead) def create_hero(hero: HeroCreate): with Session(engine) as session: db_hero = Hero.model_validate(hero) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That's perfectly fine, but in many use cases we would want to use FastAPI Dependencies, for example to verify that the client is logged in and get the current user before executing any other code in the path operation. These dependencies are also very useful during testing, because we can easily replace them, and then, for example, use a new database for our tests, or put some data before the tests, etc. So, let's refactor these sessions to use FastAPI Dependencies. Create a FastAPI DependencyÂ¶ A FastAPI dependency is very simple, it's just a function that returns a value. It could use yield instead of return, and in that case FastAPI will make sure it executes all the code after the yield, once it is done with the request. # Code above omitted ðŸ‘† def get_session(): with Session(engine) as session: yield session # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Use the DependencyÂ¶ Now let's make FastAPI execute a dependency and get its value in the path operation. We import Depends() from fastapi. Then we use it in the path operation function in a parameter, the same way we declared parameters to get JSON bodies, path parameters, etc. from typing import List, Optional from fastapi import Depends, FastAPI, HTTPException, Query from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ def get_session(): with Session(engine) as session: yield session # Code here omitted ðŸ‘ˆ @app.post(\"/heroes/\", response_model=HeroRead) def create_hero(*, session: Session = Depends(get_session), hero: HeroCreate): db_hero = Hero.model_validate(hero) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip Here's a tip about that *, thing in the parameters. Here we are passing the parameter session that has a \"default value\" of Depends(get_session) before the parameter hero, that doesn't have any default value. Python would normally complain about that, but we can use the initial \"parameter\" *, to mark all the rest of the parameters as \"keyword only\", which solves the problem. You can read more about it in the FastAPI documentation Path Parameters and Numeric Validations - Order the parameters as you need, tricks The value of a dependency will only be used for one request, FastAPI will call it right before calling your code and will give you the value from that dependency. If it had yield, then it will continue the rest of the execution once you are done sending the response. In the case of the session, it will finish the cleanup code from the with block, closing the session, etc. Then FastAPI will call it again for the next request. Because it is called once per request, we will still get a single session per request as we should, so we are still fine with that. âœ… And because dependencies can use yield, FastAPI will make sure to run the code after the yield once it is done, including all the cleanup code at the end of the with block. So we are also fine with that. âœ… The with BlockÂ¶ This means that in the main code of the path operation function, it will work equivalently to the previous version with the explicit with block. from typing import List, Optional from fastapi import Depends, FastAPI, HTTPException, Query from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ def get_session(): with Session(engine) as session: yield session # Code here omitted ðŸ‘ˆ @app.post(\"/heroes/\", response_model=HeroRead) def create_hero(*, session: Session = Depends(get_session), hero: HeroCreate): db_hero = Hero.model_validate(hero) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview In fact, you could think that all that block of code inside of the create_hero() function is still inside a with block for the session, because this is more or less what's happening behind the scenes. But now, the with block is not explicitly in the function, but in the dependency above: from typing import List, Optional from fastapi import Depends, FastAPI, HTTPException, Query from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ def get_session(): with Session(engine) as session: yield session # Code here omitted ðŸ‘ˆ @app.post(\"/heroes/\", response_model=HeroRead) def create_hero(*, session: Session = Depends(get_session), hero: HeroCreate): db_hero = Hero.model_validate(hero) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We will see how this is very useful when testing the code later. âœ… Update the Path Operations to Use the DependencyÂ¶ Now we can update the rest of the path operations to use the new dependency. We just declare the dependency in the parameters of the function, with: session: Session = Depends(get_session) And then we remove the previous with block with the old session. from typing import List, Optional from fastapi import Depends, FastAPI, HTTPException, Query from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ def get_session(): with Session(engine) as session: yield session # Code here omitted ðŸ‘ˆ @app.post(\"/heroes/\", response_model=HeroRead) def create_hero(*, session: Session = Depends(get_session), hero: HeroCreate): db_hero = Hero.model_validate(hero) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero @app.get(\"/heroes/\", response_model=List[HeroRead]) def read_heroes( *, session: Session = Depends(get_session), offset: int = 0, limit: int = Query(default=100, le=100), ): heroes = session.exec(select(Hero).offset(offset).limit(limit)).all() return heroes @app.get(\"/heroes/{hero_id}\", response_model=HeroRead) def read_hero(*, session: Session = Depends(get_session), hero_id: int): hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") return hero @app.patch(\"/heroes/{hero_id}\", response_model=HeroRead) def update_hero( *, session: Session = Depends(get_session), hero_id: int, hero: HeroUpdate ): db_hero = session.get(Hero, hero_id) if not db_hero: raise HTTPException(status_code=404, detail=\"Hero not found\") hero_data = hero.model_dump(exclude_unset=True) for key, value in hero_data.items(): setattr(db_hero, key, value) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero @app.delete(\"/heroes/{hero_id}\") def delete_hero(*, session: Session = Depends(get_session), hero_id: int): hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") session.delete(hero) session.commit() return {\"ok\": True} ðŸ‘€ Full file preview RecapÂ¶ You just learned how to use FastAPI dependencies to handle the database session. This will come in handy later when testing the code. And you will see how much these dependencies can help the more you work with FastAPI, to handle permissions, authentication, resources like database sessions, etc. ðŸš€ If you want to learn more about dependencies, checkout the FastAPI docs about Dependencies. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Update Data with FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/update/",
    "html": "Skip to content SQLModel Update Data with FastAPI Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents HeroUpdate Model Create the Update Path Operation Read the Existing Hero Get the New Data Update the Hero in the Database Remove Fields Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Update Data with FastAPIÂ¶ Now let's see how to update data in the database with a FastAPI path operation. HeroUpdate ModelÂ¶ We want clients to be able to update the name, the secret_name, and the age of a hero. But we don't want them to have to include all the data again just to update a single field. So, we need to have all those fields marked as optional. And because the HeroBase has some of them as required and not optional, we will need to create a new model. Tip Here is one of those cases where it probably makes sense to use an independent model instead of trying to come up with a complex tree of models inheriting from each other. Because each field is actually different (we just change it to Optional, but that's already making it different), it makes sense to have them in their own model. So, let's create this new HeroUpdate model: # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) class HeroCreate(HeroBase): pass class HeroRead(HeroBase): id: int class HeroUpdate(SQLModel): name: Optional[str] = None secret_name: Optional[str] = None age: Optional[int] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is almost the same as HeroBase, but all the fields are optional, so we can't simply inherit from HeroBase. Create the Update Path OperationÂ¶ Now let's use this model in the path operation to update a hero. We will use a PATCH HTTP operation. This is used to partially update data, which is what we are doing. # Code above omitted ðŸ‘† @app.patch(\"/heroes/{hero_id}\", response_model=HeroRead) def update_hero(hero_id: int, hero: HeroUpdate): with Session(engine) as session: db_hero = session.get(Hero, hero_id) if not db_hero: raise HTTPException(status_code=404, detail=\"Hero not found\") hero_data = hero.model_dump(exclude_unset=True) for key, value in hero_data.items(): setattr(db_hero, key, value) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We also read the hero_id from the path parameter and the request body, a HeroUpdate. Read the Existing HeroÂ¶ We take a hero_id with the ID of the hero we want to update. So, we need to read the hero from the database, with the same logic we used to read a single hero, checking if it exists, possibly raising an error for the client if it doesn't exist, etc. # Code above omitted ðŸ‘† @app.patch(\"/heroes/{hero_id}\", response_model=HeroRead) def update_hero(hero_id: int, hero: HeroUpdate): with Session(engine) as session: db_hero = session.get(Hero, hero_id) if not db_hero: raise HTTPException(status_code=404, detail=\"Hero not found\") hero_data = hero.model_dump(exclude_unset=True) for key, value in hero_data.items(): setattr(db_hero, key, value) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Get the New DataÂ¶ The HeroUpdate model has all the fields with default values, because they all have defaults, they are all optional, which is what we want. But that also means that if we just call hero.model_dump() we will get a dictionary that could potentially have several or all of those values with their defaults, for example: { \"name\": None, \"secret_name\": None, \"age\": None, } And then, if we update the hero in the database with this data, we would be removing any existing values, and that's probably not what the client intended. But fortunately Pydantic models (and so SQLModel models) have a parameter we can pass to the .model_dump() method for that: exclude_unset=True. This tells Pydantic to not include the values that were not sent by the client. Saying it another way, it would only include the values that were sent by the client. So, if the client sent a JSON with no values: {} Then the dictionary we would get in Python using hero.model_dump(exclude_unset=True) would be: {} But if the client sent a JSON with: { \"name\": \"Deadpuddle\" } Then the dictionary we would get in Python using hero.model_dump(exclude_unset=True) would be: { \"name\": \"Deadpuddle\" } Then we use that to get the data that was actually sent by the client: # Code above omitted ðŸ‘† @app.patch(\"/heroes/{hero_id}\", response_model=HeroRead) def update_hero(hero_id: int, hero: HeroUpdate): with Session(engine) as session: db_hero = session.get(Hero, hero_id) if not db_hero: raise HTTPException(status_code=404, detail=\"Hero not found\") hero_data = hero.model_dump(exclude_unset=True) for key, value in hero_data.items(): setattr(db_hero, key, value) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip Before SQLModel 0.0.14, the method was called hero.dict(exclude_unset=True), but it was renamed to hero.model_dump(exclude_unset=True) to be consistent with Pydantic v2. Update the Hero in the DatabaseÂ¶ Now that we have a dictionary with the data sent by the client, we can iterate for each one of the keys and the values, and then we set them in the database hero model db_hero using setattr(). # Code above omitted ðŸ‘† @app.patch(\"/heroes/{hero_id}\", response_model=HeroRead) def update_hero(hero_id: int, hero: HeroUpdate): with Session(engine) as session: db_hero = session.get(Hero, hero_id) if not db_hero: raise HTTPException(status_code=404, detail=\"Hero not found\") hero_data = hero.model_dump(exclude_unset=True) for key, value in hero_data.items(): setattr(db_hero, key, value) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read Heroes with Limit and Offset with FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/limit-and-offset/",
    "html": "Skip to content SQLModel Read Heroes with Limit and Offset with FastAPI Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Add a Limit and Offset to the Query Parameters Check the Docs UI Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Read Heroes with Limit and Offset with FastAPIÂ¶ When a client sends a request to get all the heroes, we have been returning them all. But if we had thousands of heroes that could consume a lot of computational resources, network bandwidth, etc. So, we probably want to limit it. Let's use the same offset and limit we learned about in the previous tutorial chapters for the API. Info In many cases, this is also called pagination. Add a Limit and Offset to the Query ParametersÂ¶ Let's add limit and offset to the query parameters. By default, we will return the first results from the database, so offset will have a default value of 0. And by default, we will return a maximum of 100 heroes, so limit will have a default value of 100. from typing import List, Optional from fastapi import FastAPI, HTTPException, Query from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ @app.get(\"/heroes/\", response_model=List[HeroRead]) def read_heroes(offset: int = 0, limit: int = Query(default=100, le=100)): with Session(engine) as session: heroes = session.exec(select(Hero).offset(offset).limit(limit)).all() return heroes # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We want to allow clients to set different offset and limit values. But we don't want them to be able to set a limit of something like 9999, that's over 9000! ðŸ˜± So, to prevent it, we add additional validation to the limit query parameter, declaring that it has to be less than or equal to 100 with le=100. This way, a client can decide to take fewer heroes if they want, but not more. Info If you need to refresh how query parameters and their validation work, check out the docs in FastAPI: Query Parameters Query Parameters and String Validations Path Parameters and Numeric Validations Check the Docs UIÂ¶ Now we can see that the docs UI shows the new parameters to control limit and offset of our data. RecapÂ¶ You can use FastAPI's automatic data validation to get the parameters for limit and offset, and then use them with the session to control ranges of data to be sent in responses. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read One Model with FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/read-one/",
    "html": "Skip to content SQLModel Read One Model with FastAPI Type to start searching tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Path Operation for One Hero Handling Errors Return the Hero Check the Docs UI Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Read One Model with FastAPIÂ¶ Let's now add a path operation to read a single model to our FastAPI application. Path Operation for One HeroÂ¶ Let's add a new path operation to read one single hero. We want to get the hero based on the id, so we will use a path parameter hero_id. Info If you need to refresh how path parameters work, including their data validation, check the FastAPI docs about Path Parameters. from typing import List, Optional from fastapi import FastAPI, HTTPException from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ @app.get(\"/heroes/{hero_id}\", response_model=HeroRead) def read_hero(hero_id: int): with Session(engine) as session: hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") return hero ðŸ‘€ Full file preview For example, to get the hero with ID 2 we would send a GET request to: /heroes/2 Handling ErrorsÂ¶ Then, because FastAPI already takes care of making sure that the hero_id is an actual integer, we can use it directly with Hero.get() to try and get one hero by that ID. But if the integer is not the ID of any hero in the database, it will not find anything, and the variable hero will be None. So, we check it in an if block, if it's None, we raise an HTTPException with a 404 status code. And to use it, we first import HTTPException from fastapi. This will let the client know that they probably made a mistake on their side and requested a hero that doesn't exist in the database. from typing import List, Optional from fastapi import FastAPI, HTTPException from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ @app.get(\"/heroes/{hero_id}\", response_model=HeroRead) def read_hero(hero_id: int): with Session(engine) as session: hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") return hero ðŸ‘€ Full file preview Return the HeroÂ¶ Then, if the hero exists, we return it. And because we are using the response_model with HeroRead, it will be validated, documented, etc. from typing import List, Optional from fastapi import FastAPI, HTTPException from sqlmodel import Field, Session, SQLModel, create_engine, select # Code here omitted ðŸ‘ˆ @app.get(\"/heroes/{hero_id}\", response_model=HeroRead) def read_hero(hero_id: int): with Session(engine) as session: hero = session.get(Hero, hero_id) if not hero: raise HTTPException(status_code=404, detail=\"Hero not found\") return hero ðŸ‘€ Full file preview Check the Docs UIÂ¶ We can then go to the docs UI and see the new path operation. RecapÂ¶ You can combine FastAPI features like automatic path parameter validation to get models by ID. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Multiple Models with FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/multiple-models/",
    "html": "Skip to content SQLModel Multiple Models with FastAPI Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Review Creation Schema Review Response Schema Why Is it Important to Have a Contract for Responses So Why is it Important to Have Required IDs Multiple Hero Schemas Multiple Models with Duplicated Fields Use Multiple Models to Create a Hero Shared Fields Multiple Models with Inheritance The Hero Table Model Columns and Inheritance with Multiple Models The HeroCreate Data Model The HeroRead Data Model Review the Updated Docs UI Docs UI to Create a Hero Docs UI with Hero Responses Inheritance and Table Models Only Inherit from Data Models Avoid Duplication - Keep it Simple Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Multiple Models with FastAPIÂ¶ We have been using the same Hero model to declare the schema of the data we receive in the API, the table model in the database, and the schema of the data we send back in responses. But in most of the cases, there are slight differences. Let's use multiple models to solve it. Here you will see the main and biggest feature of SQLModel. ðŸ˜Ž Review Creation SchemaÂ¶ Let's start by reviewing the automatically generated schemas from the docs UI. For input, we have: If we pay attention, it shows that the client could send an id in the JSON body of the request. This means that the client could try to use the same ID that already exists in the database for another hero. That's not what we want. We want the client only to send the data that is needed to create a new hero: name secret_name Optional age And we want the id to be generated automatically by the database, so we don't want the client to send it. We'll see how to fix it in a bit. Review Response SchemaÂ¶ Now let's review the schema of the response we send back to the client in the docs UI. If you click the small tab Schema instead of the Example Value, you will see something like this: Let's see the details. The fields with a red asterisk (*) are \"required\". This means that our API application is required to return those fields in the response: name secret_name The age is optional, we don't have to return it, or it could be None (or null in JSON), but the name and the secret_name are required. Here's the weird thing, the id currently seems also \"optional\". ðŸ¤” This is because in our SQLModel class we declare the id with Optional[int], because it could be None in memory until we save it in the database and we finally get the actual ID. But in the responses, we always send a model from the database, so it always has an ID. So the id in the responses can be declared as required. This means that our application is making the promise to the clients that if it sends a hero, it will for sure have an id with a value, it will not be None. Why Is it Important to Have a Contract for ResponsesÂ¶ The ultimate goal of an API is for some clients to use it. The clients could be a frontend application, a command line program, a graphical user interface, a mobile application, another backend application, etc. And the code those clients write depends on what our API tells them they need to send, and what they can expect to receive. Making both sides very clear will make it much easier to interact with the API. And in most of the cases, the developer of the client for that API will also be yourself, so you are doing your future self a favor by declaring those schemas for requests and responses. ðŸ˜‰ So Why is it Important to Have Required IDsÂ¶ Now, what's the matter with having one id field marked as \"optional\" in a response when in reality it is always required? For example, automatically generated clients in other languages (or also in Python) would have some declaration that this field id is optional. And then the developers using those clients in their languages would have to be checking all the time in all their code if the id is not None before using it anywhere. That's a lot of unnecessary checks and unnecessary code that could have been saved by declaring the schema properly. ðŸ˜” It would be a lot simpler for that code to know that the id from a response is required and will always have a value. Let's fix that too. ðŸ¤“ Multiple Hero SchemasÂ¶ So, we want to have our Hero model that declares the data in the database: id, optional on creation, required on database name, required secret_name, required age, optional But we also want to have a HeroCreate for the data we want to receive when creating a new hero, which is almost all the same data as Hero, except for the id, because that is created automatically by the database: name, required secret_name, required age, optional And we want to have a HeroRead with the id field, but this time annotated with id: int, instead of id: Optional[int], to make it clear that it is required in responses read from the clients: id, required name, required secret_name, required age, optional Multiple Models with Duplicated FieldsÂ¶ The simplest way to solve it could be to create multiple models, each one with all the corresponding fields: # This would work, but there's a better option below ðŸš¨ # Code above omitted ðŸ‘† class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) class HeroCreate(SQLModel): name: str secret_name: str age: Optional[int] = None class HeroRead(SQLModel): id: int name: str secret_name: str age: Optional[int] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Here's the important detail, and probably the most important feature of SQLModel: only Hero is declared with table = True. This means that the class Hero represents a table in the database. It is both a Pydantic model and a SQLAlchemy model. But HeroCreate and HeroRead don't have table = True. They are only data models, they are only Pydantic models. They won't be used with the database, but only to declare data schemas for the API (or for other uses). This also means that SQLModel.metadata.create_all() won't create tables in the database for HeroCreate and HeroRead, because they don't have table = True, which is exactly what we want. ðŸš€ Tip We will improve this code to avoid duplicating the fields, but for now we can continue learning with these models. Use Multiple Models to Create a HeroÂ¶ Let's now see how to use these new models in the FastAPI application. Let's first check how is the process to create a hero now: # Code above omitted ðŸ‘† @app.post(\"/heroes/\", response_model=HeroRead) def create_hero(hero: HeroCreate): with Session(engine) as session: db_hero = Hero.model_validate(hero) session.add(db_hero) session.commit() session.refresh(db_hero) return db_hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Let's check that in detail. Now we use the type annotation HeroCreate for the request JSON data in the hero parameter of the path operation function. # Code above omitted ðŸ‘† def create_hero(hero: HeroCreate): # Code below omitted ðŸ‘‡ Then we create a new Hero (this is the actual table model that saves things to the database) using Hero.model_validate(). The method .model_validate() reads data from another object with attributes (or a dict) and creates a new instance of this class, in this case Hero. In this case, we have a HeroCreate instance in the hero variable. This is an object with attributes, so we use .model_validate() to read those attributes. Tip In versions of SQLModel before 0.0.14 you would use the method .from_orm(), but it is now deprecated and you should use .model_validate() instead. We can now create a new Hero instance (the one for the database) and put it in the variable db_hero from the data in the hero variable that is the HeroCreate instance we received from the request. # Code above omitted ðŸ‘† db_hero = Hero.model_validate(hero) # Code below omitted ðŸ‘‡ Then we just add it to the session, commit, and refresh it, and finally, we return the same db_hero variable that has the just refreshed Hero instance. Because it is just refreshed, it has the id field set with a new ID taken from the database. And now that we return it, FastAPI will validate the data with the response_model, which is a HeroRead: # Code above omitted ðŸ‘† @app.post(\"/heroes/\", response_model=HeroRead) # Code below omitted ðŸ‘‡ This will validate that all the data that we promised is there and will remove any data we didn't declare. Tip This filtering could be very important and could be a very good security feature, for example, to make sure you filter private data, hashed passwords, etc. You can read more about it in the FastAPI docs about Response Model. In particular, it will make sure that the id is there and that it is indeed an integer (and not None). Shared FieldsÂ¶ But looking closely, we could see that these models have a lot of duplicated information. All the 3 models declare that they share some common fields that look exactly the same: name, required secret_name, required age, optional And then they declare other fields with some differences (in this case, only about the id). We want to avoid duplicated information if possible. This is important if, for example, in the future, we decide to refactor the code and rename one field (column). For example, from secret_name to secret_identity. If we have that duplicated in multiple models, we could easily forget to update one of them. But if we avoid duplication, there's only one place that would need updating. âœ¨ Let's now improve that. ðŸ¤“ Multiple Models with InheritanceÂ¶ And here it is, you found the biggest feature of SQLModel. ðŸ’Ž Each of these models is only a data model or both a data model and a table model. So, it's possible to create models with SQLModel that don't represent tables in the database. On top of that, we can use inheritance to avoid duplicated information in these models. We can see from above that they all share some base fields: name, required secret_name, required age, optional So let's create a base model HeroBase that the others can inherit from: # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview As you can see, this is not a table model, it doesn't have the table = True config. But now we can create the other models inheriting from it, they will all share these fields, just as if they had them declared. The Hero Table ModelÂ¶ Let's start with the only table model, the Hero: # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Notice that Hero now doesn't inherit from SQLModel, but from HeroBase. And now we only declare one single field directly, the id, that here is Optional[int], and is a primary_key. And even though we don't declare the other fields explicitly, because they are inherited, they are also part of this Hero model. And of course, all these fields will be in the columns for the resulting hero table in the database. And those inherited fields will also be in the autocompletion and inline errors in editors, etc. Columns and Inheritance with Multiple ModelsÂ¶ Notice that the parent model HeroBase is not a table model, but still, we can declare name and age using Field(index=True). # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This won't affect this parent data model HeroBase. But once the child model Hero (the actual table model) inherits those fields, it will use those field configurations to create the indexes when creating the tables in the database. The HeroCreate Data ModelÂ¶ Now let's see the HeroCreate model that will be used to define the data that we want to receive in the API when creating a new hero. This is a fun one: # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) class HeroCreate(HeroBase): pass # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview What's happening here? The fields we need to create are exactly the same as the ones in the HeroBase model. So we don't have to add anything. And because we can't leave the empty space when creating a new class, but we don't want to add any field, we just use pass. This means that there's nothing else special in this class apart from the fact that it is named HeroCreate and that it inherits from HeroBase. As an alternative, we could use HeroBase directly in the API code instead of HeroCreate, but it would show up in the automatic docs UI with that name \"HeroBase\" which could be confusing for clients. Instead, \"HeroCreate\" is a bit more explicit about what it is for. On top of that, we could easily decide in the future that we want to receive more data when creating a new hero apart from the data in HeroBase (for example, a password), and now we already have the class to put those extra fields. The HeroRead Data ModelÂ¶ Now let's check the HeroRead model. This one just declares that the id field is required when reading a hero from the API, because a hero read from the API will come from the database, and in the database it will always have an ID. # Code above omitted ðŸ‘† class HeroBase(SQLModel): name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) class Hero(HeroBase, table=True): id: Optional[int] = Field(default=None, primary_key=True) class HeroCreate(HeroBase): pass class HeroRead(HeroBase): id: int # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Review the Updated Docs UIÂ¶ The FastAPI code is still the same as above, we still use Hero, HeroCreate, and HeroRead. But now, we define them in a smarter way with inheritance. So, we can jump to the docs UI right away and see how they look with the updated data. Docs UI to Create a HeroÂ¶ Let's see the new UI for creating a hero: Nice! It now shows that to create a hero, we just pass the name, secret_name, and optionally age. We no longer pass an id. Docs UI with Hero ResponsesÂ¶ Now we can scroll down a bit to see the response schema: We can now see that id is a required field, it has a red asterisk (*). And if we check the schema for the Read Heroes path operation it will also show the updated schema. Inheritance and Table ModelsÂ¶ We just saw how powerful the inheritance of these models could be. This is a very simple example, and it might look a bit... meh. ðŸ˜… But now imagine that your table has 10 or 20 columns. And that you have to duplicate all that information for all your data models... then it becomes more obvious why it's quite useful to be able to avoid all that information duplication with inheritance. Now, this probably looks so flexible that it's not obvious when to use inheritance and for what. Here are a couple of rules of thumb that can help you. Only Inherit from Data ModelsÂ¶ Only inherit from data models, don't inherit from table models. It will help you avoid confusion, and there won't be any reason for you to need to inherit from a table model. If you feel like you need to inherit from a table model, then instead create a base class that is only a data model and has all those fields, like HeroBase. And then inherit from that base class that is only a data model for any other data model and for the table model. Avoid Duplication - Keep it SimpleÂ¶ It could feel like you need to have a profound reason why to inherit from one model or another, because \"in some mystical way\" they separate different concepts... or something like that. In some cases, there are simple separations that you can use, like the models to create data, read, update, etc. If that's quick and obvious, nice, use it. ðŸ’¯ Otherwise, don't worry too much about profound conceptual reasons to separate models, just try to avoid duplication and keep the code simple enough to reason about it. If you see you have a lot of overlap between two models, then you can probably avoid some of that duplication with a base model. But if to avoid some duplication you end up with a crazy tree of models with inheritance, then it might be simpler to just duplicate some of those fields, and that might be easier to reason about and to maintain. Do whatever is easier to reason about, to program with, to maintain, and to refactor in the future. ðŸ¤“ Remember that inheritance, the same as SQLModel, and anything else, are just tools to help you be more productive, that's one of their main objectives. If something is not helping with that (e.g. too much duplication, too much complexity), then change it. ðŸš€ RecapÂ¶ You can use SQLModel to declare multiple models: Some models can be only data models. They will also be Pydantic models. And some can also be table models (apart from already being data models) by having the config table = True. They will also be Pydantic models and SQLAlchemy models. Only the table models will create tables in the database. So, you can use all the other data models to validate, convert, filter, and document the schema of the data for your application. âœ¨ You can use inheritance to avoid information and code duplication. ðŸ˜Ž And you can use all these models directly with FastAPI. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI Response Model with SQLModel - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/response-model/",
    "html": "Skip to content SQLModel FastAPI Response Model with SQLModel Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Interactive API Docs Response Data Use response_model List of Heroes in response_model FastAPI and Response Model New API Docs UI Automatic Clients Recap SQLModel Tutorial - User Guide FastAPI and Pydantic FastAPI Response Model with SQLModelÂ¶ Now I'll show you how to use FastAPI's response_model with SQLModel. Interactive API DocsÂ¶ Up to now, with the code we have used, the API docs know the data the clients have to send: This interactive docs UI is powered by Swagger UI, and what Swagger UI does is to read a big JSON content that defines the API with all the data schemas (data shapes) using the standard OpenAPI, and showing it in that nice UI. FastAPI automatically generates that OpenAPI for Swagger UI to read it. And it generates it based on the code you write, using the Pydantic models (in this case SQLModel models) and type annotations to know the schemas of the data that the API handles. Response DataÂ¶ But up to now, the API docs UI doesn't know the schema of the responses our app sends back. You can see that there's a possible \"Successful Response\" with a code 200, but we have no idea how the response data would look like. Right now, we only tell FastAPI the data we want to receive, but we don't tell it yet the data we want to send back. Let's do that now. ðŸ¤“ Use response_modelÂ¶ We can use response_model to tell FastAPI the schema of the data we want to send back. For example, we can pass the same Hero SQLModel class (because it is also a Pydantic model): # Code above omitted ðŸ‘† @app.post(\"/heroes/\", response_model=Hero) def create_hero(hero: Hero): with Session(engine) as session: session.add(hero) session.commit() session.refresh(hero) return hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview List of Heroes in response_modelÂ¶ We can also use other type annotations, the same way we can use with Pydantic fields. For example, we can pass a list of Heros. First, we import List from typing and then we declare the response_model with List[Hero]: from typing import List, Optional # Code here omitted ðŸ‘ˆ @app.get(\"/heroes/\", response_model=List[Hero]) def read_heroes(): with Session(engine) as session: heroes = session.exec(select(Hero)).all() return heroes # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview FastAPI and Response ModelÂ¶ FastAPI will do data validation and filtering of the response with this response_model. So this works like a contract between our application and the client. You can read more about it in the FastAPI docs about response_model. New API Docs UIÂ¶ Now we can go back to the docs UI and see that they now show the schema of the response we will receive. The clients will know what data they should expect. Automatic ClientsÂ¶ The most visible advantage of using the response_model is that it shows up in the API docs UI. But there are other advantages, like that FastAPI will do automatic data validation and filtering of the response data using this model. Additionally, because the schemas are defined in using a standard, there are many tools that can take advantage of this. For example, client generators, that can automatically create the code necessary to talk to your API in many languages. Info If you are curious about the standards, FastAPI generates OpenAPI, that internally uses JSON Schema. You can read about all that in the FastAPI docs - First Steps. RecapÂ¶ Use the response_model to tell FastAPI the schema of the data you want to send back and have awesome data APIs. ðŸ˜Ž Made with Material for MkDocs Insiders"
  },
  {
    "title": "Simple Hero API with FastAPI - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/simple-hero-api/",
    "html": "Skip to content SQLModel Simple Hero API with FastAPI Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Install FastAPI SQLModel Code - Models, Engine FastAPI App Create Database and Tables on startup Create Heroes Path Operation The SQLModel Advantage Read Heroes Path Operation One Session per Request Run the FastAPI Application Uvicorn --reload Check the API docs UI Play with the API Check the Database Recap SQLModel Tutorial - User Guide FastAPI and Pydantic Simple Hero API with FastAPIÂ¶ Let's start by building a simple hero web API with FastAPI. âœ¨ Install FastAPIÂ¶ The first step is to install FastAPI. FastAPI is the framework to create the web API. But we also need another type of program to run it, it is called a \"server\". We will use Uvicorn for that. And we will install Uvicorn with its standard dependencies. Make sure you have a virtual environment activated. Then install FastAPI and Uvicorn: fast â†’ SQLModel Code - Models, EngineÂ¶ Now let's start with the SQLModel code. We will start with the simplest version, with just heroes (no teams yet). This is almost the same code we have seen up to now in previous examples: from typing import Optional # One line of FastAPI imports here later ðŸ‘ˆ from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" connect_args = {\"check_same_thread\": False} engine = create_engine(sqlite_url, echo=True, connect_args=connect_args) def create_db_and_tables(): SQLModel.metadata.create_all(engine) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview There's only one change here from the code we have used before, the check_same_thread in the connect_args. That is a configuration that SQLAlchemy passes to the low-level library in charge of communicating with the database. check_same_thread is by default set to True, to prevent misuses in some simple cases. But here we will make sure we don't share the same session in more than one request, and that's the actual safest way to prevent any of the problems that configuration is there for. And we also need to disable it because in FastAPI each request could be handled by multiple interacting threads. Info That's enough information for now, you can read more about it in the FastAPI docs for async and await. The main point is, by ensuring you don't share the same session with more than one request, the code is already safe. FastAPI AppÂ¶ The next step is to create the FastAPI app. We will import the FastAPI class from fastapi. And then create an app object that is an instance of that FastAPI class: from typing import Optional from fastapi import FastAPI from sqlmodel import Field, Session, SQLModel, create_engine, select # SQLModel code here omitted ðŸ‘ˆ app = FastAPI() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Create Database and Tables on startupÂ¶ We want to make sure that once the app starts running, the function create_tables is called. To create the database and tables. This should be called only once at startup, not before every request, so we put it in the function to handle the \"startup\" event: # Code above omitted ðŸ‘† app = FastAPI() @app.on_event(\"startup\") def on_startup(): create_db_and_tables() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Create Heroes Path OperationÂ¶ Info If you need a refresher on what a Path Operation is (an endpoint with a specific HTTP Operation) and how to work with it in FastAPI, check out the FastAPI First Steps docs. Let's create the path operation code to create a new hero. It will be called when a user sends a request with a POST operation to the /heroes/ path: # Code above omitted ðŸ‘† app = FastAPI() @app.on_event(\"startup\") def on_startup(): create_db_and_tables() @app.post(\"/heroes/\") def create_hero(hero: Hero): with Session(engine) as session: session.add(hero) session.commit() session.refresh(hero) return hero # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Info If you need a refresher on some of those concepts, checkout the FastAPI documentation: First Steps Path Parameters - Data Validation and Data Conversion Request Body The SQLModel AdvantageÂ¶ Here's where having our SQLModel class models be both SQLAlchemy models and Pydantic models at the same time shine. âœ¨ Here we use the same class model to define the request body that will be received by our API. Because FastAPI is based on Pydantic, it will use the same model (the Pydantic part) to do automatic data validation and conversion from the JSON request to an object that is an actual instance of the Hero class. And then, because this same SQLModel object is not only a Pydantic model instance but also a SQLAlchemy model instance, we can use it directly in a session to create the row in the database. So we can use intuitive standard Python type annotations, and we don't have to duplicate a lot of the code for the database models and the API data models. ðŸŽ‰ Tip We will improve this further later, but for now, it already shows the power of having SQLModel classes be both SQLAlchemy models and Pydantic models at the same time. Read Heroes Path OperationÂ¶ Now let's add another path operation to read all the heroes: # Code above omitted ðŸ‘† app = FastAPI() @app.on_event(\"startup\") def on_startup(): create_db_and_tables() @app.post(\"/heroes/\") def create_hero(hero: Hero): with Session(engine) as session: session.add(hero) session.commit() session.refresh(hero) return hero @app.get(\"/heroes/\") def read_heroes(): with Session(engine) as session: heroes = session.exec(select(Hero)).all() return heroes ðŸ‘€ Full file preview This is pretty straightforward. When a client sends a request to the path /heroes/ with a GET HTTP operation, we run this function that gets the heroes from the database and returns them. One Session per RequestÂ¶ Remember that we should use a SQLModel session per each group of operations and if we need other unrelated operations we should use a different session? Here it is much more obvious. We should normally have one session per request in most of the cases. In some isolated cases, we would want to have new sessions inside, so, more than one session per request. But we would never want to share the same session among different requests. In this simple example, we just create the new sessions manually in the path operation functions. In future examples later we will use a FastAPI Dependency to get the session, being able to share it with other dependencies and being able to replace it during testing. ðŸ¤“ Run the FastAPI ApplicationÂ¶ Now we are ready to run the FastAPI application. Put all that code in a file called main.py. Then run it with Uvicorn: Info The command uvicorn main:app refers to: main: the file main.py (the Python \"module\"). app: the object created inside of main.py with the line app = FastAPI(). Uvicorn --reloadÂ¶ During development (and only during development), you can also add the option --reload to Uvicorn. It will restart the server every time you make a change to the code, this way you will be able to develop faster. ðŸ¤“ Just remember to never use --reload in production, as it consumes much more resources than necessary, would be more error prone, etc. Check the API docs UIÂ¶ Now you can go to that URL in your browser http://127.0.0.1:8000. We didn't create a path operation for the root path /, so that URL alone will only show a \"Not Found\" error... that \"Not Found\" error is produced by your FastAPI application. But you can go to the automatically generated interactive API documentation at the path /docs: http://127.0.0.1:8000/docs. âœ¨ You will see that this automatic API docs UI has the paths that we defined above with their operations, and that it already knows the shape of the data that the path operations will receive: Play with the APIÂ¶ You can actually click the button Try it out and send some requests to create some heroes with the Create Hero path operation. And then you can get them back with the Read Heroes path operation: Check the DatabaseÂ¶ Now you can terminate that Uvicorn server by going back to the terminal and pressing Ctrl+C. And then, you can open DB Browser for SQLite and check the database, to explore the data and confirm that it indeed saved the heroes. ðŸŽ‰ RecapÂ¶ Good job! This is already a FastAPI web API application to interact with the heroes database. ðŸŽ‰ There are several things we can improve and extend. For example, we want the database to decide the ID of each new hero, we don't want to allow a user to send it. We will make all those improvements in the next chapters. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI and Pydantic - Intro - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/fastapi/",
    "html": "Skip to content SQLModel FastAPI and Pydantic - Intro Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Simple Hero API with FastAPI FastAPI Response Model with SQLModel Multiple Models with FastAPI Read One Model with FastAPI Read Heroes with Limit and Offset with FastAPI Update Data with FastAPI Delete Data with FastAPI Session with FastAPI Dependency FastAPI Path Operations for Teams - Other Models Models with Relationships in FastAPI Test Applications with FastAPI and SQLModel Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Learning FastAPI SQLModel Tutorial - User Guide FastAPI and Pydantic FastAPI and Pydantic - IntroÂ¶ One of the use cases where SQLModel shines the most, and the main one why it was built, was to be combined with FastAPI. âœ¨ FastAPI is a Python web framework for building web APIs created by the same author of SQLModel. FastAPI is also built on top of Pydantic. In this group of chapters we will see how to combine SQLModel table models representing tables in the SQL database as all the ones we have seen up to now, with data models that only represent data (which are actually just Pydantic models behind the scenes). Being able to combine SQLModel table models with pure data models would be useful on its own, but to make all the examples more concrete, we will use them with FastAPI. By the end we will have a simple but complete web API to interact with the data in the database. ðŸŽ‰ Learning FastAPIÂ¶ If you have never used FastAPI, maybe a good idea would be to go and study it a bit before continuing. Just reading and trying the examples on the FastAPI main page should be enough, and it shouldn't take you more than 10 minutes. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Link Model with Extra Fields - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/many-to-many/link-with-extra-fields/",
    "html": "Skip to content SQLModel Link Model with Extra Fields Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Create Models with a Many-to-Many Link Create Data with Many-to-Many Relationships Update and Remove Many-to-Many Relationships Link Model with Extra Fields Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Link Model with Two One-to-Many Update Link Model Update Team Model Update Hero Model Create Relationships Run the Program Add Relationships Run the Program with the New Relationship Update Relationships with Links Run the Program with the Updated Relationships Recap SQLModel Tutorial - User Guide Many to Many Link Model with Extra FieldsÂ¶ In the previous example we never interacted directly with the HeroTeamLink model, it was all through the automatic many-to-many relationship. But what if we needed to have additional data to describe the link between the two models? Let's say that we want to have an extra field/column to say if a hero is still training in that team or if they are already going on missions and stuff. Let's see how to achieve that. Link Model with Two One-to-ManyÂ¶ The way to handle this is to explicitly use the link model, to be able to get and modify its data (apart from the foreign keys pointing to the two models for Hero and Team). In the end, the way it works is just like two one-to-many relationships combined. A row in the table heroteamlink points to one particular hero, but a single hero can be connected to many hero-team links, so it's one-to-many. And also, the same row in the table heroteamlink points to one team, but a single team can be connected to many hero-team links, so it's also one-to-many. Tip The previous many-to-many relationship was also just two one-to-many relationships combined, but now it's going to be much more explicit. Update Link ModelÂ¶ Let's update the HeroTeamLink model. We will add a new field is_training. And we will also add two relationship attributes, for the linked team and hero: # Code above omitted ðŸ‘† class HeroTeamLink(SQLModel, table=True): team_id: Optional[int] = Field( default=None, foreign_key=\"team.id\", primary_key=True ) hero_id: Optional[int] = Field( default=None, foreign_key=\"hero.id\", primary_key=True ) is_training: bool = False team: \"Team\" = Relationship(back_populates=\"hero_links\") hero: \"Hero\" = Relationship(back_populates=\"team_links\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The new relationship attributes have their own back_populates pointing to new relationship attributes we will create in the Hero and Team models: team: has back_populates=\"hero_links\", because in the Team model, the attribute will contain the links to the team's heroes. hero: has back_populates=\"team_links\", because in the Hero model, the attribute will contain the links to the hero's teams. Info In SQLAlchemy this is called an Association Object or Association Model. I'm calling it Link Model just because that's easier to write avoiding typos. But you are also free to call it however you want. ðŸ˜‰ Update Team ModelÂ¶ Now let's update the Team model. We no longer have the heroes relationship attribute, and instead we have the new hero_links attribute: # Code above omitted ðŸ‘† class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str hero_links: List[HeroTeamLink] = Relationship(back_populates=\"team\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Update Hero ModelÂ¶ The same with the Hero model. We change the teams relationship attribute for team_links: # Code above omitted ðŸ‘† class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_links: List[HeroTeamLink] = Relationship(back_populates=\"hero\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Create RelationshipsÂ¶ Now the process to create relationships is very similar. But now we create the explicit link models manually, pointing to their hero and team instances, and specifying the additional link data (is_training): # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, ) hero_spider_boy = Hero( name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\", ) deadpond_team_z_link = HeroTeamLink(team=team_z_force, hero=hero_deadpond) deadpond_preventers_link = HeroTeamLink( team=team_preventers, hero=hero_deadpond, is_training=True ) spider_boy_preventers_link = HeroTeamLink( team=team_preventers, hero=hero_spider_boy, is_training=True ) rusty_man_preventers_link = HeroTeamLink( team=team_preventers, hero=hero_rusty_man ) session.add(deadpond_team_z_link) session.add(deadpond_preventers_link) session.add(spider_boy_preventers_link) session.add(rusty_man_preventers_link) session.commit() for link in team_z_force.hero_links: print(\"Z-Force hero:\", link.hero, \"is training:\", link.is_training) for link in team_preventers.hero_links: print(\"Preventers hero:\", link.hero, \"is training:\", link.is_training) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We are just adding the link model instances to the session, because the link model instances are connected to the heroes and teams, they will be also automatically included in the session when we commit. Run the ProgramÂ¶ Now, if we run the program, it will show almost the same output as before, because it is generating almost the same SQL, but this time including the new is_training column: Add RelationshipsÂ¶ Now, to add a new relationship, we have to create a new HeroTeamLink instance pointing to the hero and the team, add it to the session, and commit it. Here we do that in the update_heroes() function: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: hero_spider_boy = session.exec( select(Hero).where(Hero.name == \"Spider-Boy\") ).one() team_z_force = session.exec(select(Team).where(Team.name == \"Z-Force\")).one() spider_boy_z_force_link = HeroTeamLink( team=team_z_force, hero=hero_spider_boy, is_training=True ) team_z_force.hero_links.append(spider_boy_z_force_link) session.add(team_z_force) session.commit() print(\"Updated Spider-Boy's Teams:\", hero_spider_boy.team_links) print(\"Z-Force heroes:\", team_z_force.hero_links) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Run the Program with the New RelationshipÂ¶ If we run that program, we will see the output: Update Relationships with LinksÂ¶ Now let's say that Spider-Boy has been training enough in the Preventers, and they say he can join the team full time. So now we want to update the status of is_training to False. We can do that by iterating on the links: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: # Code here omitted ðŸ‘ˆ for link in hero_spider_boy.team_links: if link.team.name == \"Preventers\": link.is_training = False session.add(hero_spider_boy) session.commit() for link in hero_spider_boy.team_links: print(\"Spider-Boy team:\", link.team, \"is training:\", link.is_training) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Run the Program with the Updated RelationshipsÂ¶ And if we run the program now, it will output: RecapÂ¶ If you need to store more information about a many-to-many relationship you can use an explicit link model with extra data in it. ðŸ¤“ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Code Structure and Multiple Files - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/code-structure/",
    "html": "Skip to content SQLModel Code Structure and Multiple Files Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Circular Imports Single Module for Models Models File Database File Application File Order Matters Run It in the Command Line Make Circular Imports Work Circular Imports and Type Annotations Type Annotations and Runtime Import Only While Editing with TYPE_CHECKING Hero Model File Team Model File App File Recap SQLModel Tutorial - User Guide Code Structure and Multiple FilesÂ¶ Let's stop for a second to think about how to structure the code, particularly in large projects with multiple files. Circular ImportsÂ¶ The class Hero has a reference to the class Team internally. But the class Team also has a reference to the class Hero. So, if those two classes were in separate files and you tried to import the classes in each other's file directly, it would result in a circular import. ðŸ”„ And Python will not be able to handle it and will throw an error. ðŸš¨ But we actually want to mean that circular reference, because in our code, we would be able to do crazy things like: hero.team.heroes[0].team.heroes[1].team.heroes[2].name And that circular reference is what we are expressing with these relationship attributes, that: A hero can have a team That team can have a list of heroes Each of those heroes can have a team ...and so on. Let's see different strategies to structure the code accounting for this. Single Module for ModelsÂ¶ This is the simplest way. âœ¨ In this solution we are still using multiple files, for the models, for the database, and for the app. And we could have any other files necessary. But in this first case, all the models would live in a single file. The file structure of the project could be: . â”œâ”€â”€ project â”œâ”€â”€ __init__.py â”œâ”€â”€ app.py â”œâ”€â”€ database.py â””â”€â”€ models.py We have 3 Python modules (or files): app database models And we also have an empty __init__.py file to make this project a \"Python package\" (a collection of Python modules). This way we can use relative imports in the app.py file/module, like: from .models import Hero, Team from .database import engine We can use these relative imports because, for example, in the file app.py (the app module) Python knows that it is part of our Python package because it is in the same directory as the file __init__.py. And all the Python files on the same directory are part of the same Python package too. Models FileÂ¶ You could put all the database Models in a single Python module (a single Python file), for example models.py: from typing import List, Optional from sqlmodel import Field, Relationship, SQLModel class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") This way, you wouldn't have to deal with circular imports for other models. And then you could import the models from this file/module in any other file/module in your application. Database FileÂ¶ Then you could put the code creating the engine and the function to create all the tables (if you are not using migrations) in another file database.py: from sqlmodel import SQLModel, create_engine sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url) def create_db_and_tables(): SQLModel.metadata.create_all(engine) This file would also be imported by your application code, to use the shared engine and to get and call the function create_db_and_tables(). Application FileÂ¶ Finally, you could put the code to create the app in another file app.py: from sqlmodel import Session from .database import create_db_and_tables, engine from .models import Hero, Team def create_heroes(): with Session(engine) as session: team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team=team_z_force ) session.add(hero_deadpond) session.commit() session.refresh(hero_deadpond) print(\"Created hero:\", hero_deadpond) print(\"Hero's team:\", hero_deadpond.team) def main(): create_db_and_tables() create_heroes() if __name__ == \"__main__\": main() Here we import the models, the engine, and the function to create all the tables and then we can use them all internally. Order MattersÂ¶ Remember that Order Matters when calling SQLModel.metadata.create_all()? The point of that section in the docs is that you have to import the module that has the models before calling SQLModel.metadata.create_all(). We are doing that here, we import the models in app.py and after that we create the database and tables, so we are fine and everything works correctly. ðŸ‘Œ Run It in the Command LineÂ¶ Because now this is a larger project with a Python package and not a single Python file, we cannot call it just passing a single file name as we did before with: $ python app.py Now we have to tell Python that we want it to execute a module that is part of a package: $ python -m project.app The -m is to tell Python to call a module. And the next thing we pass is a string with project.app, that is the same format we would use in an import: import project.app Then Python will execute that module inside of that package, and because Python is executing it directly, the same trick with the main block that we have in app.py will still work: if __name__ == '__main__': main() So, the output would be: Make Circular Imports WorkÂ¶ Let's say that for some reason you hate the idea of having all the database models together in a single file, and you really want to have separate files a hero_model.py file and a team_model.py file. You can also do it. ðŸ˜Ž There's a couple of things to keep in mind. ðŸ¤“ Warning This is a bit more advanced. If the solution above already worked for you, that might be enough for you, and you can continue in the next chapter. ðŸ¤“ Let's assume that now the file structure is: . â”œâ”€â”€ project â”œâ”€â”€ __init__.py â”œâ”€â”€ app.py â”œâ”€â”€ database.py â”œâ”€â”€ hero_model.py â””â”€â”€ team_model.py Circular Imports and Type AnnotationsÂ¶ The problem with circular imports is that Python can't resolve them at runtime. But when using Python type annotations it's very common to need to declare the type of some variables with classes imported from other files. And the files with those classes might also need to import more things from the first files. And this ends up requiring the same circular imports that are not supported in Python at runtime. Type Annotations and RuntimeÂ¶ But these type annotations we want to declare are not needed at runtime. In fact, remember that we used List[\"Hero\"], with a \"Hero\" in a string? For Python, at runtime, that is just a string. So, if we could add the type annotations we need using the string versions, Python wouldn't have a problem. But if we just put strings in the type annotations, without importing anything, the editor wouldn't know what we mean, and wouldn't be able to help us with autocompletion and inline errors. So, if there was a way to \"import\" some things that act as \"imported\" only while editing the code but not at runtime, that would solve it... And it exists! Exactly that. ðŸŽ‰ Import Only While Editing with TYPE_CHECKINGÂ¶ To solve it, there's a special trick with a special variable TYPE_CHECKING in the typing module. It has a value of True for editors and tools that analyze the code with the type annotations. But when Python is executing, its value is False. So, we can use it in an if block and import things inside the if block. And they will be \"imported\" only for editors, but not at runtime. Hero Model FileÂ¶ Using that trick of TYPE_CHECKING we can \"import\" the Team in hero_model.py: from typing import TYPE_CHECKING, Optional from sqlmodel import Field, Relationship, SQLModel if TYPE_CHECKING: from .team_model import Team class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[\"Team\"] = Relationship(back_populates=\"heroes\") Have in mind that now we have to put the annotation of Team as a string: \"Team\", so that Python doesn't have errors at runtime. Team Model FileÂ¶ We use the same trick in the team_model.py file: from typing import TYPE_CHECKING, List, Optional from sqlmodel import Field, Relationship, SQLModel if TYPE_CHECKING: from .hero_model import Hero class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") Now we get editor support, autocompletion, inline errors, and SQLModel keeps working. ðŸŽ‰ App FileÂ¶ Now, just for completeness, the app.py file would import the models from both modules: from sqlmodel import Session from .database import create_db_and_tables, engine from .hero_model import Hero from .team_model import Team def create_heroes(): with Session(engine) as session: team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team=team_z_force ) session.add(hero_deadpond) session.commit() session.refresh(hero_deadpond) print(\"Created hero:\", hero_deadpond) print(\"Hero's team:\", hero_deadpond.team) def main(): create_db_and_tables() create_heroes() if __name__ == \"__main__\": main() And of course, all the tricks with TYPE_CHECKING and type annotations in strings are only needed in the files with circular imports. As there are no circular imports with app.py, we can just use normal imports and use the classes as normally here. And running that achieves the same result as before: RecapÂ¶ For the simplest cases (for most of the cases) you can just keep all the models in a single file, and structure the rest of the application (including setting up the engine) in as many files as you want. And for the complex cases that really need separating all the models in different files, you can use the TYPE_CHECKING to make it all work and still have the best developer experience with the best editor support. âœ¨ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create Data with Many-to-Many Relationships - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/many-to-many/create-data/",
    "html": "Skip to content SQLModel Create Data with Many-to-Many Relationships Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Create Models with a Many-to-Many Link Create Data with Many-to-Many Relationships Update and Remove Many-to-Many Relationships Link Model with Extra Fields Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create Heroes Commit, Refresh, and Print Add to Main Run the Program Recap SQLModel Tutorial - User Guide Many to Many Create Data with Many-to-Many RelationshipsÂ¶ Let's continue from where we left and create some data. We'll create data for this same many-to-many relationship with a link table: We'll continue from where we left off with the previous code. ðŸ‘€ Full file preview Create HeroesÂ¶ As we have done before, we'll create a function create_heroes() and we'll create some teams and heroes in it: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", teams=[team_z_force, team_preventers], ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, teams=[team_preventers], ) hero_spider_boy = Hero( name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\", teams=[team_preventers] ) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is very similar to what we have done before. We create a couple of teams, and then three heroes. The only new detail is that instead of using an argument team we now use teams, because that is the name of the new relationship attribute. And more importantly, we pass a list of teams (even if it contains a single team). See how Deadpond now belongs to the two teams? Commit, Refresh, and PrintÂ¶ Now let's do as we have done before, commit the session, refresh the data, and print it: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", teams=[team_z_force, team_preventers], ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, teams=[team_preventers], ) hero_spider_boy = Hero( name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\", teams=[team_preventers] ) session.add(hero_deadpond) session.add(hero_rusty_man) session.add(hero_spider_boy) session.commit() session.refresh(hero_deadpond) session.refresh(hero_rusty_man) session.refresh(hero_spider_boy) print(\"Deadpond:\", hero_deadpond) print(\"Deadpond teams:\", hero_deadpond.teams) print(\"Rusty-Man:\", hero_rusty_man) print(\"Rusty-Man Teams:\", hero_rusty_man.teams) print(\"Spider-Boy:\", hero_spider_boy) print(\"Spider-Boy Teams:\", hero_spider_boy.teams) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Add to MainÂ¶ As before, add the create_heroes() function to the main() function to make sure it is called when running this program from the command line: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Run the ProgramÂ¶ If we run the program from the command line, it would output: RecapÂ¶ After setting up the model link, using it with relationship attributes is fairly straightforward, just Python objects. âœ¨ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Update and Remove Many-to-Many Relationships - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/many-to-many/update-remove-relationships/",
    "html": "Skip to content SQLModel Update and Remove Many-to-Many Relationships Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Create Models with a Many-to-Many Link Create Data with Many-to-Many Relationships Update and Remove Many-to-Many Relationships Link Model with Extra Fields Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Get Data to Update Add Many-to-Many Relationships Run the Program Remove Many-to-Many Relationships Run the Program Again Recap SQLModel Tutorial - User Guide Many to Many Update and Remove Many-to-Many RelationshipsÂ¶ Now we'll see how to update and remove these many-to-many relationships. We'll continue from where we left off with the previous code. ðŸ‘€ Full file preview Get Data to UpdateÂ¶ Let's now create a function update_heroes(). We'll get Spider-Boy and the Z-Force team. As you already know how these goes, I'll use the short version and get the data in a single Python statement. And because we are now using select(), we also have to import it. from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine, select # Some code here omitted ðŸ‘ˆ def update_heroes(): with Session(engine) as session: hero_spider_boy = session.exec( select(Hero).where(Hero.name == \"Spider-Boy\") ).one() team_z_force = session.exec(select(Team).where(Team.name == \"Z-Force\")).one() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And of course, we have to add update_heroes() to our main() function: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() update_heroes() if __name__ == \"__main__\": main() ðŸ‘€ Full file preview Add Many-to-Many RelationshipsÂ¶ Now let's imagine that Spider-Boy thinks that the Z-Force team is super cool and decides to go there and join them. We can use the same relationship attributes to include hero_spider_boy in the team_z_force.heroes. # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: hero_spider_boy = session.exec( select(Hero).where(Hero.name == \"Spider-Boy\") ).one() team_z_force = session.exec(select(Team).where(Team.name == \"Z-Force\")).one() team_z_force.heroes.append(hero_spider_boy) session.add(team_z_force) session.commit() print(\"Updated Spider-Boy's Teams:\", hero_spider_boy.teams) print(\"Z-Force heroes:\", team_z_force.heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip Because we are accessing an attribute in the models right after we commit, with hero_spider_boy.teams and team_z_force.heroes, the data is refreshed automatically. So we don't have to call session.refresh(). We then commit the change, refresh, and print the updated Spider-Boy's heroes to confirm. Notice that we only add Z-Force to the session, then we commit. We never add Spider-Boy to the session, and we never even refresh it. But we still print his teams. This still works correctly because we are using back_populates in the Relationship() in the models. That way, SQLModel (actually SQLAlchemy) can keep track of the changes and updates, and make sure they also happen on the relationships in the other related models. ðŸŽ‰ Run the ProgramÂ¶ You can confirm it's all working by running the program in the command line: Remove Many-to-Many RelationshipsÂ¶ Now let's say that right after joining the team, Spider-Boy realized that their \"life preserving policies\" are much more relaxed than what he's used to. ðŸ’€ And their occupational safety and health is also not as great... ðŸ’¥ So, Spider-Boy decides to leave Z-Force. Let's update the relationships to remove team_z_force from hero_spider_boy.teams. Because hero_spider_boy.teams is just a list (a special list managed by SQLAlchemy, but a list), we can use the standard list methods. In this case, we use the method .remove(), that takes an item and removes it from the list. # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: hero_spider_boy = session.exec( select(Hero).where(Hero.name == \"Spider-Boy\") ).one() team_z_force = session.exec(select(Team).where(Team.name == \"Z-Force\")).one() team_z_force.heroes.append(hero_spider_boy) session.add(team_z_force) session.commit() print(\"Updated Spider-Boy's Teams:\", hero_spider_boy.teams) print(\"Z-Force heroes:\", team_z_force.heroes) hero_spider_boy.teams.remove(team_z_force) session.add(team_z_force) session.commit() print(\"Reverted Z-Force's heroes:\", team_z_force.heroes) print(\"Reverted Spider-Boy's teams:\", hero_spider_boy.teams) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And this time, just to show again that by using back_populates SQLModel (actually SQLAlchemy) takes care of connecting the models by their relationships, even though we performed the operation from the hero_spider_boy object (modifying hero_spider_boy.teams), we are adding team_z_force to the session. And we commit that, without even add hero_spider_boy. This still works because by updating the teams in hero_spider_boy, because they are synchronized with back_populates, the changes are also reflected in team_z_force, so it also has changes to be saved in the DB (that Spider-Boy was removed). And then we add the team, and commit the changes, which updates the team_z_force object, and because it changed the table that also had a connection with the hero_spider_boy, it is also marked internally as updated, so it all works. And then we just print them again to confirm that everything worked correctly. Run the Program AgainÂ¶ To confirm that this last part worked, you can run the program again, it will output something like: RecapÂ¶ Updating and removing many-to-many relationships is quite straightforward after setting up the link model and the relationship attributes. You can just use common list operation. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create Models with a Many-to-Many Link - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/many-to-many/create-models-with-link/",
    "html": "Skip to content SQLModel Create Models with a Many-to-Many Link Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Create Models with a Many-to-Many Link Create Data with Many-to-Many Relationships Update and Remove Many-to-Many Relationships Link Model with Extra Fields Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Link Table Model Team Model Hero Model Create the Tables Run the Code Recap SQLModel Tutorial - User Guide Many to Many Create Models with a Many-to-Many LinkÂ¶ We'll now support many-to-many relationships using a link table like this: Let's start by defining the class models, including the link table model. Link Table ModelÂ¶ As we want to support a many-to-many relationship, now we need a link table to connect them. We can create it just as any other SQLModel: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine class HeroTeamLink(SQLModel, table=True): team_id: Optional[int] = Field( default=None, foreign_key=\"team.id\", primary_key=True ) hero_id: Optional[int] = Field( default=None, foreign_key=\"hero.id\", primary_key=True ) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is a SQLModel class model table like any other. It has two fields, team_id and hero_id. They are both foreign keys to their respective tables. We'll create those models in a second, but you already know how that works. And both fields are primary keys. We hadn't used this before. ðŸ¤“ Team ModelÂ¶ Let's see the Team model, it's almost identical as before, but with a little change: # Code above omitted ðŸ‘† class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"teams\", link_model=HeroTeamLink) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The relationship attribute heroes is still a list of heroes, annotated as List[\"Hero\"]. Again, we use \"Hero\" in quotes because we haven't declared that class yet by this point in the code (but as you know, editors and SQLModel understand that). We use the same Relationship() function. We use back_populates=\"teams\". Before we referenced an attribute team, but as now we can have many, we'll rename it to teams when creating the Hero model. And here's the important part to allow the many-to-many relationship, we use link_model=HeroTeamLink. That's it. âœ¨ Hero ModelÂ¶ Let's see the other side, here's the Hero model: # Code above omitted ðŸ‘† class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) teams: List[Team] = Relationship(back_populates=\"heroes\", link_model=HeroTeamLink) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We removed the previous team_id field (column) because now the relationship is done via the link table. ðŸ”¥ The relationship attribute is now named teams instead of team, as now we support multiple teams. It is no longer an Optional[Team] but a list of teams, annotated as List[Team]. We are using the Relationship() here too. We still have back_populates=\"heroes\" as before. And now we have a link_model=HeroTeamLink. âœ¨ Create the TablesÂ¶ The same as before, we will have the rest of the code to create the engine, and a function to create all the tables create_db_and_tables(). # Code above omitted ðŸ‘† sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And as in previous examples, we will add that function to a function main(), and we will call that main() function in the main block: # Code above omitted ðŸ‘† def main(): create_db_and_tables() # We will do more stuff here later ðŸ‘ˆ if __name__ == \"__main__\": main() ðŸ‘€ Full file preview Run the CodeÂ¶ If you run the code in the command line, it would output: RecapÂ¶ We can support many-to-many relationships between tables by declaring a link table. We can create it the same way as with other SQLModel classes, and then use it in the link_model parameter to Relationship(). Now let's work with data using these models in the next chapters. ðŸ¤“ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Many to Many - Intro - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/many-to-many/",
    "html": "Skip to content SQLModel Many to Many - Intro Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Create Models with a Many-to-Many Link Create Data with Many-to-Many Relationships Update and Remove Many-to-Many Relationships Link Model with Extra Fields Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Starting from One-to-Many Introduce Many-to-Many Link Table Link Primary Key Recap SQLModel Tutorial - User Guide Many to Many Many to Many - IntroÂ¶ We saw how to work with One-to-Many relationships in the data. But how do you handle Many-to-Many relationships? Let's explore them. ðŸš€ Starting from One-to-ManyÂ¶ Let's start with the familiar and simpler option of One-to-Many. We have one table with teams and one with heroes, and for each one team, we can have many heroes. As each team could have multiple heroes, we wouldn't be able to put the Hero IDs in columns for all of them in the team table. But as each hero can belong only to one team, we have a single column in the heroes table to point to the specific team (to a specific row in the team table). The team table looks like this: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar Tip Notice that it doesn't have any foreign key to other tables. And the hero table looks like this: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Spider-Boy Pedro Parqueador null 1 3 Rusty-Man Tommy Sharp 48 1 We have a column in the hero table for the team_id that points to the ID of a specific team in the team table. This is how we connect each hero with a team: Notice that each hero can only have one connection. But each team can receive many connections. In particular, the team Preventers has two heroes. Introduce Many-to-ManyÂ¶ But let's say that as Deadpond is a great character, they recruit him to the new Preventers team, but he's still part of the Z-Force team too. So, now, we need to be able to have a hero that is connected to many teams. And then, each team, should still be able to receive many heroes. So we need a Many-to-Many relationship. A naive approach that wouldn't work very well is to add more columns to the hero table. Imagine we add two extra columns. Now we could connect a single hero to 3 teams in total, but not more. So we haven't really solved the problem of supporting many teams, only a very limited fixed number of teams. We can do better! ðŸ¤“ Link TableÂ¶ We can create another table that would represent the link between the hero and team tables. All this table contains is two columns, hero_id and team_id. Both columns are foreign keys pointing to the ID of a specific row in the hero and team tables. As this will represent the hero-team-link, let's call the table heroteamlink. It would look like this: Notice that now the table hero doesn't have a team_id column anymore, it is replaced by this link table. And the team table, just as before, doesn't have any foreign key either. Specifically, the new link table heroteamlink would be: hero_id team_id 1 1 1 2 2 1 3 1 Info Other names used for this link table are: association table secondary table junction table intermediate table join table through table relationship table connection table I'm using the term \"link table\" because it's short, doesn't collide with other terms already used (e.g. \"relationship\"), it's easy to remember how to write it, etc. Link Primary KeyÂ¶ Cool, we have a link table with just two columns. But remember that SQL databases require each row to have a primary key that uniquely identifies the row in that table? Now, what is the primary key in this table? How to we identify each unique row? Should we add another column just to be the primary key of this link table? Nope! We don't have to do that. ðŸ‘Œ Both columns are the primary key of each row in this table (and each row just has those two columns). âœ¨ A primary key is a way to uniquely identify a particular row in a single table. But it doesn't have to be a single column. A primary key can be a group of the columns in a table, which combined are unique in this table. Check the table above again, see that each row has a unique combination of hero_id and team_id? We cannot have duplicated primary keys, which means that we cannot have duplicated links between hero and team, exactly what we want! For example, the database will now prevent an error like this, with a duplicated row: hero_id team_id 1 1 1 2 2 1 3 1 3 ðŸš¨ 1 ðŸš¨ It wouldn't make sense to have a hero be part of the same team twice, right? Now, just by using the two columns as the primary keys of this table, SQL will take care of preventing us from duplicating a link between hero and team. âœ… RecapÂ¶ An intro with a recap! That's weird... but anyway. ðŸ¤· Now you have the theory about the many-to-many relationships, and how to solve them with tables in SQL. ðŸ¤“ Now let's check how to write the SQL and the code to work with them. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Relationship back_populates - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/back-populates/",
    "html": "Skip to content SQLModel Relationship back_populates Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Relationship with back_populates An Incomplete Relationship Read Data Objects Print the Data Update Objects Before Committing Commit and Print Fix It Using back_populates Review the Result The Value of back_populates A Mental Trick to Remember back_populates SQLModel Tutorial - User Guide Relationship Attributes Relationship back_populatesÂ¶ Now you know how to use the relationship attributes to manipulate connected data in the database! ðŸŽ‰ Let's now take a small step back and review how we defined those Relationship() attributes again, let's clarify that back_populates argument. ðŸ¤“ Relationship with back_populatesÂ¶ So, what is that back_populates argument in each Relationship()? The value is a string with the name of the attribute in the other model class. That tells SQLModel that if something changes in this model, it should change that attribute in the other model, and it will work even before committing with the session (that would force a refresh of the data). Let's understand that better with an example. An Incomplete RelationshipÂ¶ Let's see how that works by writing an incomplete version first, without back_populates: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine, select class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship() class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Read Data ObjectsÂ¶ Now, we will get the Spider-Boy hero and, independently, the Preventers team using two selects. As you already know how this works, I won't separate that in a select statement, results, etc. Let's use the shorter form in a single call: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: hero_spider_boy = session.exec( select(Hero).where(Hero.name == \"Spider-Boy\") ).one() preventers_team = session.exec( select(Team).where(Team.name == \"Preventers\") ).one() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip When writing your own code, this is probably the style you will use most often, as it's shorter, more convenient, and you still get all the power of autocompletion and inline errors. Print the DataÂ¶ Now, let's print the current Spider-Boy, the current Preventers team, and particularly, the current Preventers list of heroes: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: hero_spider_boy = session.exec( select(Hero).where(Hero.name == \"Spider-Boy\") ).one() preventers_team = session.exec( select(Team).where(Team.name == \"Preventers\") ).one() print(\"Hero Spider-Boy:\", hero_spider_boy) print(\"Preventers Team:\", preventers_team) print(\"Preventers Team Heroes:\", preventers_team.heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Up to this point, it's all good. ðŸ˜Š In particular, the result of printing preventers_team.heroes is: Preventers Team Heroes: [ Hero(name='Rusty-Man', age=48, id=2, secret_name='Tommy Sharp', team_id=2), Hero(name='Spider-Boy', age=None, id=3, secret_name='Pedro Parqueador', team_id=2), Hero(name='Tarantula', age=32, id=6, secret_name='Natalia Roman-on', team_id=2), Hero(name='Dr. Weird', age=36, id=7, secret_name='Steve Weird', team_id=2), Hero(name='Captain North America', age=93, id=8, secret_name='Esteban Rogelios', team_id=2) ] Notice that we have Spider-Boy there. Update Objects Before CommittingÂ¶ Now let's update Spider-Boy, removing him from the team by setting hero_spider_boy.team = None and then let's print this object again: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: # Code here omitted ðŸ‘ˆ hero_spider_boy.team = None print(\"Spider-Boy without team:\", hero_spider_boy) print(\"Preventers Team Heroes again:\", preventers_team.heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The first important thing is, we haven't committed the hero yet, so accessing the list of heroes would not trigger an automatic refresh. But in our code, in this exact point in time, we already said that Spider-Boy is no longer part of the Preventers. ðŸ”¥ Tip We could revert that later by not committing the session, but that's not what we are interested in here. Here, at this point in the code, in memory, the code expects Preventers to not include Spider-Boy. The output of printing hero_spider_boy without team is: Spider-Boy without team: name='Spider-Boy' age=None id=3 secret_name='Pedro Parqueador' team_id=2 team=None Cool, the team is set to None, the team_id attribute still has the team ID until we save it. But that's okay as we are now working mainly with the relationship attributes and the objects. âœ… But now, what happens when we print the preventers_team.heroes? Preventers Team Heroes again: [ Hero(name='Rusty-Man', age=48, id=2, secret_name='Tommy Sharp', team_id=2), Hero(name='Spider-Boy', age=None, id=3, secret_name='Pedro Parqueador', team_id=2, team=None), Hero(name='Tarantula', age=32, id=6, secret_name='Natalia Roman-on', team_id=2), Hero(name='Dr. Weird', age=36, id=7, secret_name='Steve Weird', team_id=2), Hero(name='Captain North America', age=93, id=8, secret_name='Esteban Rogelios', team_id=2) ] Oh, no! ðŸ˜± Spider-Boy is still listed there! Commit and PrintÂ¶ Now, if we commit it and print again: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: # Code here omitted ðŸ‘ˆ session.add(hero_spider_boy) session.commit() print(\"After committing\") session.refresh(hero_spider_boy) print(\"Spider-Boy after commit:\", hero_spider_boy) print(\"Preventers Team Heroes after commit:\", preventers_team.heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview When we access preventers_team.heroes after the commit, that triggers a refresh, so we get the latest list, without Spider-Boy, so that's fine again: INFO Engine SELECT hero.id AS hero_id, hero.name AS hero_name, hero.secret_name AS hero_secret_name, hero.age AS hero_age, hero.team_id AS hero_team_id FROM hero WHERE ? = hero.team_id 2021-08-13 11:15:24,658 INFO sqlalchemy.engine.Engine [cached since 0.1924s ago] (2,) Preventers Team Heroes after commit: [ Hero(name='Rusty-Man', age=48, id=2, secret_name='Tommy Sharp', team_id=2), Hero(name='Tarantula', age=32, id=6, secret_name='Natalia Roman-on', team_id=2), Hero(name='Dr. Weird', age=36, id=7, secret_name='Steve Weird', team_id=2), Hero(name='Captain North America', age=93, id=8, secret_name='Esteban Rogelios', team_id=2) ] There's no Spider-Boy after committing, so that's good. ðŸ˜Š But we still have that inconsistency in that previous point above. If we use the objects before committing, we could end up having errors. ðŸ˜” Let's fix that. ðŸ¤“ Fix It Using back_populatesÂ¶ That's what back_populates is for. âœ¨ Let's add it back: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine, select class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And we can keep the rest of the code the same: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: # Code here omitted ðŸ‘ˆ hero_spider_boy.team = None print(\"Spider-Boy without team:\", hero_spider_boy) print(\"Preventers Team Heroes again:\", preventers_team.heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip This is the same section where we updated hero_spider_boy.team to None but we haven't committed that change yet. The same section that caused a problem before. Review the ResultÂ¶ This time, SQLModel (actually SQLAlchemy) will be able to notice the change, and automatically update the list of heroes in the team, even before we commit. That second print would output: Preventers Team Heroes again: [ Hero(name='Rusty-Man', age=48, id=2, secret_name='Tommy Sharp', team_id=2), Hero(name='Tarantula', age=32, id=6, secret_name='Natalia Roman-on', team_id=2), Hero(name='Dr. Weird', age=36, id=7, secret_name='Steve Weird', team_id=2), Hero(name='Captain North America', age=93, id=8, secret_name='Esteban Rogelios', team_id=2) ] Notice that now Spider-Boy is not there, we fixed it with back_populates! ðŸŽ‰ The Value of back_populatesÂ¶ Now that you know why back_populates is there, let's review the exact value again. It's quite simple code, it's just a string, but it might be confusing to think exactly what string should go there: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine, select class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The string in back_populates is the name of the attribute in the other model, that will reference the current model. So, in the class Team, we have an attribute heroes and we declare it with Relationship(back_populates=\"team\"). # Code above omitted ðŸ‘† class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The string in back_populates=\"team\" refers to the attribute team in the class Hero (the other class). And, in the class Hero, we declare an attribute team, and we declare it with Relationship(back_populates=\"heroes\"). So, the string \"heroes\" refers to the attribute heroes in the class Team. # Code above omitted ðŸ‘† class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip Each relationship attribute points to the other one, in the other model, using back_populates. Although it's simple code, it can be confusing to think about ðŸ˜µ, because the same line has concepts related to both models in multiple places: Just by being in the current model, the line has something to do with the current model. The name of the attribute is about the other model. The type annotation is about the other model. And the back_populates refers to an attribute in the other model, that points to the current model. A Mental Trick to Remember back_populatesÂ¶ A mental trick you can use to remember is that the string in back_populates is always about the current model class you are editing. ðŸ¤“ So, if you are in the class Hero, the value of back_populates for any relationship attribute connecting to any other table (to any other model, it could be Team, Weapon, Powers, etc) will still always refer to this same class. So, back_populates would most probably be something like \"hero\" or \"heroes\". # Code above omitted ðŸ‘† class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") weapon_id: Optional[int] = Field(default=None, foreign_key=\"weapon.id\") weapon: Optional[Weapon] = Relationship(back_populates=\"hero\") powers: List[Power] = Relationship(back_populates=\"hero\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Made with Material for MkDocs Insiders"
  },
  {
    "title": "Type annotation strings - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/type-annotation-strings/",
    "html": "Skip to content SQLModel Type annotation strings Initializing search tiangolo/sqlmodel SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents About the String in List[\"Hero\"] SQLModel Tutorial - User Guide Relationship Attributes Type annotation strings About the String in List[\"Hero\"]Â¶ In the first Relationship attribute, we declare it with List[\"Hero\"], putting the Hero in quotes instead of just normally there: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview What's that about? Can't we just write it normally as List[Hero]? By that point, in that line in the code, the Python interpreter doesn't know of any class Hero, and if we put it just there, it would try to find it unsuccessfully, and then fail. ðŸ˜­ But by putting it in quotes, in a string, the interpreter sees it as just a string with the text \"Hero\" inside. But the editor and other tools can see that the string is actually a type annotation inside, and provide all the autocompletion, type checks, etc. ðŸŽ‰ And of course, SQLModel can also understand it in the string correctly. âœ¨ That is actually part of Python, it's the current official solution to handle it. Info There's a lot of work going on in Python itself to make that simpler and more intuitive, and find ways to make it possible to not wrap the class in a string. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Remove Relationships - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/remove-relationships/",
    "html": "Skip to content SQLModel Remove Relationships Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Recap SQLModel Tutorial - User Guide Relationship Attributes Remove RelationshipsÂ¶ Now let's say that Spider-Boy tells Rusty-Man something like: I don't feel so good Mr. Sharp And then for some reason needs to leave the Preventers for some years. ðŸ˜­ We can remove the relationship by setting it to None, the same as with the team_id, it also works with the new relationship attribute .team: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") result = session.exec(statement) hero_spider_boy = result.one() hero_spider_boy.team = None session.add(hero_spider_boy) session.commit() session.refresh(hero_spider_boy) print(\"Spider-Boy without team:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And of course, we should remember to add this update_heroes() function to main() so that it runs when we call this program from the command line: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() select_heroes() update_heroes() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview RecapÂ¶ This chapter was too short for a recap, wasn't it? ðŸ¤” Anyway, relationship attributes make it easy and intuitive to work with relationships stored in the database. ðŸŽ‰ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read Relationships - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/read-relationships/",
    "html": "Skip to content SQLModel Read Relationships Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Select a Hero Select the Related Team - Old Way Get Relationship Team - New Way Get a List of Relationship Objects Recap SQLModel Tutorial - User Guide Relationship Attributes Read RelationshipsÂ¶ Now that we know how to connect data using relationship Attributes, let's see how to get and read the objects from a relationship. Select a HeroÂ¶ First, add a function select_heroes() where we get a hero to start working with, and add that function to the main() function: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") result = session.exec(statement) hero_spider_boy = result.one() # Previous code here omitted ðŸ‘ˆ def main(): create_db_and_tables() create_heroes() select_heroes() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Select the Related Team - Old WayÂ¶ Now that we have a hero, we can get the team this hero belongs to. With what we have learned up to now, we could use a select() statement, then execute it with session.exec(), and then get the .first() result, for example: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") result = session.exec(statement) hero_spider_boy = result.one() statement = select(Team).where(Team.id == hero_spider_boy.team_id) result = session.exec(statement) team = result.first() print(\"Spider-Boy's team:\", team) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Get Relationship Team - New WayÂ¶ But now that we have the relationship attributes, we can just access them, and SQLModel (actually SQLAlchemy) will go and fetch the corresponding data from the database, and make it available in the attribute. âœ¨ So, the highlighted block above, has the same results as the block below: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") result = session.exec(statement) hero_spider_boy = result.one() # Code from the previous example omitted ðŸ‘ˆ print(\"Spider-Boy's team again:\", hero_spider_boy.team) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip The automatic data fetching will work as long as the starting object (in this case the Hero) is associated with an open session. For example, here, inside a with block with a Session object. Get a List of Relationship ObjectsÂ¶ And the same way, when we are working on the many side of the one-to-many relationship, we can get a list of of the related objects just by accessing the relationship attribute: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Team).where(Team.name == \"Preventers\") result = session.exec(statement) team_preventers = result.one() print(\"Preventers heroes:\", team_preventers.heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That would print a list with all the heroes in the Preventers team: RecapÂ¶ With relationship attributes you can use the power of common Python objects to easily access related data from the database. ðŸ˜Ž Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create and Update Relationships - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/create-and-update-relationships/",
    "html": "Skip to content SQLModel Create and Update Relationships Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create Instances with Fields Create Instances with Relationship Attributes Assign a Relationship Create a Team with Heroes Include Relationship Objects in the Many Side Recap SQLModel Tutorial - User Guide Relationship Attributes Create and Update RelationshipsÂ¶ Let's see now how to create data with relationships using these new relationship attributes. âœ¨ Create Instances with FieldsÂ¶ Let's check the old code we used to create some heroes and teams: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") session.add(team_preventers) session.add(team_z_force) session.commit() hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team_id=team_z_force.id ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, team_id=team_preventers.id, ) hero_spider_boy = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") session.add(hero_deadpond) session.add(hero_rusty_man) session.add(hero_spider_boy) session.commit() session.refresh(hero_deadpond) session.refresh(hero_rusty_man) session.refresh(hero_spider_boy) print(\"Created hero:\", hero_deadpond) print(\"Created hero:\", hero_rusty_man) print(\"Created hero:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview There are several things to notice here. First, we create some Team instance objects. We want to use the IDs of these teams when creating the Hero instances, in the team_id field. But model instances don't have an ID generated by the database until we add and commit them to the session. Before that, they are just None, and we want to use the actual IDs. So, we have to add them and commit the session first, before we start creating the Hero instances, to be able to use their IDs. Then, we use those IDs when creating the Hero instances. We add the new heroes to the session, and then we commit them. So, we are committing twice. And we have to remember to add some things first, and then commit, and do all that in the right order, otherwise we could end up using a team.id that is currently None because it hasn't been saved. This is the first area where these relationship attributes can help. ðŸ¤“ Create Instances with Relationship AttributesÂ¶ Now let's do all that, but this time using the new, shiny Relationship attributes: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team=team_z_force ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, team=team_preventers ) hero_spider_boy = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") session.add(hero_deadpond) session.add(hero_rusty_man) session.add(hero_spider_boy) session.commit() session.refresh(hero_deadpond) session.refresh(hero_rusty_man) session.refresh(hero_spider_boy) print(\"Created hero:\", hero_deadpond) print(\"Created hero:\", hero_rusty_man) print(\"Created hero:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Now we can create the Team instances and pass them directly to the new team argument when creating the Hero instances, as team=team_preventers instead of team_id=team_preventers.id. And thanks to SQLAlchemy and how it works underneath, these teams don't even have to have an ID yet, but because we are assigning the whole object to each hero, those teams will be automatically created in the database, the automatic ID will be generated, and will be set in the team_id column for each of the corresponding hero rows. In fact, now we don't even have to put the teams explicitly in the session with session.add(team), because these Team instances are already associated with heroes that we do add to the session. SQLAlchemy knows that it also has to include those teams in the next commit to be able to save the heroes correctly. And then, as you can see, we only have to do one commit(). Assign a RelationshipÂ¶ The same way we could assign an integer with a team.id to a hero.team_id, we can also assign the Team instance to the hero.team: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: # Previous code here omitted ðŸ‘ˆ hero_spider_boy.team = team_preventers session.add(hero_spider_boy) session.commit() session.refresh(hero_spider_boy) print(\"Updated hero:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Create a Team with HeroesÂ¶ Before, we created some Team instances and passed them in the team= argument when creating Hero instances. We could also create the Hero instances first, and then pass them in the heroes= argument that takes a list, when creating a Team instance: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: # Previous code here omitted ðŸ‘ˆ hero_black_lion = Hero(name=\"Black Lion\", secret_name=\"Trevor Challa\", age=35) hero_sure_e = Hero(name=\"Princess Sure-E\", secret_name=\"Sure-E\") team_wakaland = Team( name=\"Wakaland\", headquarters=\"Wakaland Capital City\", heroes=[hero_black_lion, hero_sure_e], ) session.add(team_wakaland) session.commit() session.refresh(team_wakaland) print(\"Team Wakaland:\", team_wakaland) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Here we create two heroes first, Black Lion and Princess Sure-E, and then we pass them in the heroes argument. Notice that, the same as before, we only have to add the Team instance to the session, and because the heroes are connected to it, they will be automatically saved too when we commit. Include Relationship Objects in the Many SideÂ¶ We said before that this is a many-to-one relationship, because there can be many heroes that belong to one team. We can also connect data with these relationship attributes on the many side. As the attribute team.heroes behaves like a list, we can simply append to it. Let's create some more heroes and add them to the team_preventers.heroes list attribute: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: # Previous code here omitted ðŸ‘ˆ hero_tarantula = Hero(name=\"Tarantula\", secret_name=\"Natalia Roman-on\", age=32) hero_dr_weird = Hero(name=\"Dr. Weird\", secret_name=\"Steve Weird\", age=36) hero_cap = Hero( name=\"Captain North America\", secret_name=\"Esteban Rogelios\", age=93 ) team_preventers.heroes.append(hero_tarantula) team_preventers.heroes.append(hero_dr_weird) team_preventers.heroes.append(hero_cap) session.add(team_preventers) session.commit() session.refresh(hero_tarantula) session.refresh(hero_dr_weird) session.refresh(hero_cap) print(\"Preventers new hero:\", hero_tarantula) print(\"Preventers new hero:\", hero_dr_weird) print(\"Preventers new hero:\", hero_cap) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The attribute team_preventers.heroes behaves like a list. But it's a special type of list, because when we modify it adding heroes to it, SQLModel (actually SQLAlchemy) keeps track of the necessary changes to be done in the database. Then we add() the team to the session and commit() it. And in the same way as before, we don't even have to add() the independent heroes to the session, because they are connected to the team. RecapÂ¶ We can use common Python objects and attributes to create and update data connections with these relationship attributes. ðŸ˜Ž Next we'll see how to use these relationship attributes to read connected data. ðŸ¤ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Define Relationships Attributes - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/define-relationships-attributes/",
    "html": "Skip to content SQLModel Define Relationships Attributes Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Declare Relationship Attributes What Are These Relationship Attributes Optional Relationship Attributes Relationship Attributes With Lists Next Steps SQLModel Tutorial - User Guide Relationship Attributes Define Relationships AttributesÂ¶ Now we are finally in one of the most exciting parts of SQLModel. Relationship Attributes. âœ¨ We currently have a team table: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar And a hero table: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Rusty-Man Tommy Sharp 48 1 3 Spider-Boy Pedro Parqueador null 1 Now that you know how these tables work underneath and how the model classes represent them, it's time to add a little convenience that will make many operations in code simpler. Declare Relationship AttributesÂ¶ Up to now, we have only used the team_id column to connect the tables when querying with select(): from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is a plain field like all the others, all representing a column in the table. But now let's add a couple of new special attributes to these model classes, let's add Relationship attributes. First, import Relationship from sqlmodel: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Next, use that Relationship to declare a new attribute in the model classes: from typing import List, Optional from sqlmodel import Field, Relationship, Session, SQLModel, create_engine class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str heroes: List[\"Hero\"] = Relationship(back_populates=\"team\") class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") team: Optional[Team] = Relationship(back_populates=\"heroes\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview What Are These Relationship AttributesÂ¶ These new attributes are not the same as fields, they don't represent a column directly in the database, and their value is not a singular value like an integer. Their value is the actual entire object that is related. So, in the case of a Hero instance, if you call hero.team, you will get the entire Team instance object that this hero belongs to. âœ¨ For example, you could check if a hero belongs to any team (if .team is not None) and then print the team's name: if hero.team: print(hero.team.name) Optional Relationship AttributesÂ¶ Notice that in the Hero class, the type annotation for team is Optional[Team]. This means that this attribute could be None, or it could be a full Team object. This is because the related team_id could also be None (or NULL in the database). If it was required for a Hero instance to belong to a Team, then the team_id would be int instead of Optional[int], its Field would be Field(foreign_key=\"team.id\") instead of Field(default=None, foreign_key=\"team.id\") and the team attribute would be a Team instead of Optional[Team]. Relationship Attributes With ListsÂ¶ And in the Team class, the heroes attribute is annotated as a list of Hero objects, because that's what it will have. SQLModel (actually SQLAlchemy) is smart enough to know that the relationship is established by the team_id, as that's the foreign key that points from the hero table to the team table, so we don't have to specify that explicitly here. Tip There's a couple of things we'll check again in some of the next chapters, about the List[\"Hero\"] and the back_populates. But for now, let's first see how to use these relationship attributes. Next StepsÂ¶ Now let's see some real examples of how to use these new relationship attributes in the next chapters. âœ¨ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Relationship Attributes - Intro - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/relationship-attributes/",
    "html": "Skip to content SQLModel Relationship Attributes - Intro Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Define Relationships Attributes Create and Update Relationships Read Relationships Remove Relationships Relationship back_populates Type annotation strings Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes SQLModel Tutorial - User Guide Relationship Attributes Relationship Attributes - IntroÂ¶ In the previous chapters we discussed how to manage databases with tables that have relationships by using fields (columns) with foreign keys pointing to other columns. And then we read the data together with select() and using .where() or .join() to connect it. Now we will see how to use Relationship Attributes, an extra feature of SQLModel (and SQLAlchemy) to work with the data in the database in way much more familiar way, and closer to normal Python code. Info When I say \"relationship\" I mean the standard dictionary term, of data related to other data. I'm not using the term \"relation\" that is the technical, academical, SQL term for a single table. And using those relationship attributes is where a tool like SQLModel really shines. âœ¨ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Remove Data Connections - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/connect/remove-data-connections/",
    "html": "Skip to content SQLModel Remove Data Connections Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Create Connected Tables Create and Connect Rows Read Connected Data Update Data Connections Remove Data Connections Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Break a Connection SQLModel Tutorial - User Guide Connect Tables - JOIN Remove Data ConnectionsÂ¶ We currently have a team table: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar And a hero table: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Rusty-Man Tommy Sharp 48 1 3 Spider-Boy Pedro Parqueador null 1 Let's see how to remove connections between rows in tables. We will continue with the code from the previous chapter. ðŸ‘€ Full file preview Break a ConnectionÂ¶ We don't really have to delete anything to break a connection. We can just assign None to the foreign key, in this case, to the team_id. Let's say Spider-Boy is tired of the lack of friendly neighbors and wants to get out of the Preventers. We can simply set the team_id to None, and now it doesn't have a connection with the team: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: # Previous code here omitted ðŸ‘ˆ hero_spider_boy.team_id = None session.add(hero_spider_boy) session.commit() session.refresh(hero_spider_boy) print(\"No longer Preventer:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Again, we just assign a value to that field attribute team_id, now the value is None, which means NULL in the database. Then we add() the hero to the session, and then commit(). Next we refresh() it to get the recent data, and we print it. Running that in the command line will output: That's it, we now removed a connection between rows in different tables by unsetting the foreign key column. ðŸ’¥ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Update Data Connections - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/connect/update-data-connections/",
    "html": "Skip to content SQLModel Update Data Connections Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Create Connected Tables Create and Connect Rows Read Connected Data Update Data Connections Remove Data Connections Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Assign a Team to a Hero SQLModel Tutorial - User Guide Connect Tables - JOIN Update Data ConnectionsÂ¶ At this point we have a team table: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar And a hero table: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Rusty-Man Tommy Sharp 48 1 3 Spider-Boy Pedro Parqueador null null Some of these heroes are part of a team. Now we'll see how to update those connections between rows tables. We will continue with the code we used to create some heroes, and we'll update them. ðŸ‘€ Full file preview Assign a Team to a HeroÂ¶ Let's say that Tommy Sharp uses his \"rich uncle\" charms to recruit Spider-Boy to join the team of the Preventers, now we need to update our Spider-Boy hero object to connect it to the Preventers team. Doing it is just like updating any other field: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: # Previous code here omitted ðŸ‘ˆ hero_spider_boy.team_id = team_preventers.id session.add(hero_spider_boy) session.commit() session.refresh(hero_spider_boy) print(\"Updated hero:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We can simply assign a value to that field attribute team_id, then add() the hero to the session, and then commit(). Next we refresh() it to get the recent data, and we print it. Running that in the command line will output: And now Spider-Boy has the team_id=1, which is the ID of the Preventers. ðŸŽ‰ Let's now see how to remove connections in the next chapter. ðŸ’¥ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read Connected Data - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/connect/read-connected-data/",
    "html": "Skip to content SQLModel Read Connected Data Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Create Connected Tables Create and Connect Rows Read Connected Data Update Data Connections Remove Data Connections Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents SELECT Connected Data with SQL Select Related Data with SQLModel Add It to Main Run the Program JOIN Tables with SQL Join Tables in SQLModel JOIN Tables with SQL and LEFT OUTER (Maybe JOIN) Foreign Keys with NULL Include Everything on the LEFT OUTER Join Tables in SQLModel with LEFT OUTER What Goes in select() Select Only Heroes But Join with Teams Include the Team Relationship Attributes SQLModel Tutorial - User Guide Connect Tables - JOIN Read Connected DataÂ¶ Now that we have some data in both tables, let's select the data that is connected together. The team table has this data: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar And the hero table has this data: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Rusty-Man Tommy Sharp 48 1 3 Spider-Boy Pedro Parqueador null null We will continue with the code in the previous example and we will add more things to it. ðŸ‘€ Full file preview SELECT Connected Data with SQLÂ¶ Let's start seeing how SQL works when selecting connected data. This is where SQL databases actually shine. If you don't have a database.db file, run that previous program we had written (or copy it from the preview above) to create it. Now open DB Browser for SQLite and open the database.db file. To SELECT connected data we use the same keywords we have used before, but now we combine the two tables. Let's get each hero with the id, name, and the team name: SELECT hero.id, hero.name, team.name FROM hero, team WHERE hero.team_id = team.id Info Because we have two columns called name, one for hero and one for team, we can specify them with the prefix of the table name and the dot to make it explicit what we refer to. Notice that now in the WHERE part we are not comparing one column with a literal value (like hero.name = \"Deadpond\"), but we are comparing two columns. It means, more or less: Hey SQL database ðŸ‘‹, please go and SELECT some data for me. I'll first tell you the columns I want: id of the hero table name of the hero table name of the team table I want you to get that data FROM the tables hero and team. And I don't want you to combine each hero with each possible team. Instead, for each hero, go and check each possible team, but give me only the ones WHERE the hero.team_id is the same as the team.id. If we execute that SQL, it will return the table: id name name 1 Deadpond Z-Force 2 Rusty-Man Preventers You can go ahead and try it in DB Browser for SQLite: Note Wait, what about Spider-Boy? ðŸ˜± He doesn't have a team, so his team_id is NULL in the database. And this SQL is comparing that NULL from the team_id with all the id fields in the rows in the team table. As there's no team with an ID of NULL, it doesn't find a match. But we'll see how to fix that later with a LEFT JOIN. Select Related Data with SQLModelÂ¶ Now let's use SQLModel to do the same select. We'll create a function select_heroes() just as we did before, but now we'll work with two tables. Remember SQLModel's select() function? It can take more than one argument. So, we can pass the Hero and Team model classes. And we can also use both their columns in the .where() part: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero, Team).where(Hero.team_id == Team.id) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Notice that in the comparison with == we are using the class attributes for both Hero.team_id and Team.id. That will generate the appropriate expression object that will be converted to the right SQL, equivalent to the SQL example we saw above. Now we can execute it and get the results object. And as we used select with two models, we will receive tuples of instances of those two models, so we can iterate over them naturally in a for loop: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero, Team).where(Hero.team_id == Team.id) results = session.exec(statement) for hero, team in results: print(\"Hero:\", hero, \"Team:\", team) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview For each iteration in the for loop we get a a tuple with an instance of the class Hero and an instance of the class Team. And in this for loop we assign them to the variable hero and the variable team. Info There was a lot of research, design, and work behind SQLModel to make this provide the best possible developer experience. And you should get autocompletion and inline errors in your editor for both hero and team. ðŸŽ‰ Add It to MainÂ¶ As always, we must remember to add this new select_heroes() function to the main() function to make sure it is executed when we call this program from the command line. # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() select_heroes() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Run the ProgramÂ¶ Now we can run the program and see how it shows us each hero with their corresponding team: JOIN Tables with SQLÂ¶ There's an alternative syntax for that SQL query from above using the keyword JOIN instead of WHERE. This is the same version from above, using WHERE: SELECT hero.id, hero.name, team.name FROM hero, team WHERE hero.team_id = team.id And this is the alternative version using JOIN: SELECT hero.id, hero.name, team.name FROM hero JOIN team ON hero.team_id = team.id Both are equivalent. The differences in the SQL code are that instead of passing the team to the FROM part (also called FROM clause) we add a JOIN and put the team table there. And then, instead of putting a WHERE with a condition, we put an ON keyword with the condition, because ON is the one that comes with JOIN. ðŸ¤· So, this second version means, more or less: Hey SQL database ðŸ‘‹, please go and SELECT some data for me. I'll first tell you the columns I want: id of the hero table name of the hero table name of the team table ...up to here it's the same as before, LOL. Now, I want you to get that data starting FROM the table hero. And to get the rest of the data, I want you to JOIN it with the table team. And I want you to join those two tables ON the combinations of rows that have the hero.team_id with the same value as the team.id. Did I say all this before already? I feel like I'm just repeating myself. ðŸ¤” That will return the same table as before: id name name 1 Deadpond Z-Force 2 Rusty-Man Preventers Also in DB Browser for SQLite: Tip Why bother with all this if the result is the same? This JOIN will be useful in a bit to be able to also get Spider-Boy, even if he doesn't have a team. Join Tables in SQLModelÂ¶ The same way there's a .where() available when using select(), there's also a .join(). And in SQLModel (actually SQLAlchemy), when using the .join(), because we already declared what is the foreign_key when creating the models, we don't have to pass an ON part, it is inferred automatically: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero, Team).join(Team) results = session.exec(statement) for hero, team in results: print(\"Hero:\", hero, \"Team:\", team) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Also notice that we are still including Team in the select(Hero, Team), because we still want to access that data. This is equivalent to the previous example. And if we run it in the command line, it will output: JOIN Tables with SQL and LEFT OUTER (Maybe JOIN)Â¶ When working with a JOIN, you can imagine that you start with a table on the FROM part and put that table in an imaginary space on the left side. And then you want another table to JOIN the result. And you put that second table in the right side on that imaginary space. And then you tell the database ON which condition it should join those two tables and give you the results back. But by default, only the rows from both left and right that match the condition will be returned. In this example of tables above ðŸ‘†, it would return all the heroes, because every hero has a team_id, so every hero can be joined with the team table: id name name 1 Deadpond Z-Force 2 Rusty-Man Preventers 3 Spider-Boy Preventers Foreign Keys with NULLÂ¶ But in the database that we are working with in the code above, Spider-Boy doesn't have any team, the value of team_id is NULL in the database. So there's no way to join the Spider-Boy row with some row in the team table: Running the same SQL we used above, the resulting table would not include Spider-Boy ðŸ˜±: id name name 1 Deadpond Z-Force 2 Rusty-Man Preventers Include Everything on the LEFT OUTERÂ¶ In this case, that we want to include all heroes in the result even if they don't have a team, we can extend that same SQL using a JOIN from above and add a LEFT OUTER right before JOIN: SELECT hero.id, hero.name, team.name FROM hero LEFT OUTER JOIN team ON hero.team_id = team.id This LEFT OUTER part tells the database that we want to keep everything on the first table, the one on the LEFT in the imaginary space, even if those rows would be left out, so we want it to include the OUTER rows too. In this case, every hero with or without a team. And that would return the following result, including Spider-Boy ðŸŽ‰: id name name 1 Deadpond Z-Force 2 Rusty-Man Preventers 3 Spider-Boy null Tip The only difference between this query and the previous is that extra LEFT OUTER. And here's another of the SQL variations, you could write LEFT OUTER JOIN or just LEFT JOIN, it means the same. Join Tables in SQLModel with LEFT OUTERÂ¶ Now let's replicate the same query in SQLModel. .join() has a parameter we can use isouter=True to make the JOIN be a LEFT OUTER JOIN: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero, Team).join(Team, isouter=True) results = session.exec(statement) for hero, team in results: print(\"Hero:\", hero, \"Team:\", team) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And if we run it, it will output: What Goes in select()Â¶ You might be wondering why we put the Team in the select() and not just in the .join(). And then why we didn't include Hero in the .join(). ðŸ¤” In SQLModel (actually in SQLAlchemy), all these functions and tools try to replicate how it would be to work with the SQL language. Remember that SELECT defines the columns to get and WHERE how to filter them?. This also applies here, but with JOIN and ON. Select Only Heroes But Join with TeamsÂ¶ If we only put the Team in the .join() and not in the select() function, we would not get the team data. But we would still be able to filter the rows with it. ðŸ¤“ We could even add some additional .where() after .join() to filter the data more, for example to return only the heroes from one team: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).join(Team).where(Team.name == \"Preventers\") results = session.exec(statement) for hero in results: print(\"Preventer Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Here we are filtering with .where() to get only the heroes that belong to the Preventers team. But we are still only requesting the data from the heroes, not their teams. If we run that, it would output: Include the TeamÂ¶ By putting the Team in select() we tell SQLModel and the database that we want the team data too. # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero, Team).join(Team).where(Team.name == \"Preventers\") results = session.exec(statement) for hero, team in results: print(\"Preventer Hero:\", hero, \"Team:\", team) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And if we run that, it will output: We still have to .join() because otherwise it would just compute all the possible combinations of heroes and teams, for example including Rusty-Man with Preventers and also Rusty-Man with Z-Force, which would be a mistake. Relationship AttributesÂ¶ Here we have been using the pure class models directly, but in a future chapter we will also see how to use Relationship Attributes that let us interact with the database in a way much more close to the code with Python objects. And we will also see how to load their data in a different, simpler way, achieving the same we achieved here. âœ¨ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create and Connect Rows - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/connect/create-connected-rows/",
    "html": "Skip to content SQLModel Create and Connect Rows Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Create Connected Tables Create and Connect Rows Read Connected Data Update Data Connections Remove Data Connections Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create Rows for Teams with SQLModel Add It to Main Run it Create Rows for Heroes in Code Refresh and Print Heroes Relationships SQLModel Tutorial - User Guide Connect Tables - JOIN Create and Connect RowsÂ¶ We will now create rows for each table. âœ¨ The team table will look like this: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar And after we finish working with the data in this chapter, the hero table will look like this: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Rusty-Man Tommy Sharp 48 1 3 Spider-Boy Pedro Parqueador null null Each row in the table hero will point to a row in the table team: Info We will later update Spider-Boy to add him to the Preventers team too, but not yet. We will continue with the code in the previous example and we will add more things to it. ðŸ‘€ Full file preview Make sure you remove the database.db file before running the examples to get the same results. Create Rows for Teams with SQLModelÂ¶ Let's do the same we did before and define a create_heroes() function where we create our heroes. And now we will also create the teams there. ðŸŽ‰ Let's start by creating two teams: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") session.add(team_preventers) session.add(team_z_force) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This would hopefully look already familiar. We start a session in a with block using the same engine we created above. Then we create two instances of the model class (in this case Team). Next we add those objects to the session. And finally we commit the session to save the changes to the database. Add It to MainÂ¶ Let's not forget to add this function create_heroes() to the main() function so that we run it when calling the program from the command line: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Run itÂ¶ If we run that code we have up to now, it will output: You can see in the output that it uses common SQL INSERT statements to create the rows. Create Rows for Heroes in CodeÂ¶ Now let's create one hero object to start. As the Hero class model now has a field (column, attribute) team_id, we can set it by using the ID field from the Team objects we just created before: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") session.add(team_preventers) session.add(team_z_force) session.commit() hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team_id=team_z_force.id ) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We haven't committed this hero to the database yet, but there are already a couple of things to pay attention to. If the database already had some teams, we wouldn't even know what is the ID that is going to be automatically assigned to each team by the database, for example, we couldn't just guess 1 or 2. But once the team is created and committed to the database, we can access the object's id field to get that ID. Accessing an attribute in a model that was just committed, for example with team_z_force.id, automatically triggers a refresh of the data from the DB in the object, and then exposes the value for that field. So, even though we are not committing this hero yet, just because we are using team_z_force.id, that will trigger some SQL sent to the database to fetch the data for this team. That line alone would generate an output of: INFO Engine BEGIN (implicit) INFO Engine SELECT team.id AS team_id, team.name AS team_name, team.headquarters AS team_headquarters FROM team WHERE team.id = ? INFO Engine [generated in 0.00025s] (2,) Let's now create two more heroes: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") session.add(team_preventers) session.add(team_z_force) session.commit() hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team_id=team_z_force.id ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, team_id=team_preventers.id, ) hero_spider_boy = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") session.add(hero_deadpond) session.add(hero_rusty_man) session.add(hero_spider_boy) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview When creating hero_rusty_man, we are accessing team_preventers.id, so that will also trigger a refresh of its data, generating an output of: INFO Engine SELECT team.id AS team_id, team.name AS team_name, team.headquarters AS team_headquarters FROM team WHERE team.id = ? INFO Engine [cached since 0.001795s ago] (1,) There's something else to note. We marked team_id as Optional[int], meaning that this could be NULL on the database (and None in Python). That means that a hero doesn't have to have a team. And in this case, Spider-Boy doesn't have one. Next we just commit the changes to save them to the database, and that will generate the output: INFO Engine INSERT INTO hero (name, secret_name, age, team_id) VALUES (?, ?, ?, ?) INFO Engine [generated in 0.00022s] ('Deadpond', 'Dive Wilson', None, 2) INFO Engine INSERT INTO hero (name, secret_name, age, team_id) VALUES (?, ?, ?, ?) INFO Engine [cached since 0.0007987s ago] ('Rusty-Man', 'Tommy Sharp', 48, 1) INFO Engine INSERT INTO hero (name, secret_name, age, team_id) VALUES (?, ?, ?, ?) INFO Engine [cached since 0.001095s ago] ('Spider-Boy', 'Pedro Parqueador', None, None) INFO Engine COMMIT Refresh and Print HeroesÂ¶ Now let's refresh and print those new heroes to see their new ID pointing to their teams: # Code above omitted ðŸ‘† def create_heroes(): with Session(engine) as session: team_preventers = Team(name=\"Preventers\", headquarters=\"Sharp Tower\") team_z_force = Team(name=\"Z-Force\", headquarters=\"Sister Margaret's Bar\") session.add(team_preventers) session.add(team_z_force) session.commit() hero_deadpond = Hero( name=\"Deadpond\", secret_name=\"Dive Wilson\", team_id=team_z_force.id ) hero_rusty_man = Hero( name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48, team_id=team_preventers.id, ) hero_spider_boy = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") session.add(hero_deadpond) session.add(hero_rusty_man) session.add(hero_spider_boy) session.commit() session.refresh(hero_deadpond) session.refresh(hero_rusty_man) session.refresh(hero_spider_boy) print(\"Created hero:\", hero_deadpond) print(\"Created hero:\", hero_rusty_man) print(\"Created hero:\", hero_spider_boy) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview If we execute that in the command line, it will output: They now have their team_ids, nice! RelationshipsÂ¶ Relationships in SQL databases are just made by having columns in one table referencing the values in columns on other tables. And here we have treated them just like that, more column fields, which is what they actually are behind the scenes in the SQL database. But later in this tutorial, in the next group of chapters, you will learn about Relationship Attributes to make it all a lot easier to work with in code. âœ¨ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create Connected Tables - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/connect/create-connected-tables/",
    "html": "Skip to content SQLModel Create Connected Tables Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Create Connected Tables Create and Connect Rows Read Connected Data Update Data Connections Remove Data Connections Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents One-to-Many and Many-to-One Create Tables in Code Create the team Table Create the New hero Table The Value of foreign_key Create the Tables Run the Code Create Tables in SQL Recap SQLModel Tutorial - User Guide Connect Tables - JOIN Create Connected TablesÂ¶ Now we will deal with connected data put in different tables. So, the first step is to create more than one table and connect them, so that each row in one table can reference another row in the other table. We have been working with heroes in a single table hero. Let's now add a table team. The team table will look like this: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar To connect them, we will add another column to the hero table to point to each team by the ID with the team_id: id name secret_name age team_id âœ¨ 1 Deadpond Dive Wilson null 2 âœ¨ 2 Spider-Boy Pedro Parqueador null 1 âœ¨ 3 Rusty-Man Tommy Sharp 48 1 âœ¨ This way each row in the table hero can point to a row in the table team: One-to-Many and Many-to-OneÂ¶ Here we are creating connected data in a relationship where one team could have many heroes. So it is commonly called a one-to-many or many-to-one relationship. The many-to-one part can be seen if we start from the heroes, many heroes could be part of one team. This is probably the most popular type of relationship, so we'll start with that. But there's also many-to-many and one-to-one relationships. Create Tables in CodeÂ¶ Create the team TableÂ¶ Let's start by creating the tables in code. Import the things we need from sqlmodel and create a new Team model: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is very similar to what we have been doing with the Hero model. The Team model will be in a table automatically named \"team\", and it will have the columns: id, the primary key, automatically generated by the database name, the name of the team We also tell SQLModel to create an index for this column headquarters, the headquarters of the team And finally we mark it as a table in the config. Create the New hero TableÂ¶ Now let's create the hero table. This is the same model we have been using up to now, we are just adding the new column team_id: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Team(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) headquarters: str class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) team_id: Optional[int] = Field(default=None, foreign_key=\"team.id\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Most of that should look familiar: The column will be named team_id. It will be an integer, and it could be NULL in the database (or None in Python), because there could be some heroes that don't belong to any team. We add a default of None to the Field() so we don't have to explicitly pass team_id=None when creating a hero. Now, here's the new part: In Field() we pass the argument foreign_key=\"team.id\". This tells the database that this column team_id is a foreign key to the table team. A \"foreign key\" just means that this column will have the key to identify a row in a foreign table. The value in this column team_id will be the same integer that is in some row in the id column on the team table. That is what connects the two tables. The Value of foreign_keyÂ¶ Notice that the foreign_key is a string. Inside it has the name of the table, then a dot, and then the name of the column. This is the name of the table in the database, so it is \"team\", not the name of the model class Team (with a capital T). If you had a custom table name, you would use that custom table name. Info You can learn about setting a custom table name for a model in the Advanced User Guide. Create the TablesÂ¶ Now we can add the same code as before to create the engine and the function to create the tables: # Code above omitted ðŸ‘† sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) ðŸ‘€ Full file preview And as before, we'll call this function from another function main(), and we'll add that function main() to the main block of the file: # Code above omitted ðŸ‘† def main(): create_db_and_tables() if __name__ == \"__main__\": main() ðŸ‘€ Full file preview Run the CodeÂ¶ Tip Before running the code, make sure you delete the file database.db to make sure you start from scratch. If we run the code we have up to now, it will go and create the database file database.db and the tables in it we just defined, team and hero: Create Tables in SQLÂ¶ Let's see that same generated SQL code. As we saw before, those VARCHAR columns are converted to TEXT in SQLite, which is the database we are using for these experiments. So, the first SQL could also be written as: CREATE TABLE team ( id INTEGER, name TEXT NOT NULL, headquarters TEXT NOT NULL, PRIMARY KEY (id) ) And the second table could be written as: CREATE TABLE hero ( id INTEGER, name TEXT NOT NULL, secret_name TEXT NOT NULL, age INTEGER, team_id INTEGER, PRIMARY KEY (id), FOREIGN KEY(team_id) REFERENCES team (id) ) The only new is the FOREIGN KEY line, and as you can see, it tells the database what column in this table is a foreign key (team_id), which other (foreign) table it references (team) and which column in that table is the key to define which row to connect (id). Feel free to experiment with it in DB Browser for SQLite. RecapÂ¶ Using SQLModel, in most of the cases you only need a field (column) with a foreign_key in the Field() with a string pointing to another table and column to connect two tables. Now that we have the tables created and connected, let's create some rows in the next chapter. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Connect Tables - JOIN - Intro - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/connect/",
    "html": "Skip to content SQLModel Connect Tables - JOIN - Intro Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Create Connected Tables Create and Connect Rows Read Connected Data Update Data Connections Remove Data Connections Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes SQLModel Tutorial - User Guide Connect Tables - JOIN Connect Tables - JOIN - IntroÂ¶ By this point, you already know how to perform the main CRUD operations with SQLModel using a single table. ðŸŽ‰ But the main advantage and feature of SQL databases is being able to handle related data, to connect or \"join\" different tables together. Connecting rows in one table to rows in another. Let's see how to use SQLModel to manage connected data in the next chapters. ðŸ¤ Tip We will extend this further in the next group of chapters making it even more convenient to work with in Python code, using relationship attributes. But you should start in this group of chapters first. ðŸ¤“ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Delete Data - DELETE - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/delete/",
    "html": "Skip to content SQLModel Delete Data - DELETE Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Continue From Previous Code Delete with SQL Read From the Database Delete the Hero from the Session Commit the Session Print the Deleted Object Query the Database for the Same Row Confirm the Deletion Review the Code Recap SQLModel Tutorial - User Guide Delete Data - DELETEÂ¶ Now let's delete some data using SQLModel. Continue From Previous CodeÂ¶ As before, we'll continue from where we left off with the previous code. ðŸ‘€ Full file preview Remember to remove the database.db file before running the examples to get the same results. Delete with SQLÂ¶ This Spider-Youngster is getting too weird, so let's just delete it. But don't worry, we'll reboot it later with a new story. ðŸ˜… Let's see how to delete it with SQL: DELETE FROM hero WHERE name = \"Spider-Youngster\" This means, more or less: Hey SQL database ðŸ‘‹, I want to DELETE rows FROM the table called hero. Please delete all the rows WHERE the value of the column name is equal to \"Spider-Youngster\". Remember that when using a SELECT statement it has the form: SELECT [some stuff here] FROM [name of a table here] WHERE [some condition here] DELETE is very similar, and again we use FROM to tell the table to work on, and we use WHERE to tell the condition to use to match the rows that we want to delete. You can try that in DB Browser for SQLite: Have in mind that DELETE is to delete entire rows, not single values in a row. If you want to \"delete\" a single value in a column while keeping the row, you would instead update the row as explained in the previous chapter, setting the specific value of the column in that row to NULL (to None in Python). Now let's delete with SQLModel. To get the same results, delete the database.db file before running the examples. Read From the DatabaseÂ¶ We'll start by selecting the hero \"Spider-Youngster\" that we updated in the previous chapter, this is the one we will delete: # Code above omitted ðŸ‘† def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.one() print(\"Hero: \", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview As this is a new function delete_heroes(), we'll also add it to the main() function so that we call it when executing the program from the command line: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() update_heroes() delete_heroes() if __name__ == \"__main__\": main() ðŸ‘€ Full file preview That will print the same existing hero Spider-Youngster: Delete the Hero from the SessionÂ¶ Now, very similar to how we used session.add() to add or update new heroes, we can use session.delete() to delete the hero from the session: # Code above omitted ðŸ‘† def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.one() print(\"Hero: \", hero) session.delete(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Commit the SessionÂ¶ To save the current changes in the session, commit it. This will save all the changes stored in the session, like the deleted hero: # Code above omitted ðŸ‘† def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.one() print(\"Hero: \", hero) session.delete(hero) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The same as we have seen before, .commit() will also save anything else that was added to the session. Including updates, or created heroes. This commit after deleting the hero will generate this output: Print the Deleted ObjectÂ¶ Now the hero is deleted from the database. If we tried to use session.refresh() with it, it would raise an exception, because there's no data in the database for this hero. Nevertheless, the object is still available with its data, but now it's not connected to the session and it no longer exists in the database. As the object is not connected to the session, it is not marked as \"expired\", the session doesn't even care much about this object anymore. Because of that, the object still contains its attributes with the data in it, so we can print it: # Code above omitted ðŸ‘† def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.one() print(\"Hero: \", hero) session.delete(hero) session.commit() print(\"Deleted hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This will output: Query the Database for the Same RowÂ¶ To confirm if it was deleted, now let's query the database again, with the same \"Spider-Youngster\" name: # Code above omitted ðŸ‘† def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.one() print(\"Hero: \", hero) session.delete(hero) session.commit() print(\"Deleted hero:\", hero) statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.first() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Here we are using results.first() to get the first object found (in case it found multiple) or None, if it didn't find anything. If we used results.one() instead, it would raise an exception, because it expects exactly one result. And because we just deleted that hero, this should not find anything and we should get None. This will execute some SQL in the database and output: Confirm the DeletionÂ¶ Now let's just confirm that, indeed, no hero was found in the database with that name. We'll do it by checking that the \"first\" item in the results is None: # Code above omitted ðŸ‘† def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.one() print(\"Hero: \", hero) session.delete(hero) session.commit() print(\"Deleted hero:\", hero) statement = select(Hero).where(Hero.name == \"Spider-Youngster\") results = session.exec(statement) hero = results.first() if hero is None: print(\"There's no hero named Spider-Youngster\") # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This will output: Review the CodeÂ¶ Now let's review all that code: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) hero_4 = Hero(name=\"Tarantula\", secret_name=\"Natalia Roman-on\", age=32) hero_5 = Hero(name=\"Black Lion\", secret_name=\"Trevor Challa\", age=35) hero_6 = Hero(name=\"Dr. Weird\", secret_name=\"Steve Weird\", age=36) hero_7 = Hero(name=\"Captain North America\", secret_name=\"Esteban Rogelios\", age=93) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.add(hero_4) session.add(hero_5) session.add(hero_6) session.add(hero_7) session.commit() def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero_1 = results.one() print(\"Hero 1:\", hero_1) statement = select(Hero).where(Hero.name == \"Captain North America\") results = session.exec(statement) hero_2 = results.one() print(\"Hero 2:\", hero_2) hero_1.age = 16 hero_1.name = \"Spider-Youngster\" session.add(hero_1) hero_2.name = \"Captain North America Except Canada\" hero_2.age = 110 session.add(hero_2) session.commit() session.refresh(hero_1) session.refresh(hero_2) print(\"Updated hero 1:\", hero_1) print(\"Updated hero 2:\", hero_2) def delete_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Youngster\") Select the hero we will delete. results = session.exec(statement) Execute the query with the select statement object. This generates the output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.name = ? INFO Engine [no key 0.00011s] ('Spider-Youngster',) hero = results.one() Get one hero object, expecting exactly one. !!! tip This ensures there's no more than one, and that there's exactly one, not None. This would never return `None`, instead it would raise an exception. print(\"Hero: \", hero) Print the hero object. This generates the output: Hero: name='Spider-Youngster' secret_name='Pedro Parqueador' age=16 id=2 session.delete(hero) Delete the hero from the session. This marks the hero as deleted from the session, but it will not be removed from the database until we commit the changes. session.commit() Commit the session. This saves the changes in the session, including deleting this row. It generates the output: INFO Engine DELETE FROM hero WHERE hero.id = ? INFO Engine [generated in 0.00020s] (2,) INFO Engine COMMIT print(\"Deleted hero:\", hero) Print the deleted hero object. The hero is deleted in the database. And is marked as deleted in the session. But we still have the object in memory with its data, so we can use it to print it. This generates the output: Deleted hero: name='Spider-Youngster' secret_name='Pedro Parqueador' age=16 id=2 statement = select(Hero).where(Hero.name == \"Spider-Youngster\") Select the same hero again. We'll do this to confirm if the hero is really deleted. results = session.exec(statement) Execute the select statement. This generates the output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.name = ? INFO Engine [no key 0.00013s] ('Spider-Youngster',) hero = results.first() Get the \"first\" item from the results. If no items were found, this will return None, which is what we expect. if hero is None: Check if the first item from the results is None. print(\"There's no hero named Spider-Youngster\") If this first item is indeed None, it means that it was correctly deleted from the database. Now we can print a message to confirm. This generates the output: There's no hero named Spider-Youngster This is the end of the with block, here the session executes its closing code. This generates the output: INFO Engine ROLLBACK def main(): create_db_and_tables() create_heroes() update_heroes() delete_heroes() if __name__ == \"__main__\": main() Tip Check out the number bubbles to see what is done by each line of code. RecapÂ¶ To delete rows with SQLModel you just have to .delete() them with the session, and then, as always, .commit() the session to save the changes to the database. ðŸ”¥ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Update Data - UPDATE - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/update/",
    "html": "Skip to content SQLModel Update Data - UPDATE Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Continue From Previous Code Update with SQL Read From the Database Set a Field Value Add the Hero to the Session Commit the Session Refresh the Object Print the Updated Object Review the Code Multiple Updates Recap SQLModel Tutorial - User Guide Update Data - UPDATEÂ¶ Now let's see how to update data using SQLModel. Continue From Previous CodeÂ¶ As before, we'll continue from where we left off with the previous code. ðŸ‘€ Full file preview Remember to remove the database.db file before running the examples to get the same results. Update with SQLÂ¶ Let's quickly check how to update data with SQL: UPDATE hero SET age=16 WHERE name = \"Spider-Boy\" This means, more or less: Hey SQL database ðŸ‘‹, I want to UPDATE the table called hero. Please SET the value of the age column to 16... ...for each of the rows WHERE the value of the column name is equal to \"Spider-Boy\". In a similar way to SELECT statements, the first part defines the columns to work with: what are the columns that have to be updated and to which value. The rest of the columns stay as they were. And the second part, with the WHERE, defines to which rows it should apply that update. In this case, as we only have one hero with the name \"Spider-Boy\", it will only apply the update in that row. Info Notice that in the UPDATE the single equals sign (=) means assignment, setting a column to some value. And in the WHERE the same single equals sign (=) is used for comparison between two values, to find rows that match. This is in contrast to Python and most programming languages, where a single equals sign (=) is used for assignment, and two equal signs (==) are used for comparisons. You can try that in DB Browser for SQLite: After that update, the data in the table will look like this, with the new age for Spider-Boy: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador 16 âœ¨ 3 Rusty-Man Tommy Sharp 48 Tip It will probably be more common to find the row to update by id, for example: UPDATE hero SET age=16 WHERE id = 2 But in the example above I used name to make it more intuitive. Now let's do the same update in code, with SQLModel. To get the same results, delete the database.db file before running the examples. Read From the DatabaseÂ¶ We'll start by selecting the hero \"Spider-Boy\", this is the one we will update: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Let's not forget to add that update_heroes() function to the main() function so that we call it when executing the program from the command line: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() update_heroes() if __name__ == \"__main__\": main() ðŸ‘€ Full file preview Up to that point, running that in the command line will output: Tip Notice that by this point, the hero still doesn't have an age. Set a Field ValueÂ¶ Now that you have a hero object, you can simply set the value of the field (the attribute representing a column) that you want. In this case, we will set the age to 16: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) hero.age = 16 # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Add the Hero to the SessionÂ¶ Now that the hero object in memory has a change, in this case a new value for the age, we need to add it to the session. This is the same we did when creating new hero instances: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) hero.age = 16 session.add(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Commit the SessionÂ¶ To save the current changes in the session, commit it. This will save the updated hero in the database: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) hero.age = 16 session.add(hero) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview It will also save anything else that was added to the session. For example, if you were also creating new heroes and had added those objects to the session before, they would now be saved too in this single commit. This commit will generate this output: Refresh the ObjectÂ¶ At this point, the hero is updated in the database and it has the new data saved there. The data in the object would be automatically refreshed if we accessed an attribute, like hero.name. But in this example we are not accessing any attribute, we will only print the object. And we also want to be explicit, so we will .refresh() the object directly: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) hero.age = 16 session.add(hero) session.commit() session.refresh(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This refresh will trigger the same SQL query that would be automatically triggered by accessing an attribute. So it will generate this output: Print the Updated ObjectÂ¶ Now we can just print the hero: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) hero.age = 16 session.add(hero) session.commit() session.refresh(hero) print(\"Updated hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Because we refreshed it right after updating it, it has fresh data, including the new age we just updated. So, printing it will show the new age: Review the CodeÂ¶ Now let's review all that code: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) hero_4 = Hero(name=\"Tarantula\", secret_name=\"Natalia Roman-on\", age=32) hero_5 = Hero(name=\"Black Lion\", secret_name=\"Trevor Challa\", age=35) hero_6 = Hero(name=\"Dr. Weird\", secret_name=\"Steve Weird\", age=36) hero_7 = Hero(name=\"Captain North America\", secret_name=\"Esteban Rogelios\", age=93) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.add(hero_4) session.add(hero_5) session.add(hero_6) session.add(hero_7) session.commit() def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") Select the hero we will work with. results = session.exec(statement) Execute the query with the select statement object. This generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.name = ? INFO Engine [no key 0.00017s] ('Spider-Boy',) hero = results.one() Get one hero object, expecting exactly one. !!! tip This ensures there's no more than one, and that there's exactly one, not None. This would never return `None`, instead it would raise an exception. print(\"Hero:\", hero) Print the hero object. This generates the output: Hero: name='Spider-Boy' secret_name='Pedro Parqueador' age=None id=2 hero.age = 16 Set the hero's age field to the new value 16. Now the hero object in memory has a different value for the age, but it is still not saved to the database. session.add(hero) Add the hero to the session. This puts it in that temporary place in the session before committing. But it's still not saved in the database yet. session.commit() Commit the session. This saves the updated hero to the database. And this generates the output: INFO Engine UPDATE hero SET age=? WHERE hero.id = ? INFO Engine [generated in 0.00017s] (16, 2) INFO Engine COMMIT session.refresh(hero) Refresh the hero object to have the recent data, including the age we just committed. This generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.id = ? INFO Engine [generated in 0.00018s] (2,) print(\"Updated hero:\", hero) Print the updated hero object. This generates the output: Updated hero: name='Spider-Boy' secret_name='Pedro Parqueador' age=16 id=2 def main(): create_db_and_tables() create_heroes() update_heroes() if __name__ == \"__main__\": main() Tip Check out the number bubbles to see what is done by each line of code. Multiple UpdatesÂ¶ The update process with SQLModel is more or less the same as with creating new objects, you add them to the session, and then commit them. This also means that you can update several fields (attributes, columns) at once, and you can also update several objects (heroes) at once: # Code above omitted ðŸ‘† def update_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") Select the hero Spider-Boy. results = session.exec(statement) Execute the select statement. This generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.name = ? INFO Engine [no key 0.00018s] ('Spider-Boy',) hero_1 = results.one() Get one hero object, the only one that should be there for Spider-Boy. print(\"Hero 1:\", hero_1) Print this hero. This generates the output: Hero 1: name='Spider-Boy' secret_name='Pedro Parqueador' age=None id=2 statement = select(Hero).where(Hero.name == \"Captain North America\") Select another hero. results = session.exec(statement) Execute the select statement. This generates the output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.name = ? INFO Engine [no key 0.00020s] ('Captain North America',) !!! tip See the BEGIN at the top? This is SQLAlchemy automatically starting a transaction for us. This way, we could revert the last changes (if there were some) if we wanted to, even if the SQL to create them was already sent to the database. hero_2 = results.one() Get one hero object for this new query. The only one that should be there for Captain North America. print(\"Hero 2:\", hero_2) Print this second hero. This generates the output: Hero 2: name='Captain North America' secret_name='Esteban Rogelios' age=93 id=7 hero_1.age = 16 Update the age for the first hero. Set the value of the attribute age to 16. This updates the hero object in memory, but not yet in the database. hero_1.name = \"Spider-Youngster\" Update the name of the first hero. Now the name of the hero will not be \"Spider-Boy\" but \"Spider-Youngster\". Also, this updates the object in memory, but not yet in the database. session.add(hero_1) Add this first hero to the session. This puts it in the temporary space in the session before committing it to the database. It is not saved yet. hero_2.name = \"Captain North America Except Canada\" Update the name of the second hero. Now the hero has a bit more precision in the name. ðŸ˜œ This updates the object in memory, but not yet in the database. hero_2.age = 110 Update the age of the second hero. This updates the object in memory, but not yet in the database. session.add(hero_2) Add the second hero to the session. This puts it in the temporary space in the session before committing it to the database. session.commit() Commit all the changes tracked in the session. This commits everything in one single batch. This generates the output: INFO Engine UPDATE hero SET name=?, age=? WHERE hero.id = ? INFO Engine [generated in 0.00028s] (('Spider-Youngster', 16, 2), ('Captain North America Except Canada', 110, 7)) INFO Engine COMMIT !!! tip See how SQLAlchemy (that powers SQLModel) optimizes the SQL to do as much work as possible in a single batch. Here it updates both heroes in a single SQL query. session.refresh(hero_1) Refresh the first hero. This generates the output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.id = ? INFO Engine [generated in 0.00023s] (2,) !!! tip Because we just committed a SQL transaction with COMMIT, SQLAlchemy will automatically start a new transaction with BEGIN. session.refresh(hero_2) Refresh the second hero. This generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.id = ? INFO Engine [cached since 0.001709s ago] (7,) !!! tip SQLAlchemy is still using the previous transaction, so it doesn't have to create a new one. print(\"Updated hero 1:\", hero_1) Print the first hero, now updated. This generates the output: Updated hero 1: name='Spider-Youngster' secret_name='Pedro Parqueador' age=16 id=2 print(\"Updated hero 2:\", hero_2) Print the second hero, now updated. This generates the output: Updated hero 2: name='Captain North America Except Canada' secret_name='Esteban Rogelios' age=110 id=7 Here is the end of the with block statement, so the session can execute its terminating code. The session will ROLLBACK (undo) any possible changes in the last transaction that were not committed. This generates the output: INFO Engine ROLLBACK # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Tip Review what each line does by clicking each number bubble in the code. ðŸ‘† RecapÂ¶ Update SQLModel objects just as you would with other Python objects. ðŸ Just remember to add them to a session, and then commit it. And if necessary, refresh them. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read a Range of Data - LIMIT and OFFSET - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/limit-and-offset/",
    "html": "Skip to content SQLModel Read a Range of Data - LIMIT and OFFSET Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create Data Review Select All Select with Limit Run the Program on the Command Line Select with Offset and Limit Run the Program with Offset on the Command Line Select Next Batch Run the Program with the Last Batch on the Command Line SQL with LIMIT and OFFSET Combine Limit and Offset with Where Run the Program with Limit, Offset, and Where on the Command Line Recap SQLModel Tutorial - User Guide Read a Range of Data - LIMIT and OFFSETÂ¶ Now you know how to get a single row with .one(), .first(), and session.get(). And you also know how to get multiple rows while filtering them using .where(). Now let's see how to get only a range of results. Create DataÂ¶ We will continue with the same code as before, but we'll modify it a little the select_heroes() function to simplify the example and focus on what we want to achieve here. Again, we will create several heroes to have some data to select from: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) hero_4 = Hero(name=\"Tarantula\", secret_name=\"Natalia Roman-on\", age=32) hero_5 = Hero(name=\"Black Lion\", secret_name=\"Trevor Challa\", age=35) hero_6 = Hero(name=\"Dr. Weird\", secret_name=\"Steve Weird\", age=36) hero_7 = Hero(name=\"Captain North America\", secret_name=\"Esteban Rogelios\", age=93) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.add(hero_4) session.add(hero_5) session.add(hero_6) session.add(hero_7) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Review Select AllÂ¶ This is the code we had to select all the heroes in the select() examples: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero) results = session.exec(statement) heroes = results.all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview But this would get us all the heroes at the same time, in a database that could have thousands, that could be problematic. Select with LimitÂ¶ We currently have 7 heroes in the database. But we could as well have thousands, so let's limit the results to get only the first 3: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).limit(3) results = session.exec(statement) heroes = results.all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The special select object we get from select() also has a method .limit() that we can use to limit the results to a certain number. In this case, instead of getting all the 7 rows, we are limiting them to only get the first 3. Run the Program on the Command LineÂ¶ If we run it on the command line, it will output: Great! We got only 3 heroes as we wanted. Tip We will check out that SQL code more in a bit. Select with Offset and LimitÂ¶ Now we can limit the results to get only the first 3. But imagine we are in a user interface showing the results in batches of 3 heroes at a time. Tip This is commonly called \"pagination\". Because the user interface would normally show a \"page\" of a predefined number of heroes at a time. And then you can interact with the user interface to get the next page, and so on. How do we get the next 3? We can use .offset(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).offset(3).limit(3) results = session.exec(statement) heroes = results.all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The way this works is that the special select object we get from select() has methods like .where(), .offset() and .limit(). Each of those methods applies the change in the internal special select statement object, and also return the same object, this way, we can continue using more methods on it, like in the example above that we use both .offset() and .limit(). Offset means \"skip this many rows\", and as we want to skip the ones we already saw, the first three, we use .offset(3). Run the Program with Offset on the Command LineÂ¶ Now we can run the program on the command line, and it will output: Select Next BatchÂ¶ Then to get the next batch of 3 rows we would offset all the ones we already saw, the first 6: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).offset(6).limit(3) results = session.exec(statement) heroes = results.all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview The database right now has only 7 rows, so this query can only get 1 row. But don't worry, the database won't throw an error trying to get 3 rows when there's only one (as would happen with a Python list). The database knows that we want to limit the number of results, but it doesn't necessarily have to find that many results. Run the Program with the Last Batch on the Command LineÂ¶ And if we run it in the command line, it will output: SQL with LIMIT and OFFSETÂ¶ You probably noticed the new SQL keywords LIMIT and OFFSET. You can use them in SQL, at the end of the other parts: SELECT id, name, secret_name, age FROM hero LIMIT 3 OFFSET 6 If you try that in DB Browser for SQLite, you will get the same result: Combine Limit and Offset with WhereÂ¶ Of course, you can also combine .limit() and .offset() with .where() and other methods you will learn about later: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age > 32).offset(1).limit(2) results = session.exec(statement) heroes = results.all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Run the Program with Limit, Offset, and Where on the Command LineÂ¶ If we run it on the command line, it will find all the heroes in the database with an age above 32. That would normally be 4 heroes. But we are starting to include after an offset of 1 (so we don't count the first one), and we are limiting the results to only get the first 2 after that: RecapÂ¶ Independently of how you filter the data with .where() or other methods, you can limit the query to get at maximum some number of results with .limit(). And the same way, you can skip the first results with .offset(). Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read One Row - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/one/",
    "html": "Skip to content SQLModel Read One Row Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Continue From Previous Code Read the First Row First or None Exactly One Exactly One with More Data Exactly One with No Data Compact Version Select by Id with .where() Select by Id with .get() Select by Id with .get() with No Data Recap SQLModel Tutorial - User Guide Read One RowÂ¶ You already know how to filter rows to select using .where(). And you saw how when executing a select() it normally returns an iterable object. Or you can call results.all() to get a list of all the rows right away, instead of an iterable. But in many cases you really just want to read a single row, and having to deal with an iterable or a list is not as convenient. Let's see the utilities to read a single row. Continue From Previous CodeÂ¶ We'll continue with the same examples we have been using in the previous chapters to create and select data and we'll keep updating them. ðŸ‘€ Full file preview If you already executed the previous examples and have a database with data, remove the database file before running each example, that way you won't have duplicate data and you will be able to get the same results. Read the First RowÂ¶ We have been iterating over the rows in a result object like: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age <= 35) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview But let's say that we are not interested in all the rows, just the first one. We can call the .first() method on the results object to get the first row: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age <= 35) results = session.exec(statement) hero = results.first() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This will return the first object in the results (if there was any). That way, we don't have to deal with an iterable or a list. Tip Notice that .first() is a method of the results object, not of the select() statement. Although this query would find two rows, by using .first() we get only the first row. If we run it in the command line it would output: First or NoneÂ¶ It would be possible that the SQL query doesn't find any row. In that case, .first() will return None: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age < 25) results = session.exec(statement) hero = results.first() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview In this case, as there's no hero with an age less than 25, .first() will return None. When we run it in the command line it will output: Exactly OneÂ¶ There might be cases where we want to ensure that there's exactly one row matching the query. And if there was more than one, it would mean that there's an error in the system, and we should terminate with an error. In that case, instead of .first() we can use .one(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Deadpond\") results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Here we know that there's only one \"Deadpond\", and there shouldn't be any more than one. If we run it once will output: But if we run it again, as it will create and insert all the heroes in the database again, they will be duplicated, and there will be more than one \"Deadpond\". ðŸ˜± So, running it again, without first deleting the file database.db will output: Exactly One with More DataÂ¶ Of course, even if we don't duplicate the data, we could get the same error if we send a query that finds more than one row and expect exactly one with .one(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age <= 35) results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That would find 2 rows, and would end up with the same error. Exactly One with No DataÂ¶ And also, if we get no rows at all with .one(), it will also raise an error: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age < 25) results = session.exec(statement) hero = results.one() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview In this case, as there are no heroes with an age less than 25, .one() will raise an error. This is what we would get if we run it in the command line: Compact VersionÂ¶ Of course, with .first() and .one() you would also probably write all that in a more compact form most of the time, all in a single line (or at least a single Python statement): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: hero = session.exec(select(Hero).where(Hero.name == \"Deadpond\")).one() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That would result in the same as some examples above. Select by Id with .where()Â¶ In many cases you might want to select a single row by its Id column with the primary key. You could do it the same way we have been doing with a .where() and then getting the first item with .first(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.id == 1) results = session.exec(statement) hero = results.first() print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That would work correctly, as expected. But there's a shorter version. ðŸ‘‡ Select by Id with .get()Â¶ As selecting a single row by its Id column with the primary key is a common operation, there's a shortcut for it: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: hero = session.get(Hero, 1) print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview session.get(Hero, 1) is an equivalent to creating a select(), then filtering by Id using .where(), and then getting the first item with .first(). If you run it, it will output: Select by Id with .get() with No DataÂ¶ .get() behaves similar to .first(), if there's no data it will simply return None (instead of raising an error): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: hero = session.get(Hero, 9001) print(\"Hero:\", hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Running that will output: RecapÂ¶ As querying the SQL database for a single row is a common operation, you know have several tools to do it in a short and simple way. ðŸŽ‰ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Indexes - Optimize Queries - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/indexes/",
    "html": "Skip to content SQLModel Indexes - Optimize Queries Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents No Time to Explain What is an Index An Index and a Dictionary An Index and a Novel A Technical Book with an Index What are Database Indexes Updating the Index Index Cost Create an Index with SQL Declare Indexes with SQLModel Query Data Run the Program More Indexes Primary Key and Indexes Recap SQLModel Tutorial - User Guide Indexes - Optimize QueriesÂ¶ We just saw how to get some data WHERE a condition is true. For example, where the hero name is \"Deadpond\". If we just create the tables and the data as we have been doing, when we SELECT some data using WHERE, the database would have to scan through each one of the records to find the ones that match. This is not a problem with 3 heroes as in these examples. But imagine that your database has thousands or millions of records, if every time you want to find the heroes with the name \"Deadpond\" it has to scan through all of the records to find all the possible matches, then that becomes problematic, as it would be too slow. I'll show you how to handle it with a database index. The change in the code is extremely small, but it's useful to understand what's happening behind the scenes, so I'll show you how it all works and what it means. If you already executed the previous examples and have a database with data, remove the database file before running each example, that way you won't have duplicate data and you will be able to get the same results. No Time to ExplainÂ¶ Are you already a SQL expert and don't have time for all my explanations? Fine, in that case, you can sneak peek the final code to create indexes here. ðŸ‘€ Full file preview ..but if you are not an expert, continue reading, this will probably be useful. ðŸ¤“ What is an IndexÂ¶ In general, an index is just something we can have to help us find things faster. It normally works by having things in order. Let's think about some real-life examples before even thinking about databases and code. An Index and a DictionaryÂ¶ Imagine a dictionary, a book with definitions of words. ðŸ“” ...not a Python dict. ðŸ˜… Let's say that you want to find a word, for example the word \"database\". You take the dictionary, and open it somewhere, for example in the middle. Maybe you see some definitions of words that start with m, like manual, so you conclude that you are in the letter m in the dictionary. You know that in the alphabet, the letter d for database comes before the letter m for manual. So, you know you have to search in the dictionary before the point you currently are. You still don't know where the word database is, because you don't know exactly where the letter d is in the dictionary, but you know that it is not after that point, you can now discard the right half of the dictionary in your search. Next, you open the dictionary again, but only taking into account the half of the dictionary that can contain the word you want, the left part of the dictionary. You open it in the middle of that left part and now you arrive maybe at the letter f. You know that d from database comes before f. So it has to be before that. But now you know that database is not after that point, and you can discard the dictionary from that point onward. Now you have a small section of dictionary to search (only a quarter of dictionary can have your word). You take that quarter of the pages at the start of the dictionary that can contain your word, and open it in the middle of that section. Maybe you arrive at the letter c. You know the word database has to be after that and not before that point, so you can discard the left part of that block of pages. You repeat this process a few more times, and you finally arrive at the letter d, you continue with the same process in that section for the letter d and you finally find the word database. ðŸŽ‰ You had to open the dictionary a few times, maybe 5 or 10. That's actually very little work compared to what it could have been. Technical Details Do you like fancy words? Cool! Programmers tend to like fancy words. ðŸ˜… That algorithm I showed you above is called Binary Search. It's called like that because you search something by splitting the dictionary (or any ordered list of things) in two (\"binary\" means \"two\") parts. And you do that process multiple times until you find what you want. An Index and a NovelÂ¶ Let's now imagine you are reading a novel book. And someone told you that at some point, they mention a database, and you want to find that chapter. How do you find the word \"database\" there? You might have to read the entire book to find where the word \"database\" is located in the book. So, instead of opening the book 5 or 10 times, you would have to open each of the 500 pages and read them one by one until you find the word. You might enjoy the book, though. ðŸ˜… But if we are only interested in quickly finding information (as when working with SQL databases), then reading each of the 500 pages is too inefficient when there could be an option to open the book in 5 or 10 places and find what you're looking for. A Technical Book with an IndexÂ¶ Now let's imagine you are reading a technical book. For example, with several topics about programming. And there's a couple of sections where it talks about a database. This book might have a book index: a section in the book that has some names of topics covered and the page numbers in the book where you can read about them. And the topic names are sorted in alphabetic order, pretty much like a dictionary (a book with words, as in the previous example). In this case, you can open that book in the end (or in the beginning) to find the book index section, it would have only a few pages. And then, you can do the same process as with the dictionary example above. Open the index, and after 5 or 10 steps, quickly find the topic \"database\" with the page numbers where that is covered, for example \"page 253 in Chapter 5\". Now you used the dictionary technique to find the topic, and that topic gave you a page number. Now you know that you need to find \"page 253\". But by looking at the closed book you still don't know where that page is, so you have to find that page. To find it, you can do the same process again, but this time, instead of searching for a topic in the index, you are searching for a page number in the entire book. And after 5 or 10 more steps, you find the page 253 in Chapter 5. After this, even though this book is not a dictionary and has some particular content, you were able to find the section in the book that talks about a \"database\" in a few steps (say 10 or 20, instead of reading all the 500 pages). The main point is that the index is sorted, so we can use the same process we used for the dictionary to find the topic. And then that gives us a page number, and the page numbers are also sorted! ðŸ˜… When we have a list of sorted things we can apply the same technique, and that's the whole trick here, we use the same technique first for the topics in the index and then for the page numbers to find the actual chapter. Such efficiency! ðŸ˜Ž What are Database IndexesÂ¶ Database indexes are very similar to book indexes. Database indexes store some info, some keys, in a way that makes it easy and fast to find (for example sorted), and then for each key they point to some data somewhere else in the database. Let's see a more clear example. Let's say you have this table in a database: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 And let's imagine you have many more rows, many more heroes. Probably thousands. If you tell the SQL database to get you a hero by a specific name, for example Spider-Boy (by using the name in the WHERE part of the SQL query), the database will have to scan all the heroes, checking one by one to find all the ones with a name of Spider-Boy. In this case, there's only one, but there's nothing limiting the database from having more records with the same name. And because of that, the database would continue searching and checking each one of the records, which would be very slow. But now let's say that the database has an index for the column name. The index could look something like this, we could imagine that the index is like an additional special table that the database manages automatically: name id Deadpond 1 Rusty-Man 3 Spider-Boy 2 It would have each name field from the hero table in order. It would not be sorted by id, but by name (in alphabetical order, as the name is a string). So, first it would have Deadpond, then Rusty-Man, and last Spider-Boy. It would also include the id of each hero. Remember that this could have thousands of heroes. Then the database would be able to use more or less the same ideas in the examples above with the dictionary and the book index. It could start somewhere (for example, in the middle of the index). It could arrive at some hero there in the middle, like Rusty-Man. And because the index has the name fields in order, the database would know that it can discard all the previous index rows and only search in the following index rows. name id Deadpond 1 Rusty-Man 3 Spider-Boy 2 And that way, as with the example with the dictionary above, instead of reading thousands of heroes, the database would be able to do a few steps, say 5 or 10 steps, and arrive at the row of the index that has Spider-Boy, even if the table (and index) has thousands of rows: name id Deadpond 1 Rusty-Man 3 âœ¨ Spider-Boy âœ¨ 2 Then by looking at this index row, it would know that the id for Spider-Boy in the hero table is 2. So then it could search that id in the hero table using more or less the same technique. That way, in the end, instead of reading thousands of records, the database only had to do a few steps to find the hero we wanted. Updating the IndexÂ¶ As you can imagine, for all this to work, the index would need to be up to date with the data in the database. If you had to update it manually in code, it would be very cumbersome and error-prone, as it would be easy to end up in a state where the index is not up to date and points to incorrect data. ðŸ˜± Here's the good news: when you create an index in a SQL Database, the database takes care of updating it automatically whenever it's necessary. ðŸ˜ŽðŸŽ‰ If you add new records to the hero table, the database will automatically update the index. It will do the same process of finding the right place to put the new index data (those 5 or 10 steps described above), and then it will save the new index information there. The same would happen when you update or delete data. Defining and creating an index is very easy with SQL databases. And then using it is even easier... it's transparent. The database will figure out which index to use automatically, the SQL queries don't even change. So, in SQL databases indexes are great! And are super easy to use. Why not just have indexes for everything? .....Because indexes also have a \"cost\" in computation and storage (disk space). Index CostÂ¶ There's a cost associated with indexes. ðŸ’° When you don't have an index and add a new row to the table hero, the database has to perform 1 operation to add the new hero row at the end of the table. But if you have an index for the hero names, now the database has to perform the same 1 operation to add that row plus some extra 5 or 10 operations in the index, to find the right spot for the name, to then add that index record there. And if you have an index for the name, one for the age, and one for the secret_name, now the database has to perform the same 1 operation to add that row plus some extra 5 or 10 operations in the index times 3, for each of the indexes. This means that now adding one row takes something like 31 operations. This also means that you are exchanging the time it takes to read data for the time it takes to write data plus some extra space in the database. If you have queries that get data out of the database comparing each one of those fields (for example using WHERE), then it makes total sense to have indexes for each one of them. Because 31 operations while creating or updating data (plus the space of the index) is much, much better than the possible 500 or 1000 operations to read all the rows to be able to compare them using each field. But if you never have queries that find records by the secret_name (you never use secret_name in the WHERE part) it probably doesn't make sense to have an index for the secret_name field/column, as that will increase the computational and space cost of writing and updating the database. Create an Index with SQLÂ¶ Phew, that was a lot of theory and explanations. ðŸ˜… The most important thing about indexes is understanding them, how, and when to use them. Let's now see the SQL syntax to create an index. It is very simple: CREATE INDEX ix_hero_name ON hero (name) This means, more or less: Hey SQL database ðŸ‘‹, please CREATE an INDEX for me. I want the name of the index to be ix_hero_name. This index should be ON the table hero, it refers to that table. The column I want you to use for it is name. Declare Indexes with SQLModelÂ¶ And now let's see how to define indexes in SQLModel. The change in code is underwhelming, it's very simple. ðŸ˜† Here's the Hero model we had before: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Let's now update it to tell SQLModel to create an index for the name field when creating the table: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We use the same Field() again as we did before, and set index=True. That's it! ðŸš€ Notice that we didn't set an argument of default=None or anything similar. This means that SQLModel (thanks to Pydantic) will keep it as a required field. Info SQLModel (actually SQLAlchemy) will automatically generate the index name for you. In this case the generated name would be ix_hero_name. Query DataÂ¶ Now, to query the data using the field name and the new index we don't have to do anything special or different in the code, it's just the same code. The SQL database will figure it out automatically. âœ¨ This is great because it means that indexes are very simple to use. But it might also feel counterintuitive at first, as you are not doing anything explicitly in the code to make it obvious that the index is useful, it all happens in the database behind the scenes. # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Deadpond\") results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is exactly the same code as we had before, but now the database will use the index underneath. Run the ProgramÂ¶ If you run the program now, you will see an output like this: More IndexesÂ¶ We are going to query the hero table doing comparisons on the age field too, so we should define an index for that one as well: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str = Field(index=True) secret_name: str age: Optional[int] = Field(default=None, index=True) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview In this case, we want the default value of age to continue being None, so we set default=None when using Field(). Now when we use SQLModel to create the database and tables, it will also create the indexes for these two columns in the hero table. So, when we query the database for the hero table and use those two columns to define what data we get, the database will be able to use those indexes to improve the reading performance. ðŸš€ Primary Key and IndexesÂ¶ You probably noticed that we didn't set index=True for the id field. Because the id is already the primary key, the database will automatically create an internal index for it. The database always creates an internal index for primary keys automatically, as those are the primary way to organize, store, and retrieve data. ðŸ¤“ But if you want to be frequently querying the SQL database for any other field (e.g. using any other field in the WHERE section), you will probably want to have at least an index for that. RecapÂ¶ Indexes are very important to improve reading performance and speed when querying the database. ðŸŽ Creating and using them is very simple and easy. The most important part is to understand how they work, when to create them, and for which columns. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Filter Data - WHERE - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/where/",
    "html": "Skip to content SQLModel Filter Data - WHERE Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Continue From Previous Code Filter Data with SQL WHERE and FROM are \"clauses\" SELECT and WHERE SELECT Land WHERE Land Review SELECT with SQLModel Filter Rows Using WHERE with SQLModel select() Objects Calling .where() .where() and Expressions Model Class Attributes, Expressions, and Instances Class or Instance .where() and Expressions Instead of Keyword Arguments Exec the Statement Other Comparisons Not Equal Pause to Add Data More Than More Than or Equal Less Than Less Than or Equal Benefits of Expressions Multiple .where() .where() With Multiple Expressions .where() With Multiple Expressions Using OR Type Annotations and Errors Recap SQLModel Tutorial - User Guide Filter Data - WHEREÂ¶ In the previous chapter we saw how to SELECT data from the database. We did it using pure SQL and using SQLModel. But we always got all the rows, the whole table: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 In most of the cases we will want to get only one row, or only a group of rows. We will see how to do that now, to filter data and get only the rows where a condition is true. Continue From Previous CodeÂ¶ We'll continue with the same examples we have been using in the previous chapters to create and select data. And now we will update select_heroes() to filter the data. ðŸ‘€ Full file preview If you already executed the previous examples and have a database with data, remove the database file before running each example, that way you won't have duplicate data and you will be able to get the same results. Filter Data with SQLÂ¶ Let's check first how to filter data with SQL using the WHERE keyword. SELECT id, name, secret_name, age FROM hero WHERE name = \"Deadpond\" The first part means the same as before: Hey SQL database ðŸ‘‹, please go and SELECT some data for me. I'll first tell you the columns I want: id name secret_name age And I want you to get them FROM the table called \"hero\". Then the WHERE keyword adds the following: So, SQL database, I already told you what columns to SELECT and where to select them FROM. But I don't want you to bring me all the rows, I only want the rows WHERE the name column has a value of \"Deadpond\". Then the database will bring a table like this: id name secret_name age 1 Deadpond Dive Wilson null Tip Even if the result is only one row, the database always returns a table. In this case, a table with only one row. You can try that out in DB Browser for SQLite: WHERE and FROM are \"clauses\"Â¶ These additional keywords with some sections like WHERE and FROM that go after SELECT (or others) have a technical name, they are called clauses. There are others clauses too, with their own SQL keywords. I won't use the term clause too much here, but it's good for you to know it as it will probably show up in other tutorials you could study later. ðŸ¤“ SELECT and WHEREÂ¶ Here's a quick tip that helps me think about it. SELECT is used to tell the SQL database what columns to return. WHERE is used to tell the SQL database what rows to return. The size of the table in the two dimensions depend mostly on those two keywords. SELECT LandÂ¶ If the table has too many or too few columns, that's changed in the SELECT part. Starting with some table: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 ...and changing the number of columns: name Deadpond Spider-Boy Rusty-Man ...is all SELECT land. WHERE LandÂ¶ If the table has too many or too few rows, that's changed in the WHERE part. Starting with some table: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 ...and changing the number of rows: id name secret_name age 2 Spider-Boy Pedro Parqueador null ...is all WHERE land. Review SELECT with SQLModelÂ¶ Let's review some of the code we used to read data with SQLModel. We care specially about the select statement: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Filter Rows Using WHERE with SQLModelÂ¶ Now, the same way that we add WHERE to a SQL statement to filter rows, we can add a .where() to a SQLModel select() statement to filter rows, which will filter the objects returned: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Deadpond\") results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview It's a very small change, but it's packed of details. Let's explore them. select() ObjectsÂ¶ The object returned by select(Hero) is a special type of object with some methods. One of those methods is .where() used to (unsurprisingly) add a WHERE to the SQL statement in that select object. There are other methods that we will explore later. ðŸ’¡ Most of these methods return the same object again after modifying it. So we could call one after the other: statement = select(Hero).where(Hero.name == \"Deadpond\").where(Hero.age == 48) Calling .where()Â¶ Now, this .where() method is special and very powerful. It is tightly integrated with SQLModel (actually SQLAlchemy) to let you use very familiar Python syntax and code. Notice that we didn't call it with a single equal (=) sign, and with something like: # Not supported ðŸš¨ select(Hero).where(name=\"Deadpond\") That would have been shorter, of course, but it would have been much more error prone and limited. I'll show you why in a bit. Instead, we used two ==: select(Hero).where(Hero.name == \"Deadpond\") So, what's happening there? .where() and ExpressionsÂ¶ In the example above we are using two equal signs (==). That's called the \"equality operator\". Tip An operator is just a symbol that is put beside one value or in the middle of two values to do something with them. == is called the equality operator because it checks if two things are equal. When writing Python, if you write something using this equality operator (==) like: some_name == \"Deadpond\" ...that's called an equality \"comparison\", and it normally results in a value of: True ...or False Tip <, >, ==, >=, <=, and != are all operators used for comparisons. But SQLAlchemy adds some magic to the columns/fields in a model class to make those Python comparisons have super powers. So, if you write something like: Hero.name == \"Deadpond\" ...that doesn't result in a value of True or False. ðŸ¤¯ Instead, it results in a special type of object. If you tried that in an interactive Python session, you'd see something like: >>> Hero.name == \"Deadpond\" So, that result value is an expression object. ðŸ’¡ And .where() takes one (or more) of these expression objects to update the SQL statement. Model Class Attributes, Expressions, and InstancesÂ¶ Now, let's stop for a second to make a clear distinction that is very important and easy to miss. Model class attributes for each of the columns/fields are special and can be used for expressions. But that's only for the model class attributes. ðŸš¨ Instance attributes behave like normal Python values. âœ… So, using the class (Hero, with capital H) in a Python comparison: Hero.name == \"Deadpond\" ...results in one of those expression objects to be used with .where(): But if you take an instance: some_hero = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") ...and use it in a comparison: some_hero.name == \"Deadpond\" ...that results in a Python value of: True ...or if it was a different object with a different name, it could have been: False The difference is that one is using the model class, the other is using an instance. Class or InstanceÂ¶ It's quite probable that you will end up having some variable hero (with lowercase h) like: hero = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") And now the class is Hero (with capital H) and the instance is hero (with a lowercase h). So now you have Hero.name and hero.name that look very similar, but are two different things: >>> Hero.name == \"Deadpond\" >>> hero.name == \"Deadpond\" True It's just something to pay attention to. ðŸ¤“ But after understanding that difference between classes and instances it can feel natural, and you can do very powerful things. ðŸš€ For example, as hero.name works like a str and Hero.name works like a special object for comparisons, you could write some code like: select(Hero).where(Hero.name == hero.name) That would mean: Hey SQL Database ðŸ‘‹, please SELECT all the columns FROM the table for the model class Hero (the table \"hero\") WHERE the column \"name\" is equal to the name of this hero instance I have here: hero.name (in the example above, the value \"Deadpond\"). .where() and Expressions Instead of Keyword ArgumentsÂ¶ Now, let me tell you why I think that for this use case of interacting with SQL databases it's better to have these expressions: # Expression âœ¨ select(Hero).where(Hero.name == \"Deadpond\") ...instead of keyword arguments like this: # Not supported, keyword argument ðŸš¨ select(Hero).where(name=\"Deadpond\") Of course, the keyword arguments would have been a bit shorter. But with the expressions your editor can help you a lot with autocompletion and inline error checks. âœ¨ Let me give you an example. Let's imagine that keyword arguments were supported in SQLModel and you wanted to filter using the secret identity of Spider-Boy. You could write: # Don't copy this ðŸš¨ select(Hero).where(secret_identity=\"Pedro Parqueador\") The editor would see the code, and because it doesn't have any information of which keyword arguments are allowed and which not, it would have no way to help you detect the error. Maybe your code could even run and seem like it's all fine, and then some months later you would be wondering why your app never finds rows although you were sure that there was one \"Pedro Parqueador\". ðŸ˜± And maybe finally you would realize that we wrote the code using secret_identity which is not a column in the table. We should have written secret_name instead. Now, with the expressions, your editor would show you an error right away if you tried this: # Expression âœ¨ select(Hero).where(Hero.secret_identity == \"Pedro Parqueador\") Even better, it would autocomplete the correct one for you, to get: select(Hero).where(Hero.secret_name == \"Pedro Parqueador\") I think that alone, having better editor support, autocompletion, and inline errors, is enough to make it worth having expressions instead of keyword arguments. âœ¨ Tip Expressions also provide more features for other types of comparisons, shown down below. ðŸ‘‡ Exec the StatementÂ¶ Now that we know how .where() works, let's finish the code. It's actually the same as in previous chapters for selecting data: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Deadpond\") results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview We take that statement, that now includes a WHERE, and we exec() it to get the results. And in this case the results will be just one: Tip The results object is an iterable to be used in a for loop. Even if we got only one row, we iterate over that results object. Just as if it was a list of one element. We'll see other ways to get the data later. Other ComparisonsÂ¶ Here's another great advantage of these special expressions passed to .where(). Above, we have been using an \"equality\" comparison (using ==), only checking if two things are the same value. But we can use other standard Python comparisons. âœ¨ Not EqualÂ¶ We could get the rows where a column is not equal to a value using !=: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.name != \"Deadpond\") results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That would output: secret_name='Pedro Parqueador' age=None id=2 name='Spider-Boy' secret_name='Tommy Sharp' age=48 id=3 name='Rusty-Man' Pause to Add DataÂ¶ Let's update the function create_heroes() and add some more rows to make the next comparison examples clearer: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) hero_4 = Hero(name=\"Tarantula\", secret_name=\"Natalia Roman-on\", age=32) hero_5 = Hero(name=\"Black Lion\", secret_name=\"Trevor Challa\", age=35) hero_6 = Hero(name=\"Dr. Weird\", secret_name=\"Steve Weird\", age=36) hero_7 = Hero(name=\"Captain North America\", secret_name=\"Esteban Rogelios\", age=93) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.add(hero_4) session.add(hero_5) session.add(hero_6) session.add(hero_7) session.commit() # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Now that we have several heroes with different ages, it's gonna be more obvious what the next comparisons do. More ThanÂ¶ Now let's use > to get the rows where a column is more than a value: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age > 35) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That would output: age=48 id=3 name='Rusty-Man' secret_name='Tommy Sharp' age=36 id=6 name='Dr. Weird' secret_name='Steve Weird' age=93 id=7 name='Captain North America' secret_name='Esteban Rogelios' Tip Notice that it didn't select Black Lion, because the age is not strictly greater than 35. More Than or EqualÂ¶ Let's do that again, but with >= to get the rows where a column is more than or equal to a value: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age >= 35) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Because we are using >=, the age 35 will be included in the output: age=48 id=3 name='Rusty-Man' secret_name='Tommy Sharp' age=35 id=5 name='Black Lion' secret_name='Trevor Challa' age=36 id=6 name='Dr. Weird' secret_name='Steve Weird' age=93 id=7 name='Captain North America' secret_name='Esteban Rogelios' Tip This time we got Black Lion too because although the age is not strictly greater than 35it is equal to 35. Less ThanÂ¶ Similarly, we can use < to get the rows where a column is less than a value: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age < 35) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And we get the younger one with an age in the database: age=32 id=4 name='Tarantula' secret_name='Natalia Roman-on' Tip We could imagine that Spider-Boy is even younger. But because we don't know the age, it is NULL in the database (None in Python), it doesn't match any of these age comparisons with numbers. Less Than or EqualÂ¶ Finally, we can use <= to get the rows where a column is less than or equal to a value: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age <= 35) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And we get the younger ones, 35 and below: age=32 id=4 name='Tarantula' secret_name='Natalia Roman-on' age=35 id=5 name='Black Lion' secret_name='Trevor Challa' Tip We get Black Lion here too because although the age is not strictly less than 35 it is equal to 35. Benefits of ExpressionsÂ¶ Here's a good moment to see that being able to use these pure Python expressions instead of keyword arguments can help a lot. âœ¨ We can use the same standard Python comparison operators like <, <=, >, >=, ==, etc. Multiple .where()Â¶ Because .where() returns the same special select object back, we can add more .where() calls to it: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age >= 35).where(Hero.age < 40) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This will select the rows WHERE the age is greater than or equal to 35, AND also the age is less than 40. The equivalent SQL would be: SELECT id, name, secret_name, age FROM hero WHERE age >= 35 AND age < 40 This uses AND to put both comparisons together. We can then run it to see the output from the program: .where() With Multiple ExpressionsÂ¶ As an alternative to using multiple .where() we can also pass several expressions to a single .where(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(Hero.age >= 35, Hero.age < 40) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This is the same as the above, and will result in the same output with the two heroes: age=35 id=5 name='Black Lion' secret_name='Trevor Challa' age=36 id=6 name='Dr. Weird' secret_name='Steve Weird' .where() With Multiple Expressions Using ORÂ¶ These last examples use where() with multiple expressions. And then those are combined in the final SQL using AND, which means that all of the expressions must be true in a row for it to be included in the results. But we can also combine expressions using OR. Which means that any (but not necessarily all) of the expressions should be true in a row for it to be included. To do it, you can import or_: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, or_, select # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And then pass both expressions to or_() and put it inside .where(). For example, here we select the heroes that are the youngest OR the oldest: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(or_(Hero.age <= 35, Hero.age > 90)) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview When we run it, this generates the output: Type Annotations and ErrorsÂ¶ There's a chance that your editor gives you an error when using these comparisons, like: Hero.age > 35 It would be an error telling you that Hero.age is potentially None, and you cannot compare None with > This is because as we are using pure and plain Python annotations for the fields, age is indeed annotated as Optional[int], which means int or None. By using this simple and standard Python type annotations we get the benefit of the extra simplicity and the inline error checks when creating or using instances. âœ¨ And when we use these special class attributes in a .where(), during execution of the program, the special class attribute will know that the comparison only applies for the values that are not NULL in the database, and it will work correctly. But the editor doesn't know that it's a special class attribute, so it tries to help us preventing an error (that in this case is a false alarm). Nevertheless, we can easily fix. ðŸŽ‰ We can tell the editor that this class attribute is actually a special SQLModel column (instead of an instance attribute with a normal value). To do that, we can import col() (as short for \"column\"): from typing import Optional from sqlmodel import Field, Session, SQLModel, col, create_engine, select # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And then put the class attribute inside col() when using it in a .where(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero).where(col(Hero.age) >= 35) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview So, now the comparison is not: Hero.age > 35 ...but: col(Hero.age) > 35 And with that the editor knows this code is actually fine, because this is a special SQLModel column. Tip That col() will come handy later, giving autocompletion to several other things we can do with these special class attributes for columns. But we'll get there later. RecapÂ¶ You can use .where() with powerful expressions using SQLModel columns (the special class attributes) to filter the rows that you want. ðŸš€ Up to now, the database would have been looking through each one of the records (rows) to find the ones that match what you want. If you have thousands or millions of records, this could be very slow. ðŸ˜± In the next section I'll tell you how to add indexes to the database, this is what will make the queries very efficient. ðŸ˜Ž Made with Material for MkDocs Insiders"
  },
  {
    "title": "Read Data - SELECT - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/select/",
    "html": "Skip to content SQLModel Read Data - SELECT Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Continue From Previous Code Read Data with SQL A SQL Shortcut SELECT Fewer Columns SELECT Variants Result Tables Don't Have to Exist Read Data with SQLModel Create a Session Create a select Statement Execute the Statement Iterate Through the Results Add select_heroes() to main() Review The Code Get a List of Hero Objects Compact Version SQLModel or SQLAlchemy - Technical Details SQLModel's select SQLModel's session.exec Caveats of SQLModel Flavor SQLModel Tutorial - User Guide Read Data - SELECTÂ¶ We already have a database and a table with some data in it that looks more or less like this: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 Things are getting more exciting! Let's now see how to read data from the database! ðŸ¤© Continue From Previous CodeÂ¶ Let's continue from the last code we used to create some data. ðŸ‘€ Full file preview We are creating a SQLModel Hero class model and creating some records. We will need the Hero model and the engine, but we will create a new session to query data in a new function. Read Data with SQLÂ¶ Before writing Python code let's do a quick review of how querying data with SQL looks like: SELECT id, name, secret_name, age FROM hero It means, more or less: Hey SQL database ðŸ‘‹, please go and SELECT some data for me. I'll first tell you the columns I want: id name secret_name age And I want you to get them FROM the table called \"hero\". Then the database will go and get the data and return it to you in a table like this: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 You can try that out in DB Browser for SQLite: Warning Here we are getting all the rows. If you have thousands of rows, that could be expensive to compute for the database. You would normally want to filter the rows to receive only the ones you want. But we'll learn about that later in the next chapter. A SQL ShortcutÂ¶ If we want to get all the columns like in this case above, in SQL there's a shortcut, instead of specifying each of the column names we could write a *: SELECT * FROM hero That would end up in the same result. Although we won't use that for SQLModel. SELECT Fewer ColumnsÂ¶ We can also SELECT fewer columns, for example: SELECT id, name FROM hero Here we are only selecting the id and name columns. And it would result in a table like this: id name 1 Deadpond 2 Spider-Boy 3 Rusty-Man And here is something interesting to notice. SQL databases store their data in tables. And they also always communicate their results in tables. SELECT VariantsÂ¶ The SQL language allows several variations in several places. One of those variations is that in SELECT statements you can use the names of the columns directly, or you can prefix them with the name of the table and a dot. For example, the same SQL code above could be written as: SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero This will be particularly important later when working with multiple tables at the same time that could have the same name for some columns. For example hero.id and team.id, or hero.name and team.name. Another variation is that most of the SQL keywords like SELECT can also be written in lowercase, like select. Result Tables Don't Have to ExistÂ¶ This is the interesting part. The tables returned by SQL databases don't have to exist in the database as independent tables. ðŸ§™ For example, in our database, we only have one table that has all the columns, id, name, secret_name, age. And here we are getting a result table with fewer columns. One of the main points of SQL is to be able to keep the data structured in different tables, without repeating data, etc, and then query the database in many ways and get many different tables as a result. Read Data with SQLModelÂ¶ Now let's do the same query to read all the heroes, but with SQLModel. Create a SessionÂ¶ The first step is to create a Session, the same way we did when creating the rows. We will start with that in a new function select_heroes(): # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Create a select StatementÂ¶ Next, pretty much the same way we wrote a SQL SELECT statement above, now we'll create a SQLModel select statement. First we have to import select from sqlmodel at the top of the file: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select # More code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And then we will use it to create a SELECT statement in Python code: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select # More code here omitted ðŸ‘ˆ def select_heroes(): with Session(engine) as session: statement = select(Hero) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview It's a very simple line of code that conveys a lot of information: statement = select(Hero) This is equivalent to the first SQL SELECT statement above: SELECT id, name, secret_name, age FROM hero We pass the class model Hero to the select() function. And that tells it that we want to select all the columns necessary for the Hero class. And notice that in the select() function we don't explicitly specify the FROM part. It is already obvious to SQLModel (actually to SQLAlchemy) that we want to select FROM the table hero, because that's the one associated with the Hero class model. Tip The value of the statement returned by select() is a special object that allows us to do other things. I'll tell you about that in the next chapters. Execute the StatementÂ¶ Now that we have the select statement, we can execute it with the session: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero) results = session.exec(statement) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview This will tell the session to go ahead and use the engine to execute that SELECT statement in the database and bring the results back. Because we created the engine with echo=True, it will show the SQL it executes in the output. This session.exec(statement) will generate this output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero INFO Engine [no key 0.00032s] () The database returns the table with all the data, just like above when we wrote SQL directly: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 Iterate Through the ResultsÂ¶ The results object is an iterable that can be used to go through each one of the rows. Now we can put it in a for loop and print each one of the heroes: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero) results = session.exec(statement) for hero in results: print(hero) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This will print the output: id=1 name='Deadpond' age=None secret_name='Dive Wilson' id=2 name='Spider-Boy' age=None secret_name='Pedro Parqueador' id=3 name='Rusty-Man' age=48 secret_name='Tommy Sharp' Add select_heroes() to main()Â¶ Now include a call to select_heroes() in the main() function so that it is executed when we run the program from the command line: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero) results = session.exec(statement) for hero in results: print(hero) def main(): create_db_and_tables() create_heroes() select_heroes() # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Review The CodeÂ¶ Great, you're now being able to read the data from the database! ðŸŽ‰ Let's review the code up to this point: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select Import from sqlmodel everything we will use, including the new select() function. class Hero(SQLModel, table=True): Create the Hero class model, representing the hero table. id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) Create the engine, we should use a single one shared by all the application code, and that's what we are doing here. def create_db_and_tables(): SQLModel.metadata.create_all(engine) Create all the tables for the models registered in SQLModel.metadata. This also creates the database if it doesn't exist already. def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") Create each one of the Hero objects. You might not have this in your version if you had already created the data in the database. hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) with Session(engine) as session: Create a new session and use it to add the heroes to the database, and then commit the changes. session.add(hero_1) session.add(hero_2) session.add(hero_3) session.commit() def select_heroes(): with Session(engine) as session: Create a new session to query data. !!! tip Notice that this is a new session independent from the one in the other function above. But it still uses the same **engine**. We still have one engine for the whole application. statement = select(Hero) Use the select() function to create a statement selecting all the Hero objects. This selects all the rows in the hero table. results = session.exec(statement) Use session.exec(statement) to make the session use the engine to execute the internal SQL statement. This will go to the database, execute that SQL, and get the results back. It returns a special iterable object that we put in the variable results. This generates the output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero INFO Engine [no key 0.00032s] () for hero in results: Iterate for each Hero object in the results. print(hero) Print each hero. The 3 iterations in the for loop will generate this output: id=1 name='Deadpond' age=None secret_name='Dive Wilson' id=2 name='Spider-Boy' age=None secret_name='Pedro Parqueador' id=3 name='Rusty-Man' age=48 secret_name='Tommy Sharp' At this point, after the with block, the session is closed. This generates the output: INFO Engine ROLLBACK def main(): create_db_and_tables() create_heroes() select_heroes() Add this function select_heroes() to the main() function so that it is called when we run this program from the command line. if __name__ == \"__main__\": main() Tip Check out the number bubbles to see what is done by each line of code. Here it starts to become more evident why we should have a single engine for the whole application, but different sessions for each group of operations. This new session we created uses the same engine, but it's a new and independent session. The code above creating the models could, for example, live in a function handling web API requests and creating models. And the second section reading data from the database could be in another function for other requests. So, both sections could be in different places and would need their own sessions. Info To be fair, in this example all that code could actually share the same session, there's actually no need to have two here. But it allows me to show you how they could be separated and to reinforce the idea that you should have one engine per application, and multiple sessions, one per each group of operations. Get a List of Hero ObjectsÂ¶ Up to now we are using the results to iterate over them. But for different reasons you might want to have the full list of Hero objects right away instead of just an iterable. For example, if you want to return them in a web API. The special results object also has a method results.all() that returns a list with all the objects: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: statement = select(Hero) results = session.exec(statement) heroes = results.all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview With this now we have all the heroes in a list in the heroes variable. After printing it, we would see something like: [ Hero(id=1, name='Deadpond', age=None, secret_name='Dive Wilson'), Hero(id=2, name='Spider-Boy', age=None, secret_name='Pedro Parqueador'), Hero(id=3, name='Rusty-Man', age=48, secret_name='Tommy Sharp') ] Info It would actually look more compact, I'm formatting it a bit for you to see that it is actually a list with all the data. Compact VersionÂ¶ I have been creating several variables to be able to explain to you what each thing is doing. But knowing what is each object and what it is all doing, we can simplify it a bit and put it in a more compact form: # Code above omitted ðŸ‘† def select_heroes(): with Session(engine) as session: heroes = session.exec(select(Hero)).all() print(heroes) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Here we are putting it all on a single line, you will probably put the select statements in a single line like this more often. SQLModel or SQLAlchemy - Technical DetailsÂ¶ SQLModel is actually, more or less, just SQLAlchemy and Pydantic underneath, combined together. It uses and returns the same types of objects and is compatible with both libraries. Nevertheless, SQLModel defines a few of its own internal parts to improve the developer experience. In this chapter we are touching some of them. SQLModel's selectÂ¶ When importing from sqlmodel the select() function, you are using SQLModel's version of select. SQLAchemy also has it's own select, and SQLModel's select uses SQLAlchemy's select internally. But SQLModel's version does a lot of tricks with type annotations to make sure you get the best editor support possible, no matter if you use VS Code, PyCharm, or something else. âœ¨ Info There was a lot of work and research, with different versions of the internal code, to improve this as much as possible. ðŸ¤“ SQLModel's session.execÂ¶ ðŸ“¢ This is one to pay special attention to. SQLAlchemy's own Session has a method session.execute(). It doesn't have a session.exec() method. If you see SQLAlchemy tutorials, they will always use session.execute(). SQLModel's own Session inherits directly from SQLAlchemy's Session, and adds this additional method session.exec(). Underneath, it uses the same session.execute(). But session.exec() does several tricks combined with the tricks in session() to give you the best editor support, with autocompletion and inline errors everywhere, even after getting data from a select. âœ¨ For example, in SQLAlchemy you would need to add a .scalars() here: heroes = session.execute(select(Hero)).scalars().all() But you would have to remove it when selecting multiple things (we'll see that later). SQLModel's session.exec() takes care of that for you, so you don't have to add the .scalars(). This is something that SQLAlchemy currently can't provide, because the regular session.execute() supports several other use cases, including legacy ones, so it can't have all the internal type annotations and tricks to support this. On top of that, SQLModel's session.exec() also does some tricks to reduce the amount of code you have to write and to make it as intuitive as possible. But SQLModel's Session still has access to session.execute() too. Tip Your editor will give you autocompletion for both session.exec() and session.execute(). ðŸ“¢ Remember to always use session.exec() to get the best editor support and developer experience. Caveats of SQLModel FlavorÂ¶ SQLModel is designed to have the best developer experience in a narrow set of very common use cases. âœ¨ You can still combine it with SQLAlchemy directly and use all the features of SQLAlchemy when you need to, including lower level more \"pure\" SQL constructs, exotic patterns, and even legacy ones. ðŸ¤“ But SQLModel's design (e.g. type annotations) assume you are using it in the ways I explain here in the documentation. Thanks to this, you will get as much autocompletion and inline errors as possible. ðŸš€ But this also means that if you use SQLModel with some more exotic patterns from SQLAlchemy, your editor might tell you that there's an error, while in fact, the code would still work. That's the trade-off. ðŸ¤· But for the situations where you need those exotic patterns, you can always use SQLAlchemy directly combined with SQLModel (using the same models, etc). Made with Material for MkDocs Insiders"
  },
  {
    "title": "Automatic IDs, None Defaults, and Refreshing Data - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/automatic-id-none-refresh/",
    "html": "Skip to content SQLModel Automatic IDs, None Defaults, and Refreshing Data Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create a New Hero Instance How Optional Helps Print the Default id Values Add the Objects to the Session Commit the Changes to the Database Print a Single Field Refresh Objects Explicitly Print Data After Closing the Session Review All the Code Recap SQLModel Tutorial - User Guide Automatic IDs, None Defaults, and Refreshing DataÂ¶ In the previous chapter, we saw how to add rows to the database using SQLModel. Now let's talk a bit about why the id field can't be NULL on the database because it's a primary key, and we declare it using Field(primary_key=True). But the same id field actually can be None in the Python code, so we declare the type with Optional[int], and set the default value to Field(default=None): # Code above omitted ðŸ‘† class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Next, I'll show you a bit more about the synchronization of data between the database and the Python code. When do we get an actual int from the database in that id field? Let's see all that. ðŸ‘‡ Create a New Hero InstanceÂ¶ When we create a new Hero instance, we don't set the id: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview How Optional HelpsÂ¶ Because we don't set the id, it takes the Python's default value of None that we set in Field(default=None). This is the only reason why we define it with Optional and with a default value of None. Because at this point in the code, before interacting with the database, the Python value could actually be None. If we assumed that the id was always an int and added the type annotation without Optional, we could end up writing broken code, like: next_hero_id = hero_1.id + 1 If we ran this code before saving the hero to the database and the hero_1.id was still None, we would get an error like: TypeError: unsupported operand type(s) for +: 'NoneType' and 'int' But by declaring it with Optional[int], the editor will help us to avoid writing broken code by showing us a warning telling us that the code could be invalid if hero_1.id is None. ðŸ” Print the Default id ValuesÂ¶ We can confirm that by printing our heroes before adding them to the database: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) print(\"Before interacting with the database\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview That will output: Notice they all have id=None. That's the default value we defined in the Hero model class. What happens when we add these objects to the session? Add the Objects to the SessionÂ¶ After we add the Hero instance objects to the session, the IDs are still None. We can verify by creating a session using a with block and adding the objects. And then printing them again: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) print(\"Before interacting with the database\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) print(\"After adding to the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview This will, again, output the ids of the objects as None: As we saw before, the session is smart and doesn't talk to the database every time we prepare something to be changed, only after we are ready and tell it to commit the changes it goes and sends all the SQL to the database to store the data. Commit the Changes to the DatabaseÂ¶ Then we can commit the changes in the session, and print again: # Code above omitted ðŸ‘† with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) print(\"After adding to the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) session.commit() print(\"After committing the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And now, something unexpected happens, look at the output, it seems as if the Hero instance objects had no data at all: What happens is that SQLModel (actually SQLAlchemy) is internally marking those objects as \"expired\", they don't have the latest version of their data. This is because we could have some fields updated in the database, for example, imagine a field updated_at: datetime that was automatically updated when we saved changes. The same way, other values could have changed, so the option the session has to be sure and safe is to just internally mark the objects as expired. And then, next time we access each attribute, for example with: current_hero_name = hero_1.name ...SQLModel (actually SQLAlchemy) will make sure to contact the database and get the most recent version of the data, updating that field name in our object and then making it available for the rest of the Python expression. In the example above, at that point, Python would be able to continue executing and use that hero_1.name value (just updated) to put it in the variable current_hero_name. All this happens automatically and behind the scenes. âœ¨ And here's the funny and strange thing with our example: print(\"Hero 1:\", hero_1) We didn't access the object's attributes, like hero.name. We only accessed the entire object and printed it, so SQLAlchemy has no way of knowing that we want to access this object's data. Print a Single FieldÂ¶ To confirm and understand how this automatic expiration and refresh of data when accessing attributes work, we can print some individual fields (instance attributes): # Code above omitted ðŸ‘† with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) print(\"After adding to the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) session.commit() print(\"After committing the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) print(\"After committing the session, show IDs\") print(\"Hero 1 ID:\", hero_1.id) print(\"Hero 2 ID:\", hero_2.id) print(\"Hero 3 ID:\", hero_3.id) print(\"After committing the session, show names\") print(\"Hero 1 name:\", hero_1.name) print(\"Hero 2 name:\", hero_2.name) print(\"Hero 3 name:\", hero_3.name) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Now we are actually accessing the attributes, because instead of printing the whole object hero_1: print(\"Hero 1:\", hero_1) ...we are now printing the id attribute in hero.id: print(\"Hero 1 ID:\", hero_1.id) By accessing the attribute, that triggers a lot of work done by SQLModel (actually SQLAlchemy) underneath to refresh the data from the database, set it in the object's id attribute, and make it available for the Python expression (in this case just to print it). Let's see how it works: Refresh Objects ExplicitlyÂ¶ You just learnt how the session refreshes the data automatically behind the scenes, as a side effect, when you access an attribute. But what if you want to explicitly refresh the data? You can do that too with session.refresh(object): # Code above omitted ðŸ‘† with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) print(\"After adding to the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) session.commit() print(\"After committing the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) print(\"After committing the session, show IDs\") print(\"Hero 1 ID:\", hero_1.id) print(\"Hero 2 ID:\", hero_2.id) print(\"Hero 3 ID:\", hero_3.id) print(\"After committing the session, show names\") print(\"Hero 1 name:\", hero_1.name) print(\"Hero 2 name:\", hero_2.name) print(\"Hero 3 name:\", hero_3.name) session.refresh(hero_1) session.refresh(hero_2) session.refresh(hero_3) print(\"After refreshing the heroes\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview When Python executes this code: session.refresh(hero_1) ...the session goes and makes the engine communicate with the database to get the recent data for this object hero_1, and then the session puts the data in the hero_1 object and marks it as \"fresh\" or \"not expired\". Here's how the output would look like: This could be useful, for example, if you are building a web API to create heroes. And once a hero is created with some data, you return it to the client. You wouldn't want to return an object that looks empty because the automatic magic to refresh the data was not triggered. In this case, after committing the object to the database with the session, you could refresh it, and then return it to the client. This would ensure that the object has its fresh data. Print Data After Closing the SessionÂ¶ Now, as a final experiment, we can also print data after the session is closed. There are no surprises here, it still works: # Code above omitted ðŸ‘† with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) print(\"After adding to the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) session.commit() print(\"After committing the session\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) print(\"After committing the session, show IDs\") print(\"Hero 1 ID:\", hero_1.id) print(\"Hero 2 ID:\", hero_2.id) print(\"Hero 3 ID:\", hero_3.id) print(\"After committing the session, show names\") print(\"Hero 1 name:\", hero_1.name) print(\"Hero 2 name:\", hero_2.name) print(\"Hero 3 name:\", hero_3.name) session.refresh(hero_1) session.refresh(hero_2) session.refresh(hero_3) print(\"After refreshing the heroes\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) print(\"After the session closes\") print(\"Hero 1:\", hero_1) print(\"Hero 2:\", hero_2) print(\"Hero 3:\", hero_3) # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview And the output shows again the same data: Review All the CodeÂ¶ Now let's review all this code once again. Tip Each one of the numbered bubbles shows what each line will print in the output. And as we created the engine with echo=True, we can see the SQL statements being executed at each step. from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") Create the hero_1. Doesn't generate any output. hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") Create the hero_2. Doesn't generate any output. hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) Create the hero_3. Doesn't generate any output. print(\"Before interacting with the database\") Print the line \"Before interacting with the database\". Generates the output: Before interacting with the database print(\"Hero 1:\", hero_1) Print the hero_1 before interacting with the database. Generates the output: Hero 1: id=None name='Deadpond' secret_name='Dive Wilson' age=None print(\"Hero 2:\", hero_2) Print the hero_2 before interacting with the database. Generates the output: Hero 2: id=None name='Spider-Boy' secret_name='Pedro Parqueador' age=None print(\"Hero 3:\", hero_3) Print the hero_3 before interacting with the database. Generates the output: Hero 3: id=None name='Rusty-Man' secret_name='Tommy Sharp' age=48 with Session(engine) as session: Create the Session in a with block. Doesn't generate any output. session.add(hero_1) Add the hero_1 to the session. This still doesn't save it to the database. Doesn't generate any output. session.add(hero_2) Add the hero_2 to the session. This still doesn't save it to the database. Doesn't generate any output. session.add(hero_3) Add the hero_3 to the session. This still doesn't save it to the database. Doesn't generate any output. print(\"After adding to the session\") Print the line \"After adding to the session\". Generates the output: After adding to the session print(\"Hero 1:\", hero_1) Print the hero_1 after adding it to the session. It still has the same data as there hasn't been any interaction with the database yet. Notice that the id is still None. Generates the output: Hero 1: id=None name='Deadpond' secret_name='Dive Wilson' age=None print(\"Hero 2:\", hero_2) Print the hero_2 after adding it to the session. It still has the same data as there hasn't been any interaction with the database yet. Notice that the id is still None. Generates the output: Hero 2: id=None name='Spider-Boy' secret_name='Pedro Parqueador' age=None print(\"Hero 3:\", hero_3) Print the hero_3 after adding it to the session. It still has the same data as there hasn't been any interaction with the database yet. Notice that the id is still None. Generates the output: Hero 3: id=None name='Rusty-Man' secret_name='Tommy Sharp' age=48 session.commit() commit the session. This will save all the data to the database. The session will use the engine to run a lot of SQL. Generates the output: INFO Engine BEGIN (implicit) INFO Engine INSERT INTO hero (name, secret_name, age) VALUES (?, ?, ?) INFO Engine [generated in 0.00018s] ('Deadpond', 'Dive Wilson', None) INFO Engine INSERT INTO hero (name, secret_name, age) VALUES (?, ?, ?) INFO Engine [cached since 0.0008968s ago] ('Spider-Boy', 'Pedro Parqueador', None) INFO Engine INSERT INTO hero (name, secret_name, age) VALUES (?, ?, ?) INFO Engine [cached since 0.001143s ago] ('Rusty-Man', 'Tommy Sharp', 48) INFO Engine COMMIT print(\"After committing the session\") Print the line \"After committing the session\". Generates the output: After committing the session print(\"Hero 1:\", hero_1) Print the hero_1 after committing the session. The hero_1 is now internally marked as expired, and until it is refreshed, it looks like if it didn't contain any data. Generates the output: Hero 1: print(\"Hero 2:\", hero_2) Print the hero_2 after committing the session. The hero_2 is now internally marked as expired, and until it is refreshed, it looks like if it didn't contain any data. Generates the output: Hero 2: print(\"Hero 3:\", hero_3) Print the hero_3 after committing the session. The hero_3 is now internally marked as expired, and until it is refreshed, it looks like if it didn't contain any data. Generates the output: Hero 3: print(\"After committing the session, show IDs\") Print the line \"After committing the session, show IDs\". Generates the output: After committing the session, show IDs print(\"Hero 1 ID:\", hero_1.id) Print the hero_1.id. A lot happens here. Because we are accessing the attribute id of hero_1, SQLModel (actually SQLAlchemy) can detect that we are trying to access data from the hero_1. It then detects that hero_1 is currently associated with a session (because we added it to the session and committed it), and it is marked as expired. Then with the session, it uses the engine to execute all the SQL to fetch the data for this object from the database. Next it updates the object with the new data and marks it internally as \"fresh\" or \"not expired\". Finally, it makes the ID value available for the rest of the Python expression. In this case, the Python expression just prints the ID. Generates the output: INFO Engine BEGIN (implicit) INFO Engine SELECT hero.id AS hero_id, hero.name AS hero_name, hero.secret_name AS hero_secret_name, hero.age AS hero_age FROM hero WHERE hero.id = ? INFO Engine [generated in 0.00017s] (1,) Hero 1 ID: 1 print(\"Hero 2 ID:\", hero_2.id) Print the hero_2.id. A lot happens here, all the same stuff that happened at point 22, but for this hero_2 object. Generates the output: INFO Engine SELECT hero.id AS hero_id, hero.name AS hero_name, hero.secret_name AS hero_secret_name, hero.age AS hero_age FROM hero WHERE hero.id = ? INFO Engine [cached since 0.001245s ago] (2,) Hero 2 ID: 2 print(\"Hero 3 ID:\", hero_3.id) Print the hero_3.id. A lot happens here, all the same stuff that happened at point 22, but for this hero_3 object. Generates the output: INFO Engine SELECT hero.id AS hero_id, hero.name AS hero_name, hero.secret_name AS hero_secret_name, hero.age AS hero_age FROM hero WHERE hero.id = ? INFO Engine [cached since 0.002215s ago] (3,) Hero 3 ID: 3 print(\"After committing the session, show names\") Print the line \"After committing the session, show names\". Generates the output: After committing the session, show names print(\"Hero 1 name:\", hero_1.name) Print the hero_1.name. Because hero_1 is still fresh, no additional data is fetched, no additional SQL is executed, and the name is available. Generates the output: Hero 1 name: Deadpond print(\"Hero 2 name:\", hero_2.name) Print the hero_2.name. Because hero_2 is still fresh, no additional data is fetched, no additional SQL is executed, and the name is available. Generates the output: Hero 2 name: Spider-Boy print(\"Hero 3 name:\", hero_3.name) Print the hero_3.name. Because hero_3 is still fresh, no additional data is fetched, no additional SQL is executed, and the name is available. Generates the output: Hero 3 name: Rusty-Man session.refresh(hero_1) Explicitly refresh the hero_1 object. The session will use the engine to execute the SQL necessary to fetch fresh data from the database for the hero_1 object. Generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.id = ? INFO Engine [generated in 0.00024s] (1,) session.refresh(hero_2) Explicitly refresh the hero_2 object. The session will use the engine to execute the SQL necessary to fetch fresh data from the database for the hero_2 object. Generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.id = ? INFO Engine [cached since 0.001487s ago] (2,) session.refresh(hero_3) Explicitly refresh the hero_3 object. The session will use the engine to execute the SQL necessary to fetch fresh data from the database for the hero_3 object. Generates the output: INFO Engine SELECT hero.id, hero.name, hero.secret_name, hero.age FROM hero WHERE hero.id = ? INFO Engine [cached since 0.002377s ago] (3,) print(\"After refreshing the heroes\") Print the line \"After refreshing the heroes\". Generates the output: After refreshing the heroes print(\"Hero 1:\", hero_1) Print the hero_1. !!! info Even if the hero_1 wasn't fresh, this would not trigger a refresh making the session use the engine to fetch data from the database because it is not accessing an attribute. Because the hero_1 is fresh it has all it's data available. Generates the output: Hero 1: age=None id=1 name='Deadpond' secret_name='Dive Wilson' print(\"Hero 2:\", hero_2) Print the hero_2. !!! info Even if the hero_2 wasn't fresh, this would not trigger a refresh making the session use the engine to fetch data from the database because it is not accessing an attribute. Because the hero_2 is fresh it has all it's data available. Generates the output: Hero 2: age=None id=2 name='Spider-Boy' secret_name='Pedro Parqueador' print(\"Hero 3:\", hero_3) Print the hero_3. !!! info Even if the hero_3 wasn't fresh, this would not trigger a refresh making the session use the engine to fetch data from the database because it is not accessing an attribute. Because the hero_3 is fresh it has all it's data available. Generates the output: Hero 3: age=48 id=3 name='Rusty-Man' secret_name='Tommy Sharp' The with block ends here (there's no more indented code), so the session is closed, running all it's closing code. This includes doing a ROLLBACK of any possible transaction that could have been started. Generates the output: INFO Engine ROLLBACK print(\"After the session closes\") Print the line \"After the session closes\". Generates the output: After the session closes print(\"Hero 1:\", hero_1) Print the hero_1 after closing the session. Generates the output: Hero 1: age=None id=1 name='Deadpond' secret_name='Dive Wilson' print(\"Hero 2:\", hero_2) Print the hero_2 after closing the session. Generates the output: Hero 2: age=None id=2 name='Spider-Boy' secret_name='Pedro Parqueador' print(\"Hero 3:\", hero_3) Print the hero_3 after closing the session. Generates the output: Hero 3: age=48 id=3 name='Rusty-Man' secret_name='Tommy Sharp' def main(): create_db_and_tables() create_heroes() if __name__ == \"__main__\": main() And here's all the output generated by running this program, all together: RecapÂ¶ You read all that! That was a lot! Have some cake, you earned it. ðŸ° We discussed how the session uses the engine to send SQL to the database, to create data and to fetch data too. How it keeps track of \"expired\" and \"fresh\" data. At which moments it fetches data automatically (when accessing instance attributes) and how that data is synchronized between objects in memory and the database via the session. If you understood all that, now you know a lot about SQLModel, SQLAlchemy, and how the interactions from Python with databases work in general. If you didn't get all that, it's fine, you can always come back later to refresh the concepts. I think this might be one of the main types of bugs that cause problems and makes you scratch your head. So, good job studying it! ðŸ’ª Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create Rows - Use the Session - INSERT - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/insert/",
    "html": "Skip to content SQLModel Create Rows - Use the Session - INSERT Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create Table and Database Create Data with SQL Try it in DB Explorer for SQLite Data in a Database and Data in Code Create Data with Python and SQLModel Create a Model Instance Create a Session Add Model Instances to the Session Commit the Session Changes Create Heroes as a Script Run the Script Close the Session A Session in a with Block Review All the Code What's Next SQLModel Tutorial - User Guide Create Rows - Use the Session - INSERTÂ¶ Now that we have a database and a table, we can start adding data. Here's a reminder of how the table would look like, this is the data we want to add: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 Create Table and DatabaseÂ¶ We will continue from where we left of in the last chapter. This is the code we had to create the database and table, nothing new here: from typing import Optional Import Optional from typing to declare fields that could be None. from sqlmodel import Field, SQLModel, create_engine Import the things we will need from sqlmodel: Field, SQLModel, create_engine. class Hero(SQLModel, table=True): Create the Hero model class, representing the hero table in the database. And also mark this class as a table model with table=True. id: Optional[int] = Field(default=None, primary_key=True) Create the id field: It could be None until the database assigns a value to it, so we annotate it with Optional. It is a primary key, so we use Field() and the argument primary_key=True. name: str Create the name field. It is required, so there's no default value, and it's not Optional. secret_name: str Create the secret_name field. Also required. age: Optional[int] = None Create the age field. It is not required, the default value is None. In the database, the default value will be NULL, the SQL equivalent of None. As this field could be None (and NULL in the database), we annotate it with Optional. sqlite_file_name = \"database.db\" Write the name of the database file. sqlite_url = f\"sqlite:///{sqlite_file_name}\" Use the name of the database file to create the database URL. engine = create_engine(sqlite_url, echo=True) Create the engine using the URL. This doesn't create the database yet, no file or table is created at this point, only the engine object that will handle the connections with this specific database, and with specific support for SQLite (based on the URL). def create_db_and_tables(): Put the code that creates side effects in a function. In this case, only one line that creates the database file with the table. SQLModel.metadata.create_all(engine) Create all the tables that were automatically registered in SQLModel.metadata. # More code here later ðŸ‘ˆ if __name__ == \"__main__\": Add a main block, or \"Top-level script environment\". And put some logic to be executed when this is called directly with Python, as in: ...but that is not executed when importing something from this module, like: from app import Hero create_db_and_tables() In this main block, call the function that creates the database file and the table. This way when we call it with: ...it will create the database file and the table. Now that we can create the database and the table, we will continue from this point and add more code on the same file to create the data. Create Data with SQLÂ¶ Before working with Python code, let's see how we can create data with SQL. Let's say we want to insert the record/row for Deadpond into our database. We can do this with the following SQL code: INSERT INTO \"hero\" (\"name\", \"secret_name\") VALUES (\"Deadpond\", \"Dive Wilson\"); It means, more or less: Hey SQL database ðŸ‘‹, please INSERT something (create a record/row) INTO the table \"hero\". I want you to insert a row with some values in these specific columns: \"name\" \"secret_name\" And the values I want you to put in these columns are: \"Deadpond\" \"Dive Wilson\" Try it in DB Explorer for SQLiteÂ¶ You can try that SQL statement in DB Explorer for SQLite. Make sure to open the same database we already created by clicking Open Database and selecting the same database.db file. Tip If you don't have that database.db file with the table hero, you can re-create it by running the Python program at the top. ðŸ‘† Then go to the Execute SQL tab and copy the SQL from above. It would look like this: Click the \"Execute all\" â–¶ button. Then you can go to the Browse Data tab, and you will see your newly created record/row: Data in a Database and Data in CodeÂ¶ When working with a database (SQL or any other type) in a programming language, we will always have some data in memory, in objects and variables we create in our code, and there will be some data in the database. We are constantly getting some of the data from the database and putting it in memory, in variables. The same way, we are constantly creating variables and objects with data in our code, that we then want to save in the database, so we send it somehow. In some cases, we can even create some data in memory and then change it and update it before saving it in the database. We might even decide with some logic in the code that we no longer want to save the data in the database, and then just remove it. ðŸ”¥ And we only handled that data in memory, without sending it back and forth to the database. SQLModel does all it can (actually via SQLAlchemy) to make this interaction as simple, intuitive, and familiar or \"close to programming\" as possible. âœ¨ But that division of the two places where some data might be at each moment in time (in memory or in the database) is always there. And it's important for you to have it in mind. ðŸ¤“ Create Data with Python and SQLModelÂ¶ Now let's create that same row in Python. First, remove that file database.db so we can start from a clean slate. Because we have Python code executing with data in memory, and the database is an independent system (an external SQLite file, or an external database server), we need to perform two steps: create the data in Python, in memory (in a variable) save/send the data to the database Create a Model InstanceÂ¶ Let's start with the first step, create the data in memory. We already created a class Hero that represents the hero table in the database. Each instance we create will represent the data in a row in the database. So, the first step is to simply create an instance of Hero. We'll create 3 right away, for the 3 heroes: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Tip The code above in this file (the omitted code) is just the same code that you see at the top of this chapter. The same code we used before to create the Hero model. We are putting that in a function create_heroes(), to call it later once we finish it. If you are trying the code interactively, you could also write that directly. Create a SessionÂ¶ Up to now, we have only used the engine to interact with the database. The engine is that single object that we share with all the code, and that is in charge of communicating with the database, handling the connections (when using a server database like PostgreSQL or MySQL), etc. But when working with SQLModel you will mostly use another tool that sits on top, the Session. In contrast to the engine that is one for the whole application, we create a new session for each group of operations with the database that belong together. In fact, the session needs and uses an engine. For example, if we have a web application, we would normally have a single session per request. We would re-use the same engine in all the code, everywhere in the application (shared by all the requests). But for each request, we would create and use a new session. And once the request is done, we would close the session. The first step is to import the Session class: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine # Code below omitted ðŸ‘‡ ðŸ‘€ Full file preview Then we can create a new session: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) session = Session(engine) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview The new Session takes an engine as a parameter. And it will use the engine underneath. Tip We will see a better way to create a session using a with block later. Add Model Instances to the SessionÂ¶ Now that we have some hero model instances (some objects in memory) and a session, the next step is to add them to the session: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) session = Session(engine) session.add(hero_1) session.add(hero_2) session.add(hero_3) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview By this point, our heroes are not stored in the database yet. And this is one of the cases where having a session independent of an engine makes sense. The session is holding in memory all the objects that should be saved in the database later. And once we are ready, we can commit those changes, and then the session will use the engine underneath to save all the data by sending the appropriate SQL to the database, and that way it will create all the rows. All in a single batch. This makes the interactions with the database more efficient (plus some extra benefits). Technical Details The session will create a new transaction and execute all the SQL code in that transaction. This ensures that the data is saved in a single batch, and that it will all succeed or all fail, but it won't leave the database in a broken state. Commit the Session ChangesÂ¶ Now that we have the heroes in the session and that we are ready to save all that to the database, we can commit the changes: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) session = Session(engine) session.add(hero_1) session.add(hero_2) session.add(hero_3) session.commit() # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Once this line is executed, the session will use the engine to save all the data in the database by sending the corresponding SQL. Create Heroes as a ScriptÂ¶ The function to create the heroes is now ready. Now we just need to make sure to call it when we run this program with Python directly. We already had a main block like: if __name__ == \"__main__\": create_db_and_tables() We could add the new function there, as: if __name__ == \"__main__\": create_db_and_tables() create_heroes() But to keep things a bit more organized, let's instead create a new function main() that will contain all the code that should be executed when called as an independent script, and we can put there the previous function create_db_and_tables(), and add the new function create_heroes(): # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() # More code here later ðŸ‘‡ ðŸ‘€ Full file preview And then we can call that single main() function from that main block: # Code above omitted ðŸ‘† def main(): create_db_and_tables() create_heroes() if __name__ == \"__main__\": main() ðŸ‘€ Full file preview By having everything that should happen when called as a script in a single function, we can easily add more code later on. And some other code could also import and use this same main() function if it was necessary. Run the ScriptÂ¶ Now we can run our program as a script from the console. Because we created the engine with echo=True, it will print out all the SQL code that it is executing: If you have ever used Git, this works very similarly. We use session.add() to add new objects (model instances) to the session (similar to git add). And that ends up in a group of data ready to be saved, but not saved yet. We can make more modifications, add more objects, etc. And once we are ready, we can commit all the changes in a single step (similar to git commit). Close the SessionÂ¶ The session holds some resources, like connections from the engine. So once we are done with the session, we should close it to make it release those resources and finish its cleanup: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) session = Session(engine) session.add(hero_1) session.add(hero_2) session.add(hero_3) session.commit() session.close() # More code here later ðŸ‘‡ ðŸ‘€ Full file preview But what happens if we forget to close the session? Or if there's an exception in the code and it never reaches the session.close()? For that, there's a better way to create and close the session, using a with block. ðŸ‘‡ A Session in a with BlockÂ¶ It's good to know how the Session works and how to create and close it manually. It might be useful if, for example, you want to explore the code in an interactive session (for example with Jupyter). But there's a better way to handle the session, using a with block: # Code above omitted ðŸ‘† def create_heroes(): hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.commit() ðŸ‘€ Full file preview This is the same as creating the session manually and then manually closing it. But here, using a with block, it will be automatically created when starting the with block and assigned to the variable session, and it will be automatically closed after the with block is finished. And it will work even if there's an exception in the code. ðŸ˜Ž Review All the CodeÂ¶ Let's give this whole file a final look. ðŸ” You already know all the first part creating the Hero model class, the engine, and creating the database and table. Let's focus on the new code: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) def create_heroes(): We use a function create_heroes() to put this logic together. hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") Create each of the objects/instances of the Hero model. Each of them represents the data for one row. hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) with Session(engine) as session: Use a with block to create a Session using the engine. The new sesion will be assigned to the variable session. And it will be automatically closed when the with block is finished. session.add(hero_1) Add each of the objects/instances to the session. Each of these objects represents a row in the database. They are all waiting there in the session to be saved. session.add(hero_2) session.add(hero_3) session.commit() Commit the changes to the database. This will actually send the data to the database. It will start a transaction automatically and save all the data in a single batch. By this point, after the with block is finished, the session is automatically closed. def main(): We have a main() function with all the code that should be executed when the program is called as a script from the console. That way we can add more code later to this function. We then put this function main() in the main block below. And as it is a single function, other Python files could import it and call it directly. create_db_and_tables() In this main() function, we are also creating the database and the tables. In the previous version, this function was called directly in the main block. But now it is just called in the main() function. create_heroes() And now we are also creating the heroes in this main() function. if __name__ == \"__main__\": We still have a main block to execute some code when the program is run as a script from the command line, like: main() There's a single main() function now that contains all the code that should be executed when running the program from the console. So this is all we need to have in the main block. Just call the main() function. Tip Review what each line does by clicking each number bubble in the code. ðŸ‘† You can now put it in a app.py file and run it with Python. And you will see an output like the one shown above. After that, if you open the database with DB Browser for SQLite, you will see the data you just created in the Browse Data tab: What's NextÂ¶ Now you know how to add rows to the database. ðŸŽ‰ Now is a good time to understand better why the id field can't be NULL on the database because it's a primary key, but actually can be None in the Python code. I'll tell you about that in the next chapter. ðŸš€ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create a Table with SQLModel - Use the Engine - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/create-db-and-table/",
    "html": "Skip to content SQLModel Create a Table with SQLModel - Use the Engine Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create the Table Model Class Define the Fields, Columns Optional Fields, Nullable Columns Primary Key id Create the Engine Engine Database URL Engine Echo Engine Technical Details Create the Database and Table SQLModel MetaData Calling create_all() SQLModel MetaData Order Matters Migrations Run The Program TEXT or VARCHAR Verify the Database Refactor Data Creation Create Data as a Script About __name__ == \"__main__\" More details Last Review Recap SQLModel Tutorial - User Guide Create a Table with SQLModel - Use the EngineÂ¶ Now let's get to the code. ðŸ‘©â€ðŸ’» Make sure you are inside of your project directory and with your virtual environment activated as explained in the previous chapter. We will: Define a table with SQLModel Create the same SQLite database and table with SQLModel Use DB Browser for SQLite to confirm the operations Here's a reminder of the table structure we want: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 Create the Table Model ClassÂ¶ The first thing we need to do is create a class to represent the data in the table. A class like this that represents some data is commonly called a model. Tip That's why this package is called SQLModel. Because it's mainly used to create SQL Models. For that, we will import SQLModel (plus other things we will also use) and create a class Hero that inherits from SQLModel and represents the table model for our heroes: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None # More code here later ðŸ‘‡ ðŸ‘€ Full file preview This class Hero represents the table for our heroes. And each instance we create later will represent a row in the table. We use the config table=True to tell SQLModel that this is a table model, it represents a table. Info It's also possible to have models without table=True, those would be only data models, without a table in the database, they would not be table models. Those data models will be very useful later, but for now, we'll just keep adding the table=True configuration. Define the Fields, ColumnsÂ¶ The next step is to define the fields or columns of the class by using standard Python type annotations. The name of each of these variables will be the name of the column in the table. And the type of each of them will also be the type of table column: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Let's now see with more detail these field/column declarations. Optional Fields, Nullable ColumnsÂ¶ Let's start with age, notice that it has a type of Optional[int]. And we import that Optional from the typing standard module. That is the standard way to declare that something \"could be an int or None\" in Python. And we also set the default value of age to None. from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None # More code here later ðŸ‘‡ ðŸ‘€ Full file preview Tip We also define id with Optional. But we will talk about id below. This way, we tell SQLModel that age is not required when validating data and that it has a default value of None. And we also tell it that, in the SQL database, the default value of age is NULL (the SQL equivalent to Python's None). So, this column is \"nullable\" (can be set to NULL). Info In terms of Pydantic, age is an optional field. In terms of SQLAlchemy, age is a nullable column. Primary Key idÂ¶ Now let's review the id field. This is the primary key of the table. So, we need to mark id as the primary key. To do that, we use the special Field function from sqlmodel and set the argument primary_key=True: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None # More code here later ðŸ‘‡ ðŸ‘€ Full file preview That way, we tell SQLModel that this id field/column is the primary key of the table. But inside the SQL database, it is always required and can't be NULL. Why should we declare it with Optional? The id will be required in the database, but it will be generated by the database, not by our code. So, whenever we create an instance of this class (in the next chapters), we will not set the id. And the value of id will be None until we save it in the database, and then it will finally have a value. my_hero = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") do_something(my_hero.id) # Oh no! my_hero.id is None! ðŸ˜±ðŸš¨ # Imagine this saves it to the database somehow_save_in_db(my_hero) do_something(my_hero.id) # Now my_hero.id has a value generated in DB ðŸŽ‰ So, because in our code (not in the database) the value of id could be None, we use Optional. This way the editor will be able to help us, for example, if we try to access the id of an object that we haven't saved in the database yet and would still be None. Now, because we are taking the place of the default value with our Field() function, we set the actual default value of id to None with the argument default=None in Field(): Field(default=None) If we didn't set the default value, whenever we use this model later to do data validation (powered by Pydantic) it would accept a value of None apart from an int, but it would still require passing that None value. And it would be confusing for whoever is using this model later (probably us), so better set the default value here. Create the EngineÂ¶ Now we need to create the SQLAlchemy Engine. It is an object that handles the communication with the database. If you have a server database (for example PostgreSQL or MySQL), the engine will hold the network connections to that database. Creating the engine is very simple, just call create_engine() with a URL for the database to use: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview You should normally have a single engine object for your whole application and re-use it everywhere. Tip There's another related thing called a Session that normally should not be a single object per application. But we will talk about it later. Engine Database URLÂ¶ Each supported database has it's own URL type. For example, for SQLite it is sqlite:/// followed by the file path. For example: sqlite:///database.db sqlite:///databases/local/application.db sqlite:///db.sqlite SQLite supports a special database that lives all in memory. Hence, it's very fast, but be careful, the database gets deleted after the program terminates. You can specify this in-memory database by using just two slash characters (//) and no file name: sqlite:// from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) SQLModel.metadata.create_all(engine) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview You can read a lot more about all the databases supported by SQLAlchemy (and that way supported by SQLModel) in the SQLAlchemy documentation. Engine EchoÂ¶ In this example, we are also using the argument echo=True. It will make the engine print all the SQL statements it executes, which can help you understand what's happening. It is particularly useful for learning and debugging: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview But in production, you would probably want to remove echo=True: engine = create_engine(sqlite_url) Engine Technical DetailsÂ¶ Tip If you didn't know about SQLAlchemy before and are just learning SQLModel, you can probably skip this section, scroll below. You can read a lot more about the engine in the SQLAlchemy documentation. SQLModel defines it's own create_engine() function. It is the same as SQLAlchemy's create_engine(), but with the difference that it defaults to use future=True (which means that it uses the style of the latest SQLAlchemy, 1.4, and the future 2.0). And SQLModel's version of create_engine() is type annotated internally, so your editor will be able to help you with autocompletion and inline errors. Create the Database and TableÂ¶ Now everything is in place to finally create the database and table: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) SQLModel.metadata.create_all(engine) Tip Creating the engine doesn't create the database.db file. But once we run SQLModel.metadata.create_all(engine), it creates the database.db file and creates the hero table in that database. Both things are done in this single step. Let's unwrap that: SQLModel.metadata.create_all(engine) SQLModel MetaDataÂ¶ The SQLModel class has a metadata attribute. It is an instance of a class MetaData. Whenever you create a class that inherits from SQLModel and is configured with table = True, it is registered in this metadata attribute. So, by the last line, SQLModel.metadata already has the Hero registered. Calling create_all()Â¶ This MetaData object at SQLModel.metadata has a create_all() method. It takes an engine and uses it to create the database and all the tables registered in this MetaData object. SQLModel MetaData Order MattersÂ¶ This also means that you have to call SQLModel.metadata.create_all() after the code that creates new model classes inheriting from SQLModel. For example, let's imagine you do this: Create the models in one Python file models.py. Create the engine object in a file db.py. Create your main app and call SQLModel.metadata.create_all() in app.py. If you only imported SQLModel and tried to call SQLModel.metadata.create_all() in app.py, it would not create your tables: # This wouldn't work! ðŸš¨ from sqlmodel import SQLModel from .db import engine SQLModel.metadata.create_all(engine) It wouldn't work because when you import SQLModel alone, Python doesn't execute all the code creating the classes inheriting from it (in our example, the class Hero), so SQLModel.metadata is still empty. But if you import the models before calling SQLModel.metadata.create_all(), it will work: from sqlmodel import SQLModel from . import models from .db import engine SQLModel.metadata.create_all(engine) This would work because by importing the models, Python executes all the code creating the classes inheriting from SQLModel and registering them in the SQLModel.metadata. As an alternative, you could import SQLModel and your models inside of db.py: # db.py from sqlmodel import SQLModel, create_engine from . import models sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url) And then import SQLModel from db.py in app.py, and there call SQLModel.metadata.create_all(): # app.py from .db import engine, SQLModel SQLModel.metadata.create_all(engine) The import of SQLModel from db.py would work because SQLModel is also imported in db.py. And this trick would work correctly and create the tables in the database because by importing SQLModel from db.py, Python executes all the code creating the classes that inherit from SQLModel in that db.py file, for example, the class Hero. MigrationsÂ¶ For this simple example, and for most of the Tutorial - User Guide, using SQLModel.metadata.create_all() is enough. But for a production system you would probably want to use a system to migrate the database. This would be useful and important, for example, whenever you add or remove a column, add a new table, change a type, etc. But you will learn about migrations later in the Advanced User Guide. Run The ProgramÂ¶ Let's run the program to see it all working. Put the code it in a file app.py if you haven't already. ðŸ‘€ Full file preview Tip Remember to activate the virtual environment before running it. Now run the program with Python: Info I simplified the output above a bit to make it easier to read. But in reality, instead of showing: INFO Engine BEGIN (implicit) it would show something like: 2021-07-25 21:37:39,175 INFO sqlalchemy.engine.Engine BEGIN (implicit) TEXT or VARCHARÂ¶ In the example in the previous chapter we created the table using TEXT for some columns. But in this output SQLAlchemy is using VARCHAR instead. Let's see what's going on. Remember that each SQL Database has some different variations in what they support? This is one of the differences. Each database supports some particular data types, like INTEGER and TEXT. Some databases have some particular types that are special for certain things. For example, PostgreSQL and MySQL support BOOLEAN for values of True and False. SQLite accepts SQL with booleans, even when defining table columns, but what it actually uses internally are INTEGERs, with 1 to represent True and 0 to represent False. The same way, there are several possible types for storing strings. SQLite uses the TEXT type. But other databases like PostgreSQL and MySQL use the VARCHAR type by default, and VARCHAR is one of the most common data types. VARCHAR comes from variable length character. SQLAlchemy generates the SQL statements to create tables using VARCHAR, and then SQLite receives them, and internally converts them to TEXTs. Additional to the difference between those two data types, some databases like MySQL require setting a maximum length for the VARCHAR types, for example VARCHAR(255) sets the maximum number of characters to 255. To make it easier to start using SQLModel right away independent of the database you use (even with MySQL), and without any extra configurations, by default, str fields are interpreted as VARCHAR in most databases and VARCHAR(255) in MySQL, this way you know the same class will be compatible with the most popular databases without extra effort. Tip You will learn how to change the maximum length of string columns later in the Advanced Tutorial - User Guide. Verify the DatabaseÂ¶ Now, open the database with DB Browser for SQLite, you will see that the program created the table hero just as before. ðŸŽ‰ Refactor Data CreationÂ¶ Now let's restructure the code a bit to make it easier to reuse, share, and test later. Let's move the code that has the main side effects, that changes data (creates a file with a database and a table) to a function. In this example it's just the SQLModel.metadata.create_all(engine). Let's put it in a function create_db_and_tables(): from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) # More code here later ðŸ‘‡ ðŸ‘€ Full file preview If SQLModel.metadata.create_all(engine) was not in a function and we tried to import something from this module (from this file) in another, it would try to create the database and table every time we executed that other file that imported this module. We don't want that to happen like that, only when we intend it to happen, that's why we put it in a function, because we can make sure that the tables are created only when we call that function, and not when this module is imported somewhere else. Now we would be able to, for example, import the Hero class in some other file without having those side effects. Tip ðŸ˜… Spoiler alert: The function is called create_db_and_tables() because we will have more tables in the future with other classes apart from Hero. ðŸš€ Create Data as a ScriptÂ¶ We prevented the side effects when importing something from your app.py file. But we still want it to create the database and table when we call it with Python directly as an independent script from the terminal, just as as above. Tip Think of the word script and program as interchangeable. The word script often implies that the code could be run independently and easily. Or in some cases it refers to a relatively simple program. For that we can use the special variable __name__ in an if block: from typing import Optional from sqlmodel import Field, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None sqlite_file_name = \"database.db\" sqlite_url = f\"sqlite:///{sqlite_file_name}\" engine = create_engine(sqlite_url, echo=True) def create_db_and_tables(): SQLModel.metadata.create_all(engine) if __name__ == \"__main__\": create_db_and_tables() About __name__ == \"__main__\"Â¶ The main purpose of the __name__ == \"__main__\" is to have some code that is executed when your file is called with: ...but is not called when another file imports it, like in: from app import Hero Tip That if block using if __name__ == \"__main__\": is sometimes called the \"main block\". The official name (in the Python docs) is \"Top-level script environment\". More detailsÂ¶ Let's say your file is named myapp.py. If you run it with: ...then the internal variable __name__ in your file, created automatically by Python, will have as value the string \"__main__\". So, the function in: if __name__ == \"__main__\": create_db_and_tables() ...will run. This won't happen if you import that module (file). So, if you have another file importer.py with: from myapp import Hero # Some more code ...in that case, the automatic variable inside of myapp.py will not have the variable __name__ with a value of \"__main__\". So, the line: if __name__ == \"__main__\": create_db_and_tables() ...will not be executed. Info For more information, check the official Python docs. Last ReviewÂ¶ After those changes, you could run it again, and it would generate the same output as before. But now we can import things from this module in other files. Now, let's give the code a final look: from typing import Optional Import Optional from typing to declare fields that could be None. from sqlmodel import Field, SQLModel, create_engine Import the things we will need from sqlmodel: Field, SQLModel, create_engine. class Hero(SQLModel, table=True): Create the Hero model class, representing the hero table in the database. And also mark this class as a table model with table=True. id: Optional[int] = Field(default=None, primary_key=True) Create the id field: It could be None until the database assigns a value to it, so we annotate it with Optional. It is a primary key, so we use Field() and the argument primary_key=True. name: str Create the name field. It is required, so there's no default value, and it's not Optional. secret_name: str Create the secret_name field. Also required. age: Optional[int] = None Create the age field. It is not required, the default value is None. In the database, the default value will be NULL, the SQL equivalent of None. As this field could be None (and NULL in the database), we annotate it with Optional. sqlite_file_name = \"database.db\" Write the name of the database file. sqlite_url = f\"sqlite:///{sqlite_file_name}\" Use the name of the database file to create the database URL. engine = create_engine(sqlite_url, echo=True) Create the engine using the URL. This doesn't create the database yet, no file or table is created at this point, only the engine object that will handle the connections with this specific database, and with specific support for SQLite (based on the URL). def create_db_and_tables(): Put the code that creates side effects in a function. In this case, only one line that creates the database file with the table. SQLModel.metadata.create_all(engine) Create all the tables that were automatically registered in SQLModel.metadata. if __name__ == \"__main__\": Add a main block, or \"Top-level script environment\". And put some logic to be executed when this is called directly with Python, as in: ...but that is not executed when importing something from this module, like: from app import Hero create_db_and_tables() In this main block, call the function that creates the database file and the table. This way when we call it with: ...it will create the database file and the table. Tip Review what each line does by clicking each number bubble in the code. ðŸ‘† RecapÂ¶ We learnt how to use SQLModel to define how a table in the database should look like, and we created a database and a table using SQLModel. We also refactored the code to make it easier to reuse, share, and test later. In the next chapters we will see how SQLModel will help us interact with SQL databases from code. ðŸ¤“ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Create a Table with SQL - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/tutorial/create-db-and-table-with-db-browser/",
    "html": "Skip to content SQLModel Create a Table with SQL Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Create a Table with SQL Create a Table with SQLModel - Use the Engine Create Rows - Use the Session - INSERT Automatic IDs, None Defaults, and Refreshing Data Read Data - SELECT Filter Data - WHERE Indexes - Optimize Queries Read One Row Read a Range of Data - LIMIT and OFFSET Update Data - UPDATE Delete Data - DELETE Connect Tables - JOIN Relationship Attributes Many to Many Code Structure and Multiple Files FastAPI and Pydantic Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Create a Database Create a Table Confirm the Table Create the Table again, with SQL Learn More SQL Recap SQLModel Tutorial - User Guide Create a Table with SQLÂ¶ Let's get started! We will: Create a SQLite database with DB Browser for SQLite Create a table in the database with DB Browser for SQLite We'll add data later. For now, we'll create the database and the first table structure. We will create a table to hold this data: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 Create a DatabaseÂ¶ SQLModel and SQLAlchemy are based on SQL. They are designed to help you with using SQL through Python classes and objects. But it's still always very useful to understand SQL. So let's start with a simple, pure SQL example. Open DB Browser for SQLite. Click the button New Database. A dialog should show up. Go to the project directory you created and save the file with a name of database.db. Tip It's common to save SQLite database files with an extension of .db. Sometimes also .sqlite. Create a TableÂ¶ After doing that, it might prompt you to create a new table right away. If it doesn't, click the button Create Table. Then you will see the dialog to create a new table. So, let's create a new table called hero with the following columns: id: an INTEGER that will be the primary key (check PK âœ…). name: a TEXT, it should be NOT NULL (check NN âœ…), so, it should always have a value. secret_name: a TEXT, it should be NOT NULL too (check NN âœ…). age: an INTEGER, this one can be NULL, so you don't have to check anything else. Click OK to create the table. While you click on the Add button and add the information, it will create and update the SQL statement that is executed to create the table: CREATE TABLE \"hero\" ( -- Create a table with the name hero. Also notice that the columns for this table are declared inside the parenthesis \" (\" that starts here. \"id\" INTEGER, -- The id column, an INTEGER. This is declared as the primary key at the end. \"name\" TEXT NOT NULL, -- The name column, a TEXT, and it should always have a value NOT NULL. \"secret_name\" TEXT NOT NULL, -- The secret_name column, another TEXT, also NOT NULL. \"age\" INTEGER, -- The age column, an INTEGER. This one doesn't have NOT NULL, so it can be NULL. PRIMARY KEY(\"id\") -- The PRIMARY KEY of all this is the id column. ); -- This is the end of the SQL table, with the final parenthesis \")\". It also has the semicolon \";\" that marks the end of the SQL statement. There could be more SQL statements in the same SQL string. Now you will see that it shows up in the list of Tables with the columns we specified. ðŸŽ‰ The only step left is to click Write Changes to save the changes to the file. After that, the new table is saved in this database on the file ./database.db. Confirm the TableÂ¶ Let's confirm that it's all saved. First click the button Close Database to close the database. Now click on Open Database to open the database again, and select the same file ./database.db. You will see again the same table we created. Create the Table again, with SQLÂ¶ Now, to see how is it that SQL works, let's create the table again, but with SQL. Click the Close Database button again. And delete that ./database.db file in your project directory. And click again on New Database. This time, if you see the dialog to create a new table, just close it by clicking the Cancel button. And now, go to the tab Execute SQL. Write the same SQL that was generated in the previous step: CREATE TABLE \"hero\" ( \"id\" INTEGER, \"name\" TEXT NOT NULL, \"secret_name\" TEXT NOT NULL, \"age\" INTEGER, PRIMARY KEY(\"id\") ); Then click the \"Execute all\" â–¶ button. You will see the \"execution finished successfully\" message. And if you go back to the Database Structure tab, you will see that you effectively created again the same table. Learn More SQLÂ¶ I will keep showing you small bits of SQL through this tutorial. And you don't have to be a SQL expert to use SQLModel. But if you are curious and want to get a quick overview of SQL, I recommend the visual documentation from SQLite, on SQL As Understood By SQLite. You can start with CREATE TABLE. Of course, you can also go and take a full SQL course or read a book about SQL, but you don't need more than what I'll explain here on the tutorial to start being productive with SQLModel. ðŸ¤“ RecapÂ¶ We saw how to interact with SQLite databases in files using DB Browser for SQLite in a visual user interface. We also saw how to use it to write some SQL directly to the SQLite database. This will be useful to verify the data in the database is looking correctly, to debug, etc. In the next chapters we will start using SQLModel to interact with the database, and we will continue to use DB Browser for SQLite at the same time to look at the database underneath. ðŸ” Made with Material for MkDocs Insiders"
  },
  {
    "title": "Features - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/features/",
    "html": "Skip to content SQLModel Features Type to start searching tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Designed for FastAPI Just Modern Python Editor support Short Based on Pydantic Based on SQLAlchemy Tested FeaturesÂ¶ Designed for FastAPIÂ¶ SQLModel was created by the same author of FastAPI. It follows the same design and ideas, and it was created to be the most intuitive way to interact with SQL databases in FastAPI applications. Nevertheless, SQLModel is completely independent of FastAPI and can be used with any other type of application. You can still benefit from its features. Just Modern PythonÂ¶ It's all based on standard modern Python type annotations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use SQLModel or FastAPI), check the FastAPI tutorial section: Python types intro. You will also see a 20 seconds refresher on the section Tutorial - User Guide: First Steps. Editor supportÂ¶ SQLModel was designed to be easy and intuitive to use to ensure the best development experience, with autocompletion everywhere. Here's how your editor might help you: in Visual Studio Code: in PyCharm: You will get completion for everything while writing the minimum amount of code. You won't need to keep guessing the types of different attributes in your models, if they could be None, etc. Your editor will be able to help you with everything because SQLModel is based on standard Python type annotations. SQLModel even adopts currently in development standards for Python type annotations to ensure the best developer experience, so you will get inline errors and autocompletion even while creating new model instances. Info Don't worry, adopting this in-development standard only affects/improves editor support. It doesn't affect performance or correctness. And if the in-progress standard was deprecated your code won't be affected. Meanwhile, you will get inline errors (like type checks) and autocompletion on places you wouldn't get with any other library. ðŸŽ‰ ShortÂ¶ SQLModel has sensible defaults for everything, with optional configurations everywhere. But by default, it all \"just works\". You can start with the simplest (and most intuitive) type annotations for your data. And later, you can fine-tune everything with all the power of SQLAlchemy and Pydantic. Based on PydanticÂ¶ SQLModel is based on Pydantic and keeps the same design, syntax, and ideas. Underneath, âœ¨ a SQLModel model is also a Pydantic model. âœ¨ There was a lot of research and effort dedicated to make it that way. That means you get all of Pydantic's features, including automatic data validation, serialization, and documentation. You can use SQLModel in the same way you can use Pydantic. You can even create SQLModel models that do not represent SQL tables. In that case, they would be the same as Pydantic models. This is useful, in particular, because now you can create a SQL database model that inherits from another non-SQL model. You can use that to reduce code duplication a lot. It will also make your code more consistent, improve editor support, etc. This makes it the perfect combination for working with SQL databases in FastAPI applications. ðŸš€ You will learn more about combining different models later in the tutorial. Based on SQLAlchemyÂ¶ SQLModel is also based on SQLAlchemy and uses it for everything. Underneath, âœ¨ a SQLModel model is also a SQLAlchemy model. âœ¨ There was a lot of research and effort dedicated to make it that way. In particular, there was a lot of effort and experimentation in making a single model be both a SQLAlchemy model and a Pydantic model at the same time. That means that you get all the power, robustness, and certainty of SQLAlchemy, the most widely used database library in Python. SQLModel provides its own utilities to improve the developer experience, but underneath, it uses all of SQLAlchemy. You can even combine SQLModel models with SQLAlchemy models. SQLModel is designed to satisfy the most common use cases and to be as simple and convenient as possible for those cases, providing the best developer experience. But when you have more exotic use cases that require more complex features, you can still plug SQLAlchemy directly into SQLModel and use all its features in your code. TestedÂ¶ 100% test coverage (currently 97%, reaching 100% in the coming days/weeks). 100% type annotated code base. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Database to Code (ORMs) - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/db-to-code/",
    "html": "Skip to content SQLModel Database to Code (ORMs) Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents SQL Inline in Code SQL Injection SQL Sanitization SQL with SQLModel Preventing SQL Injections Editor Support ORMs and SQL SQL Table Names Database to Code (ORMs)Â¶ Here I'll tell you how SQLModel interacts with the database, why you would want to use it (or use a similar tool), and how it relates to SQL. SQL Inline in CodeÂ¶ Let's check this example of a simple SQL query to get all the data from the hero table: SELECT * FROM hero; And that SQL query would return the table: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Spider-Boy Pedro Parqueador null 1 3 Rusty-Man Tommy Sharp 48 1 This SQL language has a little caveat. It was not designed to be mixed with normal code in a programming language like Python. ðŸš¨ So, if you are working with Python, the simplest option would be to put SQL code inside a string, and send that string directly to the database. statement = \"SELECT * FROM hero;\" results = database.execute(statement) But in that case, you wouldn't have editor support, inline errors, autocompletion, etc. Because for the editor, the SQL statement is just a string of text. If you have an error, the editor wouldn't be able to help. ðŸ˜” And even more importantly, in most of the cases, you would send the SQL strings with modifications and parameters. For example, to get the data for a specific item ID, a range of dates, etc. And in most cases, the parameters your code uses to query or modify the data in the database come, in some way, from an external user. For example, check this SQL query: SELECT * FROM hero WHERE id = 2; It is using the ID parameter 2. That number 2 probably comes, in some way, from a user input. The user is probably, in some way, telling your application: Hey, I want to get the hero with ID: 2 And the result would be this table (with a single row): id name secret_name age team_id 2 Spider-Boy Pedro Parqueador null 1 SQL InjectionÂ¶ But let's say that your code takes whatever the external user provides and puts it inside the SQL string before sending it to the database. Something like this: # Never do this! ðŸš¨ Continue reading. user_id = input(\"Type the user ID: \") statement = f\"SELECT * FROM hero WHERE id = {user_id};\" results = database.execute(statement) If the external user is actually an attacker, they could send you a malicious SQL string that does something terrible like deleting all the records. That's called a \"SQL Injection\". For example, imagine that this new attacker user says: Hey, I want to get the hero with ID: 2; DROP TABLE hero Then the code above that takes the user input and puts it in SQL would actually send this to the database: SELECT * FROM hero WHERE id = 2; DROP TABLE hero; Check that section added at the end. That's another entire SQL statement: DROP TABLE hero; That is how you tell the database in SQL to delete the entire table hero. Nooooo! We lost all the data in the hero table! ðŸ’¥ðŸ˜± SQL SanitizationÂ¶ The process of making sure that whatever the external user sends is safe to use in the SQL string is called sanitization. It comes by default in SQLModel (thanks to SQLAlchemy). And many other similar tools would also provide that functionality among many other features. Now you are ready for a joke from xkcd: SQL with SQLModelÂ¶ With SQLModel, instead of writing SQL statements directly, you use Python classes and objects to interact with the database. For example, you could ask the database for the same hero with ID 2 with this code: user_id = input(\"Type the user ID: \") session.exec( select(Hero).where(Hero.id == user_id) ).all() If the user provides this ID: 2 ...the result would be this table (with a single row): id name secret_name age team_id 2 Spider-Boy Pedro Parqueador null 1 Preventing SQL InjectionsÂ¶ If the user is an attacker and tries to send this as the \"ID\": 2; DROP TABLE hero Then SQLModel will convert that to a literal string \"2; DROP TABLE hero\". And then, it will tell the SQL Database to try to find a record with that exact ID instead of injecting the attack. The difference in the final SQL statement is subtle, but it changes the meaning completely: SELECT * FROM hero WHERE id = \"2; DROP TABLE hero;\"; Tip Notice the double quotes (\") making it a string instead of more raw SQL. The database will not find any record with that ID: \"2; DROP TABLE hero;\" Then the database will send an empty table as the result because it didn't find any record with that ID. Then your code will continue to execute and calmly tell the user that it couldn't find anything. But we never deleted the hero table. ðŸŽ‰ Info Of course, there are also other ways to do SQL data sanitization without using a tool like SQLModel, but it's still a nice feature you get by default. Editor SupportÂ¶ Check that Python snippet above again. Because we are using standard Python classes and objects, your editor will be able to provide you with autocompletion, inline errors, etc. For example, let's say you wanted to query the database to find a hero based on the secret identity. Maybe you don't remember how you named the column. Maybe it was: secret_identity? ...or was it: secretidentity? ...or: private_name? secret_name? secretname? If you type that in SQL strings in your code, your editor won't be able to help you: statement = \"SELECT * FROM hero WHERE secret_identity = 'Dive Wilson';\" results = database.execute(statement) ...your editor will see that as a long string with some text inside, and it will not be able to autocomplete or detect the error in secret_identity. But if you use common Python classes and objects, your editor will be able to help you: database.execute( select(Hero).where(Hero.secret_name == \"Dive Wilson\") ).all() ORMs and SQLÂ¶ These types of libraries like SQLModel (and of course, SQLAlchemy) that translate between SQL and code with classes and objects are called ORMs. ORM means Object-Relational Mapper. This is a very common term, but it also comes from quite technical and academical concepts ðŸ‘©â€ðŸŽ“: Object: refers to code with classes and instances, normally called \"Object Oriented Programming\", that's why the \"Object\" part. For example this class is part of that Object Oriented Programming: class Hero(SQLModel): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None Relational: refers to the SQL Databases. Remember that they are also called Relational Databases, because each of those tables is also called a \"relation\"? That's where the \"Relational\" comes from. For example this Relation or table: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Spider-Boy Pedro Parqueador null 1 3 Rusty-Man Tommy Sharp 48 1 Mapper: this comes from Math, when there's something that can convert from some set of things to another, that's called a \"mapping function\". That's where the Mapper comes from. We could also write a mapping function in Python that converts from the set of lowercase letters to the set of uppercase letters, like this: def map_lower_to_upper(value: str): return value.upper() It's actually a simple idea with a very academic and mathematical name. ðŸ˜… So, an ORM is a library that translates from SQL to code, and from code to SQL. All using classes and objects. There are many ORMs available apart from SQLModel, you can read more about some of them in Alternatives, Inspiration and Comparisons SQL Table NamesÂ¶ Technical Background This is a bit of boring background for SQL purists. Feel free to skip this section. ðŸ˜‰ When working with pure SQL, it's common to name the tables in plural. So, the table would be named heroes instead of hero, because it could contain multiple rows, each with one hero. Nevertheless, SQLModel and many other similar tools can generate a table name automatically from your code, as you will see later in the tutorial. But this name will be derived from a class name. And it's common practice to use singular names for classes (e.g. class Hero, instead of class Heroes). Using singular names for classes like class Hero also makes your code more intuitive. You will see your own code a lot more than the internal table names, so it's probably better to keep the code/class convention than the SQL convention. So, to keep things consistent, I'll keep using the same table names that SQLModel would have generated. Tip You can also override the table name. You can read about it in the Advanced User Guide. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Intro to Databases - SQLModel",
    "url": "https://sqlmodel.tiangolo.com/databases/",
    "html": "Skip to content SQLModel Intro to Databases Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents What is a Database Why Use a Database How to Interact with a Database A single file database A server database Distributed servers SQL Databases SQLModel for SQL Databases Invent SQL Databases An example of a big table Single table problems Multiple tables Identifications - Primary Key Relationships - Foreign Key Relations and Relational Databases SQL - The Language SQLModel for SQL NoSQL Databases Intro to DatabasesÂ¶ Info Are you a seasoned developer and already know everything about databases? ðŸ¤“ Then you can skip to the Tutorial - User Guide: First Steps right away. If you don't know everything about databases, here's a quick overview. You can always study much more on your own later. But this should help you start using databases and being productive with SQLModel. ðŸš€ What is a DatabaseÂ¶ So, what is a database? A database is a system to store and manage data in a structured and very efficient way. Tip It's very common to abbreviate the word \"database\" as \"DB\". As there's a lot of information about databases, and it can get very technical and academic, I'll give you a quick overview about some of the main concepts here. I'll even tell you a bit about different types of databases, including the ones not covered by SQLModel (\"NoSQL\" databases). Why Use a DatabaseÂ¶ When starting to program, it might not be obvious why having a database apart from the code for your program is a good idea. Let's start with that. Tip If that's obvious to you, just continue in the next section below. ðŸ‘‡ In your code you already have variables, dictionaries, lists, etc. They all store data in some way already. Why would you need to have a separate database? If you look closely, your code is static, it doesn't really change over time once you run it. Of course, you change the code frequently, adding features, etc, but once you start Python running your code, the program stays as it was when you started it. And if you change the code, the program will only change once you run it again. And even if you change things in variables, once the program terminates, all that data that was in memory is gone. ðŸ”¥ In most of the cases, the objective of your program is to do something with data outside of the program. It could be just moving files from one place to the other. Or it could be taking data from the user in the terminal and showing it differently. Or a web API that takes some data and process it in some way, etc. In most cases, the data comes from outside the program or ends outside the program (for example, shown on the screen, in a file, etc). In many cases, you need your program to be able to create and store data, read it, update it, delete it, etc. You could do all that by reading and writing to files from your code. And that works in simple cases. But for most complex systems with data that is a bit more complex that strategy is not very efficient. And you would have to deal with a lot of caveats, keeping the data in sync, making sure it is safely stored, etc. Databases are designed to solve these problems, making the process of handling data much more efficient, and independent of your code. âœ¨ How to Interact with a DatabaseÂ¶ There are many databases of many types. A single file databaseÂ¶ A database could be a single file called heroes.db, managed with code in a very efficient way. An example would be SQLite, more about that on a bit. A server databaseÂ¶ A database could also be a system running as an application on a server, handling multiple files internally in optimized formats. Like a web server, but communicating in a custom and very efficient way. That is the most common type of database interaction. In this case, your code would talk to this server application instead of reading or modifying files directly. The database could be located in a different server/machine: Or the database could be located in the same server/machine: The most important aspect of these types of databases is that your code doesn't read or modify the files containing the data directly. Instead, your code communicates with the database application and that database application is the one that actually reads and modifies its data files. This is because this database application is normally much more efficient than what your code could be. Some examples of databases that work like this could be PostgreSQL, MySQL, or MongoDB. Distributed serversÂ¶ In some cases, the database could even be a group of server applications running on different machines, working together and communicating between them to be more efficient and handle more data. In this case, your code would talk to one or more of these server applications running on different machines. Most of the databases that work as server applications also support multiple servers in one way or another. Having distributed systems also creates additional challenges, so there's a high chance that you would first interact with a single server application or one based on a single file. SQL DatabasesÂ¶ We already talked about the different ways to interact with a database and how they handle files, etc. That applies to most or all of the databases. But there's another way to categorize databases that is very important. As you can imagine, there are many types of databases and many databases in each group. But in general, they can be separated in two big groups: \"SQL Databases\" and \"NoSQL Databases\". We will get to why the name \"SQL\" in a bit, but first, let's see what is it all about. SQLModel for SQL DatabasesÂ¶ SQLModel is a tool to help you with SQL Databases. It cannot help you much with NoSQL Databases. Nevertheless, I'll explain a bit about them here. Invent SQL DatabasesÂ¶ A long time ago, some smart people realized that a great way to store data was putting it in different tables. And by \"table\" I mean just data in a grid, with different columns and rows, pretty much like a single spreadsheet. Each row would represent a specific item or record. And each column would represent a specific attribute or field of that record. An example of a big tableÂ¶ Let's imagine that we need to store some data about heroes. If we worked with a single table to store our heroes, it could be like this: id name secret_name age team headquarters 1 Deadpond Dive Wilson null Z-Factor Sister Margaret's Bar 2 Spider-Boy Pedro Parqueador null Preventers Sharp Tower 3 Rusty-Man Tommy Sharp 48 Preventers Sharp Tower That's probably what we would have to do with a single table, for example, with a single spreadsheet. But there are some problems with this. Let's check some. Single table problemsÂ¶ Imagine that they decided to rename the \"Sharp Tower\" to \"Preventers Tower\". Now we would have to update that in two places. What happens if our code starts to update that name in one place and suddenly there's a power outage and the computer goes off? We could end up with inconsistent information, having one place saying \"Preventers Tower\" and the other one saying \"Sharp Tower\": id name secret_name age team headquarters 1 Deadpond Dive Wilson null Z-Force Sister Margaret's Bar 2 Spider-Boy Pedro Parqueador null Preventers Preventers Tower âœ… 3 Rusty-Man Tommy Sharp 48 Preventers Sharp Tower ðŸš¨ And now imagine that we need to add a new hero called \"Mahjong\" that is part of the team \"Z-Force\". We could forget the name of the team and end up adding \"Mahjong\" with an invalid team name, for example \"Y-Force\". id name secret_name age team headquarters 1 Deadpond Dive Wilson null Z-Force Sister Margaret's Bar 2 Spider-Boy Pedro Parqueador null Preventers Preventers Tower 3 Rusty-Man Tommy Sharp 48 Preventers Sharp Tower 4 Mahjong Neena Thurgirl 31 Y-Force ðŸš¨ Sister Margaret's Bar And what if a single hero belongs to two teams? We wouldn't have an easy way to put this into a single big table. Multiple tablesÂ¶ But these and other problems could be solved better by having the data in multiple tables. So, instead of having a single table with all the data, we could have one table for the heroes and one for teams, and a way to connect one with the other. The table for the teams could look like this: id name headquarters 1 Preventers Sharp Tower 2 Z-Force Sister Margaret's Bar Now, the table for the heroes would look almost the same. But remember that we mentioned that we need a way to connect the two tables? The table for the heroes would now have another column team_id. This column shows the relationship from each row (from each hero) to the team they belong to. id name secret_name age team_id âœ¨ 1 Deadpond Dive Wilson null 2 âœ¨ 2 Spider-Boy Pedro Parqueador null 1 âœ¨ 3 Rusty-Man Tommy Sharp 48 1 âœ¨ Identifications - Primary KeyÂ¶ In the example above, each one of the rows has an id. Each ID is unique per table and identifies that particular row. These SQL databases require having a unique way to identify each row in a table. It could be a combination of columns that is unique, but commonly it is just one single column. This is called the \"primary key\" of the table. The primary key is frequently a single column, commonly it's just an integer generated automatically by the database, and in many cases, the column is simply called id. This primary key, in this case the column id, has to be unique per table. But two different tables could have the same ID. For example, above, both tables have the ID 2 for two different rows, one for \"Z-Force\" in one table and one for \"Spider-Boy\" in the other table, but that's still okay as long as there's a single one per table. Relationships - Foreign KeyÂ¶ Each row in a table has a single primary key (in our example a single column id). For example, the table for the teams has the ID 1 for the team Preventers and the ID 2 for the team Z-Force. As these primary key IDs can uniquely identify each row on the table for teams, we can now go to the table for heroes and refer to those IDs in the table for teams. So, in the table for heroes, we use the team_id column to define a relationship to the foreign table for teams. Each value in the team_id column on the table with heroes will be the same value as the id column of one row in the table with teams. In the table for heroes we have a primary key that is the id. But we also have another column team_id that refers to a key in a foreign table. There's a technical term for that too, the team_id is a \"foreign key\". Relations and Relational DatabasesÂ¶ The technical and academic term for each one of these tables is a \"relation\". You might hear that term a lot when talking about these databases. It doesn't have the meaning that you would use in English of something being related to something else, even though each of these tables is actually \"related\" to the others. The technical term relation just refers to each one of these tables. And because of this technical term, these SQL Databases are also called Relational Databases (in fact, that is the technically correct term). But it still just refers to these databases made with multiple tables. SQL - The LanguageÂ¶ After developing these ideas of how to store data in multiple tables they also created a language that could be used to interact with them. The language is called SQL, the name comes from for Structured Query Language. Nevertheless, the language is not only used to query for data. It is also used to create records/rows, to update them, to delete them. And to manipulate the database, create tables, etc. This language is supported by all these databases that handle multiple tables, that's why they are called SQL Databases. Although, each database has small variations in the SQL language they support (dialect). Let's imagine that the table holding the heroes is called the hero table. An example of a SQL query to get all the data from it could look like: SELECT * FROM hero; And that SQL query would return the table: id name secret_name age team_id 1 Deadpond Dive Wilson null 2 2 Spider-Boy Pedro Parqueador null 1 3 Rusty-Man Tommy Sharp 48 1 SQLModel for SQLÂ¶ SQLModel is a library that helps you write Python code with regular Python objects, and then it transfers that to SQL statements that it sends to a SQL Database. Next, it receives the data and puts it in Python objects that you can continue to use in your code. I'll tell you more about SQL, SQLModel, how to use them, and how they are related in the next sections. Technical Details SQLModel is built on top of SQLAlchemy. It is, in fact, just SQLAlchemy and Pydantic mixed together with some sugar on top. NoSQL DatabasesÂ¶ Although SQL Databases are the oldest and most commonly used type of database, there's another (very interesting) category, the one of NoSQL Databases. NoSQL Databases covers a wide range of different sub-types, including key-value stores, document stores, graph databases, and more. SQLModel can only help you with SQL Databases. So, that's what we'll talk about in the rest of the documentation. Made with Material for MkDocs Insiders"
  },
  {
    "title": "SQLModel",
    "url": "https://sqlmodel.tiangolo.com/",
    "html": "Skip to content SQLModel SQLModel Initializing search tiangolo/sqlmodel 0.0.14 11.8k 546 SQLModel SQLModel Features Intro to Databases Database to Code (ORMs) Tutorial - User Guide Advanced User Guide Alternatives, Inspiration and Comparisons Help SQLModel - Get Help Contributing Release Notes Table of contents Sponsors SQL Databases in FastAPI Requirements Installation Example A SQL Table Create a SQLModel Model Create Rows Editor Support Write to the Database Select from the Database Editor Support Everywhere SQLAlchemy and Pydantic License SQLModel, SQL databases in Python, designed for simplicity, compatibility, and robustness. Documentation: https://sqlmodel.tiangolo.com Source Code: https://github.com/tiangolo/sqlmodel SQLModel is a library for interacting with SQL databases from Python code, with Python objects. It is designed to be intuitive, easy to use, highly compatible, and robust. SQLModel is based on Python type annotations, and powered by Pydantic and SQLAlchemy. The key features are: Intuitive to write: Great editor support. Completion everywhere. Less time debugging. Designed to be easy to use and learn. Less time reading docs. Easy to use: It has sensible defaults and does a lot of work underneath to simplify the code you write. Compatible: It is designed to be compatible with FastAPI, Pydantic, and SQLAlchemy. Extensible: You have all the power of SQLAlchemy and Pydantic underneath. Short: Minimize code duplication. A single type annotation does a lot of work. No need to duplicate models in SQLAlchemy and Pydantic. SponsorsÂ¶ SQL Databases in FastAPIÂ¶ SQLModel is designed to simplify interacting with SQL databases in FastAPI applications, it was created by the same author. ðŸ˜ It combines SQLAlchemy and Pydantic and tries to simplify the code you write as much as possible, allowing you to reduce the code duplication to a minimum, but while getting the best developer experience possible. SQLModel is, in fact, a thin layer on top of Pydantic and SQLAlchemy, carefully designed to be compatible with both. RequirementsÂ¶ A recent and currently supported version of Python. As SQLModel is based on Pydantic and SQLAlchemy, it requires them. They will be automatically installed when you install SQLModel. InstallationÂ¶ ExampleÂ¶ For an introduction to databases, SQL, and everything else, see the SQLModel documentation. Here's a quick example. âœ¨ A SQL TableÂ¶ Imagine you have a SQL table called hero with: id name secret_name age And you want it to have this data: id name secret_name age 1 Deadpond Dive Wilson null 2 Spider-Boy Pedro Parqueador null 3 Rusty-Man Tommy Sharp 48 Create a SQLModel ModelÂ¶ Then you could create a SQLModel model like this: from typing import Optional from sqlmodel import Field, SQLModel class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None That class Hero is a SQLModel model, the equivalent of a SQL table in Python code. And each of those class attributes is equivalent to each table column. Create RowsÂ¶ Then you could create each row of the table as an instance of the model: hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) This way, you can use conventional Python code with classes and instances that represent tables and rows, and that way communicate with the SQL database. Editor SupportÂ¶ Everything is designed for you to get the best developer experience possible, with the best editor support. Including autocompletion: And inline errors: Write to the DatabaseÂ¶ You can learn a lot more about SQLModel by quickly following the tutorial, but if you need a taste right now of how to put all that together and save to the database, you can do this: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None hero_1 = Hero(name=\"Deadpond\", secret_name=\"Dive Wilson\") hero_2 = Hero(name=\"Spider-Boy\", secret_name=\"Pedro Parqueador\") hero_3 = Hero(name=\"Rusty-Man\", secret_name=\"Tommy Sharp\", age=48) engine = create_engine(\"sqlite:///database.db\") SQLModel.metadata.create_all(engine) with Session(engine) as session: session.add(hero_1) session.add(hero_2) session.add(hero_3) session.commit() That will save a SQLite database with the 3 heroes. Select from the DatabaseÂ¶ Then you could write queries to select from that same database, for example with: from typing import Optional from sqlmodel import Field, Session, SQLModel, create_engine, select class Hero(SQLModel, table=True): id: Optional[int] = Field(default=None, primary_key=True) name: str secret_name: str age: Optional[int] = None engine = create_engine(\"sqlite:///database.db\") with Session(engine) as session: statement = select(Hero).where(Hero.name == \"Spider-Boy\") hero = session.exec(statement).first() print(hero) Editor Support EverywhereÂ¶ SQLModel was carefully designed to give you the best developer experience and editor support, even after selecting data from the database: SQLAlchemy and PydanticÂ¶ That class Hero is a SQLModel model. But at the same time, âœ¨ it is a SQLAlchemy model âœ¨. So, you can combine it and use it with other SQLAlchemy models, or you could easily migrate applications with SQLAlchemy to SQLModel. And at the same time, âœ¨ it is also a Pydantic model âœ¨. You can use inheritance with it to define all your data models while avoiding code duplication. That makes it very easy to use with FastAPI. LicenseÂ¶ This project is licensed under the terms of the MIT license. Made with Material for MkDocs Insiders"
  }
]