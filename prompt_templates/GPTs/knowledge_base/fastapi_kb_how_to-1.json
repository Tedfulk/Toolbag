[
  {
    "title": "FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/custom-request-and-route/middleware.md#gzipmiddleware",
    "html": "Follow @fastapi on Twitter to stay updated sponsor FastAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes 404 - Not found Made with Material for MkDocs Insiders"
  },
  {
    "title": "Configure Swagger UI - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/configure-swagger-ui/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Configure Swagger UI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Disable Syntax Highlighting Change the Theme Change Default Swagger UI Parameters Other Swagger UI Parameters JavaScript-only settings FastAPI Learn How To - Recipes Configure Swagger UI¬∂ You can configure some extra Swagger UI parameters. To configure them, pass the swagger_ui_parameters argument when creating the FastAPI() app object or to the get_swagger_ui_html() function. swagger_ui_parameters receives a dictionary with the configurations passed to Swagger UI directly. FastAPI converts the configurations to JSON to make them compatible with JavaScript, as that's what Swagger UI needs. Disable Syntax Highlighting¬∂ For example, you could disable syntax highlighting in Swagger UI. Without changing the settings, syntax highlighting is enabled by default: But you can disable it by setting syntaxHighlight to False: from fastapi import FastAPI app = FastAPI(swagger_ui_parameters={\"syntaxHighlight\": False}) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} ...and then Swagger UI won't show the syntax highlighting anymore: Change the Theme¬∂ The same way you could set the syntax highlighting theme with the key \"syntaxHighlight.theme\" (notice that it has a dot in the middle): from fastapi import FastAPI app = FastAPI(swagger_ui_parameters={\"syntaxHighlight.theme\": \"obsidian\"}) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} That configuration would change the syntax highlighting color theme: Change Default Swagger UI Parameters¬∂ FastAPI includes some default configuration parameters appropriate for most of the use cases. It includes these default configurations: swagger_ui_default_parameters: Annotated[ Dict[str, Any], Doc( \"\"\" Default configurations for Swagger UI. You can override any of them by setting a different value in the argument swagger_ui_parameters. For example, to disable deepLinking you could pass these settings to swagger_ui_parameters: from fastapi import FastAPI app = FastAPI(swagger_ui_parameters={\"deepLinking\": False}) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Other Swagger UI Parameters¬∂ To see all the other possible configurations you can use, read the official docs for Swagger UI parameters. JavaScript-only settings¬∂ Swagger UI also allows other configurations to be JavaScript-only objects (for example, JavaScript functions). FastAPI also includes these JavaScript-only presets settings: presets: [ SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset ] These are JavaScript objects, not strings, so you can't pass them from Python code directly. If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI path operation and manually write any JavaScript you need. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Docs UI Static Assets (Self-Hosting) - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Custom Docs UI Static Assets (Self-Hosting) en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Custom CDN for JavaScript and CSS Disable the automatic docs Include the custom docs Create a path operation to test it Test it Self-hosting JavaScript and CSS for docs Project file structure Download the files Serve the static files Test the static files Disable the automatic docs for static files Include the custom docs for static files Create a path operation to test static files Test Static Files UI FastAPI Learn How To - Recipes Custom Docs UI Static Assets (Self-Hosting)¬∂ The API docs use Swagger UI and ReDoc, and each of those need some JavaScript and CSS files. By default, those files are served from a CDN. But it's possible to customize it, you can set a specific CDN, or serve the files yourself. Custom CDN for JavaScript and CSS¬∂ Let's say that you want to use a different CDN, for example you want to use https://unpkg.com/. This could be useful if for example you live in a country that restricts some URLs. Disable the automatic docs¬∂ The first step is to disable the automatic docs, as by default, those use the default CDN. To disable them, set their URLs to None when creating your FastAPI app: from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) app = FastAPI(docs_url=None, redoc_url=None) @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger_css_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"https://unpkg.com/redoc@next/bundles/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Include the custom docs¬∂ Now you can create the path operations for the custom docs. You can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments: openapi_url: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi_url. title: the title of your API. oauth2_redirect_url: you can use app.swagger_ui_oauth2_redirect_url here to use the default. swagger_js_url: the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the custom CDN URL. swagger_css_url: the URL where the HTML for your Swagger UI docs can get the CSS file. This is the custom CDN URL. And similarly for ReDoc... from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) app = FastAPI(docs_url=None, redoc_url=None) @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger_css_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"https://unpkg.com/redoc@next/bundles/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Tip The path operation for swagger_ui_redirect is a helper for when you use OAuth2. If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication. Swagger UI will handle it behind the scenes for you, but it needs this \"redirect\" helper. Create a path operation to test it¬∂ Now, to be able to test that everything works, create a path operation: from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) app = FastAPI(docs_url=None, redoc_url=None) @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger_css_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"https://unpkg.com/redoc@next/bundles/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Test it¬∂ Now, you should be able to go to your docs at http://127.0.0.1:8000/docs, and reload the page, it will load those assets from the new CDN. Self-hosting JavaScript and CSS for docs¬∂ Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network. Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them. Project file structure¬∂ Let's say your project file structure looks like this: . ‚îú‚îÄ‚îÄ app ‚îÇ ‚îú‚îÄ‚îÄ __init__.py ‚îÇ ‚îú‚îÄ‚îÄ main.py Now create a directory to store those static files. Your new file structure could look like this: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ static/ Download the files¬∂ Download the static files needed for the docs and put them on that static/ directory. You can probably right-click each link and select an option similar to Save link as.... Swagger UI uses the files: swagger-ui-bundle.js swagger-ui.css And ReDoc uses the file: redoc.standalone.js After that, your file structure could look like: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ static ‚îú‚îÄ‚îÄ redoc.standalone.js ‚îú‚îÄ‚îÄ swagger-ui-bundle.js ‚îî‚îÄ‚îÄ swagger-ui.css Serve the static files¬∂ Import StaticFiles. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs_url=None, redoc_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"/static/swagger-ui-bundle.js\", swagger_css_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Test the static files¬∂ Start your application and go to http://127.0.0.1:8000/static/redoc.standalone.js. You should see a very long JavaScript file for ReDoc. It could start with something like: /*! * ReDoc - OpenAPI/Swagger-generated API Reference Documentation * ------------------------------------------------------------- * Version: \"2.0.0-rc.18\" * Repo: https://github.com/Redocly/redoc */ !function(e,t){\"object\"==typeof exports&&\"object\"==typeof m ... That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place. Now we can configure the app to use those static files for the docs. Disable the automatic docs for static files¬∂ The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default. To disable them, set their URLs to None when creating your FastAPI app: from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs_url=None, redoc_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"/static/swagger-ui-bundle.js\", swagger_css_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Include the custom docs for static files¬∂ And the same way as with a custom CDN, now you can create the path operations for the custom docs. Again, you can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments: openapi_url: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi_url. title: the title of your API. oauth2_redirect_url: you can use app.swagger_ui_oauth2_redirect_url here to use the default. swagger_js_url: the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the one that your own app is now serving. swagger_css_url: the URL where the HTML for your Swagger UI docs can get the CSS file. This is the one that your own app is now serving. And similarly for ReDoc... from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs_url=None, redoc_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"/static/swagger-ui-bundle.js\", swagger_css_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Tip The path operation for swagger_ui_redirect is a helper for when you use OAuth2. If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication. Swagger UI will handle it behind the scenes for you, but it needs this \"redirect\" helper. Create a path operation to test static files¬∂ Now, to be able to test that everything works, create a path operation: from fastapi import FastAPI from fastapi.openapi.docs import ( get_redoc_html, get_swagger_ui_html, get_swagger_ui_oauth2_redirect_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs_url=None, redoc_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include_in_schema=False) async def custom_swagger_ui_html(): return get_swagger_ui_html( openapi_url=app.openapi_url, title=app.title + \" - Swagger UI\", oauth2_redirect_url=app.swagger_ui_oauth2_redirect_url, swagger_js_url=\"/static/swagger-ui-bundle.js\", swagger_css_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger_ui_oauth2_redirect_url, include_in_schema=False) async def swagger_ui_redirect(): return get_swagger_ui_oauth2_redirect_html() @app.get(\"/redoc\", include_in_schema=False) async def redoc_html(): return get_redoc_html( openapi_url=app.openapi_url, title=app.title + \" - ReDoc\", redoc_js_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read_user(username: str): return {\"message\": f\"Hello {username}\"} Test Static Files UI¬∂ Now, you should be able to disconnect your WiFi, go to your docs at http://127.0.0.1:8000/docs, and reload the page. And even without Internet, you would be able to see the docs for your API and interact with it. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Separate OpenAPI Schemas for Input and Output or Not - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/separate-openapi-schemas/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Separate OpenAPI Schemas for Input and Output or Not en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Pydantic Models for Input and Output Model for Input Input Model in Docs Model for Output Model for Output Response Data Model for Output in Docs Model for Input and Output in Docs Do not Separate Schemas Same Schema for Input and Output Models in Docs FastAPI Learn How To - Recipes Separate OpenAPI Schemas for Input and Output or Not¬∂ When using Pydantic v2, the generated OpenAPI is a bit more exact and correct than before. üòé In fact, in some cases, it will even have two JSON Schemas in OpenAPI for the same Pydantic model, for input and output, depending on if they have default values. Let's see how that works and how to change it if you need to do that. Pydantic Models for Input and Output¬∂ Let's say you have a Pydantic model with default values, like this one: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None # Code below omitted üëá üëÄ Full file preview Model for Input¬∂ If you use this model as an input like here: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.post(\"/items/\") def create_item(item: Item): return item # Code below omitted üëá üëÄ Full file preview ...then the description field will not be required. Because it has a default value of None. Input Model in Docs¬∂ You can confirm that in the docs, the description field doesn't have a red asterisk, it's not marked as required: Model for Output¬∂ But if you use the same model as an output, like here: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.post(\"/items/\") def create_item(item: Item): return item @app.get(\"/items/\") def read_items() -> list[Item]: return [ Item( name=\"Portal Gun\", description=\"Device to travel through the multi-rick-verse\", ), Item(name=\"Plumbus\"), ] ...then because description has a default value, if you don't return anything for that field, it will still have that default value. Model for Output Response Data¬∂ If you interact with the docs and check the response, even though the code didn't add anything in one of the description fields, the JSON response contains the default value (null): This means that it will always have a value, it's just that sometimes the value could be None (or null in JSON). That means that, clients using your API don't have to check if the value exists or not, they can assume the field will always be there, but just that in some cases it will have the default value of None. The way to describe this in OpenAPI, is to mark that field as required, because it will always be there. Because of that, the JSON Schema for a model can be different depending on if it's used for input or output: for input the description will not be required for output it will be required (and possibly None, or in JSON terms, null) Model for Output in Docs¬∂ You can check the output model in the docs too, both name and description are marked as required with a red asterisk: Model for Input and Output in Docs¬∂ And if you check all the available Schemas (JSON Schemas) in OpenAPI, you will see that there are two, one Item-Input and one Item-Output. For Item-Input, description is not required, it doesn't have a red asterisk. But for Item-Output, description is required, it has a red asterisk. With this feature from Pydantic v2, your API documentation is more precise, and if you have autogenerated clients and SDKs, they will be more precise too, with a better developer experience and consistency. üéâ Do not Separate Schemas¬∂ Now, there are some cases where you might want to have the same schema for input and output. Probably the main use case for this is if you already have some autogenerated client code/SDKs and you don't want to update all the autogenerated client code/SDKs yet, you probably will want to do it at some point, but maybe not right now. In that case, you can disable this feature in FastAPI, with the parameter separate_input_output_schemas=False. Info Support for separate_input_output_schemas was added in FastAPI 0.102.0. ü§ì Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI(separate_input_output_schemas=False) @app.post(\"/items/\") def create_item(item: Item): return item @app.get(\"/items/\") def read_items() -> list[Item]: return [ Item( name=\"Portal Gun\", description=\"Device to travel through the multi-rick-verse\", ), Item(name=\"Plumbus\"), ] Same Schema for Input and Output Models in Docs¬∂ And now there will be one single schema for input and output for the model, only Item, and it will have description as not required: This is the same behavior as in Pydantic v1. ü§ì Made with Material for MkDocs Insiders"
  },
  {
    "title": "Extending OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/extending-openapi/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Extending OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents The normal process Overriding the defaults Normal FastAPI Generate the OpenAPI schema Modify the OpenAPI schema Cache the OpenAPI schema Override the method Check it FastAPI Learn How To - Recipes Extending OpenAPI¬∂ There are some cases where you might need to modify the generated OpenAPI schema. In this section you will see how. The normal process¬∂ The normal (default) process, is as follows. A FastAPI application (instance) has an .openapi() method that is expected to return the OpenAPI schema. As part of the application object creation, a path operation for /openapi.json (or for whatever you set your openapi_url) is registered. It just returns a JSON response with the result of the application's .openapi() method. By default, what the method .openapi() does is check the property .openapi_schema to see if it has contents and return them. If it doesn't, it generates them using the utility function at fastapi.openapi.utils.get_openapi. And that function get_openapi() receives as parameters: title: The OpenAPI title, shown in the docs. version: The version of your API, e.g. 2.5.0. openapi_version: The version of the OpenAPI specification used. By default, the latest: 3.1.0. summary: A short summary of the API. description: The description of your API, this can include markdown and will be shown in the docs. routes: A list of routes, these are each of the registered path operations. They are taken from app.routes. Info The parameter summary is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above. Overriding the defaults¬∂ Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need. For example, let's add ReDoc's OpenAPI extension to include a custom logo. Normal FastAPI¬∂ First, write all your FastAPI application as normally: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI() @app.get(\"/items/\") async def read_items(): return [{\"name\": \"Foo\"}] def custom_openapi(): if app.openapi_schema: return app.openapi_schema openapi_schema = get_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom **OpenAPI** schema\", routes=app.routes, ) openapi_schema[\"info\"][\"x-logo\"] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi_schema = openapi_schema return app.openapi_schema app.openapi = custom_openapi Generate the OpenAPI schema¬∂ Then, use the same utility function to generate the OpenAPI schema, inside a custom_openapi() function: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI() @app.get(\"/items/\") async def read_items(): return [{\"name\": \"Foo\"}] def custom_openapi(): if app.openapi_schema: return app.openapi_schema openapi_schema = get_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom **OpenAPI** schema\", routes=app.routes, ) openapi_schema[\"info\"][\"x-logo\"] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi_schema = openapi_schema return app.openapi_schema app.openapi = custom_openapi Modify the OpenAPI schema¬∂ Now you can add the ReDoc extension, adding a custom x-logo to the info \"object\" in the OpenAPI schema: from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI() @app.get(\"/items/\") async def read_items(): return [{\"name\": \"Foo\"}] def custom_openapi(): if app.openapi_schema: return app.openapi_schema openapi_schema = get_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom **OpenAPI** schema\", routes=app.routes, ) openapi_schema[\"info\"][\"x-logo\"] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi_schema = openapi_schema return app.openapi_schema app.openapi = custom_openapi Cache the OpenAPI schema¬∂ You can use the property .openapi_schema as a \"cache\", to store your generated schema. That way, your application won't have to generate the schema every time a user opens your API docs. It will be generated only once, and then the same cached schema will be used for the next requests. from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI() @app.get(\"/items/\") async def read_items(): return [{\"name\": \"Foo\"}] def custom_openapi(): if app.openapi_schema: return app.openapi_schema openapi_schema = get_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom **OpenAPI** schema\", routes=app.routes, ) openapi_schema[\"info\"][\"x-logo\"] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi_schema = openapi_schema return app.openapi_schema app.openapi = custom_openapi Override the method¬∂ Now you can replace the .openapi() method with your new function. from fastapi import FastAPI from fastapi.openapi.utils import get_openapi app = FastAPI() @app.get(\"/items/\") async def read_items(): return [{\"name\": \"Foo\"}] def custom_openapi(): if app.openapi_schema: return app.openapi_schema openapi_schema = get_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom **OpenAPI** schema\", routes=app.routes, ) openapi_schema[\"info\"][\"x-logo\"] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi_schema = openapi_schema return app.openapi_schema app.openapi = custom_openapi Check it¬∂ Once you go to http://127.0.0.1:8000/redoc you will see that you are using your custom logo (in this example, FastAPI's logo): Made with Material for MkDocs Insiders"
  },
  {
    "title": "Conditional OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/conditional-openapi/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Conditional OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents About security, APIs, and docs Conditional OpenAPI from settings and env vars FastAPI Learn How To - Recipes Conditional OpenAPI¬∂ If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely. About security, APIs, and docs¬∂ Hiding your documentation user interfaces in production shouldn't be the way to protect your API. That doesn't add any extra security to your API, the path operations will still be available where they are. If there's a security flaw in your code, it will still exist. Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of Security through obscurity. If you want to secure your API, there are several better things you can do, for example: Make sure you have well defined Pydantic models for your request bodies and responses. Configure any required permissions and roles using dependencies. Never store plaintext passwords, only password hashes. Implement and use well-known cryptographic tools, like Passlib and JWT tokens, etc. Add more granular permission controls with OAuth2 scopes where needed. ...etc. Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables. Conditional OpenAPI from settings and env vars¬∂ You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs. For example: from fastapi import FastAPI from pydantic_settings import BaseSettings class Settings(BaseSettings): openapi_url: str = \"/openapi.json\" settings = Settings() app = FastAPI(openapi_url=settings.openapi_url) @app.get(\"/\") def root(): return {\"message\": \"Hello World\"} Here we declare the setting openapi_url with the same default of \"/openapi.json\". And then we use it when creating the FastAPI app. Then you could disable OpenAPI (including the UI docs) by setting the environment variable OPENAPI_URL to the empty string, like: Then if you go to the URLs at /openapi.json, /docs, or /redoc you will just get a 404 Not Found error like: { \"detail\": \"Not Found\" } Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Request and APIRoute class - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/custom-request-and-route/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Custom Request and APIRoute class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Use cases Handling custom request body encodings Create a custom GzipRequest class Create a custom GzipRoute class Accessing the request body in an exception handler Custom APIRoute class in a router FastAPI Learn How To - Recipes Custom Request and APIRoute class¬∂ In some cases, you may want to override the logic used by the Request and APIRoute classes. In particular, this may be a good alternative to logic in a middleware. For example, if you want to read or manipulate the request body before it is processed by your application. Danger This is an \"advanced\" feature. If you are just starting with FastAPI you might want to skip this section. Use cases¬∂ Some use cases include: Converting non-JSON request bodies to JSON (e.g. msgpack). Decompressing gzip-compressed request bodies. Automatically logging all request bodies. Handling custom request body encodings¬∂ Let's see how to make use of a custom Request subclass to decompress gzip requests. And an APIRoute subclass to use that custom request class. Create a custom GzipRequest class¬∂ Tip This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided GzipMiddleware. First, we create a GzipRequest class, which will overwrite the Request.body() method to decompress the body in the presence of an appropriate header. If there's no gzip in the header, it will not try to decompress the body. That way, the same route class can handle gzip compressed or uncompressed requests. import gzip from typing import Callable, List from fastapi import Body, FastAPI, Request, Response from fastapi.routing import APIRoute class GzipRequest(Request): async def body(self) -> bytes: if not hasattr(self, \"_body\"): body = await super().body() if \"gzip\" in self.headers.getlist(\"Content-Encoding\"): body = gzip.decompress(body) self._body = body return self._body class GzipRoute(APIRoute): def get_route_handler(self) -> Callable: original_route_handler = super().get_route_handler() async def custom_route_handler(request: Request) -> Response: request = GzipRequest(request.scope, request.receive) return await original_route_handler(request) return custom_route_handler app = FastAPI() app.router.route_class = GzipRoute @app.post(\"/sum\") async def sum_numbers(numbers: List[int] = Body()): return {\"sum\": sum(numbers)} Create a custom GzipRoute class¬∂ Next, we create a custom subclass of fastapi.routing.APIRoute that will make use of the GzipRequest. This time, it will overwrite the method APIRoute.get_route_handler(). This method returns a function. And that function is what will receive a request and return a response. Here we use it to create a GzipRequest from the original request. import gzip from typing import Callable, List from fastapi import Body, FastAPI, Request, Response from fastapi.routing import APIRoute class GzipRequest(Request): async def body(self) -> bytes: if not hasattr(self, \"_body\"): body = await super().body() if \"gzip\" in self.headers.getlist(\"Content-Encoding\"): body = gzip.decompress(body) self._body = body return self._body class GzipRoute(APIRoute): def get_route_handler(self) -> Callable: original_route_handler = super().get_route_handler() async def custom_route_handler(request: Request) -> Response: request = GzipRequest(request.scope, request.receive) return await original_route_handler(request) return custom_route_handler app = FastAPI() app.router.route_class = GzipRoute @app.post(\"/sum\") async def sum_numbers(numbers: List[int] = Body()): return {\"sum\": sum(numbers)} Technical Details A Request has a request.scope attribute, that's just a Python dict containing the metadata related to the request. A Request also has a request.receive, that's a function to \"receive\" the body of the request. The scope dict and receive function are both part of the ASGI specification. And those two things, scope and receive, are what is needed to create a new Request instance. To learn more about the Request check Starlette's docs about Requests. The only thing the function returned by GzipRequest.get_route_handler does differently is convert the Request to a GzipRequest. Doing this, our GzipRequest will take care of decompressing the data (if necessary) before passing it to our path operations. After that, all of the processing logic is the same. But because of our changes in GzipRequest.body, the request body will be automatically decompressed when it is loaded by FastAPI when needed. Accessing the request body in an exception handler¬∂ Tip To solve this same problem, it's probably a lot easier to use the body in a custom handler for RequestValidationError (Handling Errors). But this example is still valid and it shows how to interact with the internal components. We can also use this same approach to access the request body in an exception handler. All we need to do is handle the request inside a try/except block: from typing import Callable, List from fastapi import Body, FastAPI, HTTPException, Request, Response from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute class ValidationErrorLoggingRoute(APIRoute): def get_route_handler(self) -> Callable: original_route_handler = super().get_route_handler() async def custom_route_handler(request: Request) -> Response: try: return await original_route_handler(request) except RequestValidationError as exc: body = await request.body() detail = {\"errors\": exc.errors(), \"body\": body.decode()} raise HTTPException(status_code=422, detail=detail) return custom_route_handler app = FastAPI() app.router.route_class = ValidationErrorLoggingRoute @app.post(\"/\") async def sum_numbers(numbers: List[int] = Body()): return sum(numbers) If an exception occurs, theRequest instance will still be in scope, so we can read and make use of the request body when handling the error: from typing import Callable, List from fastapi import Body, FastAPI, HTTPException, Request, Response from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute class ValidationErrorLoggingRoute(APIRoute): def get_route_handler(self) -> Callable: original_route_handler = super().get_route_handler() async def custom_route_handler(request: Request) -> Response: try: return await original_route_handler(request) except RequestValidationError as exc: body = await request.body() detail = {\"errors\": exc.errors(), \"body\": body.decode()} raise HTTPException(status_code=422, detail=detail) return custom_route_handler app = FastAPI() app.router.route_class = ValidationErrorLoggingRoute @app.post(\"/\") async def sum_numbers(numbers: List[int] = Body()): return sum(numbers) Custom APIRoute class in a router¬∂ You can also set the route_class parameter of an APIRouter: import time from typing import Callable from fastapi import APIRouter, FastAPI, Request, Response from fastapi.routing import APIRoute class TimedRoute(APIRoute): def get_route_handler(self) -> Callable: original_route_handler = super().get_route_handler() async def custom_route_handler(request: Request) -> Response: before = time.time() response: Response = await original_route_handler(request) duration = time.time() - before response.headers[\"X-Response-Time\"] = str(duration) print(f\"route duration: {duration}\") print(f\"route response: {response}\") print(f\"route response headers: {response.headers}\") return response return custom_route_handler app = FastAPI() router = APIRouter(route_class=TimedRoute) @app.get(\"/\") async def not_timed(): return {\"message\": \"Not timed\"} @router.get(\"/timed\") async def timed(): return {\"message\": \"It's the time of my life\"} app.include_router(router) In this example, the path operations under the router will use the custom TimedRoute class, and will have an extra X-Response-Time header in the response with the time it took to generate the response: import time from typing import Callable from fastapi import APIRouter, FastAPI, Request, Response from fastapi.routing import APIRoute class TimedRoute(APIRoute): def get_route_handler(self) -> Callable: original_route_handler = super().get_route_handler() async def custom_route_handler(request: Request) -> Response: before = time.time() response: Response = await original_route_handler(request) duration = time.time() - before response.headers[\"X-Response-Time\"] = str(duration) print(f\"route duration: {duration}\") print(f\"route response: {response}\") print(f\"route response headers: {response.headers}\") return response return custom_route_handler app = FastAPI() router = APIRouter(route_class=TimedRoute) @app.get(\"/\") async def not_timed(): return {\"message\": \"Not timed\"} @router.get(\"/timed\") async def timed(): return {\"message\": \"It's the time of my life\"} app.include_router(router) Made with Material for MkDocs Insiders"
  },
  {
    "title": "NoSQL (Distributed / Big Data) Databases with Couchbase - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/nosql-databases-couchbase/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI NoSQL (Distributed / Big Data) Databases with Couchbase en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Import Couchbase components Define a constant to use as a \"document type\" Add a function to get a Bucket Create Pydantic models User model UserInDB model Get the user f-strings dict unpacking Create your FastAPI code Create the FastAPI app Create the path operation function Recap FastAPI Learn How To - Recipes NoSQL (Distributed / Big Data) Databases with Couchbase¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1. The new docs will hopefully use Pydantic v2 and will use ODMantic with MongoDB. FastAPI can also be integrated with any NoSQL. Here we'll see an example using Couchbase, a document based NoSQL database. You can adapt it to any other NoSQL database like: MongoDB Cassandra CouchDB ArangoDB ElasticSearch, etc. Tip There is an official project generator with FastAPI and Couchbase, all based on Docker, including a frontend and more tools: https://github.com/tiangolo/full-stack-fastapi-couchbase Import Couchbase components¬∂ For now, don't pay attention to the rest, only the imports: from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user Define a constant to use as a \"document type\"¬∂ We will use it later as a fixed field type in our documents. This is not required by Couchbase, but is a good practice that will help you afterwards. from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user Add a function to get a Bucket¬∂ In Couchbase, a bucket is a set of documents, that can be of different types. They are generally all related to the same application. The analogy in the relational database world would be a \"database\" (a specific database, not the database server). The analogy in MongoDB would be a \"collection\". In the code, a Bucket represents the main entrypoint of communication with the database. This utility function will: Connect to a Couchbase cluster (that might be a single machine). Set defaults for timeouts. Authenticate in the cluster. Get a Bucket instance. Set defaults for timeouts. Return it. from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user Create Pydantic models¬∂ As Couchbase \"documents\" are actually just \"JSON objects\", we can model them with Pydantic. User model¬∂ First, let's create a User model: from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user We will use this model in our path operation function, so, we don't include in it the hashed_password. UserInDB model¬∂ Now, let's create a UserInDB model. This will have the data that is actually stored in the database. We don't create it as a subclass of Pydantic's BaseModel but as a subclass of our own User, because it will have all the attributes in User plus a couple more: from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user Note Notice that we have a hashed_password and a type field that will be stored in the database. But it is not part of the general User model (the one we will return in the path operation). Get the user¬∂ Now create a function that will: Take a username. Generate a document ID from it. Get the document with that ID. Put the contents of the document in a UserInDB model. By creating a function that is only dedicated to getting your user from a username (or any other parameter) independent of your path operation function, you can more easily re-use it in multiple parts and also add unit tests for it: from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user f-strings¬∂ If you are not familiar with the f\"userprofile::{username}\", it is a Python \"f-string\". Any variable that is put inside of {} in an f-string will be expanded / injected in the string. dict unpacking¬∂ If you are not familiar with the UserInDB(**result.value), it is using dict \"unpacking\". It will take the dict at result.value, and take each of its keys and values and pass them as key-values to UserInDB as keyword arguments. So, if the dict contains: { \"username\": \"johndoe\", \"hashed_password\": \"some_hash\", } It will be passed to UserInDB as: UserInDB(username=\"johndoe\", hashed_password=\"some_hash\") Create your FastAPI code¬∂ Create the FastAPI app¬∂ from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user Create the path operation function¬∂ As our code is calling Couchbase and we are not using the experimental Python await support, we should declare our function with normal def instead of async def. Also, Couchbase recommends not using a single Bucket object in multiple \"threads\", so, we can just get the bucket directly and pass it to our utility functions: from typing import Union from couchbase import LOCKMODE_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE_DOC_TYPE = \"userprofile\" def get_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch_mutation_tokens=1&operation_timeout=30&n1ql_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open_bucket(\"bucket_name\", lockmode=LOCKMODE_WAIT) bucket.timeout = 30 bucket.n1ql_timeout = 300 return bucket class User(BaseModel): username: str email: Union[str, None] = None full_name: Union[str, None] = None disabled: Union[bool, None] = None class UserInDB(User): type: str = USERPROFILE_DOC_TYPE hashed_password: str def get_user(bucket: Bucket, username: str): doc_id = f\"userprofile::{username}\" result = bucket.get(doc_id, quiet=True) if not result.value: return None user = UserInDB(**result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response_model=User) def read_user(username: str): bucket = get_bucket() user = get_user(bucket=bucket, username=username) return user Recap¬∂ You can integrate any third party NoSQL database, just using their standard packages. The same applies to any other external tool, system or API. Made with Material for MkDocs Insiders"
  },
  {
    "title": "GraphQL - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/graphql/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI GraphQL en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents GraphQL Libraries GraphQL with Strawberry Older GraphQLApp from Starlette Learn More FastAPI Learn How To - Recipes GraphQL¬∂ As FastAPI is based on the ASGI standard, it's very easy to integrate any GraphQL library also compatible with ASGI. You can combine normal FastAPI path operations with GraphQL on the same application. Tip GraphQL solves some very specific use cases. It has advantages and disadvantages when compared to common web APIs. Make sure you evaluate if the benefits for your use case compensate the drawbacks. ü§ì GraphQL Libraries¬∂ Here are some of the GraphQL libraries that have ASGI support. You could use them with FastAPI: Strawberry üçì With docs for FastAPI Ariadne With docs for Starlette (that also apply to FastAPI) Tartiflette With Tartiflette ASGI to provide ASGI integration Graphene With starlette-graphene3 GraphQL with Strawberry¬∂ If you need or want to work with GraphQL, Strawberry is the recommended library as it has the design closest to FastAPI's design, it's all based on type annotations. Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try Strawberry. Here's a small preview of how you could integrate Strawberry with FastAPI: import strawberry from fastapi import FastAPI from strawberry.asgi import GraphQL @strawberry.type class User: name: str age: int @strawberry.type class Query: @strawberry.field def user(self) -> User: return User(name=\"Patrick\", age=100) schema = strawberry.Schema(query=Query) graphql_app = GraphQL(schema) app = FastAPI() app.add_route(\"/graphql\", graphql_app) app.add_websocket_route(\"/graphql\", graphql_app) You can learn more about Strawberry in the Strawberry documentation. And also the docs about Strawberry with FastAPI. Older GraphQLApp from Starlette¬∂ Previous versions of Starlette included a GraphQLApp class to integrate with Graphene. It was deprecated from Starlette, but if you have code that used it, you can easily migrate to starlette-graphene3, that covers the same use case and has an almost identical interface. Tip If you need GraphQL, I still would recommend you check out Strawberry, as it's based on type annotations instead of custom classes and types. Learn More¬∂ You can learn more about GraphQL in the official GraphQL documentation. You can also read more about each those libraries described above in their links. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Async SQL (Relational) Databases with Encode/Databases - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/async-sql-encode-databases/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Async SQL (Relational) Databases with Encode/Databases en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Import and set up SQLAlchemy Import and set up databases Create the tables Create models Connect and disconnect Read notes Notice the response_model=List[Note] Create notes About {**note.dict(), \"id\": last_record_id} Check it More info FastAPI Learn How To - Recipes Async SQL (Relational) Databases with Encode/Databases¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1. The new docs will include Pydantic v2 and will use SQLModel once it is updated to use Pydantic v2 as well. You can also use encode/databases with FastAPI to connect to databases using async and await. It is compatible with: PostgreSQL MySQL SQLite In this example, we'll use SQLite, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is. Later, for your production application, you might want to use a database server like PostgreSQL. Tip You could adopt ideas from the section about SQLAlchemy ORM (SQL (Relational) Databases), like using utility functions to perform operations in the database, independent of your FastAPI code. This section doesn't apply those ideas, to be equivalent to the counterpart in Starlette. Import and set up SQLAlchemy¬∂ Import SQLAlchemy. Create a metadata object. Create a table notes using the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} Tip Notice that all this code is pure SQLAlchemy Core. databases is not doing anything here yet. Import and set up databases¬∂ Import databases. Create a DATABASE_URL. Create a database object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} Tip If you were connecting to a different database (e.g. PostgreSQL), you would need to change the DATABASE_URL. Create the tables¬∂ In this case, we are creating the tables in the same Python file, but in production, you would probably want to create them with Alembic, integrated with migrations, etc. Here, this section would run directly, right before starting your FastAPI application. Create an engine. Create all the tables from the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} Create models¬∂ Create Pydantic models for: Notes to be created (NoteIn). Notes to be returned (Note). from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} By creating these Pydantic models, the input data will be validated, serialized (converted), and annotated (documented). So, you will be able to see it all in the interactive API docs. Connect and disconnect¬∂ Create your FastAPI application. Create event handlers to connect and disconnect from the database. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} Read notes¬∂ Create the path operation function to read notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} Note Notice that as we communicate with the database using await, the path operation function is declared with async. Notice the response_model=List[Note]¬∂ It uses typing.List. That documents (and validates, serializes, filters) the output data, as a list of Notes. Create notes¬∂ Create the path operation function to create notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE_URL = \"sqlite:///./test.db\" # DATABASE_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create_engine( DATABASE_URL, connect_args={\"check_same_thread\": False} ) metadata.create_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on_event(\"startup\") async def startup(): await database.connect() @app.on_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response_model=List[Note]) async def read_notes(): query = notes.select() return await database.fetch_all(query) @app.post(\"/notes/\", response_model=Note) async def create_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last_record_id = await database.execute(query) return {**note.dict(), \"id\": last_record_id} Note Notice that as we communicate with the database using await, the path operation function is declared with async. About {**note.dict(), \"id\": last_record_id}¬∂ note is a Pydantic Note object. note.dict() returns a dict with its data, something like: { \"text\": \"Some note\", \"completed\": False, } but it doesn't have the id field. So we create a new dict, that contains the key-value pairs from note.dict() with: {**note.dict()} **note.dict() \"unpacks\" the key value pairs directly, so, {**note.dict()} would be, more or less, a copy of note.dict(). And then, we extend that copy dict, adding another key-value pair: \"id\": last_record_id: {**note.dict(), \"id\": last_record_id} So, the final result returned would be something like: { \"id\": 1, \"text\": \"Some note\", \"completed\": False, } Check it¬∂ You can copy this code as is, and see the docs at http://127.0.0.1:8000/docs. There you can see all your API documented and interact with it: More info¬∂ You can read more about encode/databases at its GitHub page. Made with Material for MkDocs Insiders"
  },
  {
    "title": "SQL (Relational) Databases with Peewee - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/sql-databases-peewee/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI SQL (Relational) Databases with Peewee en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Peewee for async The same app File structure Create the Peewee parts The standard Peewee code Note Make Peewee async-compatible PeeweeConnectionState Use the custom PeeweeConnectionState class Create the database models Create Peewee models for our data Create the Pydantic models Create the Pydantic models / schemas Create a PeeweeGetterDict for the Pydantic models / schemas CRUD utils Create all the CRUD utils Main FastAPI app Create the database tables Create a dependency Context variable sub-dependency Peewee Proxy Create your FastAPI path operations About def vs async def Testing Peewee with async What happens Fix Peewee with FastAPI Review all the files Technical Details The problem Context variables Set context variables in the async dependency reset_db_state() Set database state in the dependency get_db() Connect and disconnect in the dependency get_db() FastAPI Learn How To - Recipes SQL (Relational) Databases with Peewee¬∂ Warning If you are just starting, the tutorial SQL (Relational) Databases that uses SQLAlchemy should be enough. Feel free to skip this. Peewee is not recommended with FastAPI as it doesn't play well with anything async Python. There are several better alternatives. Info These docs assume Pydantic v1. Because Pewee doesn't play well with anything async and there are better alternatives, I won't update these docs for Pydantic v2, they are kept for now only for historical purposes. The examples here are no longer tested in CI (as they were before). If you are starting a project from scratch, you are probably better off with SQLAlchemy ORM (SQL (Relational) Databases), or any other async ORM. If you already have a code base that uses Peewee ORM, you can check here how to use it with FastAPI. Python 3.7+ required You will need Python 3.7 or above to safely use Peewee with FastAPI. Peewee for async¬∂ Peewee was not designed for async frameworks, or with them in mind. Peewee has some heavy assumptions about its defaults and about how it should be used. If you are developing an application with an older non-async framework, and can work with all its defaults, it can be a great tool. But if you need to change some of the defaults, support more than one predefined database, work with an async framework (like FastAPI), etc, you will need to add quite some complex extra code to override those defaults. Nevertheless, it's possible to do it, and here you'll see exactly what code you have to add to be able to use Peewee with FastAPI. Technical Details You can read more about Peewee's stand about async in Python in the docs, an issue, a PR. The same app¬∂ We are going to create the same application as in the SQLAlchemy tutorial (SQL (Relational) Databases). Most of the code is actually the same. So, we are going to focus only on the differences. File structure¬∂ Let's say you have a directory named my_super_project that contains a sub-directory called sql_app with a structure like this: . ‚îî‚îÄ‚îÄ sql_app ‚îú‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ crud.py ‚îú‚îÄ‚îÄ database.py ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ schemas.py This is almost the same structure as we had for the SQLAlchemy tutorial. Now let's see what each file/module does. Create the Peewee parts¬∂ Let's refer to the file sql_app/database.py. The standard Peewee code¬∂ Let's first check all the normal Peewee code, create a Peewee database: from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db_state = ContextVar(\"db_state\", default=db_state_default.copy()) class PeeweeConnectionState(peewee._ConnectionState): def __init__(self, **kwargs): super().__setattr__(\"_state\", db_state) super().__init__(**kwargs) def __setattr__(self, name, value): self._state.get()[name] = value def __getattr__(self, name): return self._state.get()[name] db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState() Tip Have in mind that if you wanted to use a different database, like PostgreSQL, you couldn't just change the string. You would need to use a different Peewee database class. Note¬∂ The argument: check_same_thread=False is equivalent to the one in the SQLAlchemy tutorial: connect_args={\"check_same_thread\": False} ...it is needed only for SQLite. Technical Details Exactly the same technical details as in SQL (Relational) Databases apply. Make Peewee async-compatible PeeweeConnectionState¬∂ The main issue with Peewee and FastAPI is that Peewee relies heavily on Python's threading.local, and it doesn't have a direct way to override it or let you handle connections/sessions directly (as is done in the SQLAlchemy tutorial). And threading.local is not compatible with the new async features of modern Python. Technical Details threading.local is used to have a \"magic\" variable that has a different value for each thread. This was useful in older frameworks designed to have one single thread per request, no more, no less. Using this, each request would have its own database connection/session, which is the actual final goal. But FastAPI, using the new async features, could handle more than one request on the same thread. And at the same time, for a single request, it could run multiple things in different threads (in a threadpool), depending on if you use async def or normal def. This is what gives all the performance improvements to FastAPI. But Python 3.7 and above provide a more advanced alternative to threading.local, that can also be used in the places where threading.local would be used, but is compatible with the new async features. We are going to use that. It's called contextvars. We are going to override the internal parts of Peewee that use threading.local and replace them with contextvars, with the corresponding updates. This might seem a bit complex (and it actually is), you don't really need to completely understand how it works to use it. We will create a PeeweeConnectionState: from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db_state = ContextVar(\"db_state\", default=db_state_default.copy()) class PeeweeConnectionState(peewee._ConnectionState): def __init__(self, **kwargs): super().__setattr__(\"_state\", db_state) super().__init__(**kwargs) def __setattr__(self, name, value): self._state.get()[name] = value def __getattr__(self, name): return self._state.get()[name] db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState() This class inherits from a special internal class used by Peewee. It has all the logic to make Peewee use contextvars instead of threading.local. contextvars works a bit differently than threading.local. But the rest of Peewee's internal code assumes that this class works with threading.local. So, we need to do some extra tricks to make it work as if it was just using threading.local. The __init__, __setattr__, and __getattr__ implement all the required tricks for this to be used by Peewee without knowing that it is now compatible with FastAPI. Tip This will just make Peewee behave correctly when used with FastAPI. Not randomly opening or closing connections that are being used, creating errors, etc. But it doesn't give Peewee async super-powers. You should still use normal def functions and not async def. Use the custom PeeweeConnectionState class¬∂ Now, overwrite the ._state internal attribute in the Peewee database db object using the new PeeweeConnectionState: from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db_state = ContextVar(\"db_state\", default=db_state_default.copy()) class PeeweeConnectionState(peewee._ConnectionState): def __init__(self, **kwargs): super().__setattr__(\"_state\", db_state) super().__init__(**kwargs) def __setattr__(self, name, value): self._state.get()[name] = value def __getattr__(self, name): return self._state.get()[name] db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState() Tip Make sure you overwrite db._state after creating db. Tip You would do the same for any other Peewee database, including PostgresqlDatabase, MySQLDatabase, etc. Create the database models¬∂ Let's now see the file sql_app/models.py. Create Peewee models for our data¬∂ Now create the Peewee models (classes) for User and Item. This is the same you would do if you followed the Peewee tutorial and updated the models to have the same data as in the SQLAlchemy tutorial. Tip Peewee also uses the term \"model\" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \"model\" to refer to something different, the data validation, conversion, and documentation classes and instances. Import db from database (the file database.py from above) and use it here. import peewee from .database import db class User(peewee.Model): email = peewee.CharField(unique=True, index=True) hashed_password = peewee.CharField() is_active = peewee.BooleanField(default=True) class Meta: database = db class Item(peewee.Model): title = peewee.CharField(index=True) description = peewee.CharField(index=True) owner = peewee.ForeignKeyField(User, backref=\"items\") class Meta: database = db Tip Peewee creates several magic attributes. It will automatically add an id attribute as an integer to be the primary key. It will chose the name of the tables based on the class names. For the Item, it will create an attribute owner_id with the integer ID of the User. But we don't declare it anywhere. Create the Pydantic models¬∂ Now let's check the file sql_app/schemas.py. Tip To avoid confusion between the Peewee models and the Pydantic models, we will have the file models.py with the Peewee models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both. Create the Pydantic models / schemas¬∂ Create all the same Pydantic models as in the SQLAlchemy tutorial: from typing import Any, List, Union import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self._obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: Union[str, None] = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True getter_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True getter_dict = PeeweeGetterDict Tip Here we are creating the models with an id. We didn't explicitly specify an id attribute in the Peewee models, but Peewee adds one automatically. We are also adding the magic owner_id attribute to Item. Create a PeeweeGetterDict for the Pydantic models / schemas¬∂ When you access a relationship in a Peewee object, like in some_user.items, Peewee doesn't provide a list of Item. It provides a special custom object of class ModelSelect. It's possible to create a list of its items with list(some_user.items). But the object itself is not a list. And it's also not an actual Python generator. Because of this, Pydantic doesn't know by default how to convert it to a list of Pydantic models / schemas. But recent versions of Pydantic allow providing a custom class that inherits from pydantic.utils.GetterDict, to provide the functionality used when using the orm_mode = True to retrieve the values for ORM model attributes. We are going to create a custom PeeweeGetterDict class and use it in all the same Pydantic models / schemas that use orm_mode: from typing import Any, List, Union import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self._obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: Union[str, None] = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True getter_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True getter_dict = PeeweeGetterDict Here we are checking if the attribute that is being accessed (e.g. .items in some_user.items) is an instance of peewee.ModelSelect. And if that's the case, just return a list with it. And then we use it in the Pydantic models / schemas that use orm_mode = True, with the configuration variable getter_dict = PeeweeGetterDict. Tip We only need to create one PeeweeGetterDict class, and we can use it in all the Pydantic models / schemas. CRUD utils¬∂ Now let's see the file sql_app/crud.py. Create all the CRUD utils¬∂ Create all the same CRUD utils as in the SQLAlchemy tutorial, all the code is very similar: from . import models, schemas def get_user(user_id: int): return models.User.filter(models.User.id == user_id).first() def get_user_by_email(email: str): return models.User.filter(models.User.email == email).first() def get_users(skip: int = 0, limit: int = 100): return list(models.User.select().offset(skip).limit(limit)) def create_user(user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db_user.save() return db_user def get_items(skip: int = 0, limit: int = 100): return list(models.Item.select().offset(skip).limit(limit)) def create_user_item(item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db_item.save() return db_item There are some differences with the code for the SQLAlchemy tutorial. We don't pass a db attribute around. Instead we use the models directly. This is because the db object is a global object, that includes all the connection logic. That's why we had to do all the contextvars updates above. Aso, when returning several objects, like in get_users, we directly call list, like in: list(models.User.select()) This is for the same reason that we had to create a custom PeeweeGetterDict. But by returning something that is already a list instead of the peewee.ModelSelect the response_model in the path operation with List[models.User] (that we'll see later) will work correctly. Main FastAPI app¬∂ And now in the file sql_app/main.py let's integrate and use all the other parts we created before. Create the database tables¬∂ In a very simplistic way create the database tables: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users Create a dependency¬∂ Create a dependency that will connect the database right at the beginning of a request and disconnect it at the end: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users Here we have an empty yield because we are actually not using the database object directly. It is connecting to the database and storing the connection data in an internal variable that is independent for each request (using the contextvars tricks from above). Because the database connection is potentially I/O blocking, this dependency is created with a normal def function. And then, in each path operation function that needs to access the database we add it as a dependency. But we are not using the value given by this dependency (it actually doesn't give any value, as it has an empty yield). So, we don't add it to the path operation function but to the path operation decorator in the dependencies parameter: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users Context variable sub-dependency¬∂ For all the contextvars parts to work, we need to make sure we have an independent value in the ContextVar for each request that uses the database, and that value will be used as the database state (connection, transactions, etc) for the whole request. For that, we need to create another async dependency reset_db_state() that is used as a sub-dependency in get_db(). It will set the value for the context variable (with just a default dict) that will be used as the database state for the whole request. And then the dependency get_db() will store in it the database state (connection, transactions, etc). import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users For the next request, as we will reset that context variable again in the async dependency reset_db_state() and then create a new connection in the get_db() dependency, that new request will have its own database state (connection, transactions, etc). Tip As FastAPI is an async framework, one request could start being processed, and before finishing, another request could be received and start processing as well, and it all could be processed in the same thread. But context variables are aware of these async features, so, a Peewee database state set in the async dependency reset_db_state() will keep its own data throughout the entire request. And at the same time, the other concurrent request will have its own database state that will be independent for the whole request. Peewee Proxy¬∂ If you are using a Peewee Proxy, the actual database is at db.obj. So, you would reset it with: async def reset_db_state(): database.db.obj._state._state.set(db_state_default.copy()) database.db.obj._state.reset() Create your FastAPI path operations¬∂ Now, finally, here's the standard FastAPI path operations code. import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users About def vs async def¬∂ The same as with SQLAlchemy, we are not doing something like: user = await models.User.select().first() ...but instead we are using: user = models.User.select().first() So, again, we should declare the path operation functions and the dependency without async def, just with a normal def, as: # Something goes here def read_users(skip: int = 0, limit: int = 100): # Something goes here Testing Peewee with async¬∂ This example includes an extra path operation that simulates a long processing request with time.sleep(sleep_time). It will have the database connection open at the beginning and will just wait some seconds before replying back. And each new request will wait one second less. This will easily let you test that your app with Peewee and FastAPI is behaving correctly with all the stuff about threads. If you want to check how Peewee would break your app if used without modification, go the sql_app/database.py file and comment the line: # db._state = PeeweeConnectionState() And in the file sql_app/main.py file, comment the body of the async dependency reset_db_state() and replace it with a pass: async def reset_db_state(): # database.db._state._state.set(db_state_default.copy()) # database.db._state.reset() pass Then run your app with Uvicorn: Open your browser at http://127.0.0.1:8000/docs and create a couple of users. Then open 10 tabs at http://127.0.0.1:8000/docs#/default/read_slow_users_slowusers__get at the same time. Go to the path operation \"Get /slowusers/\" in all of the tabs. Use the \"Try it out\" button and execute the request in each tab, one right after the other. The tabs will wait for a bit and then some of them will show Internal Server Error. What happens¬∂ The first tab will make your app create a connection to the database and wait for some seconds before replying back and closing the database connection. Then, for the request in the next tab, your app will wait for one second less, and so on. This means that it will end up finishing some of the last tabs' requests earlier than some of the previous ones. Then one the last requests that wait less seconds will try to open a database connection, but as one of those previous requests for the other tabs will probably be handled in the same thread as the first one, it will have the same database connection that is already open, and Peewee will throw an error and you will see it in the terminal, and the response will have an Internal Server Error. This will probably happen for more than one of those tabs. If you had multiple clients talking to your app exactly at the same time, this is what could happen. And as your app starts to handle more and more clients at the same time, the waiting time in a single request needs to be shorter and shorter to trigger the error. Fix Peewee with FastAPI¬∂ Now go back to the file sql_app/database.py, and uncomment the line: db._state = PeeweeConnectionState() And in the file sql_app/main.py file, uncomment the body of the async dependency reset_db_state(): async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() Terminate your running app and start it again. Repeat the same process with the 10 tabs. This time all of them will wait and you will get all the results without errors. ...You fixed it! Review all the files¬∂ Remember you should have a directory named my_super_project (or however you want) that contains a sub-directory called sql_app. sql_app should have the following files: sql_app/__init__.py: is an empty file. sql_app/database.py: from contextvars import ContextVar import peewee DATABASE_NAME = \"test.db\" db_state_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db_state = ContextVar(\"db_state\", default=db_state_default.copy()) class PeeweeConnectionState(peewee._ConnectionState): def __init__(self, **kwargs): super().__setattr__(\"_state\", db_state) super().__init__(**kwargs) def __setattr__(self, name, value): self._state.get()[name] = value def __getattr__(self, name): return self._state.get()[name] db = peewee.SqliteDatabase(DATABASE_NAME, check_same_thread=False) db._state = PeeweeConnectionState() sql_app/models.py: import peewee from .database import db class User(peewee.Model): email = peewee.CharField(unique=True, index=True) hashed_password = peewee.CharField() is_active = peewee.BooleanField(default=True) class Meta: database = db class Item(peewee.Model): title = peewee.CharField(index=True) description = peewee.CharField(index=True) owner = peewee.ForeignKeyField(User, backref=\"items\") class Meta: database = db sql_app/schemas.py: from typing import Any, List, Union import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self._obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: Union[str, None] = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner_id: int class Config: orm_mode = True getter_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True getter_dict = PeeweeGetterDict sql_app/crud.py: from . import models, schemas def get_user(user_id: int): return models.User.filter(models.User.id == user_id).first() def get_user_by_email(email: str): return models.User.filter(models.User.email == email).first() def get_users(skip: int = 0, limit: int = 100): return list(models.User.select().offset(skip).limit(limit)) def create_user(user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db_user.save() return db_user def get_items(skip: int = 0, limit: int = 100): return list(models.Item.select().offset(skip).limit(limit)) def create_user_item(item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) db_item.save() return db_item sql_app/main.py: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db_state_default database.db.connect() database.db.create_tables([models.User, models.Item]) database.db.close() app = FastAPI() sleep_time = 10 async def reset_db_state(): database.db._state._state.set(db_state_default.copy()) database.db._state.reset() def get_db(db_state=Depends(reset_db_state)): try: database.db.connect() yield finally: if not database.db.is_closed(): database.db.close() @app.post(\"/users/\", response_model=schemas.User, dependencies=[Depends(get_db)]) def create_user(user: schemas.UserCreate): db_user = crud.get_user_by_email(email=user.email) if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(user=user) @app.get(\"/users/\", response_model=List[schemas.User], dependencies=[Depends(get_db)]) def read_users(skip: int = 0, limit: int = 100): users = crud.get_users(skip=skip, limit=limit) return users @app.get( \"/users/{user_id}\", response_model=schemas.User, dependencies=[Depends(get_db)] ) def read_user(user_id: int): db_user = crud.get_user(user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post( \"/users/{user_id}/items/\", response_model=schemas.Item, dependencies=[Depends(get_db)], ) def create_item_for_user(user_id: int, item: schemas.ItemCreate): return crud.create_user_item(item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item], dependencies=[Depends(get_db)]) def read_items(skip: int = 0, limit: int = 100): items = crud.get_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response_model=List[schemas.User], dependencies=[Depends(get_db)] ) def read_slow_users(skip: int = 0, limit: int = 100): global sleep_time sleep_time = max(0, sleep_time - 1) time.sleep(sleep_time) # Fake long processing request users = crud.get_users(skip=skip, limit=limit) return users Technical Details¬∂ Warning These are very technical details that you probably don't need. The problem¬∂ Peewee uses threading.local by default to store it's database \"state\" data (connection, transactions, etc). threading.local creates a value exclusive to the current thread, but an async framework would run all the code (e.g. for each request) in the same thread, and possibly not in order. On top of that, an async framework could run some sync code in a threadpool (using asyncio.run_in_executor), but belonging to the same request. This means that, with Peewee's current implementation, multiple tasks could be using the same threading.local variable and end up sharing the same connection and data (that they shouldn't), and at the same time, if they execute sync I/O-blocking code in a threadpool (as with normal def functions in FastAPI, in path operations and dependencies), that code won't have access to the database state variables, even while it's part of the same request and it should be able to get access to the same database state. Context variables¬∂ Python 3.7 has contextvars that can create a local variable very similar to threading.local, but also supporting these async features. There are several things to have in mind. The ContextVar has to be created at the top of the module, like: some_var = ContextVar(\"some_var\", default=\"default value\") To set a value used in the current \"context\" (e.g. for the current request) use: some_var.set(\"new value\") To get a value anywhere inside of the context (e.g. in any part handling the current request) use: some_var.get() Set context variables in the async dependency reset_db_state()¬∂ If some part of the async code sets the value with some_var.set(\"updated in function\") (e.g. like the async dependency), the rest of the code in it and the code that goes after (including code inside of async functions called with await) will see that new value. So, in our case, if we set the Peewee state variable (with a default dict) in the async dependency, all the rest of the internal code in our app will see this value and will be able to reuse it for the whole request. And the context variable would be set again for the next request, even if they are concurrent. Set database state in the dependency get_db()¬∂ As get_db() is a normal def function, FastAPI will make it run in a threadpool, with a copy of the \"context\", holding the same value for the context variable (the dict with the reset database state). Then it can add database state to that dict, like the connection, etc. But if the value of the context variable (the default dict) was set in that normal def function, it would create a new value that would stay only in that thread of the threadpool, and the rest of the code (like the path operation functions) wouldn't have access to it. In get_db() we can only set values in the dict, but not the entire dict itself. So, we need to have the async dependency reset_db_state() to set the dict in the context variable. That way, all the code has access to the same dict for the database state for a single request. Connect and disconnect in the dependency get_db()¬∂ Then the next question would be, why not just connect and disconnect the database in the async dependency itself, instead of in get_db()? The async dependency has to be async for the context variable to be preserved for the rest of the request, but creating and closing the database connection is potentially blocking, so it could degrade performance if it was there. So we also need the normal def dependency get_db(). Made with Material for MkDocs Insiders"
  },
  {
    "title": "General - How To - Recipes - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/general/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI General - How To - Recipes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Filter Data - Security Documentation Tags - OpenAPI Documentation Summary and Description - OpenAPI Documentation Response description - OpenAPI Documentation Deprecate a Path Operation - OpenAPI Convert any Data to JSON-compatible OpenAPI Metadata - Docs OpenAPI Custom URL OpenAPI Docs URLs FastAPI Learn How To - Recipes General - How To - Recipes¬∂ Here are several pointers to other places in the docs, for general or frequent questions. Filter Data - Security¬∂ To ensure that you don't return more data than you should, read the docs for Tutorial - Response Model - Return Type. Documentation Tags - OpenAPI¬∂ To add tags to your path operations, and group them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Tags. Documentation Summary and Description - OpenAPI¬∂ To add a summary and description to your path operations, and show them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Summary and Description. Documentation Response description - OpenAPI¬∂ To define the description of the response, shown in the docs UI, read the docs for Tutorial - Path Operation Configurations - Response description. Documentation Deprecate a Path Operation - OpenAPI¬∂ To deprecate a path operation, and show it in the docs UI, read the docs for Tutorial - Path Operation Configurations - Deprecation. Convert any Data to JSON-compatible¬∂ To convert any data to JSON-compatible, read the docs for Tutorial - JSON Compatible Encoder. OpenAPI Metadata - Docs¬∂ To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for Tutorial - Metadata and Docs URLs. OpenAPI Custom URL¬∂ To customize the OpenAPI URL (or remove it), read the docs for Tutorial - Metadata and Docs URLs. OpenAPI Docs URLs¬∂ To update the URLs used for the automatically generated docs user interfaces, read the docs for Tutorial - Metadata and Docs URLs. Made with Material for MkDocs Insiders"
  },
  {
    "title": "How To - Recipes - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI How To - Recipes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI FastAPI Learn How To - Recipes How To - Recipes¬∂ Here you will see different recipes or \"how to\" guides for several topics. Most of these ideas would be more or less independent, and in most cases you should only need to study them if they apply directly to your project. If something seems interesting and useful to your project, go ahead and check it, but otherwise, you might probably just skip them. Tip If you want to learn FastAPI in a structured way (recommended), go and read the Tutorial - User Guide chapter by chapter instead. Made with Material for MkDocs Insiders"
  }
]