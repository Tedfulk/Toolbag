[
  {
    "title": "Test Client - TestClient - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/testclient/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Test Client - TestClient en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†TestClient ¬†headers ¬†follow\\_redirects ¬†max\\_redirects ¬†is\\_closed ¬†trust\\_env ¬†timeout ¬†event\\_hooks ¬†auth ¬†base\\_url ¬†cookies ¬†params ¬†task ¬†portal ¬†async\\_backend ¬†app ¬†app\\_state ¬†build\\_request ¬†stream ¬†send ¬†close ¬†request ¬†get ¬†options ¬†head ¬†post ¬†put ¬†patch ¬†delete ¬†websocket\\_connect ¬†lifespan ¬†wait\\_startup ¬†wait\\_shutdown FastAPI Reference - Code API Test Client - TestClient¬∂ You can use the TestClient class to test FastAPI applications without creating an actual HTTP and socket connection, just communicating directly with the FastAPI code. Read more about it in the FastAPI docs for Testing. You can import it directly from fastapi.testclient: from fastapi.testclient import TestClient fastapi.testclient.TestClient ¬∂ TestClient( app, base\\_url=\"http://testserver\", raise\\_server\\_exceptions=True, root\\_path=\"\", backend=\"asyncio\", backend\\_options=None, cookies=None, headers=None, follow\\_redirects=True, ) Bases: Client PARAMETER DESCRIPTION app TYPE: ASGIApp base\\_url TYPE: str DEFAULT: 'http://testserver' raise\\_server\\_exceptions TYPE: bool DEFAULT: True root\\_path TYPE: str DEFAULT: '' backend TYPE: str DEFAULT: 'asyncio' backend\\_options TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None cookies TYPE: CookieTypes DEFAULT: None headers TYPE: Dict\\[str, str\\] DEFAULT: None follow\\_redirects TYPE: bool DEFAULT: True Source code in starlette/testclient.py headers property writable ¬∂ headers HTTP headers to include when sending requests. follow\\_redirects instance-attribute ¬∂ follow\\_redirects = follow\\_redirects max\\_redirects instance-attribute ¬∂ max\\_redirects = max\\_redirects is\\_closed property ¬∂ is\\_closed Check if the client being closed trust\\_env property ¬∂ trust\\_env timeout property writable ¬∂ timeout event\\_hooks property writable ¬∂ event\\_hooks auth property writable ¬∂ auth Authentication class used when none is passed at the request-level. See also Authentication. base\\_url property writable ¬∂ base\\_url Base URL to use when sending requests with relative URLs. cookies property writable ¬∂ cookies Cookie values to include when sending requests. params property writable ¬∂ params Query parameters to include in the URL when sending requests. task instance-attribute ¬∂ task portal class-attribute instance-attribute ¬∂ portal = None async\\_backend instance-attribute ¬∂ async\\_backend = \\_AsyncBackend( backend=backend, backend\\_options=backend\\_options or {} ) app instance-attribute ¬∂ app = asgi\\_app app\\_state instance-attribute ¬∂ app\\_state = {} build\\_request ¬∂ build\\_request( method, url, \\*, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, timeout=USE\\_CLIENT\\_DEFAULT, extensions=None ) Build and return a request instance. The params, headers and cookies arguments are merged with any values set on the client. The url argument is merged with any base\\_url set on the client. See also: Request instances PARAMETER DESCRIPTION method TYPE: str url TYPE: URLTypes content TYPE: Optional\\[RequestContent\\] DEFAULT: None data TYPE: Optional\\[RequestData\\] DEFAULT: None files TYPE: Optional\\[RequestFiles\\] DEFAULT: None json TYPE: Optional\\[Any\\] DEFAULT: None params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[RequestExtensions\\] DEFAULT: None Source code in httpx/\\_client.py stream ¬∂ stream( method, url, \\*, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=USE\\_CLIENT\\_DEFAULT, follow\\_redirects=USE\\_CLIENT\\_DEFAULT, timeout=USE\\_CLIENT\\_DEFAULT, extensions=None ) Alternative to httpx.request() that streams the response body instead of loading it into memory at once. Parameters: See httpx.request. See also: Streaming Responses PARAMETER DESCRIPTION method TYPE: str url TYPE: URLTypes content TYPE: Optional\\[RequestContent\\] DEFAULT: None data TYPE: Optional\\[RequestData\\] DEFAULT: None files TYPE: Optional\\[RequestFiles\\] DEFAULT: None json TYPE: Optional\\[Any\\] DEFAULT: None params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault, None\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Union\\[bool, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[RequestExtensions\\] DEFAULT: None YIELDS DESCRIPTION Response Source code in httpx/\\_client.py send ¬∂ send( request, \\*, stream=False, auth=USE\\_CLIENT\\_DEFAULT, follow\\_redirects=USE\\_CLIENT\\_DEFAULT ) Send a request. The request is sent as-is, unmodified. Typically you'll want to build one with Client.build\\_request() so that any client-level configuration is merged into the request, but passing an explicit httpx.Request() is supported as well. See also: Request instances PARAMETER DESCRIPTION request TYPE: Request stream TYPE: bool DEFAULT: False auth TYPE: Union\\[AuthTypes, UseClientDefault, None\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Union\\[bool, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT Source code in httpx/\\_client.py close ¬∂ close() Close transport and proxies. Source code in httpx/\\_client.py request ¬∂ request( method, url, \\*, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION method TYPE: str url TYPE: URLTypes content TYPE: Optional\\[RequestContent\\] DEFAULT: None data TYPE: Optional\\[\\_RequestData\\] DEFAULT: None files TYPE: Optional\\[RequestFiles\\] DEFAULT: None json TYPE: Any DEFAULT: None params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py get ¬∂ get( url, \\*, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py options ¬∂ options( url, \\*, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py head ¬∂ head( url, \\*, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py post ¬∂ post( url, \\*, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes content TYPE: Optional\\[RequestContent\\] DEFAULT: None data TYPE: Optional\\[\\_RequestData\\] DEFAULT: None files TYPE: Optional\\[RequestFiles\\] DEFAULT: None json TYPE: Any DEFAULT: None params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py put ¬∂ put( url, \\*, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes content TYPE: Optional\\[RequestContent\\] DEFAULT: None data TYPE: Optional\\[\\_RequestData\\] DEFAULT: None files TYPE: Optional\\[RequestFiles\\] DEFAULT: None json TYPE: Any DEFAULT: None params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py patch ¬∂ patch( url, \\*, content=None, data=None, files=None, json=None, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes content TYPE: Optional\\[RequestContent\\] DEFAULT: None data TYPE: Optional\\[\\_RequestData\\] DEFAULT: None files TYPE: Optional\\[RequestFiles\\] DEFAULT: None json TYPE: Any DEFAULT: None params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py delete ¬∂ delete( url, \\*, params=None, headers=None, cookies=None, auth=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, follow\\_redirects=None, allow\\_redirects=None, timeout=httpx.\\_client.USE\\_CLIENT\\_DEFAULT, extensions=None ) PARAMETER DESCRIPTION url TYPE: URLTypes params TYPE: Optional\\[QueryParamTypes\\] DEFAULT: None headers TYPE: Optional\\[HeaderTypes\\] DEFAULT: None cookies TYPE: Optional\\[CookieTypes\\] DEFAULT: None auth TYPE: Union\\[AuthTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT follow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None allow\\_redirects TYPE: Optional\\[bool\\] DEFAULT: None timeout TYPE: Union\\[TimeoutTypes, UseClientDefault\\] DEFAULT: USE\\_CLIENT\\_DEFAULT extensions TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in starlette/testclient.py websocket\\_connect ¬∂ websocket\\_connect(url, subprotocols=None, \\*\\*kwargs) PARAMETER DESCRIPTION url TYPE: str subprotocols TYPE: Sequence\\[str\\] DEFAULT: None \\*\\*kwargs TYPE: Any DEFAULT: {} Source code in starlette/testclient.py lifespan async ¬∂ lifespan() Source code in starlette/testclient.py wait\\_startup async ¬∂ wait\\_startup() Source code in starlette/testclient.py wait\\_shutdown async ¬∂ wait\\_shutdown() Source code in starlette/testclient.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Templating - Jinja2Templates - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/templating/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Templating - Jinja2Templates en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†Jinja2Templates ¬†context\\_processors ¬†env ¬†get\\_template ¬†TemplateResponse FastAPI Reference - Code API Templating - Jinja2Templates¬∂ You can use the Jinja2Templates class to render Jinja templates. Read more about it in the FastAPI docs for Templates. You can import it directly from fastapi.templating: from fastapi.templating import Jinja2Templates fastapi.templating.Jinja2Templates ¬∂ Jinja2Templates( directory=None, \\*, context\\_processors=None, env=None, \\*\\*env\\_options ) templates = Jinja2Templates(\"templates\") return templates.TemplateResponse(\"index.html\", {\"request\": request}) PARAMETER DESCRIPTION directory TYPE: Union\\[str, PathLike\\[AnyStr\\], Sequence\\[Union\\[str, PathLike\\[AnyStr\\]\\]\\], None\\] DEFAULT: None context\\_processors TYPE: Optional\\[List\\[Callable\\[\\[Request\\], Dict\\[str, Any\\]\\]\\]\\] DEFAULT: None env TYPE: Optional\\[Environment\\] DEFAULT: None \\*\\*env\\_options TYPE: Any DEFAULT: {} Source code in starlette/templating.py context\\_processors instance-attribute ¬∂ context\\_processors = context\\_processors or \\[\\] env instance-attribute ¬∂ env = \\_create\\_env(directory, \\*\\*env\\_options) get\\_template ¬∂ get\\_template(name) PARAMETER DESCRIPTION name TYPE: str Source code in starlette/templating.py TemplateResponse ¬∂ TemplateResponse( request: Request, name: str, context: Optional\\[Dict\\[str, Any\\]\\] = None, status\\_code: int = 200, headers: Optional\\[Mapping\\[str, str\\]\\] = None, media\\_type: Optional\\[str\\] = None, background: Optional\\[BackgroundTask\\] = None, ) -> \\_TemplateResponse TemplateResponse( name: str, context: Optional\\[Dict\\[str, Any\\]\\] = None, status\\_code: int = 200, headers: Optional\\[Mapping\\[str, str\\]\\] = None, media\\_type: Optional\\[str\\] = None, background: Optional\\[BackgroundTask\\] = None, ) -> \\_TemplateResponse TemplateResponse(\\*args, \\*\\*kwargs) PARAMETER DESCRIPTION \\*args TYPE: Any DEFAULT: () \\*\\*kwargs TYPE: Any DEFAULT: {} Source code in starlette/templating.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Static Files - StaticFiles - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/staticfiles/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Static Files - StaticFiles en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†StaticFiles ¬†directory ¬†packages ¬†all\\_directories ¬†html ¬†config\\_checked ¬†follow\\_symlink ¬†get\\_directories ¬†get\\_path ¬†get\\_response ¬†lookup\\_path ¬†file\\_response ¬†check\\_config ¬†is\\_not\\_modified FastAPI Reference - Code API Static Files - StaticFiles¬∂ You can use the StaticFiles class to serve static files, like JavaScript, CSS, images, etc. Read more about it in the FastAPI docs for Static Files. You can import it directly from fastapi.staticfiles: from fastapi.staticfiles import StaticFiles fastapi.staticfiles.StaticFiles ¬∂ StaticFiles( \\*, directory=None, packages=None, html=False, check\\_dir=True, follow\\_symlink=False ) PARAMETER DESCRIPTION directory TYPE: Optional\\[PathLike\\] DEFAULT: None packages TYPE: Optional\\[List\\[Union\\[str, Tuple\\[str, str\\]\\]\\]\\] DEFAULT: None html TYPE: bool DEFAULT: False check\\_dir TYPE: bool DEFAULT: True follow\\_symlink TYPE: bool DEFAULT: False Source code in starlette/staticfiles.py directory instance-attribute ¬∂ directory = directory packages instance-attribute ¬∂ packages = packages all\\_directories instance-attribute ¬∂ all\\_directories = get\\_directories(directory, packages) html instance-attribute ¬∂ html = html config\\_checked instance-attribute ¬∂ config\\_checked = False follow\\_symlink instance-attribute ¬∂ follow\\_symlink = follow\\_symlink get\\_directories ¬∂ get\\_directories(directory=None, packages=None) Given directory and packages arguments, return a list of all the directories that should be used for serving static files from. PARAMETER DESCRIPTION directory TYPE: Optional\\[PathLike\\] DEFAULT: None packages TYPE: Optional\\[List\\[Union\\[str, Tuple\\[str, str\\]\\]\\]\\] DEFAULT: None Source code in starlette/staticfiles.py get\\_path ¬∂ get\\_path(scope) Given the ASGI scope, return the path string to serve up, with OS specific path separators, and any '..', '.' components removed. PARAMETER DESCRIPTION scope TYPE: Scope Source code in starlette/staticfiles.py get\\_response async ¬∂ get\\_response(path, scope) Returns an HTTP response, given the incoming path, method and request headers. PARAMETER DESCRIPTION path TYPE: str scope TYPE: Scope Source code in starlette/staticfiles.py lookup\\_path ¬∂ lookup\\_path(path) PARAMETER DESCRIPTION path TYPE: str Source code in starlette/staticfiles.py file\\_response ¬∂ file\\_response( full\\_path, stat\\_result, scope, status\\_code=200 ) PARAMETER DESCRIPTION full\\_path TYPE: PathLike stat\\_result TYPE: stat\\_result scope TYPE: Scope status\\_code TYPE: int DEFAULT: 200 Source code in starlette/staticfiles.py check\\_config async ¬∂ check\\_config() Perform a one-off configuration check that StaticFiles is actually pointed at a directory, so that we can raise loud errors rather than just returning 404 responses. Source code in starlette/staticfiles.py is\\_not\\_modified ¬∂ is\\_not\\_modified(response\\_headers, request\\_headers) Given the request and response headers, return True if an HTTP \"Not Modified\" response could be returned instead. PARAMETER DESCRIPTION response\\_headers TYPE: Headers request\\_headers TYPE: Headers Source code in starlette/staticfiles.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Encoders - jsonable_encoder - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/encoders/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Encoders - jsonable\\_encoder en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†jsonable\\_encoder FastAPI Reference - Code API Encoders - jsonable\\_encoder¬∂ fastapi.encoders.jsonable\\_encoder ¬∂ jsonable\\_encoder( obj, include=None, exclude=None, by\\_alias=True, exclude\\_unset=False, exclude\\_defaults=False, exclude\\_none=False, custom\\_encoder=None, sqlalchemy\\_safe=True, ) Convert any object to something that can be encoded in JSON. This is used internally by FastAPI to make sure anything you return can be encoded as JSON before it is sent to the client. You can also use it yourself, for example to convert objects before saving them in a database that supports only JSON. Read more about it in the FastAPI docs for JSON Compatible Encoder. PARAMETER DESCRIPTION obj The input object to convert to JSON. TYPE: Any include Pydantic's include parameter, passed to Pydantic models to set the fields to include. TYPE: Optional\\[IncEx\\] DEFAULT: None exclude Pydantic's exclude parameter, passed to Pydantic models to set the fields to exclude. TYPE: Optional\\[IncEx\\] DEFAULT: None by\\_alias Pydantic's by\\_alias parameter, passed to Pydantic models to define if the output should use the alias names (when provided) or the Python attribute names. In an API, if you set an alias, it's probably because you want to use it in the result, so you probably want to leave this set to True. TYPE: bool DEFAULT: True exclude\\_unset Pydantic's exclude\\_unset parameter, passed to Pydantic models to define if it should exclude from the output the fields that were not explicitly set (and that only had their default values). TYPE: bool DEFAULT: False exclude\\_defaults Pydantic's exclude\\_defaults parameter, passed to Pydantic models to define if it should exclude from the output the fields that had the same default value, even when they were explicitly set. TYPE: bool DEFAULT: False exclude\\_none Pydantic's exclude\\_none parameter, passed to Pydantic models to define if it should exclude from the output any fields that have a None value. TYPE: bool DEFAULT: False custom\\_encoder Pydantic's custom\\_encoder parameter, passed to Pydantic models to define a custom encoder. TYPE: Optional\\[Dict\\[Any, Callable\\[\\[Any\\], Any\\]\\]\\] DEFAULT: None sqlalchemy\\_safe Exclude from the output any fields that start with the name \\_sa. This is mainly a hack for compatibility with SQLAlchemy objects, they store internal SQLAlchemy-specific state in attributes named with \\_sa, and those objects can't (and shouldn't be) serialized to JSON. TYPE: bool DEFAULT: True Source code in fastapi/encoders.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI models - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/openapi/models/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI OpenAPI models en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI OpenAPI docs OpenAPI models Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†models ¬†SchemaOrBool ¬†SecurityScheme ¬†EmailStr ¬†validate ¬†Contact ¬†name ¬†url ¬†email ¬†model\\_config ¬†Config ¬†extra ¬†License ¬†name ¬†identifier ¬†url ¬†model\\_config ¬†Config ¬†extra ¬†Info ¬†title ¬†summary ¬†description ¬†termsOfService ¬†contact ¬†license ¬†version ¬†model\\_config ¬†Config ¬†extra ¬†ServerVariable ¬†enum ¬†default ¬†description ¬†model\\_config ¬†Config ¬†extra ¬†Server ¬†url ¬†description ¬†variables ¬†model\\_config ¬†Config ¬†extra ¬†Reference ¬†ref ¬†Discriminator ¬†propertyName ¬†mapping ¬†XML ¬†name ¬†namespace ¬†prefix ¬†attribute ¬†wrapped ¬†model\\_config ¬†Config ¬†extra ¬†ExternalDocumentation ¬†description ¬†url ¬†model\\_config ¬†Config ¬†extra ¬†Schema ¬†schema\\_ ¬†vocabulary ¬†id ¬†anchor ¬†dynamicAnchor ¬†ref ¬†dynamicRef ¬†defs ¬†comment ¬†allOf ¬†anyOf ¬†oneOf ¬†not\\_ ¬†if\\_ ¬†then ¬†else\\_ ¬†dependentSchemas ¬†prefixItems ¬†items ¬†contains ¬†properties ¬†patternProperties ¬†additionalProperties ¬†propertyNames ¬†unevaluatedItems ¬†unevaluatedProperties ¬†type ¬†enum ¬†const ¬†multipleOf ¬†maximum ¬†exclusiveMaximum ¬†minimum ¬†exclusiveMinimum ¬†maxLength ¬†minLength ¬†pattern ¬†maxItems ¬†minItems ¬†uniqueItems ¬†maxContains ¬†minContains ¬†maxProperties ¬†minProperties ¬†required ¬†dependentRequired ¬†format ¬†contentEncoding ¬†contentMediaType ¬†contentSchema ¬†title ¬†description ¬†default ¬†deprecated ¬†readOnly ¬†writeOnly ¬†examples ¬†discriminator ¬†xml ¬†externalDocs ¬†example ¬†model\\_config ¬†Config ¬†extra ¬†Example ¬†summary ¬†description ¬†value ¬†externalValue ¬†Config ¬†extra ¬†ParameterInType ¬†query ¬†header ¬†path ¬†cookie ¬†Encoding ¬†contentType ¬†headers ¬†style ¬†explode ¬†allowReserved ¬†model\\_config ¬†Config ¬†extra ¬†MediaType ¬†schema\\_ ¬†example ¬†examples ¬†encoding ¬†model\\_config ¬†Config ¬†extra ¬†ParameterBase ¬†description ¬†required ¬†deprecated ¬†style ¬†explode ¬†allowReserved ¬†schema\\_ ¬†example ¬†examples ¬†content ¬†model\\_config ¬†Config ¬†extra ¬†Parameter ¬†description ¬†required ¬†deprecated ¬†style ¬†explode ¬†allowReserved ¬†schema\\_ ¬†example ¬†examples ¬†content ¬†model\\_config ¬†name ¬†in\\_ ¬†Config ¬†extra ¬†Header ¬†RequestBody ¬†description ¬†content ¬†required ¬†model\\_config ¬†Config ¬†extra ¬†Link ¬†operationRef ¬†operationId ¬†parameters ¬†requestBody ¬†description ¬†server ¬†model\\_config ¬†Config ¬†extra ¬†Response ¬†description ¬†headers ¬†content ¬†links ¬†model\\_config ¬†Config ¬†extra ¬†Operation ¬†tags ¬†summary ¬†description ¬†externalDocs ¬†operationId ¬†parameters ¬†requestBody ¬†responses ¬†callbacks ¬†deprecated ¬†security ¬†servers ¬†model\\_config ¬†Config ¬†extra ¬†PathItem ¬†ref ¬†summary ¬†description ¬†get ¬†put ¬†post ¬†delete ¬†options ¬†head ¬†patch ¬†trace ¬†servers ¬†parameters ¬†model\\_config ¬†Config ¬†extra ¬†SecuritySchemeType ¬†apiKey ¬†http ¬†oauth2 ¬†openIdConnect ¬†SecurityBase ¬†type\\_ ¬†description ¬†model\\_config ¬†Config ¬†extra ¬†APIKeyIn ¬†query ¬†header ¬†cookie ¬†APIKey ¬†description ¬†model\\_config ¬†type\\_ ¬†in\\_ ¬†name ¬†Config ¬†extra ¬†HTTPBase ¬†description ¬†model\\_config ¬†type\\_ ¬†scheme ¬†Config ¬†extra ¬†HTTPBearer ¬†type\\_ ¬†description ¬†model\\_config ¬†scheme ¬†bearerFormat ¬†Config ¬†extra ¬†OAuthFlow ¬†refreshUrl ¬†scopes ¬†model\\_config ¬†Config ¬†extra ¬†OAuthFlowImplicit ¬†refreshUrl ¬†scopes ¬†model\\_config ¬†authorizationUrl ¬†Config ¬†extra ¬†OAuthFlowPassword ¬†refreshUrl ¬†scopes ¬†model\\_config ¬†tokenUrl ¬†Config ¬†extra ¬†OAuthFlowClientCredentials ¬†refreshUrl ¬†scopes ¬†model\\_config ¬†tokenUrl ¬†Config ¬†extra ¬†OAuthFlowAuthorizationCode ¬†refreshUrl ¬†scopes ¬†model\\_config ¬†authorizationUrl ¬†tokenUrl ¬†Config ¬†extra ¬†OAuthFlows ¬†implicit ¬†password ¬†clientCredentials ¬†authorizationCode ¬†model\\_config ¬†Config ¬†extra ¬†OAuth2 ¬†description ¬†model\\_config ¬†type\\_ ¬†flows ¬†Config ¬†extra ¬†OpenIdConnect ¬†description ¬†model\\_config ¬†type\\_ ¬†openIdConnectUrl ¬†Config ¬†extra ¬†Components ¬†schemas ¬†responses ¬†parameters ¬†examples ¬†requestBodies ¬†headers ¬†securitySchemes ¬†links ¬†callbacks ¬†pathItems ¬†model\\_config ¬†Config ¬†extra ¬†Tag ¬†name ¬†description ¬†externalDocs ¬†model\\_config ¬†Config ¬†extra ¬†OpenAPI ¬†openapi ¬†info ¬†jsonSchemaDialect ¬†servers ¬†paths ¬†webhooks ¬†components ¬†security ¬†tags ¬†externalDocs ¬†model\\_config ¬†Config ¬†extra FastAPI Reference - Code API OpenAPI OpenAPI models¬∂ OpenAPI Pydantic models used to generate and validate the generated OpenAPI. fastapi.openapi.models ¬∂ SchemaOrBool module-attribute ¬∂ SchemaOrBool = Union\\[Schema, bool\\] SecurityScheme module-attribute ¬∂ SecurityScheme = Union\\[ APIKey, HTTPBase, OAuth2, OpenIdConnect, HTTPBearer \\] EmailStr ¬∂ Bases: str validate classmethod ¬∂ validate(v) PARAMETER DESCRIPTION v TYPE: Any Source code in fastapi/openapi/models.py Contact ¬∂ Bases: BaseModel name class-attribute instance-attribute ¬∂ name = None url class-attribute instance-attribute ¬∂ url = None email class-attribute instance-attribute ¬∂ email = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' License ¬∂ Bases: BaseModel name instance-attribute ¬∂ name identifier class-attribute instance-attribute ¬∂ identifier = None url class-attribute instance-attribute ¬∂ url = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Info ¬∂ Bases: BaseModel title instance-attribute ¬∂ title summary class-attribute instance-attribute ¬∂ summary = None description class-attribute instance-attribute ¬∂ description = None termsOfService class-attribute instance-attribute ¬∂ termsOfService = None contact class-attribute instance-attribute ¬∂ contact = None license class-attribute instance-attribute ¬∂ license = None version instance-attribute ¬∂ version model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' ServerVariable ¬∂ Bases: BaseModel enum class-attribute instance-attribute ¬∂ enum = None default instance-attribute ¬∂ default description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Server ¬∂ Bases: BaseModel url instance-attribute ¬∂ url description class-attribute instance-attribute ¬∂ description = None variables class-attribute instance-attribute ¬∂ variables = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Reference ¬∂ Bases: BaseModel ref class-attribute instance-attribute ¬∂ ref = Field(alias='$ref') Discriminator ¬∂ Bases: BaseModel propertyName instance-attribute ¬∂ propertyName mapping class-attribute instance-attribute ¬∂ mapping = None XML ¬∂ Bases: BaseModel name class-attribute instance-attribute ¬∂ name = None namespace class-attribute instance-attribute ¬∂ namespace = None prefix class-attribute instance-attribute ¬∂ prefix = None attribute class-attribute instance-attribute ¬∂ attribute = None wrapped class-attribute instance-attribute ¬∂ wrapped = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' ExternalDocumentation ¬∂ Bases: BaseModel description class-attribute instance-attribute ¬∂ description = None url instance-attribute ¬∂ url model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Schema ¬∂ Bases: BaseModel schema\\_ class-attribute instance-attribute ¬∂ schema\\_ = Field(default=None, alias='$schema') vocabulary class-attribute instance-attribute ¬∂ vocabulary = Field(default=None, alias='$vocabulary') id class-attribute instance-attribute ¬∂ id = Field(default=None, alias='$id') anchor class-attribute instance-attribute ¬∂ anchor = Field(default=None, alias='$anchor') dynamicAnchor class-attribute instance-attribute ¬∂ dynamicAnchor = Field(default=None, alias='$dynamicAnchor') ref class-attribute instance-attribute ¬∂ ref = Field(default=None, alias='$ref') dynamicRef class-attribute instance-attribute ¬∂ dynamicRef = Field(default=None, alias='$dynamicRef') defs class-attribute instance-attribute ¬∂ defs = Field(default=None, alias='$defs') comment class-attribute instance-attribute ¬∂ comment = Field(default=None, alias='$comment') allOf class-attribute instance-attribute ¬∂ allOf = None anyOf class-attribute instance-attribute ¬∂ anyOf = None oneOf class-attribute instance-attribute ¬∂ oneOf = None not\\_ class-attribute instance-attribute ¬∂ not\\_ = Field(default=None, alias='not') if\\_ class-attribute instance-attribute ¬∂ if\\_ = Field(default=None, alias='if') then class-attribute instance-attribute ¬∂ then = None else\\_ class-attribute instance-attribute ¬∂ else\\_ = Field(default=None, alias='else') dependentSchemas class-attribute instance-attribute ¬∂ dependentSchemas = None prefixItems class-attribute instance-attribute ¬∂ prefixItems = None items class-attribute instance-attribute ¬∂ items = None contains class-attribute instance-attribute ¬∂ contains = None properties class-attribute instance-attribute ¬∂ properties = None patternProperties class-attribute instance-attribute ¬∂ patternProperties = None additionalProperties class-attribute instance-attribute ¬∂ additionalProperties = None propertyNames class-attribute instance-attribute ¬∂ propertyNames = None unevaluatedItems class-attribute instance-attribute ¬∂ unevaluatedItems = None unevaluatedProperties class-attribute instance-attribute ¬∂ unevaluatedProperties = None type class-attribute instance-attribute ¬∂ type = None enum class-attribute instance-attribute ¬∂ enum = None const class-attribute instance-attribute ¬∂ const = None multipleOf class-attribute instance-attribute ¬∂ multipleOf = Field(default=None, gt=0) maximum class-attribute instance-attribute ¬∂ maximum = None exclusiveMaximum class-attribute instance-attribute ¬∂ exclusiveMaximum = None minimum class-attribute instance-attribute ¬∂ minimum = None exclusiveMinimum class-attribute instance-attribute ¬∂ exclusiveMinimum = None maxLength class-attribute instance-attribute ¬∂ maxLength = Field(default=None, ge=0) minLength class-attribute instance-attribute ¬∂ minLength = Field(default=None, ge=0) pattern class-attribute instance-attribute ¬∂ pattern = None maxItems class-attribute instance-attribute ¬∂ maxItems = Field(default=None, ge=0) minItems class-attribute instance-attribute ¬∂ minItems = Field(default=None, ge=0) uniqueItems class-attribute instance-attribute ¬∂ uniqueItems = None maxContains class-attribute instance-attribute ¬∂ maxContains = Field(default=None, ge=0) minContains class-attribute instance-attribute ¬∂ minContains = Field(default=None, ge=0) maxProperties class-attribute instance-attribute ¬∂ maxProperties = Field(default=None, ge=0) minProperties class-attribute instance-attribute ¬∂ minProperties = Field(default=None, ge=0) required class-attribute instance-attribute ¬∂ required = None dependentRequired class-attribute instance-attribute ¬∂ dependentRequired = None format class-attribute instance-attribute ¬∂ format = None contentEncoding class-attribute instance-attribute ¬∂ contentEncoding = None contentMediaType class-attribute instance-attribute ¬∂ contentMediaType = None contentSchema class-attribute instance-attribute ¬∂ contentSchema = None title class-attribute instance-attribute ¬∂ title = None description class-attribute instance-attribute ¬∂ description = None default class-attribute instance-attribute ¬∂ default = None deprecated class-attribute instance-attribute ¬∂ deprecated = None readOnly class-attribute instance-attribute ¬∂ readOnly = None writeOnly class-attribute instance-attribute ¬∂ writeOnly = None examples class-attribute instance-attribute ¬∂ examples = None discriminator class-attribute instance-attribute ¬∂ discriminator = None xml class-attribute instance-attribute ¬∂ xml = None externalDocs class-attribute instance-attribute ¬∂ externalDocs = None example class-attribute instance-attribute ¬∂ example = None Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Example ¬∂ Bases: TypedDict summary instance-attribute ¬∂ summary description instance-attribute ¬∂ description value instance-attribute ¬∂ value externalValue instance-attribute ¬∂ externalValue Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' ParameterInType ¬∂ Bases: Enum query class-attribute instance-attribute ¬∂ query = 'query' header class-attribute instance-attribute ¬∂ header = 'header' path class-attribute instance-attribute ¬∂ path = 'path' cookie class-attribute instance-attribute ¬∂ cookie = 'cookie' Encoding ¬∂ Bases: BaseModel contentType class-attribute instance-attribute ¬∂ contentType = None headers class-attribute instance-attribute ¬∂ headers = None style class-attribute instance-attribute ¬∂ style = None explode class-attribute instance-attribute ¬∂ explode = None allowReserved class-attribute instance-attribute ¬∂ allowReserved = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' MediaType ¬∂ Bases: BaseModel schema\\_ class-attribute instance-attribute ¬∂ schema\\_ = Field(default=None, alias='schema') example class-attribute instance-attribute ¬∂ example = None examples class-attribute instance-attribute ¬∂ examples = None encoding class-attribute instance-attribute ¬∂ encoding = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' ParameterBase ¬∂ Bases: BaseModel description class-attribute instance-attribute ¬∂ description = None required class-attribute instance-attribute ¬∂ required = None deprecated class-attribute instance-attribute ¬∂ deprecated = None style class-attribute instance-attribute ¬∂ style = None explode class-attribute instance-attribute ¬∂ explode = None allowReserved class-attribute instance-attribute ¬∂ allowReserved = None schema\\_ class-attribute instance-attribute ¬∂ schema\\_ = Field(default=None, alias='schema') example class-attribute instance-attribute ¬∂ example = None examples class-attribute instance-attribute ¬∂ examples = None content class-attribute instance-attribute ¬∂ content = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Parameter ¬∂ Bases: ParameterBase description class-attribute instance-attribute ¬∂ description = None required class-attribute instance-attribute ¬∂ required = None deprecated class-attribute instance-attribute ¬∂ deprecated = None style class-attribute instance-attribute ¬∂ style = None explode class-attribute instance-attribute ¬∂ explode = None allowReserved class-attribute instance-attribute ¬∂ allowReserved = None schema\\_ class-attribute instance-attribute ¬∂ schema\\_ = Field(default=None, alias='schema') example class-attribute instance-attribute ¬∂ example = None examples class-attribute instance-attribute ¬∂ examples = None content class-attribute instance-attribute ¬∂ content = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} name instance-attribute ¬∂ name in\\_ class-attribute instance-attribute ¬∂ in\\_ = Field(alias='in') Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Header ¬∂ Bases: ParameterBase RequestBody ¬∂ Bases: BaseModel description class-attribute instance-attribute ¬∂ description = None content instance-attribute ¬∂ content required class-attribute instance-attribute ¬∂ required = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Link ¬∂ Bases: BaseModel operationRef class-attribute instance-attribute ¬∂ operationRef = None operationId class-attribute instance-attribute ¬∂ operationId = None parameters class-attribute instance-attribute ¬∂ parameters = None requestBody class-attribute instance-attribute ¬∂ requestBody = None description class-attribute instance-attribute ¬∂ description = None server class-attribute instance-attribute ¬∂ server = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Response ¬∂ Bases: BaseModel description instance-attribute ¬∂ description headers class-attribute instance-attribute ¬∂ headers = None content class-attribute instance-attribute ¬∂ content = None links class-attribute instance-attribute ¬∂ links = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Operation ¬∂ Bases: BaseModel tags class-attribute instance-attribute ¬∂ tags = None summary class-attribute instance-attribute ¬∂ summary = None description class-attribute instance-attribute ¬∂ description = None externalDocs class-attribute instance-attribute ¬∂ externalDocs = None operationId class-attribute instance-attribute ¬∂ operationId = None parameters class-attribute instance-attribute ¬∂ parameters = None requestBody class-attribute instance-attribute ¬∂ requestBody = None responses class-attribute instance-attribute ¬∂ responses = None callbacks class-attribute instance-attribute ¬∂ callbacks = None deprecated class-attribute instance-attribute ¬∂ deprecated = None security class-attribute instance-attribute ¬∂ security = None servers class-attribute instance-attribute ¬∂ servers = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' PathItem ¬∂ Bases: BaseModel ref class-attribute instance-attribute ¬∂ ref = Field(default=None, alias='$ref') summary class-attribute instance-attribute ¬∂ summary = None description class-attribute instance-attribute ¬∂ description = None get class-attribute instance-attribute ¬∂ get = None put class-attribute instance-attribute ¬∂ put = None post class-attribute instance-attribute ¬∂ post = None delete class-attribute instance-attribute ¬∂ delete = None options class-attribute instance-attribute ¬∂ options = None head class-attribute instance-attribute ¬∂ head = None patch class-attribute instance-attribute ¬∂ patch = None trace class-attribute instance-attribute ¬∂ trace = None servers class-attribute instance-attribute ¬∂ servers = None parameters class-attribute instance-attribute ¬∂ parameters = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' SecuritySchemeType ¬∂ Bases: Enum apiKey class-attribute instance-attribute ¬∂ apiKey = 'apiKey' http class-attribute instance-attribute ¬∂ http = 'http' oauth2 class-attribute instance-attribute ¬∂ oauth2 = 'oauth2' openIdConnect class-attribute instance-attribute ¬∂ openIdConnect = 'openIdConnect' SecurityBase ¬∂ Bases: BaseModel type\\_ class-attribute instance-attribute ¬∂ type\\_ = Field(alias='type') description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' APIKeyIn ¬∂ Bases: Enum query class-attribute instance-attribute ¬∂ query = 'query' header class-attribute instance-attribute ¬∂ header = 'header' cookie class-attribute instance-attribute ¬∂ cookie = 'cookie' APIKey ¬∂ Bases: SecurityBase description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} type\\_ class-attribute instance-attribute ¬∂ type\\_ = Field(default=apiKey, alias='type') in\\_ class-attribute instance-attribute ¬∂ in\\_ = Field(alias='in') name instance-attribute ¬∂ name Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' HTTPBase ¬∂ Bases: SecurityBase description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} type\\_ class-attribute instance-attribute ¬∂ type\\_ = Field(default=http, alias='type') scheme instance-attribute ¬∂ scheme Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' HTTPBearer ¬∂ Bases: HTTPBase type\\_ class-attribute instance-attribute ¬∂ type\\_ = Field(default=http, alias='type') description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} scheme class-attribute instance-attribute ¬∂ scheme = 'bearer' bearerFormat class-attribute instance-attribute ¬∂ bearerFormat = None Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuthFlow ¬∂ Bases: BaseModel refreshUrl class-attribute instance-attribute ¬∂ refreshUrl = None scopes class-attribute instance-attribute ¬∂ scopes = {} model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuthFlowImplicit ¬∂ Bases: OAuthFlow refreshUrl class-attribute instance-attribute ¬∂ refreshUrl = None scopes class-attribute instance-attribute ¬∂ scopes = {} model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} authorizationUrl instance-attribute ¬∂ authorizationUrl Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuthFlowPassword ¬∂ Bases: OAuthFlow refreshUrl class-attribute instance-attribute ¬∂ refreshUrl = None scopes class-attribute instance-attribute ¬∂ scopes = {} model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} tokenUrl instance-attribute ¬∂ tokenUrl Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuthFlowClientCredentials ¬∂ Bases: OAuthFlow refreshUrl class-attribute instance-attribute ¬∂ refreshUrl = None scopes class-attribute instance-attribute ¬∂ scopes = {} model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} tokenUrl instance-attribute ¬∂ tokenUrl Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuthFlowAuthorizationCode ¬∂ Bases: OAuthFlow refreshUrl class-attribute instance-attribute ¬∂ refreshUrl = None scopes class-attribute instance-attribute ¬∂ scopes = {} model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} authorizationUrl instance-attribute ¬∂ authorizationUrl tokenUrl instance-attribute ¬∂ tokenUrl Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuthFlows ¬∂ Bases: BaseModel implicit class-attribute instance-attribute ¬∂ implicit = None password class-attribute instance-attribute ¬∂ password = None clientCredentials class-attribute instance-attribute ¬∂ clientCredentials = None authorizationCode class-attribute instance-attribute ¬∂ authorizationCode = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OAuth2 ¬∂ Bases: SecurityBase description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} type\\_ class-attribute instance-attribute ¬∂ type\\_ = Field(default=oauth2, alias='type') flows instance-attribute ¬∂ flows Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OpenIdConnect ¬∂ Bases: SecurityBase description class-attribute instance-attribute ¬∂ description = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} type\\_ class-attribute instance-attribute ¬∂ type\\_ = Field(default=openIdConnect, alias='type') openIdConnectUrl instance-attribute ¬∂ openIdConnectUrl Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Components ¬∂ Bases: BaseModel schemas class-attribute instance-attribute ¬∂ schemas = None responses class-attribute instance-attribute ¬∂ responses = None parameters class-attribute instance-attribute ¬∂ parameters = None examples class-attribute instance-attribute ¬∂ examples = None requestBodies class-attribute instance-attribute ¬∂ requestBodies = None headers class-attribute instance-attribute ¬∂ headers = None securitySchemes class-attribute instance-attribute ¬∂ securitySchemes = None links class-attribute instance-attribute ¬∂ links = None callbacks class-attribute instance-attribute ¬∂ callbacks = None pathItems class-attribute instance-attribute ¬∂ pathItems = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Tag ¬∂ Bases: BaseModel name instance-attribute ¬∂ name description class-attribute instance-attribute ¬∂ description = None externalDocs class-attribute instance-attribute ¬∂ externalDocs = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' OpenAPI ¬∂ Bases: BaseModel openapi instance-attribute ¬∂ openapi info instance-attribute ¬∂ info jsonSchemaDialect class-attribute instance-attribute ¬∂ jsonSchemaDialect = None servers class-attribute instance-attribute ¬∂ servers = None paths class-attribute instance-attribute ¬∂ paths = None webhooks class-attribute instance-attribute ¬∂ webhooks = None components class-attribute instance-attribute ¬∂ components = None security class-attribute instance-attribute ¬∂ security = None tags class-attribute instance-attribute ¬∂ tags = None externalDocs class-attribute instance-attribute ¬∂ externalDocs = None model\\_config class-attribute instance-attribute ¬∂ model\\_config = {'extra': 'allow'} Config ¬∂ EXTRA CLASS-ATTRIBUTE INSTANCE-ATTRIBUTE ¬∂ extra = 'allow' Made with Material for MkDocs Insiders"
  },
  {
    "title": "Security Tools - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/security/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Security Tools en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents API Key Security Schemes ¬†APIKeyCookie Usage Example ¬†model ¬†scheme\\_name ¬†auto\\_error ¬†APIKeyHeader Usage Example ¬†model ¬†scheme\\_name ¬†auto\\_error ¬†APIKeyQuery Usage Example ¬†model ¬†scheme\\_name ¬†auto\\_error HTTP Authentication Schemes ¬†HTTPBasic Usage Example ¬†model ¬†scheme\\_name ¬†realm ¬†auto\\_error ¬†HTTPBearer Usage Example ¬†model ¬†scheme\\_name ¬†auto\\_error ¬†HTTPDigest Usage Example ¬†model ¬†scheme\\_name ¬†auto\\_error HTTP Credentials ¬†HTTPAuthorizationCredentials ¬†scheme ¬†credentials ¬†HTTPBasicCredentials ¬†username ¬†password OAuth2 Authentication ¬†OAuth2 ¬†model ¬†scheme\\_name ¬†auto\\_error ¬†OAuth2AuthorizationCodeBearer ¬†model ¬†scheme\\_name ¬†auto\\_error ¬†OAuth2PasswordBearer ¬†model ¬†scheme\\_name ¬†auto\\_error OAuth2 Password Form ¬†OAuth2PasswordRequestForm Example ¬†grant\\_type ¬†username ¬†password ¬†scopes ¬†client\\_id ¬†client\\_secret ¬†OAuth2PasswordRequestFormStrict Example ¬†grant\\_type ¬†username ¬†password ¬†scopes ¬†client\\_id ¬†client\\_secret OAuth2 Security Scopes in Dependencies ¬†SecurityScopes ¬†scopes ¬†scope\\_str OpenID Connect ¬†OpenIdConnect ¬†model ¬†scheme\\_name ¬†auto\\_error FastAPI Reference - Code API Security Tools¬∂ When you need to declare dependencies with OAuth2 scopes you use Security(). But you still need to define what is the dependable, the callable that you pass as a parameter to Depends() or Security(). There are multiple tools that you can use to create those dependables, and they get integrated into OpenAPI so they are shown in the automatic docs UI, they can be used by automatically generated clients and SDKs, etc. You can import them from fastapi.security: from fastapi.security import ( APIKeyCookie, APIKeyHeader, APIKeyQuery, HTTPAuthorizationCredentials, HTTPBasic, HTTPBasicCredentials, HTTPBearer, HTTPDigest, OAuth2, OAuth2AuthorizationCodeBearer, OAuth2PasswordBearer, OAuth2PasswordRequestForm, OAuth2PasswordRequestFormStrict, OpenIdConnect, SecurityScopes, ) API Key Security Schemes¬∂ fastapi.security.APIKeyCookie ¬∂ APIKeyCookie( \\*, name, scheme\\_name=None, description=None, auto\\_error=True ) Bases: APIKeyBase API key authentication using a cookie. This defines the name of the cookie that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the cookie automatically and provides it as the dependency result. But it doesn't define how to set that cookie. Usage¬∂ Create an instance object and use that object as the dependency in Depends(). The dependency result will be a string containing the key value. Example¬∂ from fastapi import Depends, FastAPI from fastapi.security import APIKeyCookie app = FastAPI() cookie\\_scheme = APIKeyCookie(name=\"session\") @app.get(\"/items/\") async def read\\_items(session: str = Depends(cookie\\_scheme)): return {\"session\": session} PARAMETER DESCRIPTION name Cookie name. TYPE: str scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if the cookie is not provided, APIKeyCookie will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the cookie is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a cookie or in an HTTP Bearer token). TYPE: bool DEFAULT: True Source code in fastapi/security/api\\_key.py model instance-attribute ¬∂ model = APIKey( \\*\\*{\"in\": cookie}, name=name, description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error fastapi.security.APIKeyHeader ¬∂ APIKeyHeader( \\*, name, scheme\\_name=None, description=None, auto\\_error=True ) Bases: APIKeyBase API key authentication using a header. This defines the name of the header that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the header automatically and provides it as the dependency result. But it doesn't define how to send that key to the client. Usage¬∂ Create an instance object and use that object as the dependency in Depends(). The dependency result will be a string containing the key value. Example¬∂ from fastapi import Depends, FastAPI from fastapi.security import APIKeyHeader app = FastAPI() header\\_scheme = APIKeyHeader(name=\"x-key\") @app.get(\"/items/\") async def read\\_items(key: str = Depends(header\\_scheme)): return {\"key\": key} PARAMETER DESCRIPTION name Header name. TYPE: str scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if the header is not provided, APIKeyHeader will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the header is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a header or in an HTTP Bearer token). TYPE: bool DEFAULT: True Source code in fastapi/security/api\\_key.py model instance-attribute ¬∂ model = APIKey( \\*\\*{\"in\": header}, name=name, description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error fastapi.security.APIKeyQuery ¬∂ APIKeyQuery( \\*, name, scheme\\_name=None, description=None, auto\\_error=True ) Bases: APIKeyBase API key authentication using a query parameter. This defines the name of the query parameter that should be provided in the request with the API key and integrates that into the OpenAPI documentation. It extracts the key value sent in the query parameter automatically and provides it as the dependency result. But it doesn't define how to send that API key to the client. Usage¬∂ Create an instance object and use that object as the dependency in Depends(). The dependency result will be a string containing the key value. Example¬∂ from fastapi import Depends, FastAPI from fastapi.security import APIKeyQuery app = FastAPI() query\\_scheme = APIKeyQuery(name=\"api\\_key\") @app.get(\"/items/\") async def read\\_items(api\\_key: str = Depends(query\\_scheme)): return {\"api\\_key\": api\\_key} PARAMETER DESCRIPTION name Query parameter name. TYPE: str scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if the query parameter is not provided, APIKeyQuery will automatically cancel the request and sebd the client an error. If auto\\_error is set to False, when the query parameter is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in a query parameter or in an HTTP Bearer token). TYPE: bool DEFAULT: True Source code in fastapi/security/api\\_key.py model instance-attribute ¬∂ model = APIKey( \\*\\*{\"in\": query}, name=name, description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error HTTP Authentication Schemes¬∂ fastapi.security.HTTPBasic ¬∂ HTTPBasic( \\*, scheme\\_name=None, realm=None, description=None, auto\\_error=True ) Bases: HTTPBase HTTP Basic authentication. Usage¬∂ Create an instance object and use that object as the dependency in Depends(). The dependency result will be an HTTPBasicCredentials object containing the username and the password. Read more about it in the FastAPI docs for HTTP Basic Auth. Example¬∂ from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() @app.get(\"/users/me\") def read\\_current\\_user(credentials: Annotated\\[HTTPBasicCredentials, Depends(security)\\]): return {\"username\": credentials.username, \"password\": credentials.password} PARAMETER DESCRIPTION scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None realm HTTP Basic authentication realm. TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if the HTTP Basic authentication is not provided (a header), HTTPBasic will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Basic authentication is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Basic authentication or in an HTTP Bearer token). TYPE: bool DEFAULT: True Source code in fastapi/security/http.py model instance-attribute ¬∂ model = HTTPBase(scheme='basic', description=description) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ realm instance-attribute ¬∂ realm = realm auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error fastapi.security.HTTPBearer ¬∂ HTTPBearer( \\*, bearerFormat=None, scheme\\_name=None, description=None, auto\\_error=True ) Bases: HTTPBase HTTP Bearer token authentication. Usage¬∂ Create an instance object and use that object as the dependency in Depends(). The dependency result will be an HTTPAuthorizationCredentials object containing the scheme and the credentials. Example¬∂ from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer app = FastAPI() security = HTTPBearer() @app.get(\"/users/me\") def read\\_current\\_user( credentials: Annotated\\[HTTPAuthorizationCredentials, Depends(security)\\] ): return {\"scheme\": credentials.scheme, \"credentials\": credentials.credentials} PARAMETER DESCRIPTION bearerFormat Bearer token format. TYPE: Optional\\[str\\] DEFAULT: None scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if the HTTP Bearer token not provided (in an Authorization header), HTTPBearer will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Bearer token is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in an HTTP Bearer token or in a cookie). TYPE: bool DEFAULT: True Source code in fastapi/security/http.py model instance-attribute ¬∂ model = HTTPBearer( bearerFormat=bearerFormat, description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error fastapi.security.HTTPDigest ¬∂ HTTPDigest( \\*, scheme\\_name=None, description=None, auto\\_error=True ) Bases: HTTPBase HTTP Digest authentication. Usage¬∂ Create an instance object and use that object as the dependency in Depends(). The dependency result will be an HTTPAuthorizationCredentials object containing the scheme and the credentials. Example¬∂ from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import HTTPAuthorizationCredentials, HTTPDigest app = FastAPI() security = HTTPDigest() @app.get(\"/users/me\") def read\\_current\\_user( credentials: Annotated\\[HTTPAuthorizationCredentials, Depends(security)\\] ): return {\"scheme\": credentials.scheme, \"credentials\": credentials.credentials} PARAMETER DESCRIPTION scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if the HTTP Digest not provided, HTTPDigest will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Digest is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, in HTTP Digest or in a cookie). TYPE: bool DEFAULT: True Source code in fastapi/security/http.py model instance-attribute ¬∂ model = HTTPBase(scheme='digest', description=description) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error HTTP Credentials¬∂ fastapi.security.HTTPAuthorizationCredentials ¬∂ Bases: BaseModel The HTTP authorization credentials in the result of using HTTPBearer or HTTPDigest in a dependency. The HTTP authorization header value is split by the first space. The first part is the scheme, the second part is the credentials. For example, in an HTTP Bearer token scheme, the client will send a header like: Authorization: Bearer deadbeef12346 In this case: scheme will have the value \"Bearer\" credentials will have the value \"deadbeef12346\" scheme instance-attribute ¬∂ scheme The HTTP authorization scheme extracted from the header value. credentials instance-attribute ¬∂ credentials The HTTP authorization credentials extracted from the header value. fastapi.security.HTTPBasicCredentials ¬∂ Bases: BaseModel The HTTP Basic credendials given as the result of using HTTPBasic in a dependency. Read more about it in the FastAPI docs for HTTP Basic Auth. username instance-attribute ¬∂ username The HTTP Basic username. password instance-attribute ¬∂ password The HTTP Basic password. OAuth2 Authentication¬∂ fastapi.security.OAuth2 ¬∂ OAuth2( \\*, flows=OAuthFlowsModel(), scheme\\_name=None, description=None, auto\\_error=True ) Bases: SecurityBase This is the base class for OAuth2 authentication, an instance of it would be used as a dependency. All other OAuth2 classes inherit from it and customize it for each OAuth2 flow. You normally would not create a new class inheriting from it but use one of the existing subclasses, and maybe compose them if you want to support multiple flows. Read more about it in the FastAPI docs for Security. PARAMETER DESCRIPTION flows The dictionary of OAuth2 flows. TYPE: Union\\[OAuthFlows, Dict\\[str, Dict\\[str, Any\\]\\]\\] DEFAULT: OAuthFlows() scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if no HTTP Auhtorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie). TYPE: bool DEFAULT: True Source code in fastapi/security/oauth2.py model instance-attribute ¬∂ model = OAuth2( flows=cast(OAuthFlows, flows), description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error fastapi.security.OAuth2AuthorizationCodeBearer ¬∂ OAuth2AuthorizationCodeBearer( authorizationUrl, tokenUrl, refreshUrl=None, scheme\\_name=None, scopes=None, description=None, auto\\_error=True, ) Bases: OAuth2 OAuth2 flow for authentication using a bearer token obtained with an OAuth2 code flow. An instance of it would be used as a dependency. PARAMETER DESCRIPTION authorizationUrl TYPE: str tokenUrl The URL to obtain the OAuth2 token. TYPE: str refreshUrl The URL to refresh the token and obtain a new one. TYPE: Optional\\[str\\] DEFAULT: None scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None scopes The OAuth2 scopes that would be required by the path operations that use this dependency. TYPE: Optional\\[Dict\\[str, str\\]\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if no HTTP Auhtorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie). TYPE: bool DEFAULT: True Source code in fastapi/security/oauth2.py model instance-attribute ¬∂ model = OAuth2( flows=cast(OAuthFlows, flows), description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error fastapi.security.OAuth2PasswordBearer ¬∂ OAuth2PasswordBearer( tokenUrl, scheme\\_name=None, scopes=None, description=None, auto\\_error=True, ) Bases: OAuth2 OAuth2 flow for authentication using a bearer token obtained with a password. An instance of it would be used as a dependency. Read more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer. PARAMETER DESCRIPTION tokenUrl The URL to obtain the OAuth2 token. This would be the path operation that has OAuth2PasswordRequestForm as a dependency. TYPE: str scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None scopes The OAuth2 scopes that would be required by the path operations that use this dependency. TYPE: Optional\\[Dict\\[str, str\\]\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if no HTTP Auhtorization header is provided, required for OAuth2 authentication, it will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OAuth2 or in a cookie). TYPE: bool DEFAULT: True Source code in fastapi/security/oauth2.py model instance-attribute ¬∂ model = OAuth2( flows=cast(OAuthFlows, flows), description=description ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error OAuth2 Password Form¬∂ fastapi.security.OAuth2PasswordRequestForm ¬∂ OAuth2PasswordRequestForm( \\*, grant\\_type=None, username, password, scope=\"\", client\\_id=None, client\\_secret=None ) This is a dependency class to collect the username and password as form data for an OAuth2 password flow. The OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields username and password. All the initialization parameters are extracted from the request. Read more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer. Example¬∂ from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordRequestForm app = FastAPI() @app.post(\"/login\") def login(form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\]): data = {} data\\[\"scopes\"\\] = \\[\\] for scope in form\\_data.scopes: data\\[\"scopes\"\\].append(scope) if form\\_data.client\\_id: data\\[\"client\\_id\"\\] = form\\_data.client\\_id if form\\_data.client\\_secret: data\\[\"client\\_secret\"\\] = form\\_data.client\\_secret return data Note that for OAuth2 the scope items:read is a single scope in an opaque string. You could have custom internal logic to separate it by colon caracters (:) or similar, and get the two parts items and read. Many applications do that to group and organize permisions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification. PARAMETER DESCRIPTION grant\\_type The OAuth2 spec says it is required and MUST be the fixed string \"password\". Nevertheless, this dependency class is permissive and allows not passing it. If you want to enforce it, use instead the OAuth2PasswordRequestFormStrict dependency. TYPE: Union\\[str, None\\] DEFAULT: None username username string. The OAuth2 spec requires the exact field name username. TYPE: str password password string. The OAuth2 spec requires the exact field name \\`password\". TYPE: str scope A single string with actually several scopes separated by spaces. Each scope is also a string. For example, a single string with: \\`\\`\\`python \"items:read items:write users:read profile openid\" \\`\\`\\`\\` would represent the scopes: items:read items:write users:read profile openid TYPE: str DEFAULT: '' client\\_id If there's a client\\_id, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the client\\_id and client\\_secret (if any) using HTTP Basic auth. TYPE: Union\\[str, None\\] DEFAULT: None client\\_secret If there's a client\\_password (and a client\\_id), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the client\\_id and client\\_secret (if any) using HTTP Basic auth. TYPE: Union\\[str, None\\] DEFAULT: None Source code in fastapi/security/oauth2.py grant\\_type instance-attribute ¬∂ grant\\_type = grant\\_type username instance-attribute ¬∂ username = username password instance-attribute ¬∂ password = password scopes instance-attribute ¬∂ scopes = split() client\\_id instance-attribute ¬∂ client\\_id = client\\_id client\\_secret instance-attribute ¬∂ client\\_secret = client\\_secret fastapi.security.OAuth2PasswordRequestFormStrict ¬∂ OAuth2PasswordRequestFormStrict( grant\\_type, username, password, scope=\"\", client\\_id=None, client\\_secret=None, ) Bases: OAuth2PasswordRequestForm This is a dependency class to collect the username and password as form data for an OAuth2 password flow. The OAuth2 specification dictates that for a password flow the data should be collected using form data (instead of JSON) and that it should have the specific fields username and password. All the initialization parameters are extracted from the request. The only difference between OAuth2PasswordRequestFormStrict and OAuth2PasswordRequestForm is that OAuth2PasswordRequestFormStrict requires the client to send the form field grant\\_type with the value \"password\", which is required in the OAuth2 specification (it seems that for no particular reason), while for OAuth2PasswordRequestForm grant\\_type is optional. Read more about it in the FastAPI docs for Simple OAuth2 with Password and Bearer. Example¬∂ from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordRequestForm app = FastAPI() @app.post(\"/login\") def login(form\\_data: Annotated\\[OAuth2PasswordRequestFormStrict, Depends()\\]): data = {} data\\[\"scopes\"\\] = \\[\\] for scope in form\\_data.scopes: data\\[\"scopes\"\\].append(scope) if form\\_data.client\\_id: data\\[\"client\\_id\"\\] = form\\_data.client\\_id if form\\_data.client\\_secret: data\\[\"client\\_secret\"\\] = form\\_data.client\\_secret return data Note that for OAuth2 the scope items:read is a single scope in an opaque string. You could have custom internal logic to separate it by colon caracters (:) or similar, and get the two parts items and read. Many applications do that to group and organize permisions, you could do it as well in your application, just know that that it is application specific, it's not part of the specification. the OAuth2 spec says it is required and MUST be the fixed string \"password\". This dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class. username: username string. The OAuth2 spec requires the exact field name \"username\". password: password string. The OAuth2 spec requires the exact field name \"password\". scope: Optional string. Several scopes (each one a string) separated by spaces. E.g. \"items:read items:write users:read profile openid\" client\\_id: optional string. OAuth2 recommends sending the client\\_id and client\\_secret (if any) using HTTP Basic auth, as: client\\_id:client\\_secret client\\_secret: optional string. OAuth2 recommends sending the client\\_id and client\\_secret (if any) using HTTP Basic auth, as: client\\_id:client\\_secret PARAMETER DESCRIPTION grant\\_type The OAuth2 spec says it is required and MUST be the fixed string \"password\". This dependency is strict about it. If you want to be permissive, use instead the OAuth2PasswordRequestForm dependency class. TYPE: str username username string. The OAuth2 spec requires the exact field name username. TYPE: str password password string. The OAuth2 spec requires the exact field name \\`password\". TYPE: str scope A single string with actually several scopes separated by spaces. Each scope is also a string. For example, a single string with: \\`\\`\\`python \"items:read items:write users:read profile openid\" \\`\\`\\`\\` would represent the scopes: items:read items:write users:read profile openid TYPE: str DEFAULT: '' client\\_id If there's a client\\_id, it can be sent as part of the form fields. But the OAuth2 specification recommends sending the client\\_id and client\\_secret (if any) using HTTP Basic auth. TYPE: Union\\[str, None\\] DEFAULT: None client\\_secret If there's a client\\_password (and a client\\_id), they can be sent as part of the form fields. But the OAuth2 specification recommends sending the client\\_id and client\\_secret (if any) using HTTP Basic auth. TYPE: Union\\[str, None\\] DEFAULT: None Source code in fastapi/security/oauth2.py grant\\_type instance-attribute ¬∂ grant\\_type = grant\\_type username instance-attribute ¬∂ username = username password instance-attribute ¬∂ password = password scopes instance-attribute ¬∂ scopes = split() client\\_id instance-attribute ¬∂ client\\_id = client\\_id client\\_secret instance-attribute ¬∂ client\\_secret = client\\_secret OAuth2 Security Scopes in Dependencies¬∂ fastapi.security.SecurityScopes ¬∂ SecurityScopes(scopes=None) This is a special class that you can define in a parameter in a dependency to obtain the OAuth2 scopes required by all the dependencies in the same chain. This way, multiple dependencies can have different scopes, even when used in the same path operation. And with this, you can access all the scopes required in all those dependencies in a single place. Read more about it in the FastAPI docs for OAuth2 scopes. PARAMETER DESCRIPTION scopes This will be filled by FastAPI. TYPE: Optional\\[List\\[str\\]\\] DEFAULT: None Source code in fastapi/security/oauth2.py scopes instance-attribute ¬∂ scopes = scopes or \\[\\] The list of all the scopes required by dependencies. scope\\_str instance-attribute ¬∂ scope\\_str = join(scopes) All the scopes required by all the dependencies in a single string separated by spaces, as defined in the OAuth2 specification. OpenID Connect¬∂ fastapi.security.OpenIdConnect ¬∂ OpenIdConnect( \\*, openIdConnectUrl, scheme\\_name=None, description=None, auto\\_error=True ) Bases: SecurityBase OpenID Connect authentication class. An instance of it would be used as a dependency. PARAMETER DESCRIPTION openIdConnectUrl The OpenID Connect URL. TYPE: str scheme\\_name Security scheme name. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None description Security scheme description. It will be included in the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[str\\] DEFAULT: None auto\\_error By default, if no HTTP Auhtorization header is provided, required for OpenID Connect authentication, it will automatically cancel the request and send the client an error. If auto\\_error is set to False, when the HTTP Authorization header is not available, instead of erroring out, the dependency result will be None. This is useful when you want to have optional authentication. It is also useful when you want to have authentication that can be provided in one of multiple optional ways (for example, with OpenID Connect or in a cookie). TYPE: bool DEFAULT: True Source code in fastapi/security/open\\_id\\_connect\\_url.py model instance-attribute ¬∂ model = OpenIdConnect( openIdConnectUrl=openIdConnectUrl, description=description, ) scheme\\_name instance-attribute ¬∂ scheme\\_name = scheme\\_name or \\_\\_name\\_\\_ auto\\_error instance-attribute ¬∂ auto\\_error = auto\\_error Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI docs - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/openapi/docs/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI OpenAPI docs en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI OpenAPI docs OpenAPI models Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†get\\_swagger\\_ui\\_html ¬†get\\_redoc\\_html ¬†get\\_swagger\\_ui\\_oauth2\\_redirect\\_html ¬†swagger\\_ui\\_default\\_parameters FastAPI Reference - Code API OpenAPI OpenAPI docs¬∂ Utilities to handle OpenAPI automatic UI documentation, including Swagger UI (by default at /docs) and ReDoc (by default at /redoc). fastapi.openapi.docs.get\\_swagger\\_ui\\_html ¬∂ get\\_swagger\\_ui\\_html( \\*, openapi\\_url, title, swagger\\_js\\_url=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger\\_css\\_url=\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui.css\", swagger\\_favicon\\_url=\"https://fastapi.tiangolo.com/img/favicon.png\", oauth2\\_redirect\\_url=None, init\\_oauth=None, swagger\\_ui\\_parameters=None ) Generate and return the HTML that loads Swagger UI for the interactive API docs (normally served at /docs). You would only call this function yourself if you needed to override some parts, for example the URLs to use to load Swagger UI's JavaScript and CSS. Read more about it in the FastAPI docs for Configure Swagger UI and the FastAPI docs for Custom Docs UI Static Assets (Self-Hosting). PARAMETER DESCRIPTION openapi\\_url The OpenAPI URL that Swagger UI should load and use. This is normally done automatically by FastAPI using the default URL /openapi.json. TYPE: str title The HTML content, normally shown in the browser tab. TYPE: str swagger\\_js\\_url The URL to use to load the Swagger UI JavaScript. It is normally set to a CDN URL. TYPE: str DEFAULT: 'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui-bundle.js' swagger\\_css\\_url The URL to use to load the Swagger UI CSS. It is normally set to a CDN URL. TYPE: str DEFAULT: 'https://cdn.jsdelivr.net/npm/swagger-ui-dist@5.9.0/swagger-ui.css' swagger\\_favicon\\_url The URL of the favicon to use. It is normally shown in the browser tab. TYPE: str DEFAULT: 'https://fastapi.tiangolo.com/img/favicon.png' oauth2\\_redirect\\_url The OAuth2 redirect URL, it is normally automatically handled by FastAPI. TYPE: Optional\\[str\\] DEFAULT: None init\\_oauth A dictionary with Swagger UI OAuth2 initialization configurations. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None swagger\\_ui\\_parameters Configuration parameters for Swagger UI. It defaults to swagger\\_ui\\_default\\_parameters. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None Source code in fastapi/openapi/docs.py fastapi.openapi.docs.get\\_redoc\\_html ¬∂ get\\_redoc\\_html( \\*, openapi\\_url, title, redoc\\_js\\_url=\"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\", redoc\\_favicon\\_url=\"https://fastapi.tiangolo.com/img/favicon.png\", with\\_google\\_fonts=True ) Generate and return the HTML response that loads ReDoc for the alternative API docs (normally served at /redoc). You would only call this function yourself if you needed to override some parts, for example the URLs to use to load ReDoc's JavaScript and CSS. Read more about it in the FastAPI docs for Custom Docs UI Static Assets (Self-Hosting). PARAMETER DESCRIPTION openapi\\_url The OpenAPI URL that ReDoc should load and use. This is normally done automatically by FastAPI using the default URL /openapi.json. TYPE: str title The HTML content, normally shown in the browser tab. TYPE: str redoc\\_js\\_url The URL to use to load the ReDoc JavaScript. It is normally set to a CDN URL. TYPE: str DEFAULT: 'https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js' redoc\\_favicon\\_url The URL of the favicon to use. It is normally shown in the browser tab. TYPE: str DEFAULT: 'https://fastapi.tiangolo.com/img/favicon.png' with\\_google\\_fonts Load and use Google Fonts. TYPE: bool DEFAULT: True Source code in fastapi/openapi/docs.py fastapi.openapi.docs.get\\_swagger\\_ui\\_oauth2\\_redirect\\_html ¬∂ get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() Generate the HTML response with the OAuth2 redirection for Swagger UI. You normally don't need to use or change this. Source code in fastapi/openapi/docs.py fastapi.openapi.docs.swagger\\_ui\\_default\\_parameters module-attribute ¬∂ swagger\\_ui\\_default\\_parameters = { \"dom\\_id\": \"#swagger-ui\", \"layout\": \"BaseLayout\", \"deepLinking\": True, \"showExtensions\": True, \"showCommonExtensions\": True, } Default configurations for Swagger UI. You can use it as a template to add any other configurations needed. Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/openapi/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI OpenAPI docs OpenAPI models Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient FastAPI Reference - Code API OpenAPI OpenAPI¬∂ There are several utilities to handle OpenAPI. You normally don't need to use them unless you have a specific advanced use case that requires it. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Middleware - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/middleware/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Middleware en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†CORSMiddleware ¬†app ¬†allow\\_origins ¬†allow\\_methods ¬†allow\\_headers ¬†allow\\_all\\_origins ¬†allow\\_all\\_headers ¬†preflight\\_explicit\\_allow\\_origin ¬†allow\\_origin\\_regex ¬†simple\\_headers ¬†preflight\\_headers ¬†is\\_allowed\\_origin ¬†preflight\\_response ¬†simple\\_response ¬†send ¬†allow\\_explicit\\_origin ¬†GZipMiddleware ¬†app ¬†minimum\\_size ¬†compresslevel ¬†HTTPSRedirectMiddleware ¬†app ¬†TrustedHostMiddleware ¬†app ¬†allowed\\_hosts ¬†allow\\_any ¬†www\\_redirect ¬†WSGIMiddleware ¬†app FastAPI Reference - Code API Middleware¬∂ There are several middlewares available provided by Starlette directly. Read more about them in the FastAPI docs for Middleware. fastapi.middleware.cors.CORSMiddleware ¬∂ CORSMiddleware( app, allow\\_origins=(), allow\\_methods=(\"GET\"), allow\\_headers=(), allow\\_credentials=False, allow\\_origin\\_regex=None, expose\\_headers=(), max\\_age=600, ) PARAMETER DESCRIPTION app TYPE: ASGIApp allow\\_origins TYPE: Sequence\\[str\\] DEFAULT: () allow\\_methods TYPE: Sequence\\[str\\] DEFAULT: ('GET') allow\\_headers TYPE: Sequence\\[str\\] DEFAULT: () allow\\_credentials TYPE: bool DEFAULT: False allow\\_origin\\_regex TYPE: Optional\\[str\\] DEFAULT: None expose\\_headers TYPE: Sequence\\[str\\] DEFAULT: () max\\_age TYPE: int DEFAULT: 600 Source code in starlette/middleware/cors.py app instance-attribute ¬∂ app = app allow\\_origins instance-attribute ¬∂ allow\\_origins = allow\\_origins allow\\_methods instance-attribute ¬∂ allow\\_methods = allow\\_methods allow\\_headers instance-attribute ¬∂ allow\\_headers = \\[lower() for h in allow\\_headers\\] allow\\_all\\_origins instance-attribute ¬∂ allow\\_all\\_origins = allow\\_all\\_origins allow\\_all\\_headers instance-attribute ¬∂ allow\\_all\\_headers = allow\\_all\\_headers preflight\\_explicit\\_allow\\_origin instance-attribute ¬∂ preflight\\_explicit\\_allow\\_origin = ( preflight\\_explicit\\_allow\\_origin ) allow\\_origin\\_regex instance-attribute ¬∂ allow\\_origin\\_regex = compiled\\_allow\\_origin\\_regex simple\\_headers instance-attribute ¬∂ simple\\_headers = simple\\_headers preflight\\_headers instance-attribute ¬∂ preflight\\_headers = preflight\\_headers is\\_allowed\\_origin ¬∂ is\\_allowed\\_origin(origin) PARAMETER DESCRIPTION origin TYPE: str Source code in starlette/middleware/cors.py preflight\\_response ¬∂ preflight\\_response(request\\_headers) PARAMETER DESCRIPTION request\\_headers TYPE: Headers Source code in starlette/middleware/cors.py simple\\_response async ¬∂ simple\\_response(scope, receive, send, request\\_headers) PARAMETER DESCRIPTION scope TYPE: Scope receive TYPE: Receive send TYPE: Send request\\_headers TYPE: Headers Source code in starlette/middleware/cors.py send async ¬∂ send(message, send, request\\_headers) PARAMETER DESCRIPTION message TYPE: Message send TYPE: Send request\\_headers TYPE: Headers Source code in starlette/middleware/cors.py allow\\_explicit\\_origin staticmethod ¬∂ allow\\_explicit\\_origin(headers, origin) PARAMETER DESCRIPTION headers TYPE: MutableHeaders origin TYPE: str Source code in starlette/middleware/cors.py It can be imported from fastapi: from fastapi.middleware.cors import CORSMiddleware fastapi.middleware.gzip.GZipMiddleware ¬∂ GZipMiddleware(app, minimum\\_size=500, compresslevel=9) PARAMETER DESCRIPTION app TYPE: ASGIApp minimum\\_size TYPE: int DEFAULT: 500 compresslevel TYPE: int DEFAULT: 9 Source code in starlette/middleware/gzip.py app instance-attribute ¬∂ app = app minimum\\_size instance-attribute ¬∂ minimum\\_size = minimum\\_size compresslevel instance-attribute ¬∂ compresslevel = compresslevel It can be imported from fastapi: from fastapi.middleware.gzip import GZipMiddleware fastapi.middleware.httpsredirect.HTTPSRedirectMiddleware ¬∂ HTTPSRedirectMiddleware(app) PARAMETER DESCRIPTION app TYPE: ASGIApp Source code in starlette/middleware/httpsredirect.py app instance-attribute ¬∂ app = app It can be imported from fastapi: from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware fastapi.middleware.trustedhost.TrustedHostMiddleware ¬∂ TrustedHostMiddleware( app, allowed\\_hosts=None, www\\_redirect=True ) PARAMETER DESCRIPTION app TYPE: ASGIApp allowed\\_hosts TYPE: Optional\\[Sequence\\[str\\]\\] DEFAULT: None www\\_redirect TYPE: bool DEFAULT: True Source code in starlette/middleware/trustedhost.py app instance-attribute ¬∂ app = app allowed\\_hosts instance-attribute ¬∂ allowed\\_hosts = list(allowed\\_hosts) allow\\_any instance-attribute ¬∂ allow\\_any = '\\*' in allowed\\_hosts www\\_redirect instance-attribute ¬∂ www\\_redirect = www\\_redirect It can be imported from fastapi: from fastapi.middleware.trustedhost import TrustedHostMiddleware fastapi.middleware.wsgi.WSGIMiddleware ¬∂ WSGIMiddleware(app) PARAMETER DESCRIPTION app TYPE: Callable\\[..., Any\\] Source code in starlette/middleware/wsgi.py app instance-attribute ¬∂ app = app It can be imported from fastapi: from fastapi.middleware.wsgi import WSGIMiddleware Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Response Classes - File, HTML, Redirect, Streaming, etc. - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/responses/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Custom Response Classes - File, HTML, Redirect, Streaming, etc. en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents FastAPI Responses ¬†UJSONResponse ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†ORJSONResponse ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie Starlette Responses ¬†FileResponse ¬†chunk\\_size ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†HTMLResponse ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†JSONResponse ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†PlainTextResponse ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†RedirectResponse ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†Response ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie ¬†StreamingResponse ¬†body\\_iterator ¬†charset ¬†status\\_code ¬†media\\_type ¬†body ¬†background ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie FastAPI Reference - Code API Custom Response Classes - File, HTML, Redirect, Streaming, etc.¬∂ There are several custom response classes you can use to create an instance and return them directly from your path operations. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. You can import them directly from fastapi.responses: from fastapi.responses import ( FileResponse, HTMLResponse, JSONResponse, ORJSONResponse, PlainTextResponse, RedirectResponse, Response, StreamingResponse, UJSONResponse, ) FastAPI Responses¬∂ There are a couple of custom FastAPI response classes, you can use them to optimize JSON performance. fastapi.responses.UJSONResponse ¬∂ UJSONResponse( content, status\\_code=200, headers=None, media\\_type=None, background=None, ) Bases: JSONResponse JSON response using the high-performance ujson library to serialize data to JSON. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. PARAMETER DESCRIPTION content TYPE: Any status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = 'application/json' body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in fastapi/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.ORJSONResponse ¬∂ ORJSONResponse( content, status\\_code=200, headers=None, media\\_type=None, background=None, ) Bases: JSONResponse JSON response using the high-performance orjson library to serialize data to JSON. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. PARAMETER DESCRIPTION content TYPE: Any status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = 'application/json' body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in fastapi/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py Starlette Responses¬∂ fastapi.responses.FileResponse ¬∂ FileResponse( path, status\\_code=200, headers=None, media\\_type=None, background=None, filename=None, stat\\_result=None, method=None, content\\_disposition\\_type=\"attachment\", ) Bases: Response PARAMETER DESCRIPTION path TYPE: Union\\[str, PathLike\\[str\\]\\] status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None filename TYPE: Optional\\[str\\] DEFAULT: None stat\\_result TYPE: Optional\\[stat\\_result\\] DEFAULT: None method TYPE: Optional\\[str\\] DEFAULT: None content\\_disposition\\_type TYPE: str DEFAULT: 'attachment' Source code in starlette/responses.py chunk\\_size class-attribute instance-attribute ¬∂ chunk\\_size = 64 \\* 1024 charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type instance-attribute ¬∂ media\\_type = media\\_type body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.HTMLResponse ¬∂ HTMLResponse( content=None, status\\_code=200, headers=None, media\\_type=None, background=None, ) Bases: Response PARAMETER DESCRIPTION content TYPE: Any DEFAULT: None status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = 'text/html' body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.JSONResponse ¬∂ JSONResponse( content, status\\_code=200, headers=None, media\\_type=None, background=None, ) Bases: Response PARAMETER DESCRIPTION content TYPE: Any status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = 'application/json' body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.PlainTextResponse ¬∂ PlainTextResponse( content=None, status\\_code=200, headers=None, media\\_type=None, background=None, ) Bases: Response PARAMETER DESCRIPTION content TYPE: Any DEFAULT: None status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = 'text/plain' body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.RedirectResponse ¬∂ RedirectResponse( url, status\\_code=307, headers=None, background=None ) Bases: Response PARAMETER DESCRIPTION url TYPE: Union\\[str, URL\\] status\\_code TYPE: int DEFAULT: 307 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = None body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.Response ¬∂ Response( content=None, status\\_code=200, headers=None, media\\_type=None, background=None, ) PARAMETER DESCRIPTION content TYPE: Any DEFAULT: None status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type class-attribute instance-attribute ¬∂ media\\_type = None body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py fastapi.responses.StreamingResponse ¬∂ StreamingResponse( content, status\\_code=200, headers=None, media\\_type=None, background=None, ) Bases: Response PARAMETER DESCRIPTION content TYPE: ContentStream status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py body\\_iterator instance-attribute ¬∂ body\\_iterator charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code media\\_type instance-attribute ¬∂ media\\_type = ( media\\_type if media\\_type is None else media\\_type ) body instance-attribute ¬∂ body = render(content) background instance-attribute ¬∂ background = background headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response class - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/response/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Response class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†Response ¬†media\\_type ¬†charset ¬†status\\_code ¬†background ¬†body ¬†headers ¬†render ¬†init\\_headers ¬†set\\_cookie ¬†delete\\_cookie FastAPI Reference - Code API Response class¬∂ You can declare a parameter in a path operation function or dependency to be of type Response and then you can set data for the response like headers or cookies. You can also use it directly to create an instance of it and return it from your path operations. You can import it directly from fastapi: from fastapi import Response fastapi.Response ¬∂ Response( content=None, status\\_code=200, headers=None, media\\_type=None, background=None, ) PARAMETER DESCRIPTION content TYPE: Any DEFAULT: None status\\_code TYPE: int DEFAULT: 200 headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None media\\_type TYPE: Optional\\[str\\] DEFAULT: None background TYPE: Optional\\[BackgroundTask\\] DEFAULT: None Source code in starlette/responses.py media\\_type class-attribute instance-attribute ¬∂ media\\_type = None charset class-attribute instance-attribute ¬∂ charset = 'utf-8' status\\_code instance-attribute ¬∂ status\\_code = status\\_code background instance-attribute ¬∂ background = background body instance-attribute ¬∂ body = render(content) headers property ¬∂ headers render ¬∂ render(content) PARAMETER DESCRIPTION content TYPE: Any Source code in starlette/responses.py init\\_headers ¬∂ init\\_headers(headers=None) PARAMETER DESCRIPTION headers TYPE: Optional\\[Mapping\\[str, str\\]\\] DEFAULT: None Source code in starlette/responses.py set\\_cookie ¬∂ set\\_cookie( key, value=\"\", max\\_age=None, expires=None, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str value TYPE: str DEFAULT: '' max\\_age TYPE: Optional\\[int\\] DEFAULT: None expires TYPE: Optional\\[Union\\[datetime, str, int\\]\\] DEFAULT: None path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py delete\\_cookie ¬∂ delete\\_cookie( key, path=\"/\", domain=None, secure=False, httponly=False, samesite=\"lax\", ) PARAMETER DESCRIPTION key TYPE: str path TYPE: str DEFAULT: '/' domain TYPE: Optional\\[str\\] DEFAULT: None secure TYPE: bool DEFAULT: False httponly TYPE: bool DEFAULT: False samesite TYPE: Optional\\[Literal\\['lax', 'strict', 'none'\\]\\] DEFAULT: 'lax' Source code in starlette/responses.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "HTTPConnection class - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/httpconnection/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI HTTPConnection class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†HTTPConnection ¬†scope ¬†app ¬†url ¬†base\\_url ¬†headers ¬†query\\_params ¬†path\\_params ¬†cookies ¬†client ¬†session ¬†auth ¬†user ¬†state ¬†url\\_for FastAPI Reference - Code API HTTPConnection class¬∂ When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an HTTPConnection instead of a Request or a WebSocket. You can import it from fastapi.requests: from fastapi.requests import HTTPConnection fastapi.requests.HTTPConnection ¬∂ HTTPConnection(scope, receive=None) Bases: Mapping\\[str, Any\\] A base class for incoming HTTP connections, that is used to provide any functionality that is common to both Request and WebSocket. PARAMETER DESCRIPTION scope TYPE: Scope receive TYPE: Optional\\[Receive\\] DEFAULT: None Source code in starlette/requests.py scope instance-attribute ¬∂ scope = scope app property ¬∂ app url property ¬∂ url base\\_url property ¬∂ base\\_url headers property ¬∂ headers query\\_params property ¬∂ query\\_params path\\_params property ¬∂ path\\_params cookies property ¬∂ cookies client property ¬∂ client session property ¬∂ session auth property ¬∂ auth user property ¬∂ user state property ¬∂ state url\\_for ¬∂ url\\_for(name, /, \\*\\*path\\_params) PARAMETER DESCRIPTION name TYPE: str \\*\\*path\\_params TYPE: Any DEFAULT: {} Source code in starlette/requests.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "WebSockets - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/websockets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI WebSockets en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†WebSocket ¬†scope ¬†app ¬†url ¬†base\\_url ¬†headers ¬†query\\_params ¬†path\\_params ¬†cookies ¬†client ¬†state ¬†client\\_state ¬†application\\_state ¬†url\\_for ¬†receive ¬†send ¬†accept ¬†receive\\_text ¬†receive\\_bytes ¬†receive\\_json ¬†iter\\_text ¬†iter\\_bytes ¬†iter\\_json ¬†send\\_text ¬†send\\_bytes ¬†send\\_json ¬†close ¬†WebSocketDisconnect ¬†code ¬†reason WebSockets - additional classes ¬†WebSocketDisconnect ¬†code ¬†reason ¬†WebSocketState ¬†CONNECTING ¬†CONNECTED ¬†DISCONNECTED FastAPI Reference - Code API WebSockets¬∂ When defining WebSockets, you normally declare a parameter of type WebSocket and with it you can read data from the client and send data to it. It is provided directly by Starlette, but you can import it from fastapi: from fastapi import WebSocket Tip When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an HTTPConnection instead of a Request or a WebSocket. fastapi.WebSocket ¬∂ WebSocket(scope, receive, send) Bases: HTTPConnection PARAMETER DESCRIPTION scope TYPE: Scope receive TYPE: Receive send TYPE: Send Source code in starlette/websockets.py scope instance-attribute ¬∂ scope = scope app property ¬∂ app url property ¬∂ url base\\_url property ¬∂ base\\_url headers property ¬∂ headers query\\_params property ¬∂ query\\_params path\\_params property ¬∂ path\\_params cookies property ¬∂ cookies client property ¬∂ client state property ¬∂ state client\\_state instance-attribute ¬∂ client\\_state = CONNECTING application\\_state instance-attribute ¬∂ application\\_state = CONNECTING url\\_for ¬∂ url\\_for(name, /, \\*\\*path\\_params) PARAMETER DESCRIPTION name TYPE: str \\*\\*path\\_params TYPE: Any DEFAULT: {} Source code in starlette/requests.py receive async ¬∂ receive() Receive ASGI websocket messages, ensuring valid state transitions. Source code in starlette/websockets.py send async ¬∂ send(message) Send ASGI websocket messages, ensuring valid state transitions. PARAMETER DESCRIPTION message TYPE: Message Source code in starlette/websockets.py accept async ¬∂ accept(subprotocol=None, headers=None) PARAMETER DESCRIPTION subprotocol TYPE: Optional\\[str\\] DEFAULT: None headers TYPE: Optional\\[Iterable\\[Tuple\\[bytes, bytes\\]\\]\\] DEFAULT: None Source code in starlette/websockets.py receive\\_text async ¬∂ receive\\_text() Source code in starlette/websockets.py receive\\_bytes async ¬∂ receive\\_bytes() Source code in starlette/websockets.py receive\\_json async ¬∂ receive\\_json(mode='text') PARAMETER DESCRIPTION mode TYPE: str DEFAULT: 'text' Source code in starlette/websockets.py iter\\_text async ¬∂ iter\\_text() Source code in starlette/websockets.py iter\\_bytes async ¬∂ iter\\_bytes() Source code in starlette/websockets.py iter\\_json async ¬∂ iter\\_json() Source code in starlette/websockets.py send\\_text async ¬∂ send\\_text(data) PARAMETER DESCRIPTION data TYPE: str Source code in starlette/websockets.py send\\_bytes async ¬∂ send\\_bytes(data) PARAMETER DESCRIPTION data TYPE: bytes Source code in starlette/websockets.py send\\_json async ¬∂ send\\_json(data, mode='text') PARAMETER DESCRIPTION data TYPE: Any mode TYPE: str DEFAULT: 'text' Source code in starlette/websockets.py close async ¬∂ close(code=1000, reason=None) PARAMETER DESCRIPTION code TYPE: int DEFAULT: 1000 reason TYPE: Optional\\[str\\] DEFAULT: None Source code in starlette/websockets.py When a client disconnects, a WebSocketDisconnect exception is raised, you can catch it. You can import it directly form fastapi: from fastapi import WebSocketDisconnect fastapi.WebSocketDisconnect ¬∂ WebSocketDisconnect(code=1000, reason=None) Bases: Exception PARAMETER DESCRIPTION code TYPE: int DEFAULT: 1000 reason TYPE: Optional\\[str\\] DEFAULT: None Source code in starlette/websockets.py code instance-attribute ¬∂ code = code reason instance-attribute ¬∂ reason = reason or '' WebSockets - additional classes¬∂ Additional classes for handling WebSockets. Provided directly by Starlette, but you can import it from fastapi: from fastapi.websockets import WebSocketDisconnect, WebSocketState fastapi.websockets.WebSocketDisconnect ¬∂ WebSocketDisconnect(code=1000, reason=None) Bases: Exception PARAMETER DESCRIPTION code TYPE: int DEFAULT: 1000 reason TYPE: Optional\\[str\\] DEFAULT: None Source code in starlette/websockets.py code instance-attribute ¬∂ code = code reason instance-attribute ¬∂ reason = reason or '' fastapi.websockets.WebSocketState ¬∂ Bases: Enum CONNECTING class-attribute instance-attribute ¬∂ CONNECTING = 0 CONNECTED class-attribute instance-attribute ¬∂ CONNECTED = 1 DISCONNECTED class-attribute instance-attribute ¬∂ DISCONNECTED = 2 Made with Material for MkDocs Insiders"
  },
  {
    "title": "Request class - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/request/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Request class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†Request ¬†scope ¬†app ¬†url ¬†base\\_url ¬†headers ¬†query\\_params ¬†path\\_params ¬†cookies ¬†client ¬†session ¬†auth ¬†user ¬†state ¬†method ¬†receive ¬†url\\_for ¬†stream ¬†body ¬†json ¬†form ¬†close ¬†is\\_disconnected ¬†send\\_push\\_promise FastAPI Reference - Code API Request class¬∂ You can declare a parameter in a path operation function or dependency to be of type Request and then you can access the raw request object directly, without any validation, etc. You can import it directly from fastapi: from fastapi import Request Tip When you want to define dependencies that should be compatible with both HTTP and WebSockets, you can define a parameter that takes an HTTPConnection instead of a Request or a WebSocket. fastapi.Request ¬∂ Request(scope, receive=empty\\_receive, send=empty\\_send) Bases: HTTPConnection PARAMETER DESCRIPTION scope TYPE: Scope receive TYPE: Receive DEFAULT: empty\\_receive send TYPE: Send DEFAULT: empty\\_send Source code in starlette/requests.py scope instance-attribute ¬∂ scope = scope app property ¬∂ app url property ¬∂ url base\\_url property ¬∂ base\\_url headers property ¬∂ headers query\\_params property ¬∂ query\\_params path\\_params property ¬∂ path\\_params cookies property ¬∂ cookies client property ¬∂ client session property ¬∂ session auth property ¬∂ auth user property ¬∂ user state property ¬∂ state method property ¬∂ method receive property ¬∂ receive url\\_for ¬∂ url\\_for(name, /, \\*\\*path\\_params) PARAMETER DESCRIPTION name TYPE: str \\*\\*path\\_params TYPE: Any DEFAULT: {} Source code in starlette/requests.py stream async ¬∂ stream() Source code in starlette/requests.py body async ¬∂ body() Source code in starlette/requests.py json async ¬∂ json() Source code in starlette/requests.py form ¬∂ form(\\*, max\\_files=1000, max\\_fields=1000) PARAMETER DESCRIPTION max\\_files TYPE: Union\\[int, float\\] DEFAULT: 1000 max\\_fields TYPE: Union\\[int, float\\] DEFAULT: 1000 Source code in starlette/requests.py close async ¬∂ close() Source code in starlette/requests.py is\\_disconnected async ¬∂ is\\_disconnected() Source code in starlette/requests.py send\\_push\\_promise async ¬∂ send\\_push\\_promise(path) PARAMETER DESCRIPTION path TYPE: str Source code in starlette/requests.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "APIRouter class - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/apirouter/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI APIRouter class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†APIRouter Example ¬†websocket Example ¬†include\\_router Example ¬†get Example ¬†put Example ¬†post Example ¬†delete Example ¬†options Example ¬†head Example ¬†patch Example ¬†trace Example ¬†on\\_event FastAPI Reference - Code API APIRouter class¬∂ Here's the reference information for the APIRouter class, with all its parameters, attributes and methods. You can import the APIRouter class directly from fastapi: from fastapi import APIRouter fastapi.APIRouter ¬∂ APIRouter( \\*, prefix=\"\", tags=None, dependencies=None, default\\_response\\_class=Default(JSONResponse), responses=None, callbacks=None, routes=None, redirect\\_slashes=True, default=None, dependency\\_overrides\\_provider=None, route\\_class=APIRoute, on\\_startup=None, on\\_shutdown=None, lifespan=None, deprecated=None, include\\_in\\_schema=True, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Bases: Router APIRouter class, used to group path operations, for example to structure an app in multiple files. It would then be included in the FastAPI app, or in another APIRouter (ultimately included in the app). Read more about it in the FastAPI docs for Bigger Applications - Multiple Files. Example¬∂ from fastapi import APIRouter, FastAPI app = FastAPI() router = APIRouter() @router.get(\"/users/\", tags=\\[\"users\"\\]) async def read\\_users(): return \\[{\"username\": \"Rick\"}, {\"username\": \"Morty\"}\\] app.include\\_router(router) PARAMETER DESCRIPTION prefix An optional path prefix for the router. TYPE: str DEFAULT: '' tags A list of tags to be applied to all the path operations in this router. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to all the path operations in this router. Read more about it in the FastAPI docs for Bigger Applications - Multiple Files. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None default\\_response\\_class The default response class to be used. Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) responses Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Additional Responses in OpenAPI. And in the FastAPI docs for Bigger Applications. TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None callbacks OpenAPI callbacks that should apply to all path operations in this router. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None routes You normally wouldn't use this parameter with FastAPI, it is inherited from Starlette and supported for compatibility. In FastAPI, you normally would use the path operation methods, like router.get(), router.post(), etc. Note: you probably shouldn't use this parameter, it is inherited from Starlette and supported for compatibility. A list of routes to serve incoming HTTP and WebSocket requests. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None redirect\\_slashes Whether to detect and redirect slashes in URLs when the client doesn't use the same format. TYPE: bool DEFAULT: True default Default function handler for this router. Used to handle 404 Not Found errors. TYPE: Optional\\[ASGIApp\\] DEFAULT: None dependency\\_overrides\\_provider Only used internally by FastAPI to handle dependency overrides. You shouldn't need to use it. It normally points to the FastAPI app object. TYPE: Optional\\[Any\\] DEFAULT: None route\\_class Custom route (path operation) class to be used by this router. Read more about it in the FastAPI docs for Custom Request and APIRoute class. TYPE: Type\\[APIRoute\\] DEFAULT: APIRoute on\\_startup A list of startup event handler functions. You should instead use the lifespan handlers. Read more in the FastAPI docs for lifespan. TYPE: Optional\\[Sequence\\[Callable\\[\\[\\], Any\\]\\]\\] DEFAULT: None on\\_shutdown A list of shutdown event handler functions. You should instead use the lifespan handlers. Read more in the FastAPI docs for lifespan. TYPE: Optional\\[Sequence\\[Callable\\[\\[\\], Any\\]\\]\\] DEFAULT: None lifespan A Lifespan context manager handler. This replaces startup and shutdown functions with a single context manager. Read more in the FastAPI docs for lifespan. TYPE: Optional\\[Lifespan\\[Any\\]\\] DEFAULT: None deprecated Mark all path operations in this router as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) all the path operations in this router in the generated OpenAPI. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py websocket ¬∂ websocket(path, name=None, \\*, dependencies=None) Decorate a WebSocket function. Read more about it in the FastAPI docs for WebSockets. Example EXAMPLE¬∂ from fastapi import APIRouter, FastAPI, WebSocket app = FastAPI() router = APIRouter() @router.websocket(\"/ws\") async def websocket\\_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text(f\"Message text was: {data}\") app.include\\_router(router) PARAMETER DESCRIPTION path WebSocket path. TYPE: str name A name for the WebSocket. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be used for this WebSocket. Read more about it in the FastAPI docs for WebSockets. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None Source code in fastapi/routing.py include\\_router ¬∂ include\\_router( router, \\*, prefix=\"\", tags=None, dependencies=None, default\\_response\\_class=Default(JSONResponse), responses=None, callbacks=None, deprecated=None, include\\_in\\_schema=True, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Include another APIRouter in the same current APIRouter. Read more about it in the FastAPI docs for Bigger Applications. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI app = FastAPI() internal\\_router = APIRouter() users\\_router = APIRouter() @users\\_router.get(\"/users/\") def read\\_users(): return \\[{\"name\": \"Rick\"}, {\"name\": \"Morty\"}\\] internal\\_router.include\\_router(users\\_router) app.include\\_router(internal\\_router) PARAMETER DESCRIPTION router The APIRouter to include. TYPE: APIRouter prefix An optional path prefix for the router. TYPE: str DEFAULT: '' tags A list of tags to be applied to all the path operations in this router. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to all the path operations in this router. Read more about it in the FastAPI docs for Bigger Applications - Multiple Files. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None default\\_response\\_class The default response class to be used. Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) responses Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Additional Responses in OpenAPI. And in the FastAPI docs for Bigger Applications. TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None callbacks OpenAPI callbacks that should apply to all path operations in this router. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None deprecated Mark all path operations in this router as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema Include (or not) all the path operations in this router in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py get ¬∂ get( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP GET operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI app = FastAPI() router = APIRouter() @router.get(\"/items/\") def read\\_items(): return \\[{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}\\] app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py put ¬∂ put( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP PUT operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() router = APIRouter() @router.put(\"/items/{item\\_id}\") def replace\\_item(item\\_id: str, item: Item): return {\"message\": \"Item replaced\", \"id\": item\\_id} app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py post ¬∂ post( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP POST operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() router = APIRouter() @router.post(\"/items/\") def create\\_item(item: Item): return {\"message\": \"Item created\"} app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py delete ¬∂ delete( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP DELETE operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI app = FastAPI() router = APIRouter() @router.delete(\"/items/{item\\_id}\") def delete\\_item(item\\_id: str): return {\"message\": \"Item deleted\"} app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py options ¬∂ options( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP OPTIONS operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI app = FastAPI() router = APIRouter() @router.options(\"/items/\") def get\\_item\\_options(): return {\"additions\": \\[\"Aji\", \"Guacamole\"\\]} app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py head ¬∂ head( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP HEAD operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() router = APIRouter() @router.head(\"/items/\", status\\_code=204) def get\\_items\\_headers(response: Response): response.headers\\[\"X-Cat-Dog\"\\] = \"Alone in the world\" app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py patch ¬∂ patch( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP PATCH operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() router = APIRouter() @router.patch(\"/items/\") def update\\_item(item: Item): return {\"message\": \"Item updated in place\"} app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py trace ¬∂ trace( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP TRACE operation. EXAMPLE¬∂ from fastapi import APIRouter, FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() router = APIRouter() @router.put(\"/items/{item\\_id}\") def trace\\_item(item\\_id: str): return None app.include\\_router(router) PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/routing.py on\\_event ¬∂ on\\_event(event\\_type) Add an event handler for the router. on\\_event is deprecated, use lifespan event handlers instead. Read more about it in the FastAPI docs for Lifespan Events. PARAMETER DESCRIPTION event\\_type The type of event. startup or shutdown. TYPE: str Source code in fastapi/routing.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Background Tasks - BackgroundTasks - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/background/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Background Tasks - BackgroundTasks en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†BackgroundTasks Example ¬†func ¬†args ¬†kwargs ¬†is\\_async ¬†tasks ¬†add\\_task FastAPI Reference - Code API Background Tasks - BackgroundTasks¬∂ You can declare a parameter in a path operation function or dependency function with the type BackgroundTasks, and then you can use it to schedule the execution of background tasks after the response is sent. You can import it directly from fastapi: from fastapi import BackgroundTasks fastapi.BackgroundTasks ¬∂ BackgroundTasks(tasks=None) Bases: BackgroundTasks A collection of background tasks that will be called after a response has been sent to the client. Read more about it in the FastAPI docs for Background Tasks. Example¬∂ from fastapi import BackgroundTasks, FastAPI app = FastAPI() def write\\_notification(email: str, message=\"\"): with open(\"log.txt\", mode=\"w\") as email\\_file: content = f\"notification for {email}: {message}\" email\\_file.write(content) @app.post(\"/send-notification/{email}\") async def send\\_notification(email: str, background\\_tasks: BackgroundTasks): background\\_tasks.add\\_task(write\\_notification, email, message=\"some notification\") return {\"message\": \"Notification sent in the background\"} PARAMETER DESCRIPTION tasks TYPE: Optional\\[Sequence\\[BackgroundTask\\]\\] DEFAULT: None Source code in starlette/background.py func instance-attribute ¬∂ func = func args instance-attribute ¬∂ args = args kwargs instance-attribute ¬∂ kwargs = kwargs is\\_async instance-attribute ¬∂ is\\_async = is\\_async\\_callable(func) tasks instance-attribute ¬∂ tasks = list(tasks) if tasks else \\[\\] add\\_task ¬∂ add\\_task(func, \\*args, \\*\\*kwargs) Add a function to be called in the background after the response is sent. Read more about it in the FastAPI docs for Background Tasks. PARAMETER DESCRIPTION func The function to call after the response is sent. It can be a regular def function or an async def function. TYPE: Callable\\[P, Any\\] \\*args TYPE: args DEFAULT: () \\*\\*kwargs TYPE: kwargs DEFAULT: {} Source code in fastapi/background.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Dependencies - Depends() and Security() - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/dependencies/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Dependencies - Depends() and Security() en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents Depends() ¬†Depends Security() ¬†Security FastAPI Reference - Code API Dependencies - Depends() and Security()¬∂ Depends()¬∂ Dependencies are handled mainly with the special function Depends() that takes a callable. Here is the reference for it and its parameters. You can import it directly from fastapi: from fastapi import Depends fastapi.Depends ¬∂ Depends(dependency=None, \\*, use\\_cache=True) Declare a FastAPI dependency. It takes a single \"dependable\" callable (like a function). Don't call it directly, FastAPI will call it for you. Read more about it in the FastAPI docs for Dependencies. Example from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons PARAMETER DESCRIPTION dependency A \"dependable\" callable (like a function). Don't call it directly, FastAPI will call it for you, just pass the object directly. TYPE: Optional\\[Callable\\[..., Any\\]\\] DEFAULT: None use\\_cache By default, after a dependency is called the first time in a request, if the dependency is declared again for the rest of the request (for example if the dependency is needed by several dependencies), the value will be re-used for the rest of the request. Set use\\_cache to False to disable this behavior and ensure the dependency is called again (if declared more than once) in the same request. TYPE: bool DEFAULT: True Source code in fastapi/param\\_functions.py Security()¬∂ For many scenarios, you can handle security (authorization, authentication, etc.) with dependencies, using Depends(). But when you want to also declare OAuth2 scopes, you can use Security() instead of Depends(). You can import Security() directly from fastapi: from fastapi import Security fastapi.Security ¬∂ Security(dependency=None, \\*, scopes=None, use\\_cache=True) Declare a FastAPI Security dependency. The only difference with a regular dependency is that it can declare OAuth2 scopes that will be integrated with OpenAPI and the automatic UI docs (by default at /docs). It takes a single \"dependable\" callable (like a function). Don't call it directly, FastAPI will call it for you. Read more about it in the FastAPI docs for Security and in the FastAPI docs for OAuth2 scopes. Example from typing import Annotated from fastapi import Depends, FastAPI from .db import User from .security import get\\_current\\_active\\_user app = FastAPI() @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] PARAMETER DESCRIPTION dependency A \"dependable\" callable (like a function). Don't call it directly, FastAPI will call it for you, just pass the object directly. TYPE: Optional\\[Callable\\[..., Any\\]\\] DEFAULT: None scopes OAuth2 scopes required for the path operation that uses this Security dependency. The term \"scope\" comes from the OAuth2 specification, it seems to be intentionaly vague and interpretable. It normally refers to permissions, in cases to roles. These scopes are integrated with OpenAPI (and the API docs at /docs). So they are visible in the OpenAPI specification. ) TYPE: Optional\\[Sequence\\[str\\]\\] DEFAULT: None use\\_cache By default, after a dependency is called the first time in a request, if the dependency is declared again for the rest of the request (for example if the dependency is needed by several dependencies), the value will be re-used for the rest of the request. Set use\\_cache to False to disable this behavior and ensure the dependency is called again (if declared more than once) in the same request. TYPE: bool DEFAULT: True Source code in fastapi/param\\_functions.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Exceptions - HTTPException and WebSocketException - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/exceptions/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Exceptions - HTTPException and WebSocketException en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†HTTPException Example ¬†status\\_code ¬†detail ¬†headers ¬†WebSocketException Example ¬†code ¬†reason FastAPI Reference - Code API Exceptions - HTTPException and WebSocketException¬∂ These are the exceptions that you can raise to show errors to the client. When you raise an exception, as would happen with normal Python, the rest of the excecution is aborted. This way you can raise these exceptions from anywhere in the code to abort a request and show the error to the client. You can use: HTTPException WebSocketException These exceptions can be imported directly from fastapi: from fastapi import HTTPException, WebSocketException fastapi.HTTPException ¬∂ HTTPException(status\\_code, detail=None, headers=None) Bases: HTTPException An HTTP exception you can raise in your own code to show errors to the client. This is for client errors, invalid authentication, invalid data, etc. Not for server errors in your code. Read more about it in the FastAPI docs for Handling Errors. Example¬∂ from fastapi import FastAPI, HTTPException app = FastAPI() items = {\"foo\": \"The Foo Wrestlers\"} @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: str): if item\\_id not in items: raise HTTPException(status\\_code=404, detail=\"Item not found\") return {\"item\": items\\[item\\_id\\]} PARAMETER DESCRIPTION status\\_code HTTP status code to send to the client. TYPE: int detail Any data to be sent to the client in the detail key of the JSON response. TYPE: Any DEFAULT: None headers Any headers to send to the client in the response. TYPE: Optional\\[Dict\\[str, str\\]\\] DEFAULT: None Source code in fastapi/exceptions.py status\\_code instance-attribute ¬∂ status\\_code = status\\_code detail instance-attribute ¬∂ detail = detail headers instance-attribute ¬∂ headers = headers fastapi.WebSocketException ¬∂ WebSocketException(code, reason=None) Bases: WebSocketException A WebSocket exception you can raise in your own code to show errors to the client. This is for client errors, invalid authentication, invalid data, etc. Not for server errors in your code. Read more about it in the FastAPI docs for WebSockets. Example¬∂ from typing import Annotated from fastapi import ( Cookie, FastAPI, WebSocket, WebSocketException, status, ) app = FastAPI() @app.websocket(\"/items/{item\\_id}/ws\") async def websocket\\_endpoint( \\*, websocket: WebSocket, session: Annotated\\[str | None, Cookie()\\] = None, item\\_id: str, ): if session is None: raise WebSocketException(code=status.WS\\_1008\\_POLICY\\_VIOLATION) await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text(f\"Session cookie is: {session}\") await websocket.send\\_text(f\"Message text was: {data}, for item ID: {item\\_id}\") PARAMETER DESCRIPTION code A closing code from the valid codes defined in the specification. TYPE: int reason The reason to close the WebSocket connection. It is UTF-8-encoded data. The interpretation of the reason is up to the application, it is not specified by the WebSocket specification. It could contain text that could be human-readable or interpretable by the client code, etc. TYPE: Union\\[str, None\\] DEFAULT: None Source code in fastapi/exceptions.py code instance-attribute ¬∂ code = code reason instance-attribute ¬∂ reason = reason or '' Made with Material for MkDocs Insiders"
  },
  {
    "title": "UploadFile class - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/uploadfile/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI UploadFile class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†UploadFile Example ¬†file ¬†filename ¬†size ¬†headers ¬†content\\_type ¬†read ¬†write ¬†seek ¬†close FastAPI Reference - Code API UploadFile class¬∂ You can define path operation function parameters to be of the type UploadFile to receive files from the request. You can import it directly from fastapi: from fastapi import UploadFile fastapi.UploadFile ¬∂ UploadFile(file, \\*, size=None, filename=None, headers=None) Bases: UploadFile A file uploaded in a request. Define it as a path operation function (or dependency) parameter. If you are using a regular def function, you can use the upload\\_file.file attribute to access the raw standard Python file (blocking, not async), useful and needed for non-async code. Read more about it in the FastAPI docs for Request Files. Example¬∂ from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file(file: Annotated\\[bytes, File()\\]): return {\"file\\_size\": len(file)} @app.post(\"/uploadfile/\") async def create\\_upload\\_file(file: UploadFile): return {\"filename\": file.filename} PARAMETER DESCRIPTION file TYPE: BinaryIO size TYPE: Optional\\[int\\] DEFAULT: None filename TYPE: Optional\\[str\\] DEFAULT: None headers TYPE: Optional\\[Headers\\] DEFAULT: None Source code in starlette/datastructures.py file instance-attribute ¬∂ file The standard Python file object (non-async). filename instance-attribute ¬∂ filename The original file name. size instance-attribute ¬∂ size The size of the file in bytes. headers instance-attribute ¬∂ headers The headers of the request. content\\_type instance-attribute ¬∂ content\\_type The content type of the request, from the headers. read async ¬∂ read(size=-1) Read some bytes from the file. To be awaitable, compatible with async, this is run in threadpool. PARAMETER DESCRIPTION size The number of bytes to read from the file. TYPE: int DEFAULT: -1 Source code in fastapi/datastructures.py write async ¬∂ write(data) Write some bytes to the file. You normally wouldn't use this from a file you read in a request. To be awaitable, compatible with async, this is run in threadpool. PARAMETER DESCRIPTION data The bytes to write to the file. TYPE: bytes Source code in fastapi/datastructures.py seek async ¬∂ seek(offset) Move to a position in the file. Any next read or write will be done from that position. To be awaitable, compatible with async, this is run in threadpool. PARAMETER DESCRIPTION offset The position in bytes to seek to in the file. TYPE: int Source code in fastapi/datastructures.py close async ¬∂ close() Close the file. To be awaitable, compatible with async, this is run in threadpool. Source code in fastapi/datastructures.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Status Codes - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/status/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Status Codes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents Example ¬†status ¬†HTTP\\_100\\_CONTINUE ¬†HTTP\\_101\\_SWITCHING\\_PROTOCOLS ¬†HTTP\\_102\\_PROCESSING ¬†HTTP\\_103\\_EARLY\\_HINTS ¬†HTTP\\_200\\_OK ¬†HTTP\\_201\\_CREATED ¬†HTTP\\_202\\_ACCEPTED ¬†HTTP\\_203\\_NON\\_AUTHORITATIVE\\_INFORMATION ¬†HTTP\\_204\\_NO\\_CONTENT ¬†HTTP\\_205\\_RESET\\_CONTENT ¬†HTTP\\_206\\_PARTIAL\\_CONTENT ¬†HTTP\\_207\\_MULTI\\_STATUS ¬†HTTP\\_208\\_ALREADY\\_REPORTED ¬†HTTP\\_226\\_IM\\_USED ¬†HTTP\\_300\\_MULTIPLE\\_CHOICES ¬†HTTP\\_301\\_MOVED\\_PERMANENTLY ¬†HTTP\\_302\\_FOUND ¬†HTTP\\_303\\_SEE\\_OTHER ¬†HTTP\\_304\\_NOT\\_MODIFIED ¬†HTTP\\_305\\_USE\\_PROXY ¬†HTTP\\_306\\_RESERVED ¬†HTTP\\_307\\_TEMPORARY\\_REDIRECT ¬†HTTP\\_308\\_PERMANENT\\_REDIRECT ¬†HTTP\\_400\\_BAD\\_REQUEST ¬†HTTP\\_401\\_UNAUTHORIZED ¬†HTTP\\_402\\_PAYMENT\\_REQUIRED ¬†HTTP\\_403\\_FORBIDDEN ¬†HTTP\\_404\\_NOT\\_FOUND ¬†HTTP\\_405\\_METHOD\\_NOT\\_ALLOWED ¬†HTTP\\_406\\_NOT\\_ACCEPTABLE ¬†HTTP\\_407\\_PROXY\\_AUTHENTICATION\\_REQUIRED ¬†HTTP\\_408\\_REQUEST\\_TIMEOUT ¬†HTTP\\_409\\_CONFLICT ¬†HTTP\\_410\\_GONE ¬†HTTP\\_411\\_LENGTH\\_REQUIRED ¬†HTTP\\_412\\_PRECONDITION\\_FAILED ¬†HTTP\\_413\\_REQUEST\\_ENTITY\\_TOO\\_LARGE ¬†HTTP\\_414\\_REQUEST\\_URI\\_TOO\\_LONG ¬†HTTP\\_415\\_UNSUPPORTED\\_MEDIA\\_TYPE ¬†HTTP\\_416\\_REQUESTED\\_RANGE\\_NOT\\_SATISFIABLE ¬†HTTP\\_417\\_EXPECTATION\\_FAILED ¬†HTTP\\_418\\_IM\\_A\\_TEAPOT ¬†HTTP\\_421\\_MISDIRECTED\\_REQUEST ¬†HTTP\\_422\\_UNPROCESSABLE\\_ENTITY ¬†HTTP\\_423\\_LOCKED ¬†HTTP\\_424\\_FAILED\\_DEPENDENCY ¬†HTTP\\_425\\_TOO\\_EARLY ¬†HTTP\\_426\\_UPGRADE\\_REQUIRED ¬†HTTP\\_428\\_PRECONDITION\\_REQUIRED ¬†HTTP\\_429\\_TOO\\_MANY\\_REQUESTS ¬†HTTP\\_431\\_REQUEST\\_HEADER\\_FIELDS\\_TOO\\_LARGE ¬†HTTP\\_451\\_UNAVAILABLE\\_FOR\\_LEGAL\\_REASONS ¬†HTTP\\_500\\_INTERNAL\\_SERVER\\_ERROR ¬†HTTP\\_501\\_NOT\\_IMPLEMENTED ¬†HTTP\\_502\\_BAD\\_GATEWAY ¬†HTTP\\_503\\_SERVICE\\_UNAVAILABLE ¬†HTTP\\_504\\_GATEWAY\\_TIMEOUT ¬†HTTP\\_505\\_HTTP\\_VERSION\\_NOT\\_SUPPORTED ¬†HTTP\\_506\\_VARIANT\\_ALSO\\_NEGOTIATES ¬†HTTP\\_507\\_INSUFFICIENT\\_STORAGE ¬†HTTP\\_508\\_LOOP\\_DETECTED ¬†HTTP\\_510\\_NOT\\_EXTENDED ¬†HTTP\\_511\\_NETWORK\\_AUTHENTICATION\\_REQUIRED ¬†WS\\_1000\\_NORMAL\\_CLOSURE ¬†WS\\_1001\\_GOING\\_AWAY ¬†WS\\_1002\\_PROTOCOL\\_ERROR ¬†WS\\_1003\\_UNSUPPORTED\\_DATA ¬†WS\\_1005\\_NO\\_STATUS\\_RCVD ¬†WS\\_1006\\_ABNORMAL\\_CLOSURE ¬†WS\\_1007\\_INVALID\\_FRAME\\_PAYLOAD\\_DATA ¬†WS\\_1008\\_POLICY\\_VIOLATION ¬†WS\\_1009\\_MESSAGE\\_TOO\\_BIG ¬†WS\\_1010\\_MANDATORY\\_EXT ¬†WS\\_1011\\_INTERNAL\\_ERROR ¬†WS\\_1012\\_SERVICE\\_RESTART ¬†WS\\_1013\\_TRY\\_AGAIN\\_LATER ¬†WS\\_1014\\_BAD\\_GATEWAY ¬†WS\\_1015\\_TLS\\_HANDSHAKE FastAPI Reference - Code API Status Codes¬∂ You can import the status module from fastapi: from fastapi import status status is provided directly by Starlette. It containes a group of named constants (variables) with integer status codes. For example: 200: status.HTTP\\_200\\_OK 403: status.HTTP\\_403\\_FORBIDDEN etc. It can be convenient to quickly access HTTP (and WebSocket) status codes in your app, using autocompletion for the name without having to remember the integer status codes by memory. Read more about it in the FastAPI docs about Response Status Code. Example¬∂ from fastapi import FastAPI, status app = FastAPI() @app.get(\"/items/\", status\\_code=status.HTTP\\_418\\_IM\\_A\\_TEAPOT) def read\\_items(): return \\[{\"name\": \"Plumbus\"}, {\"name\": \"Portal Gun\"}\\] fastapi.status ¬∂ HTTP codes See HTTP Status Code Registry: https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml And RFC 2324 - https://tools.ietf.org/html/rfc2324 HTTP\\_100\\_CONTINUE module-attribute ¬∂ HTTP\\_100\\_CONTINUE = 100 HTTP\\_101\\_SWITCHING\\_PROTOCOLS module-attribute ¬∂ HTTP\\_101\\_SWITCHING\\_PROTOCOLS = 101 HTTP\\_102\\_PROCESSING module-attribute ¬∂ HTTP\\_102\\_PROCESSING = 102 HTTP\\_103\\_EARLY\\_HINTS module-attribute ¬∂ HTTP\\_103\\_EARLY\\_HINTS = 103 HTTP\\_200\\_OK module-attribute ¬∂ HTTP\\_200\\_OK = 200 HTTP\\_201\\_CREATED module-attribute ¬∂ HTTP\\_201\\_CREATED = 201 HTTP\\_202\\_ACCEPTED module-attribute ¬∂ HTTP\\_202\\_ACCEPTED = 202 HTTP\\_203\\_NON\\_AUTHORITATIVE\\_INFORMATION module-attribute ¬∂ HTTP\\_203\\_NON\\_AUTHORITATIVE\\_INFORMATION = 203 HTTP\\_204\\_NO\\_CONTENT module-attribute ¬∂ HTTP\\_204\\_NO\\_CONTENT = 204 HTTP\\_205\\_RESET\\_CONTENT module-attribute ¬∂ HTTP\\_205\\_RESET\\_CONTENT = 205 HTTP\\_206\\_PARTIAL\\_CONTENT module-attribute ¬∂ HTTP\\_206\\_PARTIAL\\_CONTENT = 206 HTTP\\_207\\_MULTI\\_STATUS module-attribute ¬∂ HTTP\\_207\\_MULTI\\_STATUS = 207 HTTP\\_208\\_ALREADY\\_REPORTED module-attribute ¬∂ HTTP\\_208\\_ALREADY\\_REPORTED = 208 HTTP\\_226\\_IM\\_USED module-attribute ¬∂ HTTP\\_226\\_IM\\_USED = 226 HTTP\\_300\\_MULTIPLE\\_CHOICES module-attribute ¬∂ HTTP\\_300\\_MULTIPLE\\_CHOICES = 300 HTTP\\_301\\_MOVED\\_PERMANENTLY module-attribute ¬∂ HTTP\\_301\\_MOVED\\_PERMANENTLY = 301 HTTP\\_302\\_FOUND module-attribute ¬∂ HTTP\\_302\\_FOUND = 302 HTTP\\_303\\_SEE\\_OTHER module-attribute ¬∂ HTTP\\_303\\_SEE\\_OTHER = 303 HTTP\\_304\\_NOT\\_MODIFIED module-attribute ¬∂ HTTP\\_304\\_NOT\\_MODIFIED = 304 HTTP\\_305\\_USE\\_PROXY module-attribute ¬∂ HTTP\\_305\\_USE\\_PROXY = 305 HTTP\\_306\\_RESERVED module-attribute ¬∂ HTTP\\_306\\_RESERVED = 306 HTTP\\_307\\_TEMPORARY\\_REDIRECT module-attribute ¬∂ HTTP\\_307\\_TEMPORARY\\_REDIRECT = 307 HTTP\\_308\\_PERMANENT\\_REDIRECT module-attribute ¬∂ HTTP\\_308\\_PERMANENT\\_REDIRECT = 308 HTTP\\_400\\_BAD\\_REQUEST module-attribute ¬∂ HTTP\\_400\\_BAD\\_REQUEST = 400 HTTP\\_401\\_UNAUTHORIZED module-attribute ¬∂ HTTP\\_401\\_UNAUTHORIZED = 401 HTTP\\_402\\_PAYMENT\\_REQUIRED module-attribute ¬∂ HTTP\\_402\\_PAYMENT\\_REQUIRED = 402 HTTP\\_403\\_FORBIDDEN module-attribute ¬∂ HTTP\\_403\\_FORBIDDEN = 403 HTTP\\_404\\_NOT\\_FOUND module-attribute ¬∂ HTTP\\_404\\_NOT\\_FOUND = 404 HTTP\\_405\\_METHOD\\_NOT\\_ALLOWED module-attribute ¬∂ HTTP\\_405\\_METHOD\\_NOT\\_ALLOWED = 405 HTTP\\_406\\_NOT\\_ACCEPTABLE module-attribute ¬∂ HTTP\\_406\\_NOT\\_ACCEPTABLE = 406 HTTP\\_407\\_PROXY\\_AUTHENTICATION\\_REQUIRED module-attribute ¬∂ HTTP\\_407\\_PROXY\\_AUTHENTICATION\\_REQUIRED = 407 HTTP\\_408\\_REQUEST\\_TIMEOUT module-attribute ¬∂ HTTP\\_408\\_REQUEST\\_TIMEOUT = 408 HTTP\\_409\\_CONFLICT module-attribute ¬∂ HTTP\\_409\\_CONFLICT = 409 HTTP\\_410\\_GONE module-attribute ¬∂ HTTP\\_410\\_GONE = 410 HTTP\\_411\\_LENGTH\\_REQUIRED module-attribute ¬∂ HTTP\\_411\\_LENGTH\\_REQUIRED = 411 HTTP\\_412\\_PRECONDITION\\_FAILED module-attribute ¬∂ HTTP\\_412\\_PRECONDITION\\_FAILED = 412 HTTP\\_413\\_REQUEST\\_ENTITY\\_TOO\\_LARGE module-attribute ¬∂ HTTP\\_413\\_REQUEST\\_ENTITY\\_TOO\\_LARGE = 413 HTTP\\_414\\_REQUEST\\_URI\\_TOO\\_LONG module-attribute ¬∂ HTTP\\_414\\_REQUEST\\_URI\\_TOO\\_LONG = 414 HTTP\\_415\\_UNSUPPORTED\\_MEDIA\\_TYPE module-attribute ¬∂ HTTP\\_415\\_UNSUPPORTED\\_MEDIA\\_TYPE = 415 HTTP\\_416\\_REQUESTED\\_RANGE\\_NOT\\_SATISFIABLE module-attribute ¬∂ HTTP\\_416\\_REQUESTED\\_RANGE\\_NOT\\_SATISFIABLE = 416 HTTP\\_417\\_EXPECTATION\\_FAILED module-attribute ¬∂ HTTP\\_417\\_EXPECTATION\\_FAILED = 417 HTTP\\_418\\_IM\\_A\\_TEAPOT module-attribute ¬∂ HTTP\\_418\\_IM\\_A\\_TEAPOT = 418 HTTP\\_421\\_MISDIRECTED\\_REQUEST module-attribute ¬∂ HTTP\\_421\\_MISDIRECTED\\_REQUEST = 421 HTTP\\_422\\_UNPROCESSABLE\\_ENTITY module-attribute ¬∂ HTTP\\_422\\_UNPROCESSABLE\\_ENTITY = 422 HTTP\\_423\\_LOCKED module-attribute ¬∂ HTTP\\_423\\_LOCKED = 423 HTTP\\_424\\_FAILED\\_DEPENDENCY module-attribute ¬∂ HTTP\\_424\\_FAILED\\_DEPENDENCY = 424 HTTP\\_425\\_TOO\\_EARLY module-attribute ¬∂ HTTP\\_425\\_TOO\\_EARLY = 425 HTTP\\_426\\_UPGRADE\\_REQUIRED module-attribute ¬∂ HTTP\\_426\\_UPGRADE\\_REQUIRED = 426 HTTP\\_428\\_PRECONDITION\\_REQUIRED module-attribute ¬∂ HTTP\\_428\\_PRECONDITION\\_REQUIRED = 428 HTTP\\_429\\_TOO\\_MANY\\_REQUESTS module-attribute ¬∂ HTTP\\_429\\_TOO\\_MANY\\_REQUESTS = 429 HTTP\\_431\\_REQUEST\\_HEADER\\_FIELDS\\_TOO\\_LARGE module-attribute ¬∂ HTTP\\_431\\_REQUEST\\_HEADER\\_FIELDS\\_TOO\\_LARGE = 431 HTTP\\_451\\_UNAVAILABLE\\_FOR\\_LEGAL\\_REASONS module-attribute ¬∂ HTTP\\_451\\_UNAVAILABLE\\_FOR\\_LEGAL\\_REASONS = 451 HTTP\\_500\\_INTERNAL\\_SERVER\\_ERROR module-attribute ¬∂ HTTP\\_500\\_INTERNAL\\_SERVER\\_ERROR = 500 HTTP\\_501\\_NOT\\_IMPLEMENTED module-attribute ¬∂ HTTP\\_501\\_NOT\\_IMPLEMENTED = 501 HTTP\\_502\\_BAD\\_GATEWAY module-attribute ¬∂ HTTP\\_502\\_BAD\\_GATEWAY = 502 HTTP\\_503\\_SERVICE\\_UNAVAILABLE module-attribute ¬∂ HTTP\\_503\\_SERVICE\\_UNAVAILABLE = 503 HTTP\\_504\\_GATEWAY\\_TIMEOUT module-attribute ¬∂ HTTP\\_504\\_GATEWAY\\_TIMEOUT = 504 HTTP\\_505\\_HTTP\\_VERSION\\_NOT\\_SUPPORTED module-attribute ¬∂ HTTP\\_505\\_HTTP\\_VERSION\\_NOT\\_SUPPORTED = 505 HTTP\\_506\\_VARIANT\\_ALSO\\_NEGOTIATES module-attribute ¬∂ HTTP\\_506\\_VARIANT\\_ALSO\\_NEGOTIATES = 506 HTTP\\_507\\_INSUFFICIENT\\_STORAGE module-attribute ¬∂ HTTP\\_507\\_INSUFFICIENT\\_STORAGE = 507 HTTP\\_508\\_LOOP\\_DETECTED module-attribute ¬∂ HTTP\\_508\\_LOOP\\_DETECTED = 508 HTTP\\_510\\_NOT\\_EXTENDED module-attribute ¬∂ HTTP\\_510\\_NOT\\_EXTENDED = 510 HTTP\\_511\\_NETWORK\\_AUTHENTICATION\\_REQUIRED module-attribute ¬∂ HTTP\\_511\\_NETWORK\\_AUTHENTICATION\\_REQUIRED = 511 WebSocket codes https://www.iana.org/assignments/websocket/websocket.xml#close-code-number https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent WS\\_1000\\_NORMAL\\_CLOSURE module-attribute ¬∂ WS\\_1000\\_NORMAL\\_CLOSURE = 1000 WS\\_1001\\_GOING\\_AWAY module-attribute ¬∂ WS\\_1001\\_GOING\\_AWAY = 1001 WS\\_1002\\_PROTOCOL\\_ERROR module-attribute ¬∂ WS\\_1002\\_PROTOCOL\\_ERROR = 1002 WS\\_1003\\_UNSUPPORTED\\_DATA module-attribute ¬∂ WS\\_1003\\_UNSUPPORTED\\_DATA = 1003 WS\\_1005\\_NO\\_STATUS\\_RCVD module-attribute ¬∂ WS\\_1005\\_NO\\_STATUS\\_RCVD = 1005 WS\\_1006\\_ABNORMAL\\_CLOSURE module-attribute ¬∂ WS\\_1006\\_ABNORMAL\\_CLOSURE = 1006 WS\\_1007\\_INVALID\\_FRAME\\_PAYLOAD\\_DATA module-attribute ¬∂ WS\\_1007\\_INVALID\\_FRAME\\_PAYLOAD\\_DATA = 1007 WS\\_1008\\_POLICY\\_VIOLATION module-attribute ¬∂ WS\\_1008\\_POLICY\\_VIOLATION = 1008 WS\\_1009\\_MESSAGE\\_TOO\\_BIG module-attribute ¬∂ WS\\_1009\\_MESSAGE\\_TOO\\_BIG = 1009 WS\\_1010\\_MANDATORY\\_EXT module-attribute ¬∂ WS\\_1010\\_MANDATORY\\_EXT = 1010 WS\\_1011\\_INTERNAL\\_ERROR module-attribute ¬∂ WS\\_1011\\_INTERNAL\\_ERROR = 1011 WS\\_1012\\_SERVICE\\_RESTART module-attribute ¬∂ WS\\_1012\\_SERVICE\\_RESTART = 1012 WS\\_1013\\_TRY\\_AGAIN\\_LATER module-attribute ¬∂ WS\\_1013\\_TRY\\_AGAIN\\_LATER = 1013 WS\\_1014\\_BAD\\_GATEWAY module-attribute ¬∂ WS\\_1014\\_BAD\\_GATEWAY = 1014 WS\\_1015\\_TLS\\_HANDSHAKE module-attribute ¬∂ WS\\_1015\\_TLS\\_HANDSHAKE = 1015 Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI class - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/fastapi/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI FastAPI class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†FastAPI Example ¬†openapi\\_version ¬†webhooks ¬†state ¬†dependency\\_overrides ¬†openapi ¬†websocket ¬†include\\_router Example ¬†get Example ¬†put Example ¬†post Example ¬†delete Example ¬†options Example ¬†head Example ¬†patch Example ¬†trace Example ¬†on\\_event ¬†middleware Example ¬†exception\\_handler Example FastAPI Reference - Code API FastAPI class¬∂ Here's the reference information for the FastAPI class, with all its parameters, attributes and methods. You can import the FastAPI class directly from fastapi: from fastapi import FastAPI fastapi.FastAPI ¬∂ FastAPI( \\*, debug=False, routes=None, title=\"FastAPI\", summary=None, description=\"\", version=\"0.1.0\", openapi\\_url=\"/openapi.json\", openapi\\_tags=None, servers=None, dependencies=None, default\\_response\\_class=Default(JSONResponse), redirect\\_slashes=True, docs\\_url=\"/docs\", redoc\\_url=\"/redoc\", swagger\\_ui\\_oauth2\\_redirect\\_url=\"/docs/oauth2-redirect\", swagger\\_ui\\_init\\_oauth=None, middleware=None, exception\\_handlers=None, on\\_startup=None, on\\_shutdown=None, lifespan=None, terms\\_of\\_service=None, contact=None, license\\_info=None, openapi\\_prefix=\"\", root\\_path=\"\", root\\_path\\_in\\_servers=True, responses=None, callbacks=None, webhooks=None, deprecated=None, include\\_in\\_schema=True, swagger\\_ui\\_parameters=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id), separate\\_input\\_output\\_schemas=True, \\*\\*extra ) Bases: Starlette FastAPI app class, the main entrypoint to use FastAPI. Read more in the FastAPI docs for First Steps. Example¬∂ from fastapi import FastAPI app = FastAPI() PARAMETER DESCRIPTION debug Boolean indicating if debug tracebacks should be returned on server errors. Read more in the Starlette docs for Applications. TYPE: bool DEFAULT: False routes You normally wouldn't use this parameter with FastAPI, it is inherited from Starlette and supported for compatibility. In FastAPI, you normally would use the path operation methods, like app.get(), app.post(), etc. Note: you probably shouldn't use this parameter, it is inherited from Starlette and supported for compatibility. A list of routes to serve incoming HTTP and WebSocket requests. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None title The title of the API. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI(title=\"ChimichangApp\") TYPE: str DEFAULT: 'FastAPI' summary A short summary of the API. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI(summary=\"Deadpond's favorite app. Nuff said.\") TYPE: Optional\\[str\\] DEFAULT: None description A description of the API. Supports Markdown (using CommonMark syntax). It will be added to the generated OpenAPI (e.g. visible at /docs). Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI( description=\"\"\" ChimichangApp API helps you do awesome stuff. üöÄ ## Items You can \\*\\*read items\\*\\*. ## Users You will be able to: \\* \\*\\*Create users\\*\\* (\\_not implemented\\_). \\* \\*\\*Read users\\*\\* (\\_not implemented\\_). \"\"\" ) TYPE: str DEFAULT: '' version The version of the API. Note This is the version of your application, not the version of the OpenAPI specification nor the version of FastAPI being used. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI(version=\"0.0.1\") TYPE: str DEFAULT: '0.1.0' openapi\\_url The URL where the OpenAPI schema will be served from. If you set it to None, no OpenAPI schema will be served publicly, and the default automatic endpoints /docs and /redoc will also be disabled. Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI(openapi\\_url=\"/api/v1/openapi.json\") TYPE: Optional\\[str\\] DEFAULT: '/openapi.json' openapi\\_tags A list of tags used by OpenAPI, these are the same tags you can set in the path operations, like: @app.get(\"/users/\", tags=\\[\"users\"\\]) @app.get(\"/items/\", tags=\\[\"items\"\\]) The order of the tags can be used to specify the order shown in tools like Swagger UI, used in the automatic path /docs. It's not required to specify all the tags used. The tags that are not declared MAY be organized randomly or based on the tools' logic. Each tag name in the list MUST be unique. The value of each item is a dict containing: name: The name of the tag. description: A short description of the tag. CommonMark syntax MAY be used for rich text representation. externalDocs: Additional external documentation for this tag. If provided, it would contain a dict with: description: A short description of the target documentation. CommonMark syntax MAY be used for rich text representation. url: The URL for the target documentation. Value MUST be in the form of a URL. Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI tags\\_metadata = \\[ { \"name\": \"users\", \"description\": \"Operations with users. The \\*\\*login\\*\\* logic is also here.\", }, { \"name\": \"items\", \"description\": \"Manage items. So \\_fancy\\_ they have their own docs.\", \"externalDocs\": { \"description\": \"Items external docs\", \"url\": \"https://fastapi.tiangolo.com/\", }, }, \\] app = FastAPI(openapi\\_tags=tags\\_metadata) TYPE: Optional\\[List\\[Dict\\[str, Any\\]\\]\\] DEFAULT: None servers A list of dicts with connectivity information to a target server. You would use it, for example, if your application is served from different domains and you want to use the same Swagger UI in the browser to interact with each of them (instead of having multiple browser tabs open). Or if you want to leave fixed the possible URLs. If the servers list is not provided, or is an empty list, the default value would be a a dict with a url value of /. Each item in the list is a dict containing: url: A URL to the target host. This URL supports Server Variables and MAY be relative, to indicate that the host location is relative to the location where the OpenAPI document is being served. Variable substitutions will be made when a variable is named in {brackets}. description: An optional string describing the host designated by the URL. CommonMark syntax MAY be used for rich text representation. variables: A dict between a variable name and its value. The value is used for substitution in the server's URL template. Read more in the FastAPI docs for Behind a Proxy. Example from fastapi import FastAPI app = FastAPI( servers=\\[ {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"}, {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"}, \\] ) TYPE: Optional\\[List\\[Dict\\[str, Union\\[str, Any\\]\\]\\]\\] DEFAULT: None dependencies A list of global dependencies, they will be applied to each path operation, including in sub-routers. Read more about it in the FastAPI docs for Global Dependencies. Example from fastapi import Depends, FastAPI from .dependencies import func\\_dep\\_1, func\\_dep\\_2 app = FastAPI(dependencies=\\[Depends(func\\_dep\\_1), Depends(func\\_dep\\_2)\\]) TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None default\\_response\\_class The default response class to be used. Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others. Example from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default\\_response\\_class=ORJSONResponse) TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) redirect\\_slashes Whether to detect and redirect slashes in URLs when the client doesn't use the same format. Example from fastapi import FastAPI app = FastAPI(redirect\\_slashes=True) # the default @app.get(\"/items/\") async def read\\_items(): return \\[{\"item\\_id\": \"Foo\"}\\] With this app, if a client goes to /items (without a trailing slash), they will be automatically redirected with an HTTP status code of 307 to /items/. TYPE: bool DEFAULT: True docs\\_url The path to the automatic interactive API documentation. It is handled in the browser by Swagger UI. The default URL is /docs. You can disable it by setting it to None. If openapi\\_url is set to None, this will be automatically disabled. Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI(docs\\_url=\"/documentation\", redoc\\_url=None) TYPE: Optional\\[str\\] DEFAULT: '/docs' redoc\\_url The path to the alternative automatic interactive API documentation provided by ReDoc. The default URL is /redoc. You can disable it by setting it to None. If openapi\\_url is set to None, this will be automatically disabled. Read more in the FastAPI docs for Metadata and Docs URLs. Example from fastapi import FastAPI app = FastAPI(docs\\_url=\"/documentation\", redoc\\_url=\"redocumentation\") TYPE: Optional\\[str\\] DEFAULT: '/redoc' swagger\\_ui\\_oauth2\\_redirect\\_url The OAuth2 redirect endpoint for the Swagger UI. By default it is /docs/oauth2-redirect. This is only used if you use OAuth2 (with the \"Authorize\" button) with Swagger UI. TYPE: Optional\\[str\\] DEFAULT: '/docs/oauth2-redirect' swagger\\_ui\\_init\\_oauth OAuth2 configuration for the Swagger UI, by default shown at /docs. Read more about the available configuration options in the Swagger UI docs. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None middleware List of middleware to be added when creating the application. In FastAPI you would normally do this with app.add\\_middleware() instead. Read more in the FastAPI docs for Middleware. TYPE: Optional\\[Sequence\\[Middleware\\]\\] DEFAULT: None exception\\_handlers A dictionary with handlers for exceptions. In FastAPI, you would normally use the decorator @app.exception\\_handler(). Read more in the FastAPI docs for Handling Errors. TYPE: Optional\\[Dict\\[Union\\[int, Type\\[Exception\\]\\], Callable\\[\\[Request, Any\\], Coroutine\\[Any, Any, Response\\]\\]\\]\\] DEFAULT: None on\\_startup A list of startup event handler functions. You should instead use the lifespan handlers. Read more in the FastAPI docs for lifespan. TYPE: Optional\\[Sequence\\[Callable\\[\\[\\], Any\\]\\]\\] DEFAULT: None on\\_shutdown A list of shutdown event handler functions. You should instead use the lifespan handlers. Read more in the FastAPI docs for lifespan. TYPE: Optional\\[Sequence\\[Callable\\[\\[\\], Any\\]\\]\\] DEFAULT: None lifespan A Lifespan context manager handler. This replaces startup and shutdown functions with a single context manager. Read more in the FastAPI docs for lifespan. TYPE: Optional\\[Lifespan\\[AppType\\]\\] DEFAULT: None terms\\_of\\_service A URL to the Terms of Service for your API. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more at the FastAPI docs for Metadata and Docs URLs. Example app = FastAPI(terms\\_of\\_service=\"http://example.com/terms/\") TYPE: Optional\\[str\\] DEFAULT: None contact A dictionary with the contact information for the exposed API. It can contain several fields. name: (str) The name of the contact person/organization. url: (str) A URL pointing to the contact information. MUST be in the format of a URL. email: (str) The email address of the contact person/organization. MUST be in the format of an email address. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more at the FastAPI docs for Metadata and Docs URLs. Example app = FastAPI( contact={ \"name\": \"Deadpoolio the Amazing\", \"url\": \"http://x-force.example.com/contact/\", \"email\": \"dp@x-force.example.com\", } ) TYPE: Optional\\[Dict\\[str, Union\\[str, Any\\]\\]\\] DEFAULT: None license\\_info A dictionary with the license information for the exposed API. It can contain several fields. name: (str) REQUIRED (if a license\\_info is set). The license name used for the API. identifier: (str) An SPDX license expression for the API. The identifier field is mutually exclusive of the url field. Available since OpenAPI 3.1.0, FastAPI 0.99.0. url: (str) A URL to the license used for the API. This MUST be the format of a URL. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more at the FastAPI docs for Metadata and Docs URLs. Example app = FastAPI( license\\_info={ \"name\": \"Apache 2.0\", \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\", } ) TYPE: Optional\\[Dict\\[str, Union\\[str, Any\\]\\]\\] DEFAULT: None openapi\\_prefix \"openapi\\_prefix\" has been deprecated in favor of \"root\\_path\", which follows more closely the ASGI standard, is simpler, and more automatic. A URL prefix for the OpenAPI URL. TYPE: str DEFAULT: '' root\\_path A path prefix handled by a proxy that is not seen by the application but is seen by external clients, which affects things like Swagger UI. Read more about it at the FastAPI docs for Behind a Proxy. Example from fastapi import FastAPI app = FastAPI(root\\_path=\"/api/v1\") TYPE: str DEFAULT: '' root\\_path\\_in\\_servers To disable automatically generating the URLs in the servers field in the autogenerated OpenAPI using the root\\_path. Read more about it in the FastAPI docs for Behind a Proxy. Example from fastapi import FastAPI app = FastAPI(root\\_path\\_in\\_servers=False) TYPE: bool DEFAULT: True responses Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Additional Responses in OpenAPI. And in the FastAPI docs for Bigger Applications. TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None callbacks OpenAPI callbacks that should apply to all path operations. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None webhooks Add OpenAPI webhooks. This is similar to callbacks but it doesn't depend on specific path operations. It will be added to the generated OpenAPI (e.g. visible at /docs). Note: This is available since OpenAPI 3.1.0, FastAPI 0.99.0. Read more about it in the FastAPI docs for OpenAPI Webhooks. TYPE: Optional\\[APIRouter\\] DEFAULT: None deprecated Mark all path operations as deprecated. You probably don't need it, but it's available. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) all the path operations in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True swagger\\_ui\\_parameters Parameters to configure Swagger UI, the autogenerated interactive API documentation (by default at /docs). Read more about it in the FastAPI docs about how to Configure Swagger UI. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) separate\\_input\\_output\\_schemas Whether to generate separate OpenAPI schemas for request body and response body when the results would be more precise. This is particularly useful when automatically generating clients. For example, if you have a model like: from pydantic import BaseModel class Item(BaseModel): name: str tags: list\\[str\\] = \\[\\] When Item is used for input, a request body, tags is not required, the client doesn't have to provide it. But when using Item for output, for a response body, tags is always available because it has a default value, even if it's just an empty list. So, the client should be able to always expect it. In this case, there would be two different schemas, one for input and another one for output. TYPE: bool DEFAULT: True \\*\\*extra Extra keyword arguments to be stored in the app, not used by FastAPI anywhere. TYPE: Any DEFAULT: {} Source code in fastapi/applications.py openapi\\_version instance-attribute ¬∂ openapi\\_version = '3.1.0' The version string of OpenAPI. FastAPI will generate OpenAPI version 3.1.0, and will output that as the OpenAPI version. But some tools, even though they might be compatible with OpenAPI 3.1.0, might not recognize it as a valid. So you could override this value to trick those tools into using the generated OpenAPI. Have in mind that this is a hack. But if you avoid using features added in OpenAPI 3.1.0, it might work for your use case. This is not passed as a parameter to the FastAPI class to avoid giving the false idea that FastAPI would generate a different OpenAPI schema. It is only available as an attribute. Example from fastapi import FastAPI app = FastAPI() app.openapi\\_version = \"3.0.2\" webhooks instance-attribute ¬∂ webhooks = webhooks or APIRouter() The app.webhooks attribute is an APIRouter with the path operations that will be used just for documentation of webhooks. Read more about it in the FastAPI docs for OpenAPI Webhooks. state instance-attribute ¬∂ state = State() A state object for the application. This is the same object for the entire application, it doesn't change from request to request. You normally woudln't use this in FastAPI, for most of the cases you would instead use FastAPI dependencies. This is simply inherited from Starlette. Read more about it in the Starlette docs for Applications. dependency\\_overrides instance-attribute ¬∂ dependency\\_overrides = {} A dictionary with overrides for the dependencies. Each key is the original dependency callable, and the value is the actual dependency that should be called. This is for testing, to replace expensive dependencies with testing versions. Read more about it in the FastAPI docs for Testing Dependencies with Overrides. openapi ¬∂ openapi() Generate the OpenAPI schema of the application. This is called by FastAPI internally. The first time it is called it stores the result in the attribute app.openapi\\_schema, and next times it is called, it just returns that same result. To avoid the cost of generating the schema every time. If you need to modify the generated OpenAPI schema, you could modify it. Read more in the FastAPI docs for OpenAPI. Source code in fastapi/applications.py websocket ¬∂ websocket(path, name=None, \\*, dependencies=None) Decorate a WebSocket function. Read more about it in the FastAPI docs for WebSockets. Example from fastapi import FastAPI, WebSocket app = FastAPI() @app.websocket(\"/ws\") async def websocket\\_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text(f\"Message text was: {data}\") PARAMETER DESCRIPTION path WebSocket path. TYPE: str name A name for the WebSocket. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be used for this WebSocket. Read more about it in the FastAPI docs for WebSockets. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None Source code in fastapi/applications.py include\\_router ¬∂ include\\_router( router, \\*, prefix=\"\", tags=None, dependencies=None, responses=None, deprecated=None, include\\_in\\_schema=True, default\\_response\\_class=Default(JSONResponse), callbacks=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Include an APIRouter in the same app. Read more about it in the FastAPI docs for Bigger Applications. EXAMPLE¬∂ from fastapi import FastAPI from .users import users\\_router app = FastAPI() app.include\\_router(users\\_router) PARAMETER DESCRIPTION router The APIRouter to include. TYPE: APIRouter prefix An optional path prefix for the router. TYPE: str DEFAULT: '' tags A list of tags to be applied to all the path operations in this router. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to all the path operations in this router. Read more about it in the FastAPI docs for Bigger Applications - Multiple Files. Example from fastapi import Depends, FastAPI from .dependencies import get\\_token\\_header from .internal import admin app = FastAPI() app.include\\_router( admin.router, dependencies=\\[Depends(get\\_token\\_header)\\], ) TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None responses Additional responses to be shown in OpenAPI. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Additional Responses in OpenAPI. And in the FastAPI docs for Bigger Applications. TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark all the path operations in this router as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). Example from fastapi import FastAPI from .internal import old\\_api app = FastAPI() app.include\\_router( old\\_api.router, deprecated=True, ) TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema Include (or not) all the path operations in this router in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Example from fastapi import FastAPI from .internal import old\\_api app = FastAPI() app.include\\_router( old\\_api.router, include\\_in\\_schema=False, ) TYPE: bool DEFAULT: True default\\_response\\_class Default response class to be used for the path operations in this router. Read more in the FastAPI docs for Custom Response - HTML, Stream, File, others. Example from fastapi import FastAPI from fastapi.responses import ORJSONResponse from .internal import old\\_api app = FastAPI() app.include\\_router( old\\_api.router, default\\_response\\_class=ORJSONResponse, ) TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py get ¬∂ get( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP GET operation. EXAMPLE¬∂ from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\") def read\\_items(): return \\[{\"name\": \"Empanada\"}, {\"name\": \"Arepa\"}\\] PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py put ¬∂ put( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP PUT operation. EXAMPLE¬∂ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.put(\"/items/{item\\_id}\") def replace\\_item(item\\_id: str, item: Item): return {\"message\": \"Item replaced\", \"id\": item\\_id} PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py post ¬∂ post( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP POST operation. EXAMPLE¬∂ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.post(\"/items/\") def create\\_item(item: Item): return {\"message\": \"Item created\"} PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py delete ¬∂ delete( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP DELETE operation. EXAMPLE¬∂ from fastapi import FastAPI app = FastAPI() @app.delete(\"/items/{item\\_id}\") def delete\\_item(item\\_id: str): return {\"message\": \"Item deleted\"} PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py options ¬∂ options( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP OPTIONS operation. EXAMPLE¬∂ from fastapi import FastAPI app = FastAPI() @app.options(\"/items/\") def get\\_item\\_options(): return {\"additions\": \\[\"Aji\", \"Guacamole\"\\]} PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py head ¬∂ head( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP HEAD operation. EXAMPLE¬∂ from fastapi import FastAPI, Response app = FastAPI() @app.head(\"/items/\", status\\_code=204) def get\\_items\\_headers(response: Response): response.headers\\[\"X-Cat-Dog\"\\] = \"Alone in the world\" PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py patch ¬∂ patch( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP PATCH operation. EXAMPLE¬∂ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.patch(\"/items/\") def update\\_item(item: Item): return {\"message\": \"Item updated in place\"} PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py trace ¬∂ trace( path, \\*, response\\_model=Default(None), status\\_code=None, tags=None, dependencies=None, summary=None, description=None, response\\_description=\"Successful Response\", responses=None, deprecated=None, operation\\_id=None, response\\_model\\_include=None, response\\_model\\_exclude=None, response\\_model\\_by\\_alias=True, response\\_model\\_exclude\\_unset=False, response\\_model\\_exclude\\_defaults=False, response\\_model\\_exclude\\_none=False, include\\_in\\_schema=True, response\\_class=Default(JSONResponse), name=None, callbacks=None, openapi\\_extra=None, generate\\_unique\\_id\\_function=Default(generate\\_unique\\_id) ) Add a path operation using an HTTP TRACE operation. EXAMPLE¬∂ from fastapi import FastAPI app = FastAPI() @app.put(\"/items/{item\\_id}\") def trace\\_item(item\\_id: str): return None PARAMETER DESCRIPTION path The URL path to be used for this path operation. For example, in http://example.com/items, the path is /items. TYPE: str response\\_model The type to use for the response. It could be any valid Pydantic field type. So, it doesn't have to be a Pydantic model, it could be other things, like a list, dict, etc. It will be used for: Documentation: the generated OpenAPI (and the UI at /docs) will show it as the response (JSON Schema). Serialization: you could return an arbitrary object and the response\\_model would be used to serialize that object into the corresponding JSON. Filtering: the JSON sent to the client will only contain the data (fields) defined in the response\\_model. If you returned an object that contains an attribute password but the response\\_model does not include that field, the JSON sent to the client would not have that password. Validation: whatever you return will be serialized with the response\\_model, converting any data as necessary to generate the corresponding JSON. But if the data in the object returned is not valid, that would mean a violation of the contract with the client, so it's an error from the API developer. So, FastAPI will raise an error and return a 500 error code (Internal Server Error). Read more about it in the FastAPI docs for Response Model. TYPE: Any DEFAULT: Default(None) status\\_code The default status code to be used for the response. You could override the status code by returning a response directly. Read more about it in the FastAPI docs for Response Status Code. TYPE: Optional\\[int\\] DEFAULT: None tags A list of tags to be applied to the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[List\\[Union\\[str, Enum\\]\\]\\] DEFAULT: None dependencies A list of dependencies (using Depends()) to be applied to the path operation. Read more about it in the FastAPI docs for Dependencies in path operation decorators. TYPE: Optional\\[Sequence\\[Depends\\]\\] DEFAULT: None summary A summary for the path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None description A description for the path operation. If not provided, it will be extracted automatically from the docstring of the path operation function. It can contain Markdown. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Path Operation Configuration. TYPE: Optional\\[str\\] DEFAULT: None response\\_description The description for the default response. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: str DEFAULT: 'Successful Response' responses Additional responses that could be returned by this path operation. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[Dict\\[Union\\[int, str\\], Dict\\[str, Any\\]\\]\\] DEFAULT: None deprecated Mark this path operation as deprecated. It will be added to the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None operation\\_id Custom operation ID to be used by this path operation. By default, it is generated automatically. If you provide a custom operation ID, you need to make sure it is unique for the whole API. You can customize the operation ID generation with the parameter generate\\_unique\\_id\\_function in the FastAPI class. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Optional\\[str\\] DEFAULT: None response\\_model\\_include Configuration passed to Pydantic to include only certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_exclude Configuration passed to Pydantic to exclude certain fields in the response data. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: Optional\\[IncEx\\] DEFAULT: None response\\_model\\_by\\_alias Configuration passed to Pydantic to define if the response model should be serialized by alias when an alias is used. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: True response\\_model\\_exclude\\_unset Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that were not set and have their default values. This is different from response\\_model\\_exclude\\_defaults in that if the fields are set, they will be included in the response, even if the value is the same as the default. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_defaults Configuration passed to Pydantic to define if the response data should have all the fields, including the ones that have the same value as the default. This is different from response\\_model\\_exclude\\_unset in that if the fields are set but contain the same default values, they will be excluded from the response. When True, default values are omitted from the response. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False response\\_model\\_exclude\\_none Configuration passed to Pydantic to define if the response data should exclude fields set to None. This is much simpler (less smart) than response\\_model\\_exclude\\_unset and response\\_model\\_exclude\\_defaults. You probably want to use one of those two instead of this one, as those allow returning None values when it makes sense. Read more about it in the FastAPI docs for Response Model - Return Type. TYPE: bool DEFAULT: False include\\_in\\_schema Include this path operation in the generated OpenAPI schema. This affects the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for Query Parameters and String Validations. TYPE: bool DEFAULT: True response\\_class Response class to be used for this path operation. This will not be used if you return a response directly. Read more about it in the FastAPI docs for Custom Response - HTML, Stream, File, others. TYPE: Type\\[Response\\] DEFAULT: Default(JSONResponse) name Name for this path operation. Only used internally. TYPE: Optional\\[str\\] DEFAULT: None callbacks List of path operations that will be used as OpenAPI callbacks. This is only for OpenAPI documentation, the callbacks won't be used directly. It will be added to the generated OpenAPI (e.g. visible at /docs). Read more about it in the FastAPI docs for OpenAPI Callbacks. TYPE: Optional\\[List\\[BaseRoute\\]\\] DEFAULT: None openapi\\_extra Extra metadata to be included in the OpenAPI schema for this path operation. Read more about it in the FastAPI docs for Path Operation Advanced Configuration. TYPE: Optional\\[Dict\\[str, Any\\]\\] DEFAULT: None generate\\_unique\\_id\\_function Customize the function used to generate unique IDs for the path operations shown in the generated OpenAPI. This is particularly useful when automatically generating clients or SDKs for your API. Read more about it in the FastAPI docs about how to Generate Clients. TYPE: Callable\\[\\[APIRoute\\], str\\] DEFAULT: Default(generate\\_unique\\_id) Source code in fastapi/applications.py on\\_event ¬∂ on\\_event(event\\_type) Add an event handler for the application. on\\_event is deprecated, use lifespan event handlers instead. Read more about it in the FastAPI docs for Lifespan Events. PARAMETER DESCRIPTION event\\_type The type of event. startup or shutdown. TYPE: str Source code in fastapi/applications.py middleware ¬∂ middleware(middleware\\_type) Add a middleware to the application. Read more about it in the FastAPI docs for Middleware. EXAMPLE¬∂ import time from fastapi import FastAPI, Request app = FastAPI() @app.middleware(\"http\") async def add\\_process\\_time\\_header(request: Request, call\\_next): start\\_time = time.time() response = await call\\_next(request) process\\_time = time.time() - start\\_time response.headers\\[\"X-Process-Time\"\\] = str(process\\_time) return response PARAMETER DESCRIPTION middleware\\_type The type of middleware. Currently only supports http. TYPE: str Source code in fastapi/applications.py exception\\_handler ¬∂ exception\\_handler(exc\\_class\\_or\\_status\\_code) Add an exception handler to the app. Read more about it in the FastAPI docs for Handling Errors. EXAMPLE¬∂ from fastapi import FastAPI, Request from fastapi.responses import JSONResponse class UnicornException(Exception): def \\_\\_init\\_\\_(self, name: str): self.name = name app = FastAPI() @app.exception\\_handler(UnicornException) async def unicorn\\_exception\\_handler(request: Request, exc: UnicornException): return JSONResponse( status\\_code=418, content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"}, ) PARAMETER DESCRIPTION exc\\_class\\_or\\_status\\_code The Exception class this would handle, or a status code. TYPE: Union\\[int, Type\\[Exception\\]\\] Source code in fastapi/applications.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Request Parameters - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/parameters/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Request Parameters en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient Table of contents ¬†Query ¬†Path ¬†Body ¬†Cookie ¬†Header ¬†Form ¬†File FastAPI Reference - Code API Request Parameters¬∂ Here's the reference information for the request parameters. These are the special functions that you can put in path operation function parameters or dependency functions with Annotated to get data from the request. It includes: Query() Path() Body() Cookie() Header() Form() File() You can import them all directly from fastapi: from fastapi import Body, Cookie, File, Form, Header, Path, Query fastapi.Query ¬∂ Query( default=Undefined, \\*, default\\_factory=\\_Unset, alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) PARAMETER DESCRIPTION default Default value if the parameter field is not set. TYPE: Any DEFAULT: Undefined default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py fastapi.Path ¬∂ Path( default=..., \\*, default\\_factory=\\_Unset, alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) Declare a path parameter for a path operation. Read more about it in the FastAPI docs for Path Parameters and Numeric Validations. from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\")\\], ): return {\"item\\_id\": item\\_id} PARAMETER DESCRIPTION default Default value if the parameter field is not set. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Any DEFAULT: ... default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py fastapi.Body ¬∂ Body( default=Undefined, \\*, default\\_factory=\\_Unset, embed=False, media\\_type=\"application/json\", alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) PARAMETER DESCRIPTION default Default value if the parameter field is not set. TYPE: Any DEFAULT: Undefined default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset embed When embed is True, the parameter will be expected in a JSON body as a key instead of being the JSON body itself. This happens automatically when more than one Body parameter is declared. Read more about it in the FastAPI docs for Body - Multiple Parameters. TYPE: bool DEFAULT: False media\\_type The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data. TYPE: str DEFAULT: 'application/json' alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py fastapi.Cookie ¬∂ Cookie( default=Undefined, \\*, default\\_factory=\\_Unset, alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) PARAMETER DESCRIPTION default Default value if the parameter field is not set. TYPE: Any DEFAULT: Undefined default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py fastapi.Header ¬∂ Header( default=Undefined, \\*, default\\_factory=\\_Unset, alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, convert\\_underscores=True, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) PARAMETER DESCRIPTION default Default value if the parameter field is not set. TYPE: Any DEFAULT: Undefined default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None convert\\_underscores Automatically convert underscores to hyphens in the parameter field name. Read more about it in the FastAPI docs for Header Parameters TYPE: bool DEFAULT: True title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py fastapi.Form ¬∂ Form( default=Undefined, \\*, default\\_factory=\\_Unset, media\\_type=\"application/x-www-form-urlencoded\", alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) PARAMETER DESCRIPTION default Default value if the parameter field is not set. TYPE: Any DEFAULT: Undefined default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset media\\_type The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data. TYPE: str DEFAULT: 'application/x-www-form-urlencoded' alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py fastapi.File ¬∂ File( default=Undefined, \\*, default\\_factory=\\_Unset, media\\_type=\"multipart/form-data\", alias=None, alias\\_priority=\\_Unset, validation\\_alias=None, serialization\\_alias=None, title=None, description=None, gt=None, ge=None, lt=None, le=None, min\\_length=None, max\\_length=None, pattern=None, regex=None, discriminator=None, strict=\\_Unset, multiple\\_of=\\_Unset, allow\\_inf\\_nan=\\_Unset, max\\_digits=\\_Unset, decimal\\_places=\\_Unset, examples=None, example=\\_Unset, openapi\\_examples=None, deprecated=None, include\\_in\\_schema=True, json\\_schema\\_extra=None, \\*\\*extra ) PARAMETER DESCRIPTION default Default value if the parameter field is not set. TYPE: Any DEFAULT: Undefined default\\_factory A callable to generate the default value. This doesn't affect Path parameters as the value is always required. The parameter is available only for compatibility. TYPE: Union\\[Callable\\[\\[\\], Any\\], None\\] DEFAULT: \\_Unset media\\_type The media type of this parameter field. Changing it would affect the generated OpenAPI, but currently it doesn't affect the parsing of the data. TYPE: str DEFAULT: 'multipart/form-data' alias An alternative name for the parameter field. This will be used to extract the data and for the generated OpenAPI. It is particularly useful when you can't use the name you want because it is a Python reserved keyword or similar. TYPE: Optional\\[str\\] DEFAULT: None alias\\_priority Priority of the alias. This affects whether an alias generator is used. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset validation\\_alias 'Whitelist' validation step. The parameter field will be the single one allowed by the alias or set of aliases defined. TYPE: Union\\[str, None\\] DEFAULT: None serialization\\_alias 'Blacklist' validation step. The vanilla parameter field will be the single one of the alias' or set of aliases' fields and all the other fields will be ignored at serialization time. TYPE: Union\\[str, None\\] DEFAULT: None title Human-readable title. TYPE: Optional\\[str\\] DEFAULT: None description Human-readable description. TYPE: Optional\\[str\\] DEFAULT: None gt Greater than. If set, value must be greater than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None ge Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None lt Less than. If set, value must be less than this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None le Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers. TYPE: Optional\\[float\\] DEFAULT: None min\\_length Minimum length for strings. TYPE: Optional\\[int\\] DEFAULT: None max\\_length Maximum length for strings. TYPE: Optional\\[int\\] DEFAULT: None pattern RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None regex Deprecated in FastAPI 0.100.0 and Pydantic v2, use pattern instead. RegEx pattern for strings. TYPE: Optional\\[str\\] DEFAULT: None discriminator Parameter field name for discriminating the type in a tagged union. TYPE: Union\\[str, None\\] DEFAULT: None strict If True, strict validation is applied to the field. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset multiple\\_of Value must be a multiple of this. Only applicable to numbers. TYPE: Union\\[float, None\\] DEFAULT: \\_Unset allow\\_inf\\_nan Allow inf, -inf, nan. Only applicable to numbers. TYPE: Union\\[bool, None\\] DEFAULT: \\_Unset max\\_digits Maximum number of allow digits for strings. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset decimal\\_places Maximum number of decimal places allowed for numbers. TYPE: Union\\[int, None\\] DEFAULT: \\_Unset examples Example values for this field. TYPE: Optional\\[List\\[Any\\]\\] DEFAULT: None example Deprecated in OpenAPI 3.1.0 that now uses JSON Schema 2020-12, although still supported. Use examples instead. TYPE: Optional\\[Any\\] DEFAULT: \\_Unset openapi\\_examples OpenAPI-specific examples. It will be added to the generated OpenAPI (e.g. visible at /docs). Swagger UI (that provides the /docs interface) has better support for the OpenAPI-specific examples than the JSON Schema examples, that's the main use case for this. Read more about it in the FastAPI docs for Declare Request Example Data. TYPE: Optional\\[Dict\\[str, Example\\]\\] DEFAULT: None deprecated Mark this parameter field as deprecated. It will affect the generated OpenAPI (e.g. visible at /docs). TYPE: Optional\\[bool\\] DEFAULT: None include\\_in\\_schema To include (or not) this parameter field in the generated OpenAPI. You probably don't need it, but it's available. This affects the generated OpenAPI (e.g. visible at /docs). TYPE: bool DEFAULT: True json\\_schema\\_extra Any additional JSON schema data. TYPE: Union\\[Dict\\[str, Any\\], None\\] DEFAULT: None \\*\\*extra The extra kwargs is deprecated. Use json\\_schema\\_extra instead. Include extra fields used by the JSON Schema. TYPE: Any DEFAULT: {} Source code in fastapi/param\\_functions.py Made with Material for MkDocs Insiders"
  },
  {
    "title": "Reference - Code API - FastAPI",
    "url": "https://fastapi.tiangolo.com/reference/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Reference - Code API en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Reference - Code API FastAPI class Request Parameters Status Codes UploadFile class Exceptions - HTTPException and WebSocketException Dependencies - Depends() and Security() APIRouter class Background Tasks - BackgroundTasks Request class WebSockets HTTPConnection class Response class Custom Response Classes - File, HTML, Redirect, Streaming, etc. Middleware OpenAPI Security Tools Encoders - jsonable\\_encoder Static Files - StaticFiles Templating - Jinja2Templates Test Client - TestClient FastAPI Reference - Code API Reference - Code API¬∂ Here's the reference or code API, the classes, functions, parameters, attributes, and all the FastAPI parts you can use in your applications. If you want to learn FastAPI you are much better off reading the FastAPI Tutorial. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Debugging - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/debugging/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Debugging en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Call uvicorn About \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\" More details Run your code with your debugger FastAPI Learn Tutorial - User Guide Debugging¬∂ You can connect the debugger in your editor, for example with Visual Studio Code or PyCharm. Call uvicorn¬∂ In your FastAPI application, import and run uvicorn directly: import uvicorn from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def root(): a = \"a\" b = \"b\" + a return {\"hello world\": b} if \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\": uvicorn.run(app, host=\"0.0.0.0\", port=8000) About \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\"¬∂ The main purpose of the \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\" is to have some code that is executed when your file is called with: but is not called when another file imports it, like in: from myapp import app More details¬∂ Let's say your file is named myapp.py. If you run it with: then the internal variable \\_\\_name\\_\\_ in your file, created automatically by Python, will have as value the string \"\\_\\_main\\_\\_\". So, the section: uvicorn.run(app, host=\"0.0.0.0\", port=8000) will run. This won't happen if you import that module (file). So, if you have another file importer.py with: from myapp import app # Some more code in that case, the automatically created variable inside of myapp.py will not have the variable \\_\\_name\\_\\_ with a value of \"\\_\\_main\\_\\_\". So, the line: uvicorn.run(app, host=\"0.0.0.0\", port=8000) will not be executed. Info For more information, check the official Python docs. Run your code with your debugger¬∂ Because you are running the Uvicorn server directly from your code, you can call your Python program (your FastAPI application) directly from the debugger. For example, in Visual Studio Code, you can: Go to the \"Debug\" panel. \"Add configuration...\". Select \"Python\" Run the debugger with the option \"Python: Current File (Integrated Terminal)\". It will then start the server with your FastAPI code, stop at your breakpoints, etc. Here's how it might look: If you use Pycharm, you can: Open the \"Run\" menu. Select the option \"Debug...\". Then a context menu shows up. Select the file to debug (in this case, main.py). It will then start the server with your FastAPI code, stop at your breakpoints, etc. Here's how it might look: Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/advanced/async-sql-databases.md",
    "html": "Follow @fastapi on Twitter to stay updated sponsor FastAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes 404 - Not found Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/testing/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Testing en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Using TestClient Separating tests FastAPI app file Testing file Testing: extended example Extended FastAPI app file Extended testing file Run it FastAPI Learn Tutorial - User Guide Testing¬∂ Thanks to Starlette, testing FastAPI applications is easy and enjoyable. It is based on HTTPX, which in turn is designed based on Requests, so it's very familiar and intuitive. With it, you can use pytest directly with FastAPI. Using TestClient¬∂ Info To use TestClient, first install httpx. E.g. pip install httpx. Import TestClient. Create a TestClient by passing your FastAPI application to it. Create functions with a name that starts with test\\_ (this is standard pytest conventions). Use the TestClient object the same way as you do with httpx. Write simple assert statements with the standard Python expressions that you need to check (again, standard pytest). from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI() @app.get(\"/\") async def read\\_main(): return {\"msg\": \"Hello World\"} client = TestClient(app) def test\\_read\\_main(): response = client.get(\"/\") assert response.status\\_code == 200 assert response.json() == {\"msg\": \"Hello World\"} Tip Notice that the testing functions are normal def, not async def. And the calls to the client are also normal calls, not using await. This allows you to use pytest directly without complications. Technical Details You could also use from starlette.testclient import TestClient. FastAPI provides the same starlette.testclient as fastapi.testclient just as a convenience for you, the developer. But it comes directly from Starlette. Tip If you want to call async functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the Async Tests in the advanced tutorial. Separating tests¬∂ In a real application, you probably would have your tests in a different file. And your FastAPI application might also be composed of several files/modules, etc. FastAPI app file¬∂ Let's say you have a file structure as described in Bigger Applications: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.py In the file main.py you have your FastAPI app: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def read\\_main(): return {\"msg\": \"Hello World\"} Testing file¬∂ Then you could have a file test\\_main.py with your tests. It could live on the same Python package (the same directory with a \\_\\_init\\_\\_.py file): . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test\\_main.py Because this file is in the same package, you can use relative imports to import the object app from the main module (main.py): from fastapi.testclient import TestClient from .main import app client = TestClient(app) def test\\_read\\_main(): response = client.get(\"/\") assert response.status\\_code == 200 assert response.json() == {\"msg\": \"Hello World\"} ...and have the code for the tests just like before. Testing: extended example¬∂ Now let's extend this example and add more details to see how to test different parts. Extended FastAPI app file¬∂ Let's continue with the same file structure as before: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test\\_main.py Let's say that now the file main.py with your FastAPI app has some other path operations. It has a GET operation that could return an error. It has a POST operation that could return several errors. Both path operations require an X-Token header. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Header, HTTPException from pydantic import BaseModel fake\\_secret\\_token = \"coneofsilence\" fake\\_db = { \"foo\": {\"id\": \"foo\", \"title\": \"Foo\", \"description\": \"There goes my hero\"}, \"bar\": {\"id\": \"bar\", \"title\": \"Bar\", \"description\": \"The bartenders\"}, } app = FastAPI() class Item(BaseModel): id: str title: str description: str | None = None @app.get(\"/items/{item\\_id}\", response\\_model=Item) async def read\\_main(item\\_id: str, x\\_token: Annotated\\[str, Header()\\]): if x\\_token != fake\\_secret\\_token: raise HTTPException(status\\_code=400, detail=\"Invalid X-Token header\") if item\\_id not in fake\\_db: raise HTTPException(status\\_code=404, detail=\"Item not found\") return fake\\_db\\[item\\_id\\] @app.post(\"/items/\", response\\_model=Item) async def create\\_item(item: Item, x\\_token: Annotated\\[str, Header()\\]): if x\\_token != fake\\_secret\\_token: raise HTTPException(status\\_code=400, detail=\"Invalid X-Token header\") if item.id in fake\\_db: raise HTTPException(status\\_code=400, detail=\"Item already exists\") fake\\_db\\[item.id\\] = item return item Extended testing file¬∂ You could then update test\\_main.py with the extended tests: from fastapi.testclient import TestClient from .main import app client = TestClient(app) def test\\_read\\_item(): response = client.get(\"/items/foo\", headers={\"X-Token\": \"coneofsilence\"}) assert response.status\\_code == 200 assert response.json() == { \"id\": \"foo\", \"title\": \"Foo\", \"description\": \"There goes my hero\", } def test\\_read\\_item\\_bad\\_token(): response = client.get(\"/items/foo\", headers={\"X-Token\": \"hailhydra\"}) assert response.status\\_code == 400 assert response.json() == {\"detail\": \"Invalid X-Token header\"} def test\\_read\\_inexistent\\_item(): response = client.get(\"/items/baz\", headers={\"X-Token\": \"coneofsilence\"}) assert response.status\\_code == 404 assert response.json() == {\"detail\": \"Item not found\"} def test\\_create\\_item(): response = client.post( \"/items/\", headers={\"X-Token\": \"coneofsilence\"}, json={\"id\": \"foobar\", \"title\": \"Foo Bar\", \"description\": \"The Foo Barters\"}, ) assert response.status\\_code == 200 assert response.json() == { \"id\": \"foobar\", \"title\": \"Foo Bar\", \"description\": \"The Foo Barters\", } def test\\_create\\_item\\_bad\\_token(): response = client.post( \"/items/\", headers={\"X-Token\": \"hailhydra\"}, json={\"id\": \"bazz\", \"title\": \"Bazz\", \"description\": \"Drop the bazz\"}, ) assert response.status\\_code == 400 assert response.json() == {\"detail\": \"Invalid X-Token header\"} def test\\_create\\_existing\\_item(): response = client.post( \"/items/\", headers={\"X-Token\": \"coneofsilence\"}, json={ \"id\": \"foo\", \"title\": \"The Foo ID Stealers\", \"description\": \"There goes my stealer\", }, ) assert response.status\\_code == 400 assert response.json() == {\"detail\": \"Item already exists\"} Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in httpx, or even how to do it with requests, as HTTPX's design is based on Requests' design. Then you just do the same in your tests. E.g.: To pass a path or query parameter, add it to the URL itself. To pass a JSON body, pass a Python object (e.g. a dict) to the parameter json. If you need to send Form Data instead of JSON, use the data parameter instead. To pass headers, use a dict in the headers parameter. For cookies, a dict in the cookies parameter. For more information about how to pass data to the backend (using httpx or the TestClient) check the HTTPX documentation. Info Note that the TestClient receives data that can be converted to JSON, not Pydantic models. If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the jsonable\\_encoder described in JSON Compatible Encoder. Run it¬∂ After that, you just need to install pytest: It will detect the files and tests automatically, execute them, and report the results back to you. Run the tests with: Made with Material for MkDocs Insiders"
  },
  {
    "title": "Static Files - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/static-files/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Static Files en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Use StaticFiles What is \"Mounting\" Details More info FastAPI Learn Tutorial - User Guide Static Files¬∂ You can serve static files automatically from a directory using StaticFiles. Use StaticFiles¬∂ Import StaticFiles. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from fastapi.staticfiles import StaticFiles app = FastAPI() app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") Technical Details You could also use from starlette.staticfiles import StaticFiles. FastAPI provides the same starlette.staticfiles as fastapi.staticfiles just as a convenience for you, the developer. But it actually comes directly from Starlette. What is \"Mounting\"¬∂ \"Mounting\" means adding a complete \"independent\" application in a specific path, that then takes care of handling all the sub-paths. This is different from using an APIRouter as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc. You can read more about this in the Advanced User Guide. Details¬∂ The first \"/static\" refers to the sub-path this \"sub-application\" will be \"mounted\" on. So, any path that starts with \"/static\" will be handled by it. The directory=\"static\" refers to the name of the directory that contains your static files. The name=\"static\" gives it a name that can be used internally by FastAPI. All these parameters can be different than \"static\", adjust them with the needs and specific details of your own application. More info¬∂ For more details and options check Starlette's docs about Static Files. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Metadata and Docs URLs - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/metadata/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Metadata and Docs URLs en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Metadata for API License identifier Metadata for tags Create metadata for tags Use your tags Check the docs Order of tags OpenAPI URL Docs URLs FastAPI Learn Tutorial - User Guide Metadata and Docs URLs¬∂ You can customize several metadata configurations in your FastAPI application. Metadata for API¬∂ You can set the following fields that are used in the OpenAPI specification and the automatic API docs UIs: Parameter Type Description title str The title of the API. summary str A short summary of the API. Available since OpenAPI 3.1.0, FastAPI 0.99.0. description str A short description of the API. It can use Markdown. version string The version of the API. This is the version of your own application, not of OpenAPI. For example 2.5.0. terms\\_of\\_service str A URL to the Terms of Service for the API. If provided, this has to be a URL. contact dict The contact information for the exposed API. It can contain several fields. contact fields license\\_info dict The license information for the exposed API. It can contain several fields. license\\_info fields You can set them as follows: from fastapi import FastAPI description = \"\"\" ChimichangApp API helps you do awesome stuff. üöÄ ## Items You can \\*\\*read items\\*\\*. ## Users You will be able to: \\* \\*\\*Create users\\*\\* (\\_not implemented\\_). \\* \\*\\*Read users\\*\\* (\\_not implemented\\_). \"\"\" app = FastAPI( title=\"ChimichangApp\", description=description, summary=\"Deadpool's favorite app. Nuff said.\", version=\"0.0.1\", terms\\_of\\_service=\"http://example.com/terms/\", contact={ \"name\": \"Deadpoolio the Amazing\", \"url\": \"http://x-force.example.com/contact/\", \"email\": \"dp@x-force.example.com\", }, license\\_info={ \"name\": \"Apache 2.0\", \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\", }, ) @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Katana\"}\\] Tip You can write Markdown in the description field and it will be rendered in the output. With this configuration, the automatic API docs would look like: License identifier¬∂ Since OpenAPI 3.1.0 and FastAPI 0.99.0, you can also set the license\\_info with an identifier instead of a url. For example: from fastapi import FastAPI description = \"\"\" ChimichangApp API helps you do awesome stuff. üöÄ ## Items You can \\*\\*read items\\*\\*. ## Users You will be able to: \\* \\*\\*Create users\\*\\* (\\_not implemented\\_). \\* \\*\\*Read users\\*\\* (\\_not implemented\\_). \"\"\" app = FastAPI( title=\"ChimichangApp\", description=description, summary=\"Deadpool's favorite app. Nuff said.\", version=\"0.0.1\", terms\\_of\\_service=\"http://example.com/terms/\", contact={ \"name\": \"Deadpoolio the Amazing\", \"url\": \"http://x-force.example.com/contact/\", \"email\": \"dp@x-force.example.com\", }, license\\_info={ \"name\": \"Apache 2.0\", \"identifier\": \"MIT\", }, ) @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Katana\"}\\] Metadata for tags¬∂ You can also add additional metadata for the different tags used to group your path operations with the parameter openapi\\_tags. It takes a list containing one dictionary for each tag. Each dictionary can contain: name (required): a str with the same tag name you use in the tags parameter in your path operations and APIRouters. description: a str with a short description for the tag. It can have Markdown and will be shown in the docs UI. externalDocs: a dict describing external documentation with: description: a str with a short description for the external docs. url (required): a str with the URL for the external documentation. Create metadata for tags¬∂ Let's try that in an example with tags for users and items. Create metadata for your tags and pass it to the openapi\\_tags parameter: from fastapi import FastAPI tags\\_metadata = \\[ { \"name\": \"users\", \"description\": \"Operations with users. The \\*\\*login\\*\\* logic is also here.\", }, { \"name\": \"items\", \"description\": \"Manage items. So \\_fancy\\_ they have their own docs.\", \"externalDocs\": { \"description\": \"Items external docs\", \"url\": \"https://fastapi.tiangolo.com/\", }, }, \\] app = FastAPI(openapi\\_tags=tags\\_metadata) @app.get(\"/users/\", tags=\\[\"users\"\\]) async def get\\_users(): return \\[{\"name\": \"Harry\"}, {\"name\": \"Ron\"}\\] @app.get(\"/items/\", tags=\\[\"items\"\\]) async def get\\_items(): return \\[{\"name\": \"wand\"}, {\"name\": \"flying broom\"}\\] Notice that you can use Markdown inside of the descriptions, for example \"login\" will be shown in bold (login) and \"fancy\" will be shown in italics (fancy). Tip You don't have to add metadata for all the tags that you use. Use your tags¬∂ Use the tags parameter with your path operations (and APIRouters) to assign them to different tags: from fastapi import FastAPI tags\\_metadata = \\[ { \"name\": \"users\", \"description\": \"Operations with users. The \\*\\*login\\*\\* logic is also here.\", }, { \"name\": \"items\", \"description\": \"Manage items. So \\_fancy\\_ they have their own docs.\", \"externalDocs\": { \"description\": \"Items external docs\", \"url\": \"https://fastapi.tiangolo.com/\", }, }, \\] app = FastAPI(openapi\\_tags=tags\\_metadata) @app.get(\"/users/\", tags=\\[\"users\"\\]) async def get\\_users(): return \\[{\"name\": \"Harry\"}, {\"name\": \"Ron\"}\\] @app.get(\"/items/\", tags=\\[\"items\"\\]) async def get\\_items(): return \\[{\"name\": \"wand\"}, {\"name\": \"flying broom\"}\\] Info Read more about tags in Path Operation Configuration. Check the docs¬∂ Now, if you check the docs, they will show all the additional metadata: Order of tags¬∂ The order of each tag metadata dictionary also defines the order shown in the docs UI. For example, even though users would go after items in alphabetical order, it is shown before them, because we added their metadata as the first dictionary in the list. OpenAPI URL¬∂ By default, the OpenAPI schema is served at /openapi.json. But you can configure it with the parameter openapi\\_url. For example, to set it to be served at /api/v1/openapi.json: from fastapi import FastAPI app = FastAPI(openapi\\_url=\"/api/v1/openapi.json\") @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] If you want to disable the OpenAPI schema completely you can set openapi\\_url=None, that will also disable the documentation user interfaces that use it. Docs URLs¬∂ You can configure the two documentation user interfaces included: Swagger UI: served at /docs. You can set its URL with the parameter docs\\_url. You can disable it by setting docs\\_url=None. ReDoc: served at /redoc. You can set its URL with the parameter redoc\\_url. You can disable it by setting redoc\\_url=None. For example, to set Swagger UI to be served at /documentation and disable ReDoc: from fastapi import FastAPI app = FastAPI(docs\\_url=\"/documentation\", redoc\\_url=None) @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] Made with Material for MkDocs Insiders"
  },
  {
    "title": "Background Tasks - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/background-tasks/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Background Tasks en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Using BackgroundTasks Create a task function Add the background task Dependency Injection Technical Details Caveat Recap FastAPI Learn Tutorial - User Guide Background Tasks¬∂ You can define background tasks to be run after returning a response. This is useful for operations that need to happen after a request, but that the client doesn't really have to be waiting for the operation to complete before receiving the response. This includes, for example: Email notifications sent after performing an action: As connecting to an email server and sending an email tends to be \"slow\" (several seconds), you can return the response right away and send the email notification in the background. Processing data: For example, let's say you receive a file that must go through a slow process, you can return a response of \"Accepted\" (HTTP 202) and process it in the background. Using BackgroundTasks¬∂ First, import BackgroundTasks and define a parameter in your path operation function with a type declaration of BackgroundTasks: from fastapi import BackgroundTasks, FastAPI app = FastAPI() def write\\_notification(email: str, message=\"\"): with open(\"log.txt\", mode=\"w\") as email\\_file: content = f\"notification for {email}: {message}\" email\\_file.write(content) @app.post(\"/send-notification/{email}\") async def send\\_notification(email: str, background\\_tasks: BackgroundTasks): background\\_tasks.add\\_task(write\\_notification, email, message=\"some notification\") return {\"message\": \"Notification sent in the background\"} FastAPI will create the object of type BackgroundTasks for you and pass it as that parameter. Create a task function¬∂ Create a function to be run as the background task. It is just a standard function that can receive parameters. It can be an async def or normal def function, FastAPI will know how to handle it correctly. In this case, the task function will write to a file (simulating sending an email). And as the write operation doesn't use async and await, we define the function with normal def: from fastapi import BackgroundTasks, FastAPI app = FastAPI() def write\\_notification(email: str, message=\"\"): with open(\"log.txt\", mode=\"w\") as email\\_file: content = f\"notification for {email}: {message}\" email\\_file.write(content) @app.post(\"/send-notification/{email}\") async def send\\_notification(email: str, background\\_tasks: BackgroundTasks): background\\_tasks.add\\_task(write\\_notification, email, message=\"some notification\") return {\"message\": \"Notification sent in the background\"} Add the background task¬∂ Inside of your path operation function, pass your task function to the background tasks object with the method .add\\_task(): from fastapi import BackgroundTasks, FastAPI app = FastAPI() def write\\_notification(email: str, message=\"\"): with open(\"log.txt\", mode=\"w\") as email\\_file: content = f\"notification for {email}: {message}\" email\\_file.write(content) @app.post(\"/send-notification/{email}\") async def send\\_notification(email: str, background\\_tasks: BackgroundTasks): background\\_tasks.add\\_task(write\\_notification, email, message=\"some notification\") return {\"message\": \"Notification sent in the background\"} .add\\_task() receives as arguments: A task function to be run in the background (write\\_notification). Any sequence of arguments that should be passed to the task function in order (email). Any keyword arguments that should be passed to the task function (message=\"some notification\"). Dependency Injection¬∂ Using BackgroundTasks also works with the dependency injection system, you can declare a parameter of type BackgroundTasks at multiple levels: in a path operation function, in a dependency (dependable), in a sub-dependency, etc. FastAPI knows what to do in each case and how to re-use the same object, so that all the background tasks are merged together and are run in the background afterwards: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import BackgroundTasks, Depends, FastAPI app = FastAPI() def write\\_log(message: str): with open(\"log.txt\", mode=\"a\") as log: log.write(message) def get\\_query(background\\_tasks: BackgroundTasks, q: str | None = None): if q: message = f\"found query: {q}\\\\n\" background\\_tasks.add\\_task(write\\_log, message) return q @app.post(\"/send-notification/{email}\") async def send\\_notification( email: str, background\\_tasks: BackgroundTasks, q: Annotated\\[str, Depends(get\\_query)\\] ): message = f\"message to {email}\\\\n\" background\\_tasks.add\\_task(write\\_log, message) return {\"message\": \"Message sent\"} In this example, the messages will be written to the log.txt file after the response is sent. If there was a query in the request, it will be written to the log in a background task. And then another background task generated at the path operation function will write a message using the email path parameter. Technical Details¬∂ The class BackgroundTasks comes directly from starlette.background. It is imported/included directly into FastAPI so that you can import it from fastapi and avoid accidentally importing the alternative BackgroundTask (without the s at the end) from starlette.background. By only using BackgroundTasks (and not BackgroundTask), it's then possible to use it as a path operation function parameter and have FastAPI handle the rest for you, just like when using the Request object directly. It's still possible to use BackgroundTask alone in FastAPI, but you have to create the object in your code and return a Starlette Response including it. You can see more details in Starlette's official docs for Background Tasks. Caveat¬∂ If you need to perform heavy background computation and you don't necessarily need it to be run by the same process (for example, you don't need to share memory, variables, etc), you might benefit from using other bigger tools like Celery. They tend to require more complex configurations, a message/job queue manager, like RabbitMQ or Redis, but they allow you to run background tasks in multiple processes, and especially, in multiple servers. To see an example, check the Project Generators, they all include Celery already configured. But if you need to access variables and objects from the same FastAPI app, or you need to perform small background tasks (like sending an email notification), you can simply just use BackgroundTasks. Recap¬∂ Import and use BackgroundTasks with parameters in path operation functions and dependencies to add background tasks. Made with Material for MkDocs Insiders"
  },
  {
    "title": "SQL (Relational) Databases - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/sql-databases/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI SQL (Relational) Databases en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents ORMs File structure Install SQLAlchemy Create the SQLAlchemy parts Import the SQLAlchemy parts Create a database URL for SQLAlchemy Create the SQLAlchemy engine Note Create a SessionLocal class Create a Base class Create the database models Create SQLAlchemy models from the Base class Create model attributes/columns Create the relationships Create the Pydantic models Create initial Pydantic models / schemas SQLAlchemy style and Pydantic style Create Pydantic models / schemas for reading / returning Use Pydantic's orm\\_mode Technical Details about ORM mode CRUD utils Read data Create data Main FastAPI app Create the database tables Alembic Note Create a dependency Create your FastAPI path operations About def vs async def Migrations Review all the files Check it Interact with the database directly Alternative DB session with middleware Create a middleware About request.state Dependencies with yield or middleware FastAPI Learn Tutorial - User Guide SQL (Relational) Databases¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1, and SQLAlchemy versions less than 2.0. The new docs will include Pydantic v2 and will use SQLModel (which is also based on SQLAlchemy) once it is updated to use Pydantic v2 as well. FastAPI doesn't require you to use a SQL (relational) database. But you can use any relational database that you want. Here we'll see an example using SQLAlchemy. You can easily adapt it to any database supported by SQLAlchemy, like: PostgreSQL MySQL SQLite Oracle Microsoft SQL Server, etc. In this example, we'll use SQLite, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is. Later, for your production application, you might want to use a database server like PostgreSQL. Tip There is an official project generator with FastAPI and PostgreSQL, all based on Docker, including a frontend and more tools: https://github.com/tiangolo/full-stack-fastapi-postgresql Note Notice that most of the code is the standard SQLAlchemy code you would use with any framework. The FastAPI specific code is as small as always. ORMs¬∂ FastAPI works with any database and any style of library to talk to the database. A common pattern is to use an \"ORM\": an \"object-relational mapping\" library. An ORM has tools to convert (\"map\") between objects in code and database tables (\"relations\"). With an ORM, you normally create a class that represents a table in a SQL database, each attribute of the class represents a column, with a name and a type. For example a class Pet could represent a SQL table pets. And each instance object of that class represents a row in the database. For example an object orion\\_cat (an instance of Pet) could have an attribute orion\\_cat.type, for the column type. And the value of that attribute could be, e.g. \"cat\". These ORMs also have tools to make the connections or relations between tables or entities. This way, you could also have an attribute orion\\_cat.owner and the owner would contain the data for this pet's owner, taken from the table owners. So, orion\\_cat.owner.name could be the name (from the name column in the owners table) of this pet's owner. It could have a value like \"Arquilian\". And the ORM will do all the work to get the information from the corresponding table owners when you try to access it from your pet object. Common ORMs are for example: Django-ORM (part of the Django framework), SQLAlchemy ORM (part of SQLAlchemy, independent of framework) and Peewee (independent of framework), among others. Here we will see how to work with SQLAlchemy ORM. In a similar way you could use any other ORM. Tip There's an equivalent article using Peewee here in the docs. File structure¬∂ For these examples, let's say you have a directory named my\\_super\\_project that contains a sub-directory called sql\\_app with a structure like this: . ‚îî‚îÄ‚îÄ sql\\_app ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îú‚îÄ‚îÄ crud.py ‚îú‚îÄ‚îÄ database.py ‚îú‚îÄ‚îÄ main.py ‚îú‚îÄ‚îÄ models.py ‚îî‚îÄ‚îÄ schemas.py The file \\_\\_init\\_\\_.py is just an empty file, but it tells Python that sql\\_app with all its modules (Python files) is a package. Now let's see what each file/module does. Install SQLAlchemy¬∂ First you need to install SQLAlchemy: Create the SQLAlchemy parts¬∂ Let's refer to the file sql\\_app/database.py. Import the SQLAlchemy parts¬∂ from sqlalchemy import create\\_engine from sqlalchemy.ext.declarative import declarative\\_base from sqlalchemy.orm import sessionmaker SQLALCHEMY\\_DATABASE\\_URL = \"sqlite:///./sql\\_app.db\" # SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative\\_base() Create a database URL for SQLAlchemy¬∂ from sqlalchemy import create\\_engine from sqlalchemy.ext.declarative import declarative\\_base from sqlalchemy.orm import sessionmaker SQLALCHEMY\\_DATABASE\\_URL = \"sqlite:///./sql\\_app.db\" # SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative\\_base() In this example, we are \"connecting\" to a SQLite database (opening a file with the SQLite database). The file will be located at the same directory in the file sql\\_app.db. That's why the last part is ./sql\\_app.db. If you were using a PostgreSQL database instead, you would just have to uncomment the line: SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" ...and adapt it with your database data and credentials (equivalently for MySQL, MariaDB or any other). Tip This is the main line that you would have to modify if you wanted to use a different database. Create the SQLAlchemy engine¬∂ The first step is to create a SQLAlchemy \"engine\". We will later use this engine in other places. from sqlalchemy import create\\_engine from sqlalchemy.ext.declarative import declarative\\_base from sqlalchemy.orm import sessionmaker SQLALCHEMY\\_DATABASE\\_URL = \"sqlite:///./sql\\_app.db\" # SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative\\_base() Note¬∂ The argument: connect\\_args={\"check\\_same\\_thread\": False} ...is needed only for SQLite. It's not needed for other databases. Technical Details By default SQLite will only allow one thread to communicate with it, assuming that each thread would handle an independent request. This is to prevent accidentally sharing the same connection for different things (for different requests). But in FastAPI, using normal functions (def) more than one thread could interact with the database for the same request, so we need to make SQLite know that it should allow that with connect\\_args={\"check\\_same\\_thread\": False}. Also, we will make sure each request gets its own database connection session in a dependency, so there's no need for that default mechanism. Create a SessionLocal class¬∂ Each instance of the SessionLocal class will be a database session. The class itself is not a database session yet. But once we create an instance of the SessionLocal class, this instance will be the actual database session. We name it SessionLocal to distinguish it from the Session we are importing from SQLAlchemy. We will use Session (the one imported from SQLAlchemy) later. To create the SessionLocal class, use the function sessionmaker: from sqlalchemy import create\\_engine from sqlalchemy.ext.declarative import declarative\\_base from sqlalchemy.orm import sessionmaker SQLALCHEMY\\_DATABASE\\_URL = \"sqlite:///./sql\\_app.db\" # SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative\\_base() Create a Base class¬∂ Now we will use the function declarative\\_base() that returns a class. Later we will inherit from this class to create each of the database models or classes (the ORM models): from sqlalchemy import create\\_engine from sqlalchemy.ext.declarative import declarative\\_base from sqlalchemy.orm import sessionmaker SQLALCHEMY\\_DATABASE\\_URL = \"sqlite:///./sql\\_app.db\" # SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative\\_base() Create the database models¬∂ Let's now see the file sql\\_app/models.py. Create SQLAlchemy models from the Base class¬∂ We will use this Base class we created before to create the SQLAlchemy models. Tip SQLAlchemy uses the term \"model\" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \"model\" to refer to something different, the data validation, conversion, and documentation classes and instances. Import Base from database (the file database.py from above). Create classes that inherit from it. These classes are the SQLAlchemy models. from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): \\_\\_tablename\\_\\_ = \"users\" id = Column(Integer, primary\\_key=True, index=True) email = Column(String, unique=True, index=True) hashed\\_password = Column(String) is\\_active = Column(Boolean, default=True) items = relationship(\"Item\", back\\_populates=\"owner\") class Item(Base): \\_\\_tablename\\_\\_ = \"items\" id = Column(Integer, primary\\_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner\\_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back\\_populates=\"items\") The \\_\\_tablename\\_\\_ attribute tells SQLAlchemy the name of the table to use in the database for each of these models. Create model attributes/columns¬∂ Now create all the model (class) attributes. Each of these attributes represents a column in its corresponding database table. We use Column from SQLAlchemy as the default value. And we pass a SQLAlchemy class \"type\", as Integer, String, and Boolean, that defines the type in the database, as an argument. from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): \\_\\_tablename\\_\\_ = \"users\" id = Column(Integer, primary\\_key=True, index=True) email = Column(String, unique=True, index=True) hashed\\_password = Column(String) is\\_active = Column(Boolean, default=True) items = relationship(\"Item\", back\\_populates=\"owner\") class Item(Base): \\_\\_tablename\\_\\_ = \"items\" id = Column(Integer, primary\\_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner\\_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back\\_populates=\"items\") Create the relationships¬∂ Now create the relationships. For this, we use relationship provided by SQLAlchemy ORM. This will become, more or less, a \"magic\" attribute that will contain the values from other tables related to this one. from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): \\_\\_tablename\\_\\_ = \"users\" id = Column(Integer, primary\\_key=True, index=True) email = Column(String, unique=True, index=True) hashed\\_password = Column(String) is\\_active = Column(Boolean, default=True) items = relationship(\"Item\", back\\_populates=\"owner\") class Item(Base): \\_\\_tablename\\_\\_ = \"items\" id = Column(Integer, primary\\_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner\\_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back\\_populates=\"items\") When accessing the attribute items in a User, as in my\\_user.items, it will have a list of Item SQLAlchemy models (from the items table) that have a foreign key pointing to this record in the users table. When you access my\\_user.items, SQLAlchemy will actually go and fetch the items from the database in the items table and populate them here. And when accessing the attribute owner in an Item, it will contain a User SQLAlchemy model from the users table. It will use the owner\\_id attribute/column with its foreign key to know which record to get from the users table. Create the Pydantic models¬∂ Now let's check the file sql\\_app/schemas.py. Tip To avoid confusion between the SQLAlchemy models and the Pydantic models, we will have the file models.py with the SQLAlchemy models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both. Create initial Pydantic models / schemas¬∂ Create an ItemBase and UserBase Pydantic models (or let's say \"schemas\") to have common attributes while creating or reading data. And create an ItemCreate and UserCreate that inherit from them (so they will have the same attributes), plus any additional data (attributes) needed for creation. So, the user will also have a password when creating it. But for security, the password won't be in other Pydantic models, for example, it won't be sent from the API when reading a user. Python 3.10+ Python 3.9+ Python 3.8+ from pydantic import BaseModel class ItemBase(BaseModel): title: str description: str | None = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: list\\[Item\\] = \\[\\] class Config: orm\\_mode = True SQLAlchemy style and Pydantic style¬∂ Notice that SQLAlchemy models define attributes using =, and pass the type as a parameter to Column, like in: name = Column(String) while Pydantic models declare the types using :, the new type annotation syntax/type hints: name: str Have it in mind, so you don't get confused when using = and : with them. Create Pydantic models / schemas for reading / returning¬∂ Now create Pydantic models (schemas) that will be used when reading data, when returning it from the API. For example, before creating an item, we don't know what will be the ID assigned to it, but when reading it (when returning it from the API) we will already know its ID. The same way, when reading a user, we can now declare that items will contain the items that belong to this user. Not only the IDs of those items, but all the data that we defined in the Pydantic model for reading items: Item. Python 3.10+ Python 3.9+ Python 3.8+ from pydantic import BaseModel class ItemBase(BaseModel): title: str description: str | None = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: list\\[Item\\] = \\[\\] class Config: orm\\_mode = True Tip Notice that the User, the Pydantic model that will be used when reading a user (returning it from the API) doesn't include the password. Use Pydantic's orm\\_mode¬∂ Now, in the Pydantic models for reading, Item and User, add an internal Config class. This Config class is used to provide configurations to Pydantic. In the Config class, set the attribute orm\\_mode = True. Python 3.10+ Python 3.9+ Python 3.8+ from pydantic import BaseModel class ItemBase(BaseModel): title: str description: str | None = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: list\\[Item\\] = \\[\\] class Config: orm\\_mode = True Tip Notice it's assigning a value with =, like: orm\\_mode = True It doesn't use : as for the type declarations before. This is setting a config value, not declaring a type. Pydantic's orm\\_mode will tell the Pydantic model to read the data even if it is not a dict, but an ORM model (or any other arbitrary object with attributes). This way, instead of only trying to get the id value from a dict, as in: id = data\\[\"id\"\\] it will also try to get it from an attribute, as in: id = data.id And with this, the Pydantic model is compatible with ORMs, and you can just declare it in the response\\_model argument in your path operations. You will be able to return a database model and it will read the data from it. Technical Details about ORM mode¬∂ SQLAlchemy and many others are by default \"lazy loading\". That means, for example, that they don't fetch the data for relationships from the database unless you try to access the attribute that would contain that data. For example, accessing the attribute items: current\\_user.items would make SQLAlchemy go to the items table and get the items for this user, but not before. Without orm\\_mode, if you returned a SQLAlchemy model from your path operation, it wouldn't include the relationship data. Even if you declared those relationships in your Pydantic models. But with ORM mode, as Pydantic itself will try to access the data it needs from attributes (instead of assuming a dict), you can declare the specific data you want to return and it will be able to go and get it, even from ORMs. CRUD utils¬∂ Now let's see the file sql\\_app/crud.py. In this file we will have reusable functions to interact with the data in the database. CRUD comes from: Create, Read, Update, and Delete. ...although in this example we are only creating and reading. Read data¬∂ Import Session from sqlalchemy.orm, this will allow you to declare the type of the db parameters and have better type checks and completion in your functions. Import models (the SQLAlchemy models) and schemas (the Pydantic models / schemas). Create utility functions to: Read a single user by ID and by email. Read multiple users. Read multiple items. from sqlalchemy.orm import Session from . import models, schemas def get\\_user(db: Session, user\\_id: int): return db.query(models.User).filter(models.User.id == user\\_id).first() def get\\_user\\_by\\_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first() def get\\_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() def create\\_user(db: Session, user: schemas.UserCreate): fake\\_hashed\\_password = user.password + \"notreallyhashed\" db\\_user = models.User(email=user.email, hashed\\_password=fake\\_hashed\\_password) db.add(db\\_user) db.commit() db.refresh(db\\_user) return db\\_user def get\\_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all() def create\\_user\\_item(db: Session, item: schemas.ItemCreate, user\\_id: int): db\\_item = models.Item(\\*\\*item.dict(), owner\\_id=user\\_id) db.add(db\\_item) db.commit() db.refresh(db\\_item) return db\\_item Tip By creating functions that are only dedicated to interacting with the database (get a user or an item) independent of your path operation function, you can more easily reuse them in multiple parts and also add unit tests for them. Create data¬∂ Now create utility functions to create data. The steps are: Create a SQLAlchemy model instance with your data. add that instance object to your database session. commit the changes to the database (so that they are saved). refresh your instance (so that it contains any new data from the database, like the generated ID). from sqlalchemy.orm import Session from . import models, schemas def get\\_user(db: Session, user\\_id: int): return db.query(models.User).filter(models.User.id == user\\_id).first() def get\\_user\\_by\\_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first() def get\\_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() def create\\_user(db: Session, user: schemas.UserCreate): fake\\_hashed\\_password = user.password + \"notreallyhashed\" db\\_user = models.User(email=user.email, hashed\\_password=fake\\_hashed\\_password) db.add(db\\_user) db.commit() db.refresh(db\\_user) return db\\_user def get\\_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all() def create\\_user\\_item(db: Session, item: schemas.ItemCreate, user\\_id: int): db\\_item = models.Item(\\*\\*item.dict(), owner\\_id=user\\_id) db.add(db\\_item) db.commit() db.refresh(db\\_item) return db\\_item Tip The SQLAlchemy model for User contains a hashed\\_password that should contain a secure hashed version of the password. But as what the API client provides is the original password, you need to extract it and generate the hashed password in your application. And then pass the hashed\\_password argument with the value to save. Warning This example is not secure, the password is not hashed. In a real life application you would need to hash the password and never save them in plaintext. For more details, go back to the Security section in the tutorial. Here we are focusing only on the tools and mechanics of databases. Tip Instead of passing each of the keyword arguments to Item and reading each one of them from the Pydantic model, we are generating a dict with the Pydantic model's data with: item.dict() and then we are passing the dict's key-value pairs as the keyword arguments to the SQLAlchemy Item, with: Item(\\*\\*item.dict()) And then we pass the extra keyword argument owner\\_id that is not provided by the Pydantic model, with: Item(\\*\\*item.dict(), owner\\_id=user\\_id) Main FastAPI app¬∂ And now in the file sql\\_app/main.py let's integrate and use all the other parts we created before. Create the database tables¬∂ In a very simplistic way create the database tables: Python 3.9+ Python 3.8+ from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create\\_all(bind=engine) app = FastAPI() # Dependency def get\\_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(\"/users/\", response\\_model=schemas.User) def create\\_user(user: schemas.UserCreate, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user\\_by\\_email(db, email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(db=db, user=user) @app.get(\"/users/\", response\\_model=list\\[schemas.User\\]) def read\\_users(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): users = crud.get\\_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post(\"/users/{user\\_id}/items/\", response\\_model=schemas.Item) def create\\_item\\_for\\_user( user\\_id: int, item: schemas.ItemCreate, db: Session = Depends(get\\_db) ): return crud.create\\_user\\_item(db=db, item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=list\\[schemas.Item\\]) def read\\_items(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): items = crud.get\\_items(db, skip=skip, limit=limit) return items Alembic Note¬∂ Normally you would probably initialize your database (create tables, etc) with Alembic. And you would also use Alembic for \"migrations\" (that's its main job). A \"migration\" is the set of steps needed whenever you change the structure of your SQLAlchemy models, add a new attribute, etc. to replicate those changes in the database, add a new column, a new table, etc. You can find an example of Alembic in a FastAPI project in the templates from Project Generation - Template. Specifically in the alembic directory in the source code. Create a dependency¬∂ Now use the SessionLocal class we created in the sql\\_app/database.py file to create a dependency. We need to have an independent database session/connection (SessionLocal) per request, use the same session through all the request and then close it after the request is finished. And then a new session will be created for the next request. For that, we will create a new dependency with yield, as explained before in the section about Dependencies with yield. Our dependency will create a new SQLAlchemy SessionLocal that will be used in a single request, and then close it once the request is finished. Python 3.9+ Python 3.8+ from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create\\_all(bind=engine) app = FastAPI() # Dependency def get\\_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(\"/users/\", response\\_model=schemas.User) def create\\_user(user: schemas.UserCreate, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user\\_by\\_email(db, email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(db=db, user=user) @app.get(\"/users/\", response\\_model=list\\[schemas.User\\]) def read\\_users(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): users = crud.get\\_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post(\"/users/{user\\_id}/items/\", response\\_model=schemas.Item) def create\\_item\\_for\\_user( user\\_id: int, item: schemas.ItemCreate, db: Session = Depends(get\\_db) ): return crud.create\\_user\\_item(db=db, item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=list\\[schemas.Item\\]) def read\\_items(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): items = crud.get\\_items(db, skip=skip, limit=limit) return items Info We put the creation of the SessionLocal() and handling of the requests in a try block. And then we close it in the finally block. This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request. But you can't raise another exception from the exit code (after yield). See more in Dependencies with yield and HTTPException And then, when using the dependency in a path operation function, we declare it with the type Session we imported directly from SQLAlchemy. This will then give us better editor support inside the path operation function, because the editor will know that the db parameter is of type Session: Python 3.9+ Python 3.8+ from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create\\_all(bind=engine) app = FastAPI() # Dependency def get\\_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(\"/users/\", response\\_model=schemas.User) def create\\_user(user: schemas.UserCreate, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user\\_by\\_email(db, email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(db=db, user=user) @app.get(\"/users/\", response\\_model=list\\[schemas.User\\]) def read\\_users(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): users = crud.get\\_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post(\"/users/{user\\_id}/items/\", response\\_model=schemas.Item) def create\\_item\\_for\\_user( user\\_id: int, item: schemas.ItemCreate, db: Session = Depends(get\\_db) ): return crud.create\\_user\\_item(db=db, item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=list\\[schemas.Item\\]) def read\\_items(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): items = crud.get\\_items(db, skip=skip, limit=limit) return items Technical Details The parameter db is actually of type SessionLocal, but this class (created with sessionmaker()) is a \"proxy\" of a SQLAlchemy Session, so, the editor doesn't really know what methods are provided. But by declaring the type as Session, the editor now can know the available methods (.add(), .query(), .commit(), etc) and can provide better support (like completion). The type declaration doesn't affect the actual object. Create your FastAPI path operations¬∂ Now, finally, here's the standard FastAPI path operations code. Python 3.9+ Python 3.8+ from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create\\_all(bind=engine) app = FastAPI() # Dependency def get\\_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(\"/users/\", response\\_model=schemas.User) def create\\_user(user: schemas.UserCreate, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user\\_by\\_email(db, email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(db=db, user=user) @app.get(\"/users/\", response\\_model=list\\[schemas.User\\]) def read\\_users(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): users = crud.get\\_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post(\"/users/{user\\_id}/items/\", response\\_model=schemas.Item) def create\\_item\\_for\\_user( user\\_id: int, item: schemas.ItemCreate, db: Session = Depends(get\\_db) ): return crud.create\\_user\\_item(db=db, item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=list\\[schemas.Item\\]) def read\\_items(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): items = crud.get\\_items(db, skip=skip, limit=limit) return items We are creating the database session before each request in the dependency with yield, and then closing it afterwards. And then we can create the required dependency in the path operation function, to get that session directly. With that, we can just call crud.get\\_user directly from inside of the path operation function and use that session. Tip Notice that the values you return are SQLAlchemy models, or lists of SQLAlchemy models. But as all the path operations have a response\\_model with Pydantic models / schemas using orm\\_mode, the data declared in your Pydantic models will be extracted from them and returned to the client, with all the normal filtering and validation. Tip Also notice that there are response\\_models that have standard Python types like List\\[schemas.Item\\]. But as the content/parameter of that List is a Pydantic model with orm\\_mode, the data will be retrieved and returned to the client as normally, without problems. About def vs async def¬∂ Here we are using SQLAlchemy code inside of the path operation function and in the dependency, and, in turn, it will go and communicate with an external database. That could potentially require some \"waiting\". But as SQLAlchemy doesn't have compatibility for using await directly, as would be with something like: user = await db.query(User).first() ...and instead we are using: user = db.query(User).first() Then we should declare the path operation functions and the dependency without async def, just with a normal def, as: @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) ... Info If you need to connect to your relational database asynchronously, see Async SQL (Relational) Databases. Very Technical Details If you are curious and have a deep technical knowledge, you can check the very technical details of how this async def vs def is handled in the Async docs. Migrations¬∂ Because we are using SQLAlchemy directly and we don't require any kind of plug-in for it to work with FastAPI, we could integrate database migrations with Alembic directly. And as the code related to SQLAlchemy and the SQLAlchemy models lives in separate independent files, you would even be able to perform the migrations with Alembic without having to install FastAPI, Pydantic, or anything else. The same way, you would be able to use the same SQLAlchemy models and utilities in other parts of your code that are not related to FastAPI. For example, in a background task worker with Celery, RQ, or ARQ. Review all the files¬∂ Remember you should have a directory named my\\_super\\_project that contains a sub-directory called sql\\_app. sql\\_app should have the following files: sql\\_app/\\_\\_init\\_\\_.py: is an empty file. sql\\_app/database.py: from sqlalchemy import create\\_engine from sqlalchemy.ext.declarative import declarative\\_base from sqlalchemy.orm import sessionmaker SQLALCHEMY\\_DATABASE\\_URL = \"sqlite:///./sql\\_app.db\" # SQLALCHEMY\\_DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base = declarative\\_base() sql\\_app/models.py: from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): \\_\\_tablename\\_\\_ = \"users\" id = Column(Integer, primary\\_key=True, index=True) email = Column(String, unique=True, index=True) hashed\\_password = Column(String) is\\_active = Column(Boolean, default=True) items = relationship(\"Item\", back\\_populates=\"owner\") class Item(Base): \\_\\_tablename\\_\\_ = \"items\" id = Column(Integer, primary\\_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner\\_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back\\_populates=\"items\") sql\\_app/schemas.py: Python 3.10+ Python 3.9+ Python 3.8+ from pydantic import BaseModel class ItemBase(BaseModel): title: str description: str | None = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: list\\[Item\\] = \\[\\] class Config: orm\\_mode = True sql\\_app/crud.py: from sqlalchemy.orm import Session from . import models, schemas def get\\_user(db: Session, user\\_id: int): return db.query(models.User).filter(models.User.id == user\\_id).first() def get\\_user\\_by\\_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first() def get\\_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() def create\\_user(db: Session, user: schemas.UserCreate): fake\\_hashed\\_password = user.password + \"notreallyhashed\" db\\_user = models.User(email=user.email, hashed\\_password=fake\\_hashed\\_password) db.add(db\\_user) db.commit() db.refresh(db\\_user) return db\\_user def get\\_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all() def create\\_user\\_item(db: Session, item: schemas.ItemCreate, user\\_id: int): db\\_item = models.Item(\\*\\*item.dict(), owner\\_id=user\\_id) db.add(db\\_item) db.commit() db.refresh(db\\_item) return db\\_item sql\\_app/main.py: Python 3.9+ Python 3.8+ from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create\\_all(bind=engine) app = FastAPI() # Dependency def get\\_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(\"/users/\", response\\_model=schemas.User) def create\\_user(user: schemas.UserCreate, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user\\_by\\_email(db, email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(db=db, user=user) @app.get(\"/users/\", response\\_model=list\\[schemas.User\\]) def read\\_users(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): users = crud.get\\_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post(\"/users/{user\\_id}/items/\", response\\_model=schemas.Item) def create\\_item\\_for\\_user( user\\_id: int, item: schemas.ItemCreate, db: Session = Depends(get\\_db) ): return crud.create\\_user\\_item(db=db, item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=list\\[schemas.Item\\]) def read\\_items(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): items = crud.get\\_items(db, skip=skip, limit=limit) return items Check it¬∂ You can copy this code and use it as is. Info In fact, the code shown here is part of the tests. As most of the code in these docs. Then you can run it with Uvicorn: And then, you can open your browser at http://127.0.0.1:8000/docs. And you will be able to interact with your FastAPI application, reading data from a real database: Interact with the database directly¬∂ If you want to explore the SQLite database (file) directly, independently of FastAPI, to debug its contents, add tables, columns, records, modify data, etc. you can use DB Browser for SQLite. It will look like this: You can also use an online SQLite browser like SQLite Viewer or ExtendsClass. Alternative DB session with middleware¬∂ If you can't use dependencies with yield -- for example, if you are not using Python 3.7 and can't install the \"backports\" mentioned above for Python 3.6 -- you can set up the session in a \"middleware\" in a similar way. A \"middleware\" is basically a function that is always executed for each request, with some code executed before, and some code executed after the endpoint function. Create a middleware¬∂ The middleware we'll add (just a function) will create a new SQLAlchemy SessionLocal for each request, add it to the request and then close it once the request is finished. Python 3.9+ Python 3.8+ from fastapi import Depends, FastAPI, HTTPException, Request, Response from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create\\_all(bind=engine) app = FastAPI() @app.middleware(\"http\") async def db\\_session\\_middleware(request: Request, call\\_next): response = Response(\"Internal server error\", status\\_code=500) try: request.state.db = SessionLocal() response = await call\\_next(request) finally: request.state.db.close() return response # Dependency def get\\_db(request: Request): return request.state.db @app.post(\"/users/\", response\\_model=schemas.User) def create\\_user(user: schemas.UserCreate, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user\\_by\\_email(db, email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(db=db, user=user) @app.get(\"/users/\", response\\_model=list\\[schemas.User\\]) def read\\_users(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): users = crud.get\\_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user\\_id}\", response\\_model=schemas.User) def read\\_user(user\\_id: int, db: Session = Depends(get\\_db)): db\\_user = crud.get\\_user(db, user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post(\"/users/{user\\_id}/items/\", response\\_model=schemas.Item) def create\\_item\\_for\\_user( user\\_id: int, item: schemas.ItemCreate, db: Session = Depends(get\\_db) ): return crud.create\\_user\\_item(db=db, item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=list\\[schemas.Item\\]) def read\\_items(skip: int = 0, limit: int = 100, db: Session = Depends(get\\_db)): items = crud.get\\_items(db, skip=skip, limit=limit) return items Info We put the creation of the SessionLocal() and handling of the requests in a try block. And then we close it in the finally block. This way we make sure the database session is always closed after the request. Even if there was an exception while processing the request. About request.state¬∂ request.state is a property of each Request object. It is there to store arbitrary objects attached to the request itself, like the database session in this case. You can read more about it in Starlette's docs about Request state. For us in this case, it helps us ensure a single database session is used through all the request, and then closed afterwards (in the middleware). Dependencies with yield or middleware¬∂ Adding a middleware here is similar to what a dependency with yield does, with some differences: It requires more code and is a bit more complex. The middleware has to be an async function. If there is code in it that has to \"wait\" for the network, it could \"block\" your application there and degrade performance a bit. Although it's probably not very problematic here with the way SQLAlchemy works. But if you added more code to the middleware that had a lot of I/O waiting, it could then be problematic. A middleware is run for every request. So, a connection will be created for every request. Even when the path operation that handles that request didn't need the DB. Tip It's probably better to use dependencies with yield when they are enough for the use case. Info Dependencies with yield were added recently to FastAPI. A previous version of this tutorial only had the examples with a middleware and there are probably several applications using the middleware for database session management. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Bigger Applications - Multiple Files - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/bigger-applications/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Bigger Applications - Multiple Files en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents An example file structure APIRouter Import APIRouter Path operations with APIRouter Dependencies Another module with APIRouter Import the dependencies How relative imports work Add some custom tags, responses, and dependencies The main FastAPI Import FastAPI Import the APIRouter How the importing works Avoid name collisions Include the APIRouters for users and items Include an APIRouter with a custom prefix, tags, responses, and dependencies Include a path operation Check the automatic API docs Include the same router multiple times with different prefix Include an APIRouter in another FastAPI Learn Tutorial - User Guide Bigger Applications - Multiple Files¬∂ If you are building an application or a web API, it's rarely the case that you can put everything on a single file. FastAPI provides a convenience tool to structure your application while keeping all the flexibility. Info If you come from Flask, this would be the equivalent of Flask's Blueprints. An example file structure¬∂ Let's say you have a file structure like this: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers ‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ items.py ‚îÇ¬†¬† ‚îÇ ‚îî‚îÄ‚îÄ users.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ admin.py Tip There are several \\_\\_init\\_\\_.py files: one in each directory or subdirectory. This is what allows importing code from one file into another. For example, in app/main.py you could have a line like: from app.routers import items The app directory contains everything. And it has an empty file app/\\_\\_init\\_\\_.py, so it is a \"Python package\" (a collection of \"Python modules\"): app. It contains an app/main.py file. As it is inside a Python package (a directory with a file \\_\\_init\\_\\_.py), it is a \"module\" of that package: app.main. There's also an app/dependencies.py file, just like app/main.py, it is a \"module\": app.dependencies. There's a subdirectory app/routers/ with another file \\_\\_init\\_\\_.py, so it's a \"Python subpackage\": app.routers. The file app/routers/items.py is inside a package, app/routers/, so, it's a submodule: app.routers.items. The same with app/routers/users.py, it's another submodule: app.routers.users. There's also a subdirectory app/internal/ with another file \\_\\_init\\_\\_.py, so it's another \"Python subpackage\": app.internal. And the file app/internal/admin.py is another submodule: app.internal.admin. The same file structure with comments: . ‚îú‚îÄ‚îÄ app # \"app\" is a Python package ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py # this file makes \"app\" a \"Python package\" ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py # \"main\" module, e.g. import app.main ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py # \"dependencies\" module, e.g. import app.dependencies ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers # \"routers\" is a \"Python subpackage\" ‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py # makes \"routers\" a \"Python subpackage\" ‚îÇ¬†¬† ‚îÇ ‚îú‚îÄ‚îÄ items.py # \"items\" submodule, e.g. import app.routers.items ‚îÇ¬†¬† ‚îÇ ‚îî‚îÄ‚îÄ users.py # \"users\" submodule, e.g. import app.routers.users ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal # \"internal\" is a \"Python subpackage\" ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py # makes \"internal\" a \"Python subpackage\" ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ admin.py # \"admin\" submodule, e.g. import app.internal.admin APIRouter¬∂ Let's say the file dedicated to handling just users is the submodule at /app/routers/users.py. You want to have the path operations related to your users separated from the rest of the code, to keep it organized. But it's still part of the same FastAPI application/web API (it's part of the same \"Python Package\"). You can create the path operations for that module using APIRouter. Import APIRouter¬∂ You import it and create an \"instance\" the same way you would with the class FastAPI: from fastapi import APIRouter router = APIRouter() @router.get(\"/users/\", tags=\\[\"users\"\\]) async def read\\_users(): return \\[{\"username\": \"Rick\"}, {\"username\": \"Morty\"}\\] @router.get(\"/users/me\", tags=\\[\"users\"\\]) async def read\\_user\\_me(): return {\"username\": \"fakecurrentuser\"} @router.get(\"/users/{username}\", tags=\\[\"users\"\\]) async def read\\_user(username: str): return {\"username\": username} Path operations with APIRouter¬∂ And then you use it to declare your path operations. Use it the same way you would use the FastAPI class: from fastapi import APIRouter router = APIRouter() @router.get(\"/users/\", tags=\\[\"users\"\\]) async def read\\_users(): return \\[{\"username\": \"Rick\"}, {\"username\": \"Morty\"}\\] @router.get(\"/users/me\", tags=\\[\"users\"\\]) async def read\\_user\\_me(): return {\"username\": \"fakecurrentuser\"} @router.get(\"/users/{username}\", tags=\\[\"users\"\\]) async def read\\_user(username: str): return {\"username\": username} You can think of APIRouter as a \"mini FastAPI\" class. All the same options are supported. All the same parameters, responses, dependencies, tags, etc. Tip In this example, the variable is called router, but you can name it however you want. We are going to include this APIRouter in the main FastAPI app, but first, let's check the dependencies and another APIRouter. Dependencies¬∂ We see that we are going to need some dependencies used in several places of the application. So we put them in their own dependencies module (app/dependencies.py). We will now use a simple dependency to read a custom X-Token header: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Header, HTTPException async def get\\_token\\_header(x\\_token: Annotated\\[str, Header()\\]): if x\\_token != \"fake-super-secret-token\": raise HTTPException(status\\_code=400, detail=\"X-Token header invalid\") async def get\\_query\\_token(token: str): if token != \"jessica\": raise HTTPException(status\\_code=400, detail=\"No Jessica token provided\") Tip We are using an invented header to simplify this example. But in real cases you will get better results using the integrated Security utilities. Another module with APIRouter¬∂ Let's say you also have the endpoints dedicated to handling \"items\" from your application in the module at app/routers/items.py. You have path operations for: /items/ /items/{item\\_id} It's all the same structure as with app/routers/users.py. But we want to be smarter and simplify the code a bit. We know all the path operations in this module have the same: Path prefix: /items. tags: (just one tag: items). Extra responses. dependencies: they all need that X-Token dependency we created. So, instead of adding all that to each path operation, we can add it to the APIRouter. from fastapi import APIRouter, Depends, HTTPException from ..dependencies import get\\_token\\_header router = APIRouter( prefix=\"/items\", tags=\\[\"items\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={404: {\"description\": \"Not found\"}}, ) fake\\_items\\_db = {\"plumbus\": {\"name\": \"Plumbus\"}, \"gun\": {\"name\": \"Portal Gun\"}} @router.get(\"/\") async def read\\_items(): return fake\\_items\\_db @router.get(\"/{item\\_id}\") async def read\\_item(item\\_id: str): if item\\_id not in fake\\_items\\_db: raise HTTPException(status\\_code=404, detail=\"Item not found\") return {\"name\": fake\\_items\\_db\\[item\\_id\\]\\[\"name\"\\], \"item\\_id\": item\\_id} @router.put( \"/{item\\_id}\", tags=\\[\"custom\"\\], responses={403: {\"description\": \"Operation forbidden\"}}, ) async def update\\_item(item\\_id: str): if item\\_id != \"plumbus\": raise HTTPException( status\\_code=403, detail=\"You can only update the item: plumbus\" ) return {\"item\\_id\": item\\_id, \"name\": \"The great Plumbus\"} As the path of each path operation has to start with /, like in: @router.get(\"/{item\\_id}\") async def read\\_item(item\\_id: str): ... ...the prefix must not include a final /. So, the prefix in this case is /items. We can also add a list of tags and extra responses that will be applied to all the path operations included in this router. And we can add a list of dependencies that will be added to all the path operations in the router and will be executed/solved for each request made to them. Tip Note that, much like dependencies in path operation decorators, no value will be passed to your path operation function. The end result is that the item paths are now: /items/ /items/{item\\_id} ...as we intended. They will be marked with a list of tags that contain a single string \"items\". These \"tags\" are especially useful for the automatic interactive documentation systems (using OpenAPI). All of them will include the predefined responses. All these path operations will have the list of dependencies evaluated/executed before them. If you also declare dependencies in a specific path operation, they will be executed too. The router dependencies are executed first, then the dependencies in the decorator, and then the normal parameter dependencies. You can also add Security dependencies with scopes. Tip Having dependencies in the APIRouter can be used, for example, to require authentication for a whole group of path operations. Even if the dependencies are not added individually to each one of them. Check The prefix, tags, responses, and dependencies parameters are (as in many other cases) just a feature from FastAPI to help you avoid code duplication. Import the dependencies¬∂ This code lives in the module app.routers.items, the file app/routers/items.py. And we need to get the dependency function from the module app.dependencies, the file app/dependencies.py. So we use a relative import with .. for the dependencies: from fastapi import APIRouter, Depends, HTTPException from ..dependencies import get\\_token\\_header router = APIRouter( prefix=\"/items\", tags=\\[\"items\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={404: {\"description\": \"Not found\"}}, ) fake\\_items\\_db = {\"plumbus\": {\"name\": \"Plumbus\"}, \"gun\": {\"name\": \"Portal Gun\"}} @router.get(\"/\") async def read\\_items(): return fake\\_items\\_db @router.get(\"/{item\\_id}\") async def read\\_item(item\\_id: str): if item\\_id not in fake\\_items\\_db: raise HTTPException(status\\_code=404, detail=\"Item not found\") return {\"name\": fake\\_items\\_db\\[item\\_id\\]\\[\"name\"\\], \"item\\_id\": item\\_id} @router.put( \"/{item\\_id}\", tags=\\[\"custom\"\\], responses={403: {\"description\": \"Operation forbidden\"}}, ) async def update\\_item(item\\_id: str): if item\\_id != \"plumbus\": raise HTTPException( status\\_code=403, detail=\"You can only update the item: plumbus\" ) return {\"item\\_id\": item\\_id, \"name\": \"The great Plumbus\"} How relative imports work¬∂ Tip If you know perfectly how imports work, continue to the next section below. A single dot ., like in: from .dependencies import get\\_token\\_header would mean: Starting in the same package that this module (the file app/routers/items.py) lives in (the directory app/routers/)... find the module dependencies (an imaginary file at app/routers/dependencies.py)... and from it, import the function get\\_token\\_header. But that file doesn't exist, our dependencies are in a file at app/dependencies.py. Remember how our app/file structure looks like: The two dots .., like in: from ..dependencies import get\\_token\\_header mean: Starting in the same package that this module (the file app/routers/items.py) lives in (the directory app/routers/)... go to the parent package (the directory app/)... and in there, find the module dependencies (the file at app/dependencies.py)... and from it, import the function get\\_token\\_header. That works correctly! üéâ The same way, if we had used three dots ..., like in: from ...dependencies import get\\_token\\_header that would mean: Starting in the same package that this module (the file app/routers/items.py) lives in (the directory app/routers/)... go to the parent package (the directory app/)... then go to the parent of that package (there's no parent package, app is the top level üò±)... and in there, find the module dependencies (the file at app/dependencies.py)... and from it, import the function get\\_token\\_header. That would refer to some package above app/, with its own file \\_\\_init\\_\\_.py, etc. But we don't have that. So, that would throw an error in our example. üö® But now you know how it works, so you can use relative imports in your own apps no matter how complex they are. ü§ì Add some custom tags, responses, and dependencies¬∂ We are not adding the prefix /items nor the tags=\\[\"items\"\\] to each path operation because we added them to the APIRouter. But we can still add more tags that will be applied to a specific path operation, and also some extra responses specific to that path operation: from fastapi import APIRouter, Depends, HTTPException from ..dependencies import get\\_token\\_header router = APIRouter( prefix=\"/items\", tags=\\[\"items\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={404: {\"description\": \"Not found\"}}, ) fake\\_items\\_db = {\"plumbus\": {\"name\": \"Plumbus\"}, \"gun\": {\"name\": \"Portal Gun\"}} @router.get(\"/\") async def read\\_items(): return fake\\_items\\_db @router.get(\"/{item\\_id}\") async def read\\_item(item\\_id: str): if item\\_id not in fake\\_items\\_db: raise HTTPException(status\\_code=404, detail=\"Item not found\") return {\"name\": fake\\_items\\_db\\[item\\_id\\]\\[\"name\"\\], \"item\\_id\": item\\_id} @router.put( \"/{item\\_id}\", tags=\\[\"custom\"\\], responses={403: {\"description\": \"Operation forbidden\"}}, ) async def update\\_item(item\\_id: str): if item\\_id != \"plumbus\": raise HTTPException( status\\_code=403, detail=\"You can only update the item: plumbus\" ) return {\"item\\_id\": item\\_id, \"name\": \"The great Plumbus\"} Tip This last path operation will have the combination of tags: \\[\"items\", \"custom\"\\]. And it will also have both responses in the documentation, one for 404 and one for 403. The main FastAPI¬∂ Now, let's see the module at app/main.py. Here's where you import and use the class FastAPI. This will be the main file in your application that ties everything together. And as most of your logic will now live in its own specific module, the main file will be quite simple. Import FastAPI¬∂ You import and create a FastAPI class as normally. And we can even declare global dependencies that will be combined with the dependencies for each APIRouter: from fastapi import Depends, FastAPI from .dependencies import get\\_query\\_token, get\\_token\\_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=\\[Depends(get\\_query\\_token)\\]) app.include\\_router(users.router) app.include\\_router(items.router) app.include\\_router( admin.router, prefix=\"/admin\", tags=\\[\"admin\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} Import the APIRouter¬∂ Now we import the other submodules that have APIRouters: from fastapi import Depends, FastAPI from .dependencies import get\\_query\\_token, get\\_token\\_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=\\[Depends(get\\_query\\_token)\\]) app.include\\_router(users.router) app.include\\_router(items.router) app.include\\_router( admin.router, prefix=\"/admin\", tags=\\[\"admin\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} As the files app/routers/users.py and app/routers/items.py are submodules that are part of the same Python package app, we can use a single dot . to import them using \"relative imports\". How the importing works¬∂ The section: from .routers import items, users Means: Starting in the same package that this module (the file app/main.py) lives in (the directory app/)... look for the subpackage routers (the directory at app/routers/)... and from it, import the submodule items (the file at app/routers/items.py) and users (the file at app/routers/users.py)... The module items will have a variable router (items.router). This is the same one we created in the file app/routers/items.py, it's an APIRouter object. And then we do the same for the module users. We could also import them like: from app.routers import items, users Info The first version is a \"relative import\": from .routers import items, users The second version is an \"absolute import\": from app.routers import items, users To learn more about Python Packages and Modules, read the official Python documentation about Modules. Avoid name collisions¬∂ We are importing the submodule items directly, instead of importing just its variable router. This is because we also have another variable named router in the submodule users. If we had imported one after the other, like: from .routers.items import router from .routers.users import router The router from users would overwrite the one from items and we wouldn't be able to use them at the same time. So, to be able to use both of them in the same file, we import the submodules directly: from fastapi import Depends, FastAPI from .dependencies import get\\_query\\_token, get\\_token\\_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=\\[Depends(get\\_query\\_token)\\]) app.include\\_router(users.router) app.include\\_router(items.router) app.include\\_router( admin.router, prefix=\"/admin\", tags=\\[\"admin\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} Include the APIRouters for users and items¬∂ Now, let's include the routers from the submodules users and items: from fastapi import Depends, FastAPI from .dependencies import get\\_query\\_token, get\\_token\\_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=\\[Depends(get\\_query\\_token)\\]) app.include\\_router(users.router) app.include\\_router(items.router) app.include\\_router( admin.router, prefix=\"/admin\", tags=\\[\"admin\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} Info users.router contains the APIRouter inside of the file app/routers/users.py. And items.router contains the APIRouter inside of the file app/routers/items.py. With app.include\\_router() we can add each APIRouter to the main FastAPI application. It will include all the routes from that router as part of it. Technical Details It will actually internally create a path operation for each path operation that was declared in the APIRouter. So, behind the scenes, it will actually work as if everything was the same single app. Check You don't have to worry about performance when including routers. This will take microseconds and will only happen at startup. So it won't affect performance. ‚ö° Include an APIRouter with a custom prefix, tags, responses, and dependencies¬∂ Now, let's imagine your organization gave you the app/internal/admin.py file. It contains an APIRouter with some admin path operations that your organization shares between several projects. For this example it will be super simple. But let's say that because it is shared with other projects in the organization, we cannot modify it and add a prefix, dependencies, tags, etc. directly to the APIRouter: from fastapi import APIRouter router = APIRouter() @router.post(\"/\") async def update\\_admin(): return {\"message\": \"Admin getting schwifty\"} But we still want to set a custom prefix when including the APIRouter so that all its path operations start with /admin, we want to secure it with the dependencies we already have for this project, and we want to include tags and responses. We can declare all that without having to modify the original APIRouter by passing those parameters to app.include\\_router(): from fastapi import Depends, FastAPI from .dependencies import get\\_query\\_token, get\\_token\\_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=\\[Depends(get\\_query\\_token)\\]) app.include\\_router(users.router) app.include\\_router(items.router) app.include\\_router( admin.router, prefix=\"/admin\", tags=\\[\"admin\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} That way, the original APIRouter will keep unmodified, so we can still share that same app/internal/admin.py file with other projects in the organization. The result is that in our app, each of the path operations from the admin module will have: The prefix /admin. The tag admin. The dependency get\\_token\\_header. The response 418. üçµ But that will only affect that APIRouter in our app, not in any other code that uses it. So, for example, other projects could use the same APIRouter with a different authentication method. Include a path operation¬∂ We can also add path operations directly to the FastAPI app. Here we do it... just to show that we can ü§∑: from fastapi import Depends, FastAPI from .dependencies import get\\_query\\_token, get\\_token\\_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=\\[Depends(get\\_query\\_token)\\]) app.include\\_router(users.router) app.include\\_router(items.router) app.include\\_router( admin.router, prefix=\"/admin\", tags=\\[\"admin\"\\], dependencies=\\[Depends(get\\_token\\_header)\\], responses={418: {\"description\": \"I'm a teapot\"}}, ) @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} and it will work correctly, together with all the other path operations added with app.include\\_router(). Very Technical Details Note: this is a very technical detail that you probably can just skip. The APIRouters are not \"mounted\", they are not isolated from the rest of the application. This is because we want to include their path operations in the OpenAPI schema and the user interfaces. As we cannot just isolate them and \"mount\" them independently of the rest, the path operations are \"cloned\" (re-created), not included directly. Check the automatic API docs¬∂ Now, run uvicorn, using the module app.main and the variable app: And open the docs at http://127.0.0.1:8000/docs. You will see the automatic API docs, including the paths from all the submodules, using the correct paths (and prefixes) and the correct tags: Include the same router multiple times with different prefix¬∂ You can also use .include\\_router() multiple times with the same router using different prefixes. This could be useful, for example, to expose the same API under different prefixes, e.g. /api/v1 and /api/latest. This is an advanced usage that you might not really need, but it's there in case you do. Include an APIRouter in another¬∂ The same way you can include an APIRouter in a FastAPI application, you can include an APIRouter in another APIRouter using: router.include\\_router(other\\_router) Make sure you do it before including router in the FastAPI app, so that the path operations from other\\_router are also included. Made with Material for MkDocs Insiders"
  },
  {
    "title": "CORS (Cross-Origin Resource Sharing) - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/cors/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI CORS (Cross-Origin Resource Sharing) en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Origin Steps Wildcards Use CORSMiddleware CORS preflight requests Simple requests More info FastAPI Learn Tutorial - User Guide CORS (Cross-Origin Resource Sharing)¬∂ CORS or \"Cross-Origin Resource Sharing\" refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different \"origin\" than the frontend. Origin¬∂ An origin is the combination of protocol (http, https), domain (myapp.com, localhost, localhost.tiangolo.com), and port (80, 443, 8080). So, all these are different origins: http://localhost https://localhost http://localhost:8080 Even if they are all in localhost, they use different protocols or ports, so, they are different \"origins\". Steps¬∂ So, let's say you have a frontend running in your browser at http://localhost:8080, and its JavaScript is trying to communicate with a backend running at http://localhost (because we don't specify a port, the browser will assume the default port 80). Then, the browser will send an HTTP OPTIONS request to the backend, and if the backend sends the appropriate headers authorizing the communication from this different origin (http://localhost:8080) then the browser will let the JavaScript in the frontend send its request to the backend. To achieve this, the backend must have a list of \"allowed origins\". In this case, it would have to include http://localhost:8080 for the frontend to work correctly. Wildcards¬∂ It's also possible to declare the list as \"\\*\" (a \"wildcard\") to say that all are allowed. But that will only allow certain types of communication, excluding everything that involves credentials: Cookies, Authorization headers like those used with Bearer Tokens, etc. So, for everything to work correctly, it's better to specify explicitly the allowed origins. Use CORSMiddleware¬∂ You can configure it in your FastAPI application using the CORSMiddleware. Import CORSMiddleware. Create a list of allowed origins (as strings). Add it as a \"middleware\" to your FastAPI application. You can also specify if your backend allows: Credentials (Authorization headers, Cookies, etc). Specific HTTP methods (POST, PUT) or all of them with the wildcard \"\\*\". Specific HTTP headers or all of them with the wildcard \"\\*\". from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware app = FastAPI() origins = \\[ \"http://localhost.tiangolo.com\", \"https://localhost.tiangolo.com\", \"http://localhost\", \"http://localhost:8080\", \\] app.add\\_middleware( CORSMiddleware, allow\\_origins=origins, allow\\_credentials=True, allow\\_methods=\\[\"\\*\"\\], allow\\_headers=\\[\"\\*\"\\], ) @app.get(\"/\") async def main(): return {\"message\": \"Hello World\"} The default parameters used by the CORSMiddleware implementation are restrictive by default, so you'll need to explicitly enable particular origins, methods, or headers, in order for browsers to be permitted to use them in a Cross-Domain context. The following arguments are supported: allow\\_origins - A list of origins that should be permitted to make cross-origin requests. E.g. \\['https://example.org', 'https://www.example.org'\\]. You can use \\['\\*'\\] to allow any origin. allow\\_origin\\_regex - A regex string to match against origins that should be permitted to make cross-origin requests. e.g. 'https://.\\*\\\\.example\\\\.org'. allow\\_methods - A list of HTTP methods that should be allowed for cross-origin requests. Defaults to \\['GET'\\]. You can use \\['\\*'\\] to allow all standard methods. allow\\_headers - A list of HTTP request headers that should be supported for cross-origin requests. Defaults to \\[\\]. You can use \\['\\*'\\] to allow all headers. The Accept, Accept-Language, Content-Language and Content-Type headers are always allowed for simple CORS requests. allow\\_credentials - Indicate that cookies should be supported for cross-origin requests. Defaults to False. Also, allow\\_origins cannot be set to \\['\\*'\\] for credentials to be allowed, origins must be specified. expose\\_headers - Indicate any response headers that should be made accessible to the browser. Defaults to \\[\\]. max\\_age - Sets a maximum time in seconds for browsers to cache CORS responses. Defaults to 600. The middleware responds to two particular types of HTTP request... CORS preflight requests¬∂ These are any OPTIONS request with Origin and Access-Control-Request-Method headers. In this case the middleware will intercept the incoming request and respond with appropriate CORS headers, and either a 200 or 400 response for informational purposes. Simple requests¬∂ Any request with an Origin header. In this case the middleware will pass the request through as normal, but will include appropriate CORS headers on the response. More info¬∂ For more info about CORS, check the Mozilla CORS documentation. Technical Details You could also use from starlette.middleware.cors import CORSMiddleware. FastAPI provides several middlewares in fastapi.middleware just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette. Made with Material for MkDocs Insiders"
  },
  {
    "title": "OAuth2 with Password (and hashing), Bearer with JWT tokens - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI OAuth2 with Password (and hashing), Bearer with JWT tokens en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents About JWT Install python-jose Password hashing Why use password hashing Install passlib Hash and verify the passwords Handle JWT tokens Update the dependencies Update the /token path operation Technical details about the JWT \"subject\" sub Check it Advanced usage with scopes Recap FastAPI Learn Tutorial - User Guide Security OAuth2 with Password (and hashing), Bearer with JWT tokens¬∂ Now that we have all the security flow, let's make the application actually secure, using JWT tokens and secure password hashing. This code is something you can actually use in your application, save the password hashes in your database, etc. We are going to start from where we left in the previous chapter and increment it. About JWT¬∂ JWT means \"JSON Web Tokens\". It's a standard to codify a JSON object in a long dense string without spaces. It looks like this: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV\\_adQssw5c It is not encrypted, so, anyone could recover the information from the contents. But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it. That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system. After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match. If you want to play with JWT tokens and see how they work, check https://jwt.io. Install python-jose¬∂ We need to install python-jose to generate and verify the JWT tokens in Python: Python-jose requires a cryptographic backend as an extra. Here we are using the recommended one: pyca/cryptography. Tip This tutorial previously used PyJWT. But it was updated to use Python-jose instead as it provides all the features from PyJWT plus some extras that you might need later when building integrations with other tools. Password hashing¬∂ \"Hashing\" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish. Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish. But you cannot convert from the gibberish back to the password. Why use password hashing¬∂ If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes. So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous). Install passlib¬∂ PassLib is a great Python package to handle password hashes. It supports many secure hashing algorithms and utilities to work with them. The recommended algorithm is \"Bcrypt\". So, install PassLib with Bcrypt: Tip With passlib, you could even configure it to be able to read passwords created by Django, a Flask security plug-in or many others. So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database. And your users would be able to login from your Django app or from your FastAPI app, at the same time. Hash and verify the passwords¬∂ Import the tools we need from passlib. Create a PassLib \"context\". This is what will be used to hash and verify passwords. Tip The PassLib context also has functionality to use different hashing algorithms, including deprecated old ones only to allow verifying them, etc. For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt. And be compatible with all of them at the same time. Create a utility function to hash a password coming from the user. And another utility to verify if a received password matches the hash stored. And another one to authenticate and return a user. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, } } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_data = TokenData(username=username) except JWTError: raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username}, expires\\_delta=access\\_token\\_expires ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] Note If you check the new (fake) database fake\\_users\\_db, you will see how the hashed password looks like now: \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\". Handle JWT tokens¬∂ Import the modules installed. Create a random secret key that will be used to sign the JWT tokens. To generate a secure random secret key use the command: And copy the output to the variable SECRET\\_KEY (don't use the one in the example). Create a variable ALGORITHM with the algorithm used to sign the JWT token and set it to \"HS256\". Create a variable for the expiration of the token. Define a Pydantic Model that will be used in the token endpoint for the response. Create a utility function to generate a new access token. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, } } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_data = TokenData(username=username) except JWTError: raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username}, expires\\_delta=access\\_token\\_expires ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] Update the dependencies¬∂ Update get\\_current\\_user to receive the same token as before, but this time, using JWT tokens. Decode the received token, verify it, and return the current user. If the token is invalid, return an HTTP error right away. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, } } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_data = TokenData(username=username) except JWTError: raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username}, expires\\_delta=access\\_token\\_expires ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] Update the /token path operation¬∂ Create a timedelta with the expiration time of the token. Create a real JWT access token and return it Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, } } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_data = TokenData(username=username) except JWTError: raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username}, expires\\_delta=access\\_token\\_expires ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] Technical details about the JWT \"subject\" sub¬∂ The JWT specification says that there's a key sub, with the subject of the token. It's optional to use it, but that's where you would put the user's identification, so we are using it here. JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API. For example, you could identify a \"car\" or a \"blog post\". Then you could add permissions about that entity, like \"drive\" (for the car) or \"edit\" (for the blog). And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that. Using these ideas, JWT can be used for way more sophisticated scenarios. In those cases, several of those entities could have the same ID, let's say foo (a user foo, a car foo, and a blog post foo). So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the sub key, e.g. with username:. So, in this example, the value of sub could have been: username:johndoe. The important thing to have in mind is that the sub key should have a unique identifier across the entire application, and it should be a string. Check it¬∂ Run the server and go to the docs: http://127.0.0.1:8000/docs. You'll see the user interface like: Authorize the application the same way as before. Using the credentials: Username: johndoe Password: secret Check Notice that nowhere in the code is the plaintext password \"secret\", we only have the hashed version. Call the endpoint /users/me/, you will get the response as: { \"username\": \"johndoe\", \"email\": \"johndoe@example.com\", \"full\\_name\": \"John Doe\", \"disabled\": false } If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards: Note Notice the header Authorization, with a value that starts with Bearer. Advanced usage with scopes¬∂ OAuth2 has the notion of \"scopes\". You can use them to add a specific set of permissions to a JWT token. Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions. You can learn how to use them and how they are integrated into FastAPI later in the Advanced User Guide. Recap¬∂ With what you have seen up to now, you can set up a secure FastAPI application using standards like OAuth2 and JWT. In almost any framework handling the security becomes a rather complex subject quite quickly. Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath. FastAPI doesn't make any compromise with any database, data model or tool. It gives you all the flexibility to choose the ones that fit your project the best. And you can use directly many well maintained and widely used packages like passlib and python-jose, because FastAPI doesn't require any complex mechanisms to integrate external packages. But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security. And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way. You can learn more in the Advanced User Guide about how to use OAuth2 \"scopes\", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Simple OAuth2 with Password and Bearer - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Simple OAuth2 with Password and Bearer en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Get the username and password scope Code to get the username and password OAuth2PasswordRequestForm Use the form data Check the password Password hashing Why use password hashing About \\*\\*user\\_dict Return the token Update the dependencies See it in action Authenticate Get your own user data Inactive user Recap FastAPI Learn Tutorial - User Guide Security Simple OAuth2 with Password and Bearer¬∂ Now let's build from the previous chapter and add the missing parts to have a complete security flow. Get the username and password¬∂ We are going to use FastAPI security utilities to get the username and password. OAuth2 specifies that when using the \"password flow\" (that we are using) the client/user must send a username and password fields as form data. And the spec says that the fields have to be named like that. So user-name or email wouldn't work. But don't worry, you can show it as you wish to your final users in the frontend. And your database models can use any other names you want. But for the login path operation, we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system). The spec also states that the username and password must be sent as form data (so, no JSON here). scope¬∂ The spec also says that the client can send another form field \"scope\". The form field name is scope (in singular), but it is actually a long string with \"scopes\" separated by spaces. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram\\_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings. Code to get the username and password¬∂ Now let's use the utilities provided by FastAPI to handle this. OAuth2PasswordRequestForm¬∂ First, import OAuth2PasswordRequestForm, and use it as a dependency with Depends in the path operation for /token: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"fakehashedsecret\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Wonderson\", \"email\": \"alice@example.com\", \"hashed\\_password\": \"fakehashedsecret2\", \"disabled\": True, }, } app = FastAPI() def fake\\_hash\\_password(password: str): return \"fakehashed\" + password oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def fake\\_decode\\_token(token): # This doesn't provide any security at all # Check the next version user = get\\_user(fake\\_users\\_db, token) return user async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Invalid authentication credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\") async def login(form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\]): user\\_dict = fake\\_users\\_db.get(form\\_data.username) if not user\\_dict: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") user = UserInDB(\\*\\*user\\_dict) hashed\\_password = fake\\_hash\\_password(form\\_data.password) if not hashed\\_password == user.hashed\\_password: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") return {\"access\\_token\": user.username, \"token\\_type\": \"bearer\"} @app.get(\"/users/me\") async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user OAuth2PasswordRequestForm is a class dependency that declares a form body with: The username. The password. An optional scope field as a big string, composed of strings separated by spaces. An optional grant\\_type. Tip The OAuth2 spec actually requires a field grant\\_type with a fixed value of password, but OAuth2PasswordRequestForm doesn't enforce it. If you need to enforce it, use OAuth2PasswordRequestFormStrict instead of OAuth2PasswordRequestForm. An optional client\\_id (we don't need it for our example). An optional client\\_secret (we don't need it for our example). Info The OAuth2PasswordRequestForm is not a special class for FastAPI as is OAuth2PasswordBearer. OAuth2PasswordBearer makes FastAPI know that it is a security scheme. So it is added that way to OpenAPI. But OAuth2PasswordRequestForm is just a class dependency that you could have written yourself, or you could have declared Form parameters directly. But as it's a common use case, it is provided by FastAPI directly, just to make it easier. Use the form data¬∂ Tip The instance of the dependency class OAuth2PasswordRequestForm won't have an attribute scope with the long string separated by spaces, instead, it will have a scopes attribute with the actual list of strings for each scope sent. We are not using scopes in this example, but the functionality is there if you need it. Now, get the user data from the (fake) database, using the username from the form field. If there is no such user, we return an error saying \"incorrect username or password\". For the error, we use the exception HTTPException: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"fakehashedsecret\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Wonderson\", \"email\": \"alice@example.com\", \"hashed\\_password\": \"fakehashedsecret2\", \"disabled\": True, }, } app = FastAPI() def fake\\_hash\\_password(password: str): return \"fakehashed\" + password oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def fake\\_decode\\_token(token): # This doesn't provide any security at all # Check the next version user = get\\_user(fake\\_users\\_db, token) return user async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Invalid authentication credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\") async def login(form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\]): user\\_dict = fake\\_users\\_db.get(form\\_data.username) if not user\\_dict: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") user = UserInDB(\\*\\*user\\_dict) hashed\\_password = fake\\_hash\\_password(form\\_data.password) if not hashed\\_password == user.hashed\\_password: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") return {\"access\\_token\": user.username, \"token\\_type\": \"bearer\"} @app.get(\"/users/me\") async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user Check the password¬∂ At this point we have the user data from our database, but we haven't checked the password. Let's put that data in the Pydantic UserInDB model first. You should never save plaintext passwords, so, we'll use the (fake) password hashing system. If the passwords don't match, we return the same error. Password hashing¬∂ \"Hashing\" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish. Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish. But you cannot convert from the gibberish back to the password. WHY USE PASSWORD HASHING¬∂ If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes. So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous). Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"fakehashedsecret\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Wonderson\", \"email\": \"alice@example.com\", \"hashed\\_password\": \"fakehashedsecret2\", \"disabled\": True, }, } app = FastAPI() def fake\\_hash\\_password(password: str): return \"fakehashed\" + password oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def fake\\_decode\\_token(token): # This doesn't provide any security at all # Check the next version user = get\\_user(fake\\_users\\_db, token) return user async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Invalid authentication credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\") async def login(form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\]): user\\_dict = fake\\_users\\_db.get(form\\_data.username) if not user\\_dict: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") user = UserInDB(\\*\\*user\\_dict) hashed\\_password = fake\\_hash\\_password(form\\_data.password) if not hashed\\_password == user.hashed\\_password: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") return {\"access\\_token\": user.username, \"token\\_type\": \"bearer\"} @app.get(\"/users/me\") async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user About \\*\\*user\\_dict¬∂ UserInDB(\\*\\*user\\_dict) means: Pass the keys and values of the user\\_dict directly as key-value arguments, equivalent to: UserInDB( username = user\\_dict\\[\"username\"\\], email = user\\_dict\\[\"email\"\\], full\\_name = user\\_dict\\[\"full\\_name\"\\], disabled = user\\_dict\\[\"disabled\"\\], hashed\\_password = user\\_dict\\[\"hashed\\_password\"\\], ) Info For a more complete explanation of \\*\\*user\\_dict check back in the documentation for Extra Models. Return the token¬∂ The response of the token endpoint must be a JSON object. It should have a token\\_type. In our case, as we are using \"Bearer\" tokens, the token type should be \"bearer\". And it should have an access\\_token, with a string containing our access token. For this simple example, we are going to just be completely insecure and return the same username as the token. Tip In the next chapter, you will see a real secure implementation, with password hashing and JWT tokens. But for now, let's focus on the specific details we need. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"fakehashedsecret\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Wonderson\", \"email\": \"alice@example.com\", \"hashed\\_password\": \"fakehashedsecret2\", \"disabled\": True, }, } app = FastAPI() def fake\\_hash\\_password(password: str): return \"fakehashed\" + password oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def fake\\_decode\\_token(token): # This doesn't provide any security at all # Check the next version user = get\\_user(fake\\_users\\_db, token) return user async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Invalid authentication credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\") async def login(form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\]): user\\_dict = fake\\_users\\_db.get(form\\_data.username) if not user\\_dict: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") user = UserInDB(\\*\\*user\\_dict) hashed\\_password = fake\\_hash\\_password(form\\_data.password) if not hashed\\_password == user.hashed\\_password: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") return {\"access\\_token\": user.username, \"token\\_type\": \"bearer\"} @app.get(\"/users/me\") async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user Tip By the spec, you should return a JSON with an access\\_token and a token\\_type, the same as in this example. This is something that you have to do yourself in your code, and make sure you use those JSON keys. It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications. For the rest, FastAPI handles it for you. Update the dependencies¬∂ Now we are going to update our dependencies. We want to get the current\\_user only if this user is active. So, we create an additional dependency get\\_current\\_active\\_user that in turn uses get\\_current\\_user as a dependency. Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive. So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm from pydantic import BaseModel fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"fakehashedsecret\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Wonderson\", \"email\": \"alice@example.com\", \"hashed\\_password\": \"fakehashedsecret2\", \"disabled\": True, }, } app = FastAPI() def fake\\_hash\\_password(password: str): return \"fakehashed\" + password oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def fake\\_decode\\_token(token): # This doesn't provide any security at all # Check the next version user = get\\_user(fake\\_users\\_db, token) return user async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) if not user: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Invalid authentication credentials\", headers={\"WWW-Authenticate\": \"Bearer\"}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\") async def login(form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\]): user\\_dict = fake\\_users\\_db.get(form\\_data.username) if not user\\_dict: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") user = UserInDB(\\*\\*user\\_dict) hashed\\_password = fake\\_hash\\_password(form\\_data.password) if not hashed\\_password == user.hashed\\_password: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") return {\"access\\_token\": user.username, \"token\\_type\": \"bearer\"} @app.get(\"/users/me\") async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user Info The additional header WWW-Authenticate with value Bearer we are returning here is also part of the spec. Any HTTP (error) status code 401 \"UNAUTHORIZED\" is supposed to also return a WWW-Authenticate header. In the case of bearer tokens (our case), the value of that header should be Bearer. You can actually skip that extra header and it would still work. But it's provided here to be compliant with the specifications. Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future. That's the benefit of standards... See it in action¬∂ Open the interactive docs: http://127.0.0.1:8000/docs. Authenticate¬∂ Click the \"Authorize\" button. Use the credentials: User: johndoe Password: secret After authenticating in the system, you will see it like: Get your own user data¬∂ Now use the operation GET with the path /users/me. You will get your user's data, like: { \"username\": \"johndoe\", \"email\": \"johndoe@example.com\", \"full\\_name\": \"John Doe\", \"disabled\": false, \"hashed\\_password\": \"fakehashedsecret\" } If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of: { \"detail\": \"Not authenticated\" } Inactive user¬∂ Now try with an inactive user, authenticate with: User: alice Password: secret2 And try to use the operation GET with the path /users/me. You will get an \"inactive user\" error, like: { \"detail\": \"Inactive user\" } Recap¬∂ You now have the tools to implement a complete security system based on username and password for your API. Using these tools, you can make the security system compatible with any database and with any user or data model. The only detail missing is that it is not actually \"secure\" yet. In the next chapter you'll see how to use a secure password hashing library and JWT tokens. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Middleware - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/middleware/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Middleware en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Create a middleware Before and after the response Other middlewares FastAPI Learn Tutorial - User Guide Middleware¬∂ You can add middleware to FastAPI applications. A \"middleware\" is a function that works with every request before it is processed by any specific path operation. And also with every response before returning it. It takes each request that comes to your application. It can then do something to that request or run any needed code. Then it passes the request to be processed by the rest of the application (by some path operation). It then takes the response generated by the application (by some path operation). It can do something to that response or run any needed code. Then it returns the response. Technical Details If you have dependencies with yield, the exit code will run after the middleware. If there were any background tasks (documented later), they will run after all the middleware. Create a middleware¬∂ To create a middleware you use the decorator @app.middleware(\"http\") on top of a function. The middleware function receives: The request. A function call\\_next that will receive the request as a parameter. This function will pass the request to the corresponding path operation. Then it returns the response generated by the corresponding path operation. You can then modify further the response before returning it. import time from fastapi import FastAPI, Request app = FastAPI() @app.middleware(\"http\") async def add\\_process\\_time\\_header(request: Request, call\\_next): start\\_time = time.time() response = await call\\_next(request) process\\_time = time.time() - start\\_time response.headers\\[\"X-Process-Time\"\\] = str(process\\_time) return response Tip Have in mind that custom proprietary headers can be added using the 'X-' prefix. But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (CORS (Cross-Origin Resource Sharing)) using the parameter expose\\_headers documented in Starlette's CORS docs. Technical Details You could also use from starlette.requests import Request. FastAPI provides it as a convenience for you, the developer. But it comes directly from Starlette. Before and after the response¬∂ You can add code to be run with the request, before any path operation receives it. And also after the response is generated, before returning it. For example, you could add a custom header X-Process-Time containing the time in seconds that it took to process the request and generate a response: import time from fastapi import FastAPI, Request app = FastAPI() @app.middleware(\"http\") async def add\\_process\\_time\\_header(request: Request, call\\_next): start\\_time = time.time() response = await call\\_next(request) process\\_time = time.time() - start\\_time response.headers\\[\"X-Process-Time\"\\] = str(process\\_time) return response Other middlewares¬∂ You can later read more about other middlewares in the Advanced User Guide: Advanced Middleware. You will read about how to handle CORS with a middleware in the next section. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Get Current User - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/security/get-current-user/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Get Current User en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Create a user model Create a get\\_current\\_user dependency Get the user Inject the current user Other models Code size Recap FastAPI Learn Tutorial - User Guide Security Get Current User¬∂ In the previous chapter the security system (which is based on the dependency injection system) was giving the path operation function a token as a str: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") @app.get(\"/items/\") async def read\\_items(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): return {\"token\": token} But that is still not that useful. Let's make it give us the current user. Create a user model¬∂ First, let's create a Pydantic user model. The same way we use Pydantic to declare bodies, we can use it anywhere else: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None def fake\\_decode\\_token(token): return User( username=token + \"fakedecoded\", email=\"john@example.com\", full\\_name=\"John Doe\" ) async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) return user @app.get(\"/users/me\") async def read\\_users\\_me(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return current\\_user Create a get\\_current\\_user dependency¬∂ Let's create a dependency get\\_current\\_user. Remember that dependencies can have sub-dependencies? get\\_current\\_user will have a dependency with the same oauth2\\_scheme we created before. The same as we were doing before in the path operation directly, our new dependency get\\_current\\_user will receive a token as a str from the sub-dependency oauth2\\_scheme: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None def fake\\_decode\\_token(token): return User( username=token + \"fakedecoded\", email=\"john@example.com\", full\\_name=\"John Doe\" ) async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) return user @app.get(\"/users/me\") async def read\\_users\\_me(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return current\\_user Get the user¬∂ get\\_current\\_user will use a (fake) utility function we created, that takes a token as a str and returns our Pydantic User model: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None def fake\\_decode\\_token(token): return User( username=token + \"fakedecoded\", email=\"john@example.com\", full\\_name=\"John Doe\" ) async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) return user @app.get(\"/users/me\") async def read\\_users\\_me(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return current\\_user Inject the current user¬∂ So now we can use the same Depends with our get\\_current\\_user in the path operation: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None def fake\\_decode\\_token(token): return User( username=token + \"fakedecoded\", email=\"john@example.com\", full\\_name=\"John Doe\" ) async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) return user @app.get(\"/users/me\") async def read\\_users\\_me(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return current\\_user Notice that we declare the type of current\\_user as the Pydantic model User. This will help us inside of the function with all the completion and type checks. Tip You might remember that request bodies are also declared with Pydantic models. Here FastAPI won't get confused because you are using Depends. Check The way this dependency system is designed allows us to have different dependencies (different \"dependables\") that all return a User model. We are not restricted to having only one dependency that can return that type of data. Other models¬∂ You can now get the current user directly in the path operation functions and deal with the security mechanisms at the Dependency Injection level, using Depends. And you can use any model or data for the security requirements (in this case, a Pydantic model User). But you are not restricted to using some specific data model, class or type. Do you want to have an id and email and not have any username in your model? Sure. You can use these same tools. Do you want to just have a str? Or just a dict? Or a database class model instance directly? It all works the same way. You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same. Just use any kind of model, any kind of class, any kind of database that you need for your application. FastAPI has you covered with the dependency injection system. Code size¬∂ This example might seem verbose. Have in mind that we are mixing security, data models, utility functions and path operations in the same file. But here's the key point. The security and dependency injection stuff is written once. And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility. But you can have thousands of endpoints (path operations) using the same security system. And all of them (or any portion of them that you want) can take the advantage of re-using these dependencies or any other dependencies you create. And all these thousands of path operations can be as small as 3 lines: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer from pydantic import BaseModel app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None def fake\\_decode\\_token(token): return User( username=token + \"fakedecoded\", email=\"john@example.com\", full\\_name=\"John Doe\" ) async def get\\_current\\_user(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): user = fake\\_decode\\_token(token) return user @app.get(\"/users/me\") async def read\\_users\\_me(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return current\\_user Recap¬∂ You can now get the current user directly in your path operation function. We are already halfway there. We just need to add a path operation for the user/client to actually send the username and password. That comes next. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Security - First Steps - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/security/first-steps/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Security - First Steps en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents How it looks Create main.py Run it Check it The password flow FastAPI's OAuth2PasswordBearer Use it What it does Recap FastAPI Learn Tutorial - User Guide Security Security - First Steps¬∂ Let's imagine that you have your backend API in some domain. And you have a frontend in another domain or in a different path of the same domain (or in a mobile application). And you want to have a way for the frontend to authenticate with the backend, using a username and password. We can use OAuth2 to build that with FastAPI. But let's save you the time of reading the full long specification just to find those little pieces of information you need. Let's use the tools provided by FastAPI to handle security. How it looks¬∂ Let's first just use the code and see how it works, and then we'll come back to understand what's happening. Create main.py¬∂ Copy the example in a file main.py: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") @app.get(\"/items/\") async def read\\_items(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): return {\"token\": token} Run it¬∂ Info First install python-multipart. E.g. pip install python-multipart. This is because OAuth2 uses \"form data\" for sending the username and password. Run the example with: Check it¬∂ Go to the interactive docs at: http://127.0.0.1:8000/docs. You will see something like this: Authorize button! You already have a shiny new \"Authorize\" button. And your path operation has a little lock in the top-right corner that you can click. And if you click it, you have a little authorization form to type a username and password (and other optional fields): Note It doesn't matter what you type in the form, it won't work yet. But we'll get there. This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API. It can be used by the frontend team (that can also be yourself). It can be used by third party applications and systems. And it can also be used by yourself, to debug, check and test the same application. The password flow¬∂ Now let's go back a bit and understand what is all that. The password \"flow\" is one of the ways (\"flows\") defined in OAuth2, to handle security and authentication. OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user. But in this case, the same FastAPI application will handle the API and the authentication. So, let's review it from that simplified point of view: The user types the username and password in the frontend, and hits Enter. The frontend (running in the user's browser) sends that username and password to a specific URL in our API (declared with tokenUrl=\"token\"). The API checks that username and password, and responds with a \"token\" (we haven't implemented any of this yet). A \"token\" is just a string with some content that we can use later to verify this user. Normally, a token is set to expire after some time. So, the user will have to log in again at some point later. And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases). The frontend stores that token temporarily somewhere. The user clicks in the frontend to go to another section of the frontend web app. The frontend needs to fetch some more data from the API. But it needs authentication for that specific endpoint. So, to authenticate with our API, it sends a header Authorization with a value of Bearer plus the token. If the token contains foobar, the content of the Authorization header would be: Bearer foobar. FastAPI's OAuth2PasswordBearer¬∂ FastAPI provides several tools, at different levels of abstraction, to implement these security features. In this example we are going to use OAuth2, with the Password flow, using a Bearer token. We do that using the OAuth2PasswordBearer class. Info A \"bearer\" token is not the only option. But it's the best one for our use case. And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that suits better your needs. In that case, FastAPI also provides you with the tools to build it. When we create an instance of the OAuth2PasswordBearer class we pass in the tokenUrl parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the username and password in order to get a token. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") @app.get(\"/items/\") async def read\\_items(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): return {\"token\": token} Tip Here tokenUrl=\"token\" refers to a relative URL token that we haven't created yet. As it's a relative URL, it's equivalent to ./token. Because we are using a relative URL, if your API was located at https://example.com/, then it would refer to https://example.com/token. But if your API was located at https://example.com/api/v1/, then it would refer to https://example.com/api/v1/token. Using a relative URL is important to make sure your application keeps working even in an advanced use case like Behind a Proxy. This parameter doesn't create that endpoint / path operation, but declares that the URL /token will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems. We will soon also create the actual path operation. Info If you are a very strict \"Pythonista\" you might dislike the style of the parameter name tokenUrl instead of token\\_url. That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it. The oauth2\\_scheme variable is an instance of OAuth2PasswordBearer, but it is also a \"callable\". It could be called as: oauth2\\_scheme(some, parameters) So, it can be used with Depends. Use it¬∂ Now you can pass that oauth2\\_scheme in a dependency with Depends. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import OAuth2PasswordBearer app = FastAPI() oauth2\\_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") @app.get(\"/items/\") async def read\\_items(token: Annotated\\[str, Depends(oauth2\\_scheme)\\]): return {\"token\": token} This dependency will provide a str that is assigned to the parameter token of the path operation function. FastAPI will know that it can use this dependency to define a \"security scheme\" in the OpenAPI schema (and the automatic API docs). Technical Details FastAPI will know that it can use the class OAuth2PasswordBearer (declared in a dependency) to define the security scheme in OpenAPI because it inherits from fastapi.security.oauth2.OAuth2, which in turn inherits from fastapi.security.base.SecurityBase. All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from SecurityBase, that's how FastAPI can know how to integrate them in OpenAPI. What it does¬∂ It will go and look in the request for that Authorization header, check if the value is Bearer plus some token, and will return the token as a str. If it doesn't see an Authorization header, or the value doesn't have a Bearer token, it will respond with a 401 status code error (UNAUTHORIZED) directly. You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a str in that token. You can try it already in the interactive docs: We are not verifying the validity of the token yet, but that's a start already. Recap¬∂ So, in just 3 or 4 extra lines, you already have some primitive form of security. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Dependencies with yield - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-with-yield/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Dependencies with yield en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents A database dependency with yield A dependency with yield and try Sub-dependencies with yield Dependencies with yield and HTTPException Execution of dependencies with yield Dependencies with yield, HTTPException and Background Tasks Context Managers What are \"Context Managers\" Using context managers in dependencies with yield FastAPI Learn Tutorial - User Guide Dependencies Dependencies with yield¬∂ FastAPI supports dependencies that do some extra steps after finishing. To do this, use yield instead of return, and write the extra steps (code) after. Tip Make sure to use yield one single time. Technical Details Any function that is valid to use with: @contextlib.contextmanager or @contextlib.asynccontextmanager would be valid to use as a FastAPI dependency. In fact, FastAPI uses those two decorators internally. A database dependency with yield¬∂ For example, you could use this to create a database session and close it after finishing. Only the code prior to and including the yield statement is executed before creating a response: async def get\\_db(): db = DBSession() try: yield db finally: db.close() The yielded value is what is injected into path operations and other dependencies: async def get\\_db(): db = DBSession() try: yield db finally: db.close() The code following the yield statement is executed after the response has been delivered: async def get\\_db(): db = DBSession() try: yield db finally: db.close() Tip You can use async or regular functions. FastAPI will do the right thing with each, the same as with normal dependencies. A dependency with yield and try¬∂ If you use a try block in a dependency with yield, you'll receive any exception that was thrown when using the dependency. For example, if some code at some point in the middle, in another dependency or in a path operation, made a database transaction \"rollback\" or create any other error, you will receive the exception in your dependency. So, you can look for that specific exception inside the dependency with except SomeException. In the same way, you can use finally to make sure the exit steps are executed, no matter if there was an exception or not. async def get\\_db(): db = DBSession() try: yield db finally: db.close() Sub-dependencies with yield¬∂ You can have sub-dependencies and \"trees\" of sub-dependencies of any size and shape, and any or all of them can use yield. FastAPI will make sure that the \"exit code\" in each dependency with yield is run in the correct order. For example, dependency\\_c can have a dependency on dependency\\_b, and dependency\\_b on dependency\\_a: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends async def dependency\\_a(): dep\\_a = generate\\_dep\\_a() try: yield dep\\_a finally: dep\\_a.close() async def dependency\\_b(dep\\_a: Annotated\\[DepA, Depends(dependency\\_a)\\]): dep\\_b = generate\\_dep\\_b() try: yield dep\\_b finally: dep\\_b.close(dep\\_a) async def dependency\\_c(dep\\_b: Annotated\\[DepB, Depends(dependency\\_b)\\]): dep\\_c = generate\\_dep\\_c() try: yield dep\\_c finally: dep\\_c.close(dep\\_b) And all of them can use yield. In this case dependency\\_c, to execute its exit code, needs the value from dependency\\_b (here named dep\\_b) to still be available. And, in turn, dependency\\_b needs the value from dependency\\_a (here named dep\\_a) to be available for its exit code. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends async def dependency\\_a(): dep\\_a = generate\\_dep\\_a() try: yield dep\\_a finally: dep\\_a.close() async def dependency\\_b(dep\\_a: Annotated\\[DepA, Depends(dependency\\_a)\\]): dep\\_b = generate\\_dep\\_b() try: yield dep\\_b finally: dep\\_b.close(dep\\_a) async def dependency\\_c(dep\\_b: Annotated\\[DepB, Depends(dependency\\_b)\\]): dep\\_c = generate\\_dep\\_c() try: yield dep\\_c finally: dep\\_c.close(dep\\_b) The same way, you could have some dependencies with yield and some other dependencies with return, and have some of those depend on some of the others. And you could have a single dependency that requires several other dependencies with yield, etc. You can have any combinations of dependencies that you want. FastAPI will make sure everything is run in the correct order. Technical Details This works thanks to Python's Context Managers. FastAPI uses them internally to achieve this. Dependencies with yield and HTTPException¬∂ You saw that you can use dependencies with yield and have try blocks that catch exceptions. The same way, you could raise an HTTPException or similar in the exit code, after the yield. Tip This is a somewhat advanced technique, and in most of the cases you won't really need it, as you can raise exceptions (including HTTPException) from inside of the rest of your application code, for example, in the path operation function. But it's there for you if you need it. ü§ì Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, HTTPException app = FastAPI() data = { \"plumbus\": {\"description\": \"Freshly pickled plumbus\", \"owner\": \"Morty\"}, \"portal-gun\": {\"description\": \"Gun to create portals\", \"owner\": \"Rick\"}, } class OwnerError(Exception): pass def get\\_username(): try: yield \"Rick\" except OwnerError as e: raise HTTPException(status\\_code=400, detail=f\"Owner error: {e}\") @app.get(\"/items/{item\\_id}\") def get\\_item(item\\_id: str, username: Annotated\\[str, Depends(get\\_username)\\]): if item\\_id not in data: raise HTTPException(status\\_code=404, detail=\"Item not found\") item = data\\[item\\_id\\] if item\\[\"owner\"\\] != username: raise OwnerError(username) return item An alternative you could use to catch exceptions (and possibly also raise another HTTPException) is ot create a Custom Exception Handler. Execution of dependencies with yield¬∂ The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code. Info Only one response will be sent to the client. It might be one of the error responses or it will be the response from the path operation. After one of those responses is sent, no other response can be sent. Tip This diagram shows HTTPException, but you could also raise any other exception that you catch in a dependency with yield or with a Custom Exception Handler. If you raise any exception, it will be passed to the dependencies with yield, including HTTPException, and then again to the exception handlers. If there's no exception handler for that exception, it will then be handled by the default internal ServerErrorMiddleware, returning a 500 HTTP status code, to let the client know that there was an error in the server. Dependencies with yield, HTTPException and Background Tasks¬∂ Warning You most probably don't need these technical details, you can skip this section and continue below. These details are useful mainly if you were using a version of FastAPI prior to 0.106.0 and used resources from dependencies with yield in background tasks. Before FastAPI 0.106.0, raising exceptions after yield was not possible, the exit code in dependencies with yield was executed after the response was sent, so Exception Handlers would have already run. This was designed this way mainly to allow using the same objects \"yielded\" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished. Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0. Tip Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection). So, this way you will probably have cleaner code. If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with yield. For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function. Context Managers¬∂ What are \"Context Managers\"¬∂ \"Context Managers\" are any of those Python objects that you can use in a with statement. For example, you can use with to read a file: with open(\"./somefile.txt\") as f: contents = f.read() print(contents) Underneath, the open(\"./somefile.txt\") creates an object that is a called a \"Context Manager\". When the with block finishes, it makes sure to close the file, even if there were exceptions. When you create a dependency with yield, FastAPI will internally create a context manager for it, and combine it with some other related tools. Using context managers in dependencies with yield¬∂ Warning This is, more or less, an \"advanced\" idea. If you are just starting with FastAPI you might want to skip it for now. In Python, you can create Context Managers by creating a class with two methods: \\_\\_enter\\_\\_() and \\_\\_exit\\_\\_(). You can also use them inside of FastAPI dependencies with yield by using with or async with statements inside of the dependency function: class MySuperContextManager: def \\_\\_init\\_\\_(self): self.db = DBSession() def \\_\\_enter\\_\\_(self): return self.db def \\_\\_exit\\_\\_(self, exc\\_type, exc\\_value, traceback): self.db.close() async def get\\_db(): with MySuperContextManager() as db: yield db Tip Another way to create a context manager is with: @contextlib.contextmanager or @contextlib.asynccontextmanager using them to decorate a function with a single yield. That's what FastAPI uses internally for dependencies with yield. But you don't have to use the decorators for FastAPI dependencies (and you shouldn't). FastAPI will do it for you internally. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Security - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/security/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Security en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Security - First Steps Get Current User Simple OAuth2 with Password and Bearer OAuth2 with Password (and hashing), Bearer with JWT tokens Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents In a hurry? OAuth2 OAuth 1 OpenID Connect OpenID (not \"OpenID Connect\") OpenAPI FastAPI utilities FastAPI Learn Tutorial - User Guide Security Security¬∂ There are many ways to handle security, authentication and authorization. And it normally is a complex and \"difficult\" topic. In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written). FastAPI provides several tools to help you deal with Security easily, rapidly, in a standard way, without having to study and learn all the security specifications. But first, let's check some small concepts. In a hurry?¬∂ If you don't care about any of these terms and you just need to add security with authentication based on username and password right now, skip to the next chapters. OAuth2¬∂ OAuth2 is a specification that defines several ways to handle authentication and authorization. It is quite an extensive specification and covers several complex use cases. It includes ways to authenticate using a \"third party\". That's what all the systems with \"login with Facebook, Google, Twitter, GitHub\" use underneath. OAuth 1¬∂ There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication. It is not very popular or used nowadays. OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS. Tip In the section about deployment you will see how to set up HTTPS for free, using Traefik and Let's Encrypt. OpenID Connect¬∂ OpenID Connect is another specification, based on OAuth2. It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable. For example, Google login uses OpenID Connect (which underneath uses OAuth2). But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2. OpenID (not \"OpenID Connect\")¬∂ There was also an \"OpenID\" specification. That tried to solve the same thing as OpenID Connect, but was not based on OAuth2. So, it was a complete additional system. It is not very popular or used nowadays. OpenAPI¬∂ OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation). FastAPI is based on OpenAPI. That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc. OpenAPI has a way to define multiple security \"schemes\". By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems. OpenAPI defines the following security schemes: apiKey: an application specific key that can come from: A query parameter. A header. A cookie. http: standard HTTP authentication systems, including: bearer: a header Authorization with a value of Bearer plus a token. This is inherited from OAuth2. HTTP Basic authentication. HTTP Digest, etc. oauth2: all the OAuth2 ways to handle security (called \"flows\"). Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc): implicit clientCredentials authorizationCode But there is one specific \"flow\" that can be perfectly used for handling authentication in the same application directly: password: some next chapters will cover examples of this. openIdConnect: has a way to define how to discover OAuth2 authentication data automatically. This automatic discovery is what is defined in the OpenID Connect specification. Tip Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy. The most complex problem is building an authentication/authorization provider like those, but FastAPI gives you the tools to do it easily, while doing the heavy lifting for you. FastAPI utilities¬∂ FastAPI provides several tools for each of these security schemes in the fastapi.security module that simplify using these security mechanisms. In the next chapters you will see how to add security to your API using those tools provided by FastAPI. And you will also see how it gets automatically integrated into the interactive documentation system. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Sub-dependencies - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/dependencies/sub-dependencies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Sub-dependencies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents First dependency \"dependable\" Second dependency, \"dependable\" and \"dependant\" Use the dependency Using the same dependency multiple times Recap FastAPI Learn Tutorial - User Guide Dependencies Sub-dependencies¬∂ You can create dependencies that have sub-dependencies. They can be as deep as you need them to be. FastAPI will take care of solving them. First dependency \"dependable\"¬∂ You could create a first dependency (\"dependable\") like: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10 non-Annotated Python 3.8 non-Annotated from typing import Annotated from fastapi import Cookie, Depends, FastAPI app = FastAPI() def query\\_extractor(q: str | None = None): return q def query\\_or\\_cookie\\_extractor( q: Annotated\\[str, Depends(query\\_extractor)\\], last\\_query: Annotated\\[str | None, Cookie()\\] = None, ): if not q: return last\\_query return q @app.get(\"/items/\") async def read\\_query( query\\_or\\_default: Annotated\\[str, Depends(query\\_or\\_cookie\\_extractor)\\] ): return {\"q\\_or\\_cookie\": query\\_or\\_default} It declares an optional query parameter q as a str, and then it just returns it. This is quite simple (not very useful), but will help us focus on how the sub-dependencies work. Second dependency, \"dependable\" and \"dependant\"¬∂ Then you can create another dependency function (a \"dependable\") that at the same time declares a dependency of its own (so it is a \"dependant\" too): Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10 non-Annotated Python 3.8 non-Annotated from typing import Annotated from fastapi import Cookie, Depends, FastAPI app = FastAPI() def query\\_extractor(q: str | None = None): return q def query\\_or\\_cookie\\_extractor( q: Annotated\\[str, Depends(query\\_extractor)\\], last\\_query: Annotated\\[str | None, Cookie()\\] = None, ): if not q: return last\\_query return q @app.get(\"/items/\") async def read\\_query( query\\_or\\_default: Annotated\\[str, Depends(query\\_or\\_cookie\\_extractor)\\] ): return {\"q\\_or\\_cookie\": query\\_or\\_default} Let's focus on the parameters declared: Even though this function is a dependency (\"dependable\") itself, it also declares another dependency (it \"depends\" on something else). It depends on the query\\_extractor, and assigns the value returned by it to the parameter q. It also declares an optional last\\_query cookie, as a str. If the user didn't provide any query q, we use the last query used, which we saved to a cookie before. Use the dependency¬∂ Then we can use the dependency with: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10 non-Annotated Python 3.8 non-Annotated from typing import Annotated from fastapi import Cookie, Depends, FastAPI app = FastAPI() def query\\_extractor(q: str | None = None): return q def query\\_or\\_cookie\\_extractor( q: Annotated\\[str, Depends(query\\_extractor)\\], last\\_query: Annotated\\[str | None, Cookie()\\] = None, ): if not q: return last\\_query return q @app.get(\"/items/\") async def read\\_query( query\\_or\\_default: Annotated\\[str, Depends(query\\_or\\_cookie\\_extractor)\\] ): return {\"q\\_or\\_cookie\": query\\_or\\_default} Info Notice that we are only declaring one dependency in the path operation function, the query\\_or\\_cookie\\_extractor. But FastAPI will know that it has to solve query\\_extractor first, to pass the results of that to query\\_or\\_cookie\\_extractor while calling it. Using the same dependency multiple times¬∂ If one of your dependencies is declared multiple times for the same path operation, for example, multiple dependencies have a common sub-dependency, FastAPI will know to call that sub-dependency only once per request. And it will save the returned value in a \"cache\" and pass it to all the \"dependants\" that need it in that specific request, instead of calling the dependency multiple times for the same request. In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the \"cached\" value, you can set the parameter use\\_cache=False when using Depends: Python 3.8+ Python 3.8+ non-Annotated async def needy\\_dependency(fresh\\_value: Annotated\\[str, Depends(get\\_value, use\\_cache=False)\\]): return {\"fresh\\_value\": fresh\\_value} Recap¬∂ Apart from all the fancy words used here, the Dependency Injection system is quite simple. Just functions that look the same as the path operation functions. But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency \"graphs\" (trees). Tip All this might not seem as useful with these simple examples. But you will see how useful it is in the chapters about security. And you will also see the amounts of code it will save you. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Dependencies in path operation decorators - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/dependencies/dependencies-in-path-operation-decorators/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Dependencies in path operation decorators en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Add dependencies to the path operation decorator Dependencies errors and return values Dependency requirements Raise exceptions Return values Dependencies for a group of path operations Global Dependencies FastAPI Learn Tutorial - User Guide Dependencies Dependencies in path operation decorators¬∂ In some cases you don't really need the return value of a dependency inside your path operation function. Or the dependency doesn't return a value. But you still need it to be executed/solved. For those cases, instead of declaring a path operation function parameter with Depends, you can add a list of dependencies to the path operation decorator. Add dependencies to the path operation decorator¬∂ The path operation decorator receives an optional argument dependencies. It should be a list of Depends(): Python 3.9+ Python 3.8+ Python 3.8 non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, Header, HTTPException app = FastAPI() async def verify\\_token(x\\_token: Annotated\\[str, Header()\\]): if x\\_token != \"fake-super-secret-token\": raise HTTPException(status\\_code=400, detail=\"X-Token header invalid\") async def verify\\_key(x\\_key: Annotated\\[str, Header()\\]): if x\\_key != \"fake-super-secret-key\": raise HTTPException(status\\_code=400, detail=\"X-Key header invalid\") return x\\_key @app.get(\"/items/\", dependencies=\\[Depends(verify\\_token), Depends(verify\\_key)\\]) async def read\\_items(): return \\[{\"item\": \"Foo\"}, {\"item\": \"Bar\"}\\] These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your path operation function. Tip Some editors check for unused function parameters, and show them as errors. Using these dependencies in the path operation decorator you can make sure they are executed while avoiding editor/tooling errors. It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary. Info In this example we use invented custom headers X-Key and X-Token. But in real cases, when implementing security, you would get more benefits from using the integrated Security utilities (the next chapter). Dependencies errors and return values¬∂ You can use the same dependency functions you use normally. Dependency requirements¬∂ They can declare request requirements (like headers) or other sub-dependencies: Python 3.9+ Python 3.8+ Python 3.8 non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, Header, HTTPException app = FastAPI() async def verify\\_token(x\\_token: Annotated\\[str, Header()\\]): if x\\_token != \"fake-super-secret-token\": raise HTTPException(status\\_code=400, detail=\"X-Token header invalid\") async def verify\\_key(x\\_key: Annotated\\[str, Header()\\]): if x\\_key != \"fake-super-secret-key\": raise HTTPException(status\\_code=400, detail=\"X-Key header invalid\") return x\\_key @app.get(\"/items/\", dependencies=\\[Depends(verify\\_token), Depends(verify\\_key)\\]) async def read\\_items(): return \\[{\"item\": \"Foo\"}, {\"item\": \"Bar\"}\\] Raise exceptions¬∂ These dependencies can raise exceptions, the same as normal dependencies: Python 3.9+ Python 3.8+ Python 3.8 non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, Header, HTTPException app = FastAPI() async def verify\\_token(x\\_token: Annotated\\[str, Header()\\]): if x\\_token != \"fake-super-secret-token\": raise HTTPException(status\\_code=400, detail=\"X-Token header invalid\") async def verify\\_key(x\\_key: Annotated\\[str, Header()\\]): if x\\_key != \"fake-super-secret-key\": raise HTTPException(status\\_code=400, detail=\"X-Key header invalid\") return x\\_key @app.get(\"/items/\", dependencies=\\[Depends(verify\\_token), Depends(verify\\_key)\\]) async def read\\_items(): return \\[{\"item\": \"Foo\"}, {\"item\": \"Bar\"}\\] Return values¬∂ And they can return values or not, the values won't be used. So, you can re-use a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed: Python 3.9+ Python 3.8+ Python 3.8 non-Annotated from typing import Annotated from fastapi import Depends, FastAPI, Header, HTTPException app = FastAPI() async def verify\\_token(x\\_token: Annotated\\[str, Header()\\]): if x\\_token != \"fake-super-secret-token\": raise HTTPException(status\\_code=400, detail=\"X-Token header invalid\") async def verify\\_key(x\\_key: Annotated\\[str, Header()\\]): if x\\_key != \"fake-super-secret-key\": raise HTTPException(status\\_code=400, detail=\"X-Key header invalid\") return x\\_key @app.get(\"/items/\", dependencies=\\[Depends(verify\\_token), Depends(verify\\_key)\\]) async def read\\_items(): return \\[{\"item\": \"Foo\"}, {\"item\": \"Bar\"}\\] Dependencies for a group of path operations¬∂ Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations. Global Dependencies¬∂ Next we will see how to add dependencies to the whole FastAPI application, so that they apply to each path operation. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Global Dependencies - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/dependencies/global-dependencies/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Global Dependencies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Dependencies for groups of path operations FastAPI Learn Tutorial - User Guide Dependencies Global Dependencies¬∂ For some types of applications you might want to add dependencies to the whole application. Similar to the way you can add dependencies to the path operation decorators, you can add them to the FastAPI application. In that case, they will be applied to all the path operations in the application: Python 3.9+ Python 3.8+ Python 3.8 non-Annotated from fastapi import Depends, FastAPI, Header, HTTPException from typing\\_extensions import Annotated async def verify\\_token(x\\_token: Annotated\\[str, Header()\\]): if x\\_token != \"fake-super-secret-token\": raise HTTPException(status\\_code=400, detail=\"X-Token header invalid\") async def verify\\_key(x\\_key: Annotated\\[str, Header()\\]): if x\\_key != \"fake-super-secret-key\": raise HTTPException(status\\_code=400, detail=\"X-Key header invalid\") return x\\_key app = FastAPI(dependencies=\\[Depends(verify\\_token), Depends(verify\\_key)\\]) @app.get(\"/items/\") async def read\\_items(): return \\[{\"item\": \"Portal Gun\"}, {\"item\": \"Plumbus\"}\\] @app.get(\"/users/\") async def read\\_users(): return \\[{\"username\": \"Rick\"}, {\"username\": \"Morty\"}\\] And all the ideas in the section about adding dependencies to the path operation decorators still apply, but in this case, to all of the path operations in the app. Dependencies for groups of path operations¬∂ Later, when reading about how to structure bigger applications (Bigger Applications - Multiple Files), possibly with multiple files, you will learn how to declare a single dependencies parameter for a group of path operations. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Classes as Dependencies - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Classes as Dependencies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents A dict from the previous example What makes a dependency Classes as dependencies Use it Type annotation vs Depends Shortcut FastAPI Learn Tutorial - User Guide Dependencies Classes as Dependencies¬∂ Before diving deeper into the Dependency Injection system, let's upgrade the previous example. A dict from the previous example¬∂ In the previous example, we were returning a dict from our dependency (\"dependable\"): Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons @app.get(\"/users/\") async def read\\_users(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons But then we get a dict in the parameter commons of the path operation function. And we know that editors can't provide a lot of support (like completion) for dicts, because they can't know their keys and value types. We can do better... What makes a dependency¬∂ Up to now you have seen dependencies declared as functions. But that's not the only way to declare dependencies (although it would probably be the more common). The key factor is that a dependency should be a \"callable\". A \"callable\" in Python is anything that Python can \"call\" like a function. So, if you have an object something (that might not be a function) and you can \"call\" it (execute it) like: something() or something(some\\_argument, some\\_keyword\\_argument=\"foo\") then it is a \"callable\". Classes as dependencies¬∂ You might notice that to create an instance of a Python class, you use that same syntax. For example: class Cat: def \\_\\_init\\_\\_(self, name: str): self.name = name fluffy = Cat(name=\"Mr Fluffy\") In this case, fluffy is an instance of the class Cat. And to create fluffy, you are \"calling\" Cat. So, a Python class is also a callable. Then, in FastAPI, you could use a Python class as a dependency. What FastAPI actually checks is that it is a \"callable\" (function, class or anything else) and the parameters defined. If you pass a \"callable\" as a dependency in FastAPI, it will analyze the parameters for that \"callable\", and process them in the same way as the parameters for a path operation function. Including sub-dependencies. That also applies to callables with no parameters at all. The same as it would be for path operation functions with no parameters. Then, we can change the dependency \"dependable\" common\\_parameters from above to the class CommonQueryParams: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() fake\\_items\\_db = \\[{\"item\\_name\": \"Foo\"}, {\"item\\_name\": \"Bar\"}, {\"item\\_name\": \"Baz\"}\\] class CommonQueryParams: def \\_\\_init\\_\\_(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[CommonQueryParams, Depends(CommonQueryParams)\\]): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake\\_items\\_db\\[commons.skip : commons.skip + commons.limit\\] response.update({\"items\": items}) return response Pay attention to the \\_\\_init\\_\\_ method used to create the instance of the class: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() fake\\_items\\_db = \\[{\"item\\_name\": \"Foo\"}, {\"item\\_name\": \"Bar\"}, {\"item\\_name\": \"Baz\"}\\] class CommonQueryParams: def \\_\\_init\\_\\_(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[CommonQueryParams, Depends(CommonQueryParams)\\]): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake\\_items\\_db\\[commons.skip : commons.skip + commons.limit\\] response.update({\"items\": items}) return response ...it has the same parameters as our previous common\\_parameters: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons @app.get(\"/users/\") async def read\\_users(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons Those parameters are what FastAPI will use to \"solve\" the dependency. In both cases, it will have: An optional q query parameter that is a str. A skip query parameter that is an int, with a default of 0. A limit query parameter that is an int, with a default of 100. In both cases the data will be converted, validated, documented on the OpenAPI schema, etc. Use it¬∂ Now you can declare your dependency using this class. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() fake\\_items\\_db = \\[{\"item\\_name\": \"Foo\"}, {\"item\\_name\": \"Bar\"}, {\"item\\_name\": \"Baz\"}\\] class CommonQueryParams: def \\_\\_init\\_\\_(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[CommonQueryParams, Depends(CommonQueryParams)\\]): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake\\_items\\_db\\[commons.skip : commons.skip + commons.limit\\] response.update({\"items\": items}) return response FastAPI calls the CommonQueryParams class. This creates an \"instance\" of that class and the instance will be passed as the parameter commons to your function. Type annotation vs Depends¬∂ Notice how we write CommonQueryParams twice in the above code: Python 3.8+ non-Annotated Python 3.8+ Tip Prefer to use the Annotated version if possible. commons: CommonQueryParams = Depends(CommonQueryParams) The last CommonQueryParams, in: ... Depends(CommonQueryParams) ...is what FastAPI will actually use to know what is the dependency. From it is that FastAPI will extract the declared parameters and that is what FastAPI will actually call. In this case, the first CommonQueryParams, in: Python 3.8+ Python 3.8+ non-Annotated commons: Annotated\\[CommonQueryParams, ... ...doesn't have any special meaning for FastAPI. FastAPI won't use it for data conversion, validation, etc. (as it is using the Depends(CommonQueryParams) for that). You could actually write just: Python 3.8+ Python 3.8+ non-Annotated commons: Annotated\\[Any, Depends(CommonQueryParams)\\] ..as in: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated, Any from fastapi import Depends, FastAPI app = FastAPI() fake\\_items\\_db = \\[{\"item\\_name\": \"Foo\"}, {\"item\\_name\": \"Bar\"}, {\"item\\_name\": \"Baz\"}\\] class CommonQueryParams: def \\_\\_init\\_\\_(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[Any, Depends(CommonQueryParams)\\]): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake\\_items\\_db\\[commons.skip : commons.skip + commons.limit\\] response.update({\"items\": items}) return response But declaring the type is encouraged as that way your editor will know what will be passed as the parameter commons, and then it can help you with code completion, type checks, etc: Shortcut¬∂ But you see that we are having some code repetition here, writing CommonQueryParams twice: Python 3.8+ non-Annotated Python 3.8+ Tip Prefer to use the Annotated version if possible. commons: CommonQueryParams = Depends(CommonQueryParams) FastAPI provides a shortcut for these cases, in where the dependency is specifically a class that FastAPI will \"call\" to create an instance of the class itself. For those specific cases, you can do the following: Instead of writing: Python 3.8+ Python 3.8+ non-Annotated commons: Annotated\\[CommonQueryParams, Depends(CommonQueryParams)\\] ...you write: Python 3.8+ Python 3.8 non-Annotated commons: Annotated\\[CommonQueryParams, Depends()\\] You declare the dependency as the type of the parameter, and you use Depends() without any parameter, instead of having to write the full class again inside of Depends(CommonQueryParams). The same example would then look like: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() fake\\_items\\_db = \\[{\"item\\_name\": \"Foo\"}, {\"item\\_name\": \"Bar\"}, {\"item\\_name\": \"Baz\"}\\] class CommonQueryParams: def \\_\\_init\\_\\_(self, q: str | None = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[CommonQueryParams, Depends()\\]): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake\\_items\\_db\\[commons.skip : commons.skip + commons.limit\\] response.update({\"items\": items}) return response ...and FastAPI will know what to do. Tip If that seems more confusing than helpful, disregard it, you don't need it. It is just a shortcut. Because FastAPI cares about helping you minimize code repetition. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Dependencies - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/dependencies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Dependencies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Classes as Dependencies Sub-dependencies Dependencies in path operation decorators Global Dependencies Dependencies with yield Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents What is \"Dependency Injection\" First Steps Create a dependency, or \"dependable\" Import Depends Declare the dependency, in the \"dependant\" Share Annotated dependencies To async or not to async Integrated with OpenAPI Simple usage FastAPI plug-ins FastAPI compatibility Simple and Powerful Integrated with OpenAPI FastAPI Learn Tutorial - User Guide Dependencies Dependencies¬∂ FastAPI has a very powerful but intuitive Dependency Injection system. It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with FastAPI. What is \"Dependency Injection\"¬∂ \"Dependency Injection\" means, in programming, that there is a way for your code (in this case, your path operation functions) to declare things that it requires to work and use: \"dependencies\". And then, that system (in this case FastAPI) will take care of doing whatever is needed to provide your code with those needed dependencies (\"inject\" the dependencies). This is very useful when you need to: Have shared logic (the same code logic again and again). Share database connections. Enforce security, authentication, role requirements, etc. And many other things... All these, while minimizing code repetition. First Steps¬∂ Let's see a very simple example. It will be so simple that it is not very useful, for now. But this way we can focus on how the Dependency Injection system works. Create a dependency, or \"dependable\"¬∂ Let's first focus on the dependency. It is just a function that can take all the same parameters that a path operation function can take: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons @app.get(\"/users/\") async def read\\_users(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons That's it. 2 lines. And it has the same shape and structure that all your path operation functions have. You can think of it as a path operation function without the \"decorator\" (without the @app.get(\"/some-path\")). And it can return anything you want. In this case, this dependency expects: An optional query parameter q that is a str. An optional query parameter skip that is an int, and by default is 0. An optional query parameter limit that is an int, and by default is 100. And then it just returns a dict containing those values. Info FastAPI added support for Annotated (and started recommending it) in version 0.95.0. If you have an older version, you would get errors when trying to use Annotated. Make sure you Upgrade the FastAPI version to at least 0.95.1 before using Annotated. Import Depends¬∂ Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons @app.get(\"/users/\") async def read\\_users(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons Declare the dependency, in the \"dependant\"¬∂ The same way you use Body, Query, etc. with your path operation function parameters, use Depends with a new parameter: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons @app.get(\"/users/\") async def read\\_users(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return commons Although you use Depends in the parameters of your function the same way you use Body, Query, etc, Depends works a bit differently. You only give Depends a single parameter. This parameter must be something like a function. You don't call it directly (don't add the parenthesis at the end), you just pass it as a parameter to Depends(). And that function takes parameters in the same way that path operation functions do. Tip You'll see what other \"things\", apart from functions, can be used as dependencies in the next chapter. Whenever a new request arrives, FastAPI will take care of: Calling your dependency (\"dependable\") function with the correct parameters. Get the result from your function. Assign that result to the parameter in your path operation function. This way you write shared code once and FastAPI takes care of calling it for your path operations. Check Notice that you don't have to create a special class and pass it somewhere to FastAPI to \"register\" it or anything similar. You just pass it to Depends and FastAPI knows how to do the rest. Share Annotated dependencies¬∂ In the examples above, you see that there's a tiny bit of code duplication. When you need to use the common\\_parameters() dependency, you have to write the whole parameter with the type annotation and Depends(): commons: Annotated\\[dict, Depends(common\\_parameters)\\] But because we are using Annotated, we can store that Annotated value in a variable and use it in multiple places: Python 3.10+ Python 3.9+ Python 3.8+ from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} CommonsDep = Annotated\\[dict, Depends(common\\_parameters)\\] @app.get(\"/items/\") async def read\\_items(commons: CommonsDep): return commons @app.get(\"/users/\") async def read\\_users(commons: CommonsDep): return commons Tip This is just standard Python, it's called a \"type alias\", it's actually not specific to FastAPI. But because FastAPI is based on the Python standards, including Annotated, you can use this trick in your code. üòé The dependencies will keep working as expected, and the best part is that the type information will be preserved, which means that your editor will be able to keep providing you with autocompletion, inline errors, etc. The same for other tools like mypy. This will be especially useful when you use it in a large code base where you use the same dependencies over and over again in many path operations. To async or not to async¬∂ As dependencies will also be called by FastAPI (the same as your path operation functions), the same rules apply while defining your functions. You can use async def or normal def. And you can declare dependencies with async def inside of normal def path operation functions, or def dependencies inside of async def path operation functions, etc. It doesn't matter. FastAPI will know what to do. Note If you don't know, check the Async: \"In a hurry?\" section about async and await in the docs. Integrated with OpenAPI¬∂ All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema. So, the interactive docs will have all the information from these dependencies too: Simple usage¬∂ If you look at it, path operation functions are declared to be used whenever a path and operation matches, and then FastAPI takes care of calling the function with the correct parameters, extracting the data from the request. Actually, all (or most) of the web frameworks work in this same way. You never call those functions directly. They are called by your framework (in this case, FastAPI). With the Dependency Injection system, you can also tell FastAPI that your path operation function also \"depends\" on something else that should be executed before your path operation function, and FastAPI will take care of executing it and \"injecting\" the results. Other common terms for this same idea of \"dependency injection\" are: resources providers services injectables components FastAPI plug-ins¬∂ Integrations and \"plug-in\"s can be built using the Dependency Injection system. But in fact, there is actually no need to create \"plug-ins\", as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your path operation functions. And dependencies can be created in a very simple and intuitive way that allow you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, literally. You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc. FastAPI compatibility¬∂ The simplicity of the dependency injection system makes FastAPI compatible with: all the relational databases NoSQL databases external packages external APIs authentication and authorization systems API usage monitoring systems response data injection systems etc. Simple and Powerful¬∂ Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful. You can define dependencies that in turn can define dependencies themselves. In the end, a hierarchical tree of dependencies is built, and the Dependency Injection system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step. For example, let's say you have 4 API endpoints (path operations): /items/public/ /items/private/ /users/{user\\_id}/activate /items/pro/ then you could add different permission requirements for each of them just with dependencies and sub-dependencies: Integrated with OpenAPI¬∂ All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your path operations. FastAPI will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Body - Updates - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/body-updates/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Body - Updates en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Update replacing with PUT Warning about replacing Partial updates with PATCH Using Pydantic's exclude\\_unset parameter Using Pydantic's update parameter Partial updates recap FastAPI Learn Tutorial - User Guide Body - Updates¬∂ Update replacing with PUT¬∂ To update an item you can use the HTTP PUT operation. You can use the jsonable\\_encoder to convert the input data to data that can be stored as JSON (e.g. with a NoSQL database). For example, converting datetime to str. Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from fastapi.encoders import jsonable\\_encoder from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.5 tags: list\\[str\\] = \\[\\] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\]}, } @app.get(\"/items/{item\\_id}\", response\\_model=Item) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] @app.put(\"/items/{item\\_id}\", response\\_model=Item) async def update\\_item(item\\_id: str, item: Item): update\\_item\\_encoded = jsonable\\_encoder(item) items\\[item\\_id\\] = update\\_item\\_encoded return update\\_item\\_encoded PUT is used to receive data that should replace the existing data. Warning about replacing¬∂ That means that if you want to update the item bar using PUT with a body containing: { \"name\": \"Barz\", \"price\": 3, \"description\": None, } because it doesn't include the already stored attribute \"tax\": 20.2, the input model would take the default value of \"tax\": 10.5. And the data would be saved with that \"new\" tax of 10.5. Partial updates with PATCH¬∂ You can also use the HTTP PATCH operation to partially update data. This means that you can send only the data that you want to update, leaving the rest intact. Note PATCH is less commonly used and known than PUT. And many teams use only PUT, even for partial updates. You are free to use them however you want, FastAPI doesn't impose any restrictions. But this guide shows you, more or less, how they are intended to be used. Using Pydantic's exclude\\_unset parameter¬∂ If you want to receive partial updates, it's very useful to use the parameter exclude\\_unset in Pydantic's model's .dict(). Like item.dict(exclude\\_unset=True). That would generate a dict with only the data that was set when creating the item model, excluding default values. Then you can use this to generate a dict with only the data that was set (sent in the request), omitting default values: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from fastapi.encoders import jsonable\\_encoder from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.5 tags: list\\[str\\] = \\[\\] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\]}, } @app.get(\"/items/{item\\_id}\", response\\_model=Item) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] @app.patch(\"/items/{item\\_id}\", response\\_model=Item) async def update\\_item(item\\_id: str, item: Item): stored\\_item\\_data = items\\[item\\_id\\] stored\\_item\\_model = Item(\\*\\*stored\\_item\\_data) update\\_data = item.dict(exclude\\_unset=True) updated\\_item = stored\\_item\\_model.copy(update=update\\_data) items\\[item\\_id\\] = jsonable\\_encoder(updated\\_item) return updated\\_item Using Pydantic's update parameter¬∂ Now, you can create a copy of the existing model using .copy(), and pass the update parameter with a dict containing the data to update. Like stored\\_item\\_model.copy(update=update\\_data): Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from fastapi.encoders import jsonable\\_encoder from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.5 tags: list\\[str\\] = \\[\\] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\]}, } @app.get(\"/items/{item\\_id}\", response\\_model=Item) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] @app.patch(\"/items/{item\\_id}\", response\\_model=Item) async def update\\_item(item\\_id: str, item: Item): stored\\_item\\_data = items\\[item\\_id\\] stored\\_item\\_model = Item(\\*\\*stored\\_item\\_data) update\\_data = item.dict(exclude\\_unset=True) updated\\_item = stored\\_item\\_model.copy(update=update\\_data) items\\[item\\_id\\] = jsonable\\_encoder(updated\\_item) return updated\\_item Partial updates recap¬∂ In summary, to apply partial updates you would: (Optionally) use PATCH instead of PUT. Retrieve the stored data. Put that data in a Pydantic model. Generate a dict without default values from the input model (using exclude\\_unset). This way you can update only the values actually set by the user, instead of overriding values already stored with default values in your model. Create a copy of the stored model, updating it's attributes with the received partial updates (using the update parameter). Convert the copied model to something that can be stored in your DB (for example, using the jsonable\\_encoder). This is comparable to using the model's .dict() method again, but it makes sure (and converts) the values to data types that can be converted to JSON, for example, datetime to str. Save the data to your DB. Return the updated model. Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from fastapi.encoders import jsonable\\_encoder from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str | None = None description: str | None = None price: float | None = None tax: float = 10.5 tags: list\\[str\\] = \\[\\] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\]}, } @app.get(\"/items/{item\\_id}\", response\\_model=Item) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] @app.patch(\"/items/{item\\_id}\", response\\_model=Item) async def update\\_item(item\\_id: str, item: Item): stored\\_item\\_data = items\\[item\\_id\\] stored\\_item\\_model = Item(\\*\\*stored\\_item\\_data) update\\_data = item.dict(exclude\\_unset=True) updated\\_item = stored\\_item\\_model.copy(update=update\\_data) items\\[item\\_id\\] = jsonable\\_encoder(updated\\_item) return updated\\_item Tip You can actually use this same technique with an HTTP PUT operation. But the example here uses PATCH because it was created for these use cases. Note Notice that the input model is still validated. So, if you want to receive partial updates that can omit all the attributes, you need to have a model with all the attributes marked as optional (with default values or None). To distinguish from the models with all optional values for updates and models with required values for creation, you can use the ideas described in Extra Models. Made with Material for MkDocs Insiders"
  },
  {
    "title": "JSON Compatible Encoder - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/encoder/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI JSON Compatible Encoder en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Using the jsonable\\_encoder FastAPI Learn Tutorial - User Guide JSON Compatible Encoder¬∂ There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a dict, list, etc). For example, if you need to store it in a database. For that, FastAPI provides a jsonable\\_encoder() function. Using the jsonable\\_encoder¬∂ Let's imagine that you have a database fake\\_db that only receives JSON compatible data. For example, it doesn't receive datetime objects, as those are not compatible with JSON. So, a datetime object would have to be converted to a str containing the data in ISO format. The same way, this database wouldn't receive a Pydantic model (an object with attributes), only a dict. You can use jsonable\\_encoder for that. It receives an object, like a Pydantic model, and returns a JSON compatible version: Python 3.10+ Python 3.8+ from datetime import datetime from fastapi import FastAPI from fastapi.encoders import jsonable\\_encoder from pydantic import BaseModel fake\\_db = {} class Item(BaseModel): title: str timestamp: datetime description: str | None = None app = FastAPI() @app.put(\"/items/{id}\") def update\\_item(id: str, item: Item): json\\_compatible\\_item\\_data = jsonable\\_encoder(item) fake\\_db\\[id\\] = json\\_compatible\\_item\\_data In this example, it would convert the Pydantic model to a dict, and the datetime to a str. The result of calling it is something that can be encoded with the Python standard json.dumps(). It doesn't return a large str containing the data in JSON format (as a string). It returns a Python standard data structure (e.g. a dict) with values and sub-values that are all compatible with JSON. Note jsonable\\_encoder is actually used by FastAPI internally to convert data. But it is useful in many other scenarios. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Path Operation Configuration - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/path-operation-configuration/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Path Operation Configuration en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Response Status Code Tags Tags with Enums Summary and description Description from docstring Response description Deprecate a path operation Recap FastAPI Learn Tutorial - User Guide Path Operation Configuration¬∂ There are several parameters that you can pass to your path operation decorator to configure it. Warning Notice that these parameters are passed directly to the path operation decorator, not to your path operation function. Response Status Code¬∂ You can define the (HTTP) status\\_code to be used in the response of your path operation. You can pass directly the int code, like 404. But if you don't remember what each number code is for, you can use the shortcut constants in status: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI, status from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() @app.post(\"/items/\", response\\_model=Item, status\\_code=status.HTTP\\_201\\_CREATED) async def create\\_item(item: Item): return item That status code will be used in the response and will be added to the OpenAPI schema. Technical Details You could also use from starlette import status. FastAPI provides the same starlette.status as fastapi.status just as a convenience for you, the developer. But it comes directly from Starlette. Tags¬∂ You can add tags to your path operation, pass the parameter tags with a list of str (commonly just one str): Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() @app.post(\"/items/\", response\\_model=Item, tags=\\[\"items\"\\]) async def create\\_item(item: Item): return item @app.get(\"/items/\", tags=\\[\"items\"\\]) async def read\\_items(): return \\[{\"name\": \"Foo\", \"price\": 42}\\] @app.get(\"/users/\", tags=\\[\"users\"\\]) async def read\\_users(): return \\[{\"username\": \"johndoe\"}\\] They will be added to the OpenAPI schema and used by the automatic documentation interfaces: Tags with Enums¬∂ If you have a big application, you might end up accumulating several tags, and you would want to make sure you always use the same tag for related path operations. In these cases, it could make sense to store the tags in an Enum. FastAPI supports that the same way as with plain strings: from enum import Enum from fastapi import FastAPI app = FastAPI() class Tags(Enum): items = \"items\" users = \"users\" @app.get(\"/items/\", tags=\\[Tags.items\\]) async def get\\_items(): return \\[\"Portal gun\", \"Plumbus\"\\] @app.get(\"/users/\", tags=\\[Tags.users\\]) async def read\\_users(): return \\[\"Rick\", \"Morty\"\\] Summary and description¬∂ You can add a summary and description: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() @app.post( \"/items/\", response\\_model=Item, summary=\"Create an item\", description=\"Create an item with all the information, name, description, price, tax and a set of unique tags\", ) async def create\\_item(item: Item): return item Description from docstring¬∂ As descriptions tend to be long and cover multiple lines, you can declare the path operation description in the function docstring and FastAPI will read it from there. You can write Markdown in the docstring, it will be interpreted and displayed correctly (taking into account docstring indentation). Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() @app.post(\"/items/\", response\\_model=Item, summary=\"Create an item\") async def create\\_item(item: Item): \"\"\" Create an item with all the information: - \\*\\*name\\*\\*: each item must have a name - \\*\\*description\\*\\*: a long description - \\*\\*price\\*\\*: required - \\*\\*tax\\*\\*: if the item doesn't have tax, you can omit this - \\*\\*tags\\*\\*: a set of unique tag strings for this item \"\"\" return item It will be used in the interactive docs: Response description¬∂ You can specify the response description with the parameter response\\_description: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() @app.post( \"/items/\", response\\_model=Item, summary=\"Create an item\", response\\_description=\"The created item\", ) async def create\\_item(item: Item): \"\"\" Create an item with all the information: - \\*\\*name\\*\\*: each item must have a name - \\*\\*description\\*\\*: a long description - \\*\\*price\\*\\*: required - \\*\\*tax\\*\\*: if the item doesn't have tax, you can omit this - \\*\\*tags\\*\\*: a set of unique tag strings for this item \"\"\" return item Info Notice that response\\_description refers specifically to the response, the description refers to the path operation in general. Check OpenAPI specifies that each path operation requires a response description. So, if you don't provide one, FastAPI will automatically generate one of \"Successful response\". Deprecate a path operation¬∂ If you need to mark a path operation as deprecated, but without removing it, pass the parameter deprecated: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", tags=\\[\"items\"\\]) async def read\\_items(): return \\[{\"name\": \"Foo\", \"price\": 42}\\] @app.get(\"/users/\", tags=\\[\"users\"\\]) async def read\\_users(): return \\[{\"username\": \"johndoe\"}\\] @app.get(\"/elements/\", tags=\\[\"items\"\\], deprecated=True) async def read\\_elements(): return \\[{\"item\\_id\": \"Foo\"}\\] It will be clearly marked as deprecated in the interactive docs: Check how deprecated and non-deprecated path operations look like: Recap¬∂ You can configure and add metadata for your path operations easily by passing parameters to the path operation decorators. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Handling Errors - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/handling-errors/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Handling Errors en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Use HTTPException Import HTTPException Raise an HTTPException in your code The resulting response Add custom headers Install custom exception handlers Override the default exception handlers Override request validation exceptions RequestValidationError vs ValidationError Override the HTTPException error handler Use the RequestValidationError body FastAPI's HTTPException vs Starlette's HTTPException Re-use FastAPI's exception handlers FastAPI Learn Tutorial - User Guide Handling Errors¬∂ There are many situations in which you need to notify an error to a client that is using your API. This client could be a browser with a frontend, a code from someone else, an IoT device, etc. You could need to tell the client that: The client doesn't have enough privileges for that operation. The client doesn't have access to that resource. The item the client was trying to access doesn't exist. etc. In these cases, you would normally return an HTTP status code in the range of 400 (from 400 to 499). This is similar to the 200 HTTP status codes (from 200 to 299). Those \"200\" status codes mean that somehow there was a \"success\" in the request. The status codes in the 400 range mean that there was an error from the client. Remember all those \"404 Not Found\" errors (and jokes)? Use HTTPException¬∂ To return HTTP responses with errors to the client you use HTTPException. Import HTTPException¬∂ from fastapi import FastAPI, HTTPException app = FastAPI() items = {\"foo\": \"The Foo Wrestlers\"} @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: str): if item\\_id not in items: raise HTTPException(status\\_code=404, detail=\"Item not found\") return {\"item\": items\\[item\\_id\\]} Raise an HTTPException in your code¬∂ HTTPException is a normal Python exception with additional data relevant for APIs. Because it's a Python exception, you don't return it, you raise it. This also means that if you are inside a utility function that you are calling inside of your path operation function, and you raise the HTTPException from inside of that utility function, it won't run the rest of the code in the path operation function, it will terminate that request right away and send the HTTP error from the HTTPException to the client. The benefit of raising an exception over returning a value will be more evident in the section about Dependencies and Security. In this example, when the client requests an item by an ID that doesn't exist, raise an exception with a status code of 404: from fastapi import FastAPI, HTTPException app = FastAPI() items = {\"foo\": \"The Foo Wrestlers\"} @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: str): if item\\_id not in items: raise HTTPException(status\\_code=404, detail=\"Item not found\") return {\"item\": items\\[item\\_id\\]} The resulting response¬∂ If the client requests http://example.com/items/foo (an item\\_id \"foo\"), that client will receive an HTTP status code of 200, and a JSON response of: { \"item\": \"The Foo Wrestlers\" } But if the client requests http://example.com/items/bar (a non-existent item\\_id \"bar\"), that client will receive an HTTP status code of 404 (the \"not found\" error), and a JSON response of: { \"detail\": \"Item not found\" } Tip When raising an HTTPException, you can pass any value that can be converted to JSON as the parameter detail, not only str. You could pass a dict, a list, etc. They are handled automatically by FastAPI and converted to JSON. Add custom headers¬∂ There are some situations in where it's useful to be able to add custom headers to the HTTP error. For example, for some types of security. You probably won't need to use it directly in your code. But in case you needed it for an advanced scenario, you can add custom headers: from fastapi import FastAPI, HTTPException app = FastAPI() items = {\"foo\": \"The Foo Wrestlers\"} @app.get(\"/items-header/{item\\_id}\") async def read\\_item\\_header(item\\_id: str): if item\\_id not in items: raise HTTPException( status\\_code=404, detail=\"Item not found\", headers={\"X-Error\": \"There goes my error\"}, ) return {\"item\": items\\[item\\_id\\]} Install custom exception handlers¬∂ You can add custom exception handlers with the same exception utilities from Starlette. Let's say you have a custom exception UnicornException that you (or a library you use) might raise. And you want to handle this exception globally with FastAPI. You could add a custom exception handler with @app.exception\\_handler(): from fastapi import FastAPI, Request from fastapi.responses import JSONResponse class UnicornException(Exception): def \\_\\_init\\_\\_(self, name: str): self.name = name app = FastAPI() @app.exception\\_handler(UnicornException) async def unicorn\\_exception\\_handler(request: Request, exc: UnicornException): return JSONResponse( status\\_code=418, content={\"message\": f\"Oops! {exc.name} did something. There goes a rainbow...\"}, ) @app.get(\"/unicorns/{name}\") async def read\\_unicorn(name: str): if name == \"yolo\": raise UnicornException(name=name) return {\"unicorn\\_name\": name} Here, if you request /unicorns/yolo, the path operation will raise a UnicornException. But it will be handled by the unicorn\\_exception\\_handler. So, you will receive a clean error, with an HTTP status code of 418 and a JSON content of: {\"message\": \"Oops! yolo did something. There goes a rainbow...\"} Technical Details You could also use from starlette.requests import Request and from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with Request. Override the default exception handlers¬∂ FastAPI has some default exception handlers. These handlers are in charge of returning the default JSON responses when you raise an HTTPException and when the request has invalid data. You can override these exception handlers with your own. Override request validation exceptions¬∂ When a request contains invalid data, FastAPI internally raises a RequestValidationError. And it also includes a default exception handler for it. To override it, import the RequestValidationError and use it with @app.exception\\_handler(RequestValidationError) to decorate the exception handler. The exception handler will receive a Request and the exception. from fastapi import FastAPI, HTTPException from fastapi.exceptions import RequestValidationError from fastapi.responses import PlainTextResponse from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI() @app.exception\\_handler(StarletteHTTPException) async def http\\_exception\\_handler(request, exc): return PlainTextResponse(str(exc.detail), status\\_code=exc.status\\_code) @app.exception\\_handler(RequestValidationError) async def validation\\_exception\\_handler(request, exc): return PlainTextResponse(str(exc), status\\_code=400) @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: int): if item\\_id == 3: raise HTTPException(status\\_code=418, detail=\"Nope! I don't like 3.\") return {\"item\\_id\": item\\_id} Now, if you go to /items/foo, instead of getting the default JSON error with: { \"detail\": \\[ { \"loc\": \\[ \"path\", \"item\\_id\" \\], \"msg\": \"value is not a valid integer\", \"type\": \"type\\_error.integer\" } \\] } you will get a text version, with: 1 validation error path -> item\\_id value is not a valid integer (type=type\\_error.integer) RequestValidationError vs ValidationError¬∂ Warning These are technical details that you might skip if it's not important for you now. RequestValidationError is a sub-class of Pydantic's ValidationError. FastAPI uses it so that, if you use a Pydantic model in response\\_model, and your data has an error, you will see the error in your log. But the client/user will not see it. Instead, the client will receive an \"Internal Server Error\" with a HTTP status code 500. It should be this way because if you have a Pydantic ValidationError in your response or anywhere in your code (not in the client's request), it's actually a bug in your code. And while you fix it, your clients/users shouldn't have access to internal information about the error, as that could expose a security vulnerability. Override the HTTPException error handler¬∂ The same way, you can override the HTTPException handler. For example, you could want to return a plain text response instead of JSON for these errors: from fastapi import FastAPI, HTTPException from fastapi.exceptions import RequestValidationError from fastapi.responses import PlainTextResponse from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI() @app.exception\\_handler(StarletteHTTPException) async def http\\_exception\\_handler(request, exc): return PlainTextResponse(str(exc.detail), status\\_code=exc.status\\_code) @app.exception\\_handler(RequestValidationError) async def validation\\_exception\\_handler(request, exc): return PlainTextResponse(str(exc), status\\_code=400) @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: int): if item\\_id == 3: raise HTTPException(status\\_code=418, detail=\"Nope! I don't like 3.\") return {\"item\\_id\": item\\_id} Technical Details You could also use from starlette.responses import PlainTextResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. Use the RequestValidationError body¬∂ The RequestValidationError contains the body it received with invalid data. You could use it while developing your app to log the body and debug it, return it to the user, etc. from fastapi import FastAPI, Request, status from fastapi.encoders import jsonable\\_encoder from fastapi.exceptions import RequestValidationError from fastapi.responses import JSONResponse from pydantic import BaseModel app = FastAPI() @app.exception\\_handler(RequestValidationError) async def validation\\_exception\\_handler(request: Request, exc: RequestValidationError): return JSONResponse( status\\_code=status.HTTP\\_422\\_UNPROCESSABLE\\_ENTITY, content=jsonable\\_encoder({\"detail\": exc.errors(), \"body\": exc.body}), ) class Item(BaseModel): title: str size: int @app.post(\"/items/\") async def create\\_item(item: Item): return item Now try sending an invalid item like: { \"title\": \"towel\", \"size\": \"XL\" } You will receive a response telling you that the data is invalid containing the received body: { \"detail\": \\[ { \"loc\": \\[ \"body\", \"size\" \\], \"msg\": \"value is not a valid integer\", \"type\": \"type\\_error.integer\" } \\], \"body\": { \"title\": \"towel\", \"size\": \"XL\" } } FastAPI's HTTPException vs Starlette's HTTPException¬∂ FastAPI has its own HTTPException. And FastAPI's HTTPException error class inherits from Starlette's HTTPException error class. The only difference, is that FastAPI's HTTPException allows you to add headers to be included in the response. This is needed/used internally for OAuth 2.0 and some security utilities. So, you can keep raising FastAPI's HTTPException as normally in your code. But when you register an exception handler, you should register it for Starlette's HTTPException. This way, if any part of Starlette's internal code, or a Starlette extension or plug-in, raises a Starlette HTTPException, your handler will be able to catch and handle it. In this example, to be able to have both HTTPExceptions in the same code, Starlette's exceptions is renamed to StarletteHTTPException: from starlette.exceptions import HTTPException as StarletteHTTPException Re-use FastAPI's exception handlers¬∂ If you want to use the exception along with the same default exception handlers from FastAPI, You can import and re-use the default exception handlers from fastapi.exception\\_handlers: from fastapi import FastAPI, HTTPException from fastapi.exception\\_handlers import ( http\\_exception\\_handler, request\\_validation\\_exception\\_handler, ) from fastapi.exceptions import RequestValidationError from starlette.exceptions import HTTPException as StarletteHTTPException app = FastAPI() @app.exception\\_handler(StarletteHTTPException) async def custom\\_http\\_exception\\_handler(request, exc): print(f\"OMG! An HTTP error!: {repr(exc)}\") return await http\\_exception\\_handler(request, exc) @app.exception\\_handler(RequestValidationError) async def validation\\_exception\\_handler(request, exc): print(f\"OMG! The client sent invalid data!: {exc}\") return await request\\_validation\\_exception\\_handler(request, exc) @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: int): if item\\_id == 3: raise HTTPException(status\\_code=418, detail=\"Nope! I don't like 3.\") return {\"item\\_id\": item\\_id} In this example you are just printing the error with a very expressive message, but you get the idea. You can use the exception and then just re-use the default exception handlers. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Request Forms and Files - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/request-forms-and-files/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Request Forms and Files en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import File and Form Define File and Form parameters Recap FastAPI Learn Tutorial - User Guide Request Forms and Files¬∂ You can define files and form fields at the same time using File and Form. Info To receive uploaded files and/or form data, first install python-multipart. E.g. pip install python-multipart. Import File and Form¬∂ Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, Form, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file( file: Annotated\\[bytes, File()\\], fileb: Annotated\\[UploadFile, File()\\], token: Annotated\\[str, Form()\\], ): return { \"file\\_size\": len(file), \"token\": token, \"fileb\\_content\\_type\": fileb.content\\_type, } Define File and Form parameters¬∂ Create file and form parameters the same way you would for Body or Query: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, Form, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file( file: Annotated\\[bytes, File()\\], fileb: Annotated\\[UploadFile, File()\\], token: Annotated\\[str, Form()\\], ): return { \"file\\_size\": len(file), \"token\": token, \"fileb\\_content\\_type\": fileb.content\\_type, } The files and form fields will be uploaded as form data and you will receive the files and form fields. And you can declare some of the files as bytes and some as UploadFile. Warning You can declare multiple File and Form parameters in a path operation, but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json. This is not a limitation of FastAPI, it's part of the HTTP protocol. Recap¬∂ Use File and Form together when you need to receive data and files in the same request. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Request Files - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/request-files/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Request Files en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import File Define File Parameters File Parameters with UploadFile UploadFile What is \"Form Data\" Optional File Upload UploadFile with Additional Metadata Multiple File Uploads Multiple File Uploads with Additional Metadata Recap FastAPI Learn Tutorial - User Guide Request Files¬∂ You can define files to be uploaded by the client using File. Info To receive uploaded files, first install python-multipart. E.g. pip install python-multipart. This is because uploaded files are sent as \"form data\". Import File¬∂ Import File and UploadFile from fastapi: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file(file: Annotated\\[bytes, File()\\]): return {\"file\\_size\": len(file)} @app.post(\"/uploadfile/\") async def create\\_upload\\_file(file: UploadFile): return {\"filename\": file.filename} Define File Parameters¬∂ Create file parameters the same way you would for Body or Form: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file(file: Annotated\\[bytes, File()\\]): return {\"file\\_size\": len(file)} @app.post(\"/uploadfile/\") async def create\\_upload\\_file(file: UploadFile): return {\"filename\": file.filename} Info File is a class that inherits directly from Form. But remember that when you import Query, Path, File and others from fastapi, those are actually functions that return special classes. Tip To declare File bodies, you need to use File, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters. The files will be uploaded as \"form data\". If you declare the type of your path operation function parameter as bytes, FastAPI will read the file for you and you will receive the contents as bytes. Have in mind that this means that the whole contents will be stored in memory. This will work well for small files. But there are several cases in which you might benefit from using UploadFile. File Parameters with UploadFile¬∂ Define a file parameter with a type of UploadFile: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file(file: Annotated\\[bytes, File()\\]): return {\"file\\_size\": len(file)} @app.post(\"/uploadfile/\") async def create\\_upload\\_file(file: UploadFile): return {\"filename\": file.filename} Using UploadFile has several advantages over bytes: You don't have to use File() in the default value of the parameter. It uses a \"spooled\" file: A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk. This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory. You can get metadata from the uploaded file. It has a file-like async interface. It exposes an actual Python SpooledTemporaryFile object that you can pass directly to other libraries that expect a file-like object. UploadFile¬∂ UploadFile has the following attributes: filename: A str with the original file name that was uploaded (e.g. myimage.jpg). content\\_type: A str with the content type (MIME type / media type) (e.g. image/jpeg). file: A SpooledTemporaryFile (a file-like object). This is the actual Python file that you can pass directly to other functions or libraries that expect a \"file-like\" object. UploadFile has the following async methods. They all call the corresponding file methods underneath (using the internal SpooledTemporaryFile). write(data): Writes data (str or bytes) to the file. read(size): Reads size (int) bytes/characters of the file. seek(offset): Goes to the byte position offset (int) in the file. E.g., await myfile.seek(0) would go to the start of the file. This is especially useful if you run await myfile.read() once and then need to read the contents again. close(): Closes the file. As all these methods are async methods, you need to \"await\" them. For example, inside of an async path operation function you can get the contents with: contents = await myfile.read() If you are inside of a normal def path operation function, you can access the UploadFile.file directly, for example: contents = myfile.file.read() async Technical Details When you use the async methods, FastAPI runs the file methods in a threadpool and awaits for them. Starlette Technical Details FastAPI's UploadFile inherits directly from Starlette's UploadFile, but adds some necessary parts to make it compatible with Pydantic and the other parts of FastAPI. What is \"Form Data\"¬∂ The way HTML forms ( ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON. FastAPI will make sure to read that data from the right place instead of JSON. Technical Details Data from forms is normally encoded using the \"media type\" application/x-www-form-urlencoded when it doesn't include files. But when the form includes files, it is encoded as multipart/form-data. If you use File, FastAPI will know it has to get the files from the correct part of the body. If you want to read more about these encodings and form fields, head to the MDN web docs for POST. Warning You can declare multiple File and Form parameters in a path operation, but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using multipart/form-data instead of application/json. This is not a limitation of FastAPI, it's part of the HTTP protocol. Optional File Upload¬∂ You can make a file optional by using standard type annotations and setting a default value of None: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file(file: Annotated\\[bytes | None, File()\\] = None): if not file: return {\"message\": \"No file sent\"} else: return {\"file\\_size\": len(file)} @app.post(\"/uploadfile/\") async def create\\_upload\\_file(file: UploadFile | None = None): if not file: return {\"message\": \"No upload file sent\"} else: return {\"filename\": file.filename} UploadFile with Additional Metadata¬∂ You can also use File() with UploadFile, for example, to set additional metadata: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile app = FastAPI() @app.post(\"/files/\") async def create\\_file(file: Annotated\\[bytes, File(description=\"A file read as bytes\")\\]): return {\"file\\_size\": len(file)} @app.post(\"/uploadfile/\") async def create\\_upload\\_file( file: Annotated\\[UploadFile, File(description=\"A file read as UploadFile\")\\], ): return {\"filename\": file.filename} Multiple File Uploads¬∂ It's possible to upload several files at the same time. They would be associated to the same \"form field\" sent using \"form data\". To use that, declare a list of bytes or UploadFile: Python 3.9+ Python 3.8+ Python 3.9+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse app = FastAPI() @app.post(\"/files/\") async def create\\_files(files: Annotated\\[list\\[bytes\\], File()\\]): return {\"file\\_sizes\": \\[len(file) for file in files\\]} @app.post(\"/uploadfiles/\") async def create\\_upload\\_files(files: list\\[UploadFile\\]): return {\"filenames\": \\[file.filename for file in files\\]} @app.get(\"/\") async def main(): content = \"\"\" \"\"\" return HTMLResponse(content=content) You will receive, as declared, a list of bytes or UploadFiles. Technical Details You could also use from starlette.responses import HTMLResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. Multiple File Uploads with Additional Metadata¬∂ And the same way as before, you can use File() to set additional parameters, even for UploadFile: Python 3.9+ Python 3.8+ Python 3.9+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, File, UploadFile from fastapi.responses import HTMLResponse app = FastAPI() @app.post(\"/files/\") async def create\\_files( files: Annotated\\[list\\[bytes\\], File(description=\"Multiple files as bytes\")\\], ): return {\"file\\_sizes\": \\[len(file) for file in files\\]} @app.post(\"/uploadfiles/\") async def create\\_upload\\_files( files: Annotated\\[ list\\[UploadFile\\], File(description=\"Multiple files as UploadFile\") \\], ): return {\"filenames\": \\[file.filename for file in files\\]} @app.get(\"/\") async def main(): content = \"\"\" \"\"\" return HTMLResponse(content=content) Recap¬∂ Use File, bytes, and UploadFile to declare files to be uploaded in the request, sent as form data. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Form Data - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/request-forms/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Form Data en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import Form Define Form parameters About \"Form Fields\" Recap FastAPI Learn Tutorial - User Guide Form Data¬∂ When you need to receive form fields instead of JSON, you can use Form. Info To use forms, first install python-multipart. E.g. pip install python-multipart. Import Form¬∂ Import Form from fastapi: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Form app = FastAPI() @app.post(\"/login/\") async def login(username: Annotated\\[str, Form()\\], password: Annotated\\[str, Form()\\]): return {\"username\": username} Define Form parameters¬∂ Create form parameters the same way you would for Body or Query: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Form app = FastAPI() @app.post(\"/login/\") async def login(username: Annotated\\[str, Form()\\], password: Annotated\\[str, Form()\\]): return {\"username\": username} For example, in one of the ways the OAuth2 specification can be used (called \"password flow\") it is required to send a username and password as form fields. The spec requires the fields to be exactly named username and password, and to be sent as form fields, not JSON. With Form you can declare the same configurations as with Body (and Query, Path, Cookie), including validation, examples, an alias (e.g. user-name instead of username), etc. Info Form is a class that inherits directly from Body. Tip To declare form bodies, you need to use Form explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters. About \"Form Fields\"¬∂ The way HTML forms ( ) sends the data to the server normally uses a \"special\" encoding for that data, it's different from JSON. FastAPI will make sure to read that data from the right place instead of JSON. Technical Details Data from forms is normally encoded using the \"media type\" application/x-www-form-urlencoded. But when the form includes files, it is encoded as multipart/form-data. You'll read about handling files in the next chapter. If you want to read more about these encodings and form fields, head to the MDN web docs for POST. Warning You can declare multiple Form parameters in a path operation, but you can't also declare Body fields that you expect to receive as JSON, as the request will have the body encoded using application/x-www-form-urlencoded instead of application/json. This is not a limitation of FastAPI, it's part of the HTTP protocol. Recap¬∂ Use Form to declare form data input parameters. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response Status Code - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/response-status-code/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Response Status Code en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents About HTTP status codes Shortcut to remember the names Changing the default FastAPI Learn Tutorial - User Guide Response Status Code¬∂ The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter status\\_code in any of the path operations: @app.get() @app.post() @app.put() @app.delete() etc. from fastapi import FastAPI app = FastAPI() @app.post(\"/items/\", status\\_code=201) async def create\\_item(name: str): return {\"name\": name} Note Notice that status\\_code is a parameter of the \"decorator\" method (get, post, etc). Not of your path operation function, like all the parameters and body. The status\\_code parameter receives a number with the HTTP status code. Info status\\_code can alternatively also receive an IntEnum, such as Python's http.HTTPStatus. It will: Return that status code in the response. Document it as such in the OpenAPI schema (and so, in the user interfaces): Note Some response codes (see the next section) indicate that the response does not have a body. FastAPI knows this, and will produce OpenAPI docs that state there is no response body. About HTTP status codes¬∂ Note If you already know what HTTP status codes are, skip to the next section. In HTTP, you send a numeric status code of 3 digits as part of the response. These status codes have a name associated to recognize them, but the important part is the number. In short: 100 and above are for \"Information\". You rarely use them directly. Responses with these status codes cannot have a body. 200 and above are for \"Successful\" responses. These are the ones you would use the most. 200 is the default status code, which means everything was \"OK\". Another example would be 201, \"Created\". It is commonly used after creating a new record in the database. A special case is 204, \"No Content\". This response is used when there is no content to return to the client, and so the response must not have a body. 300 and above are for \"Redirection\". Responses with these status codes may or may not have a body, except for 304, \"Not Modified\", which must not have one. 400 and above are for \"Client error\" responses. These are the second type you would probably use the most. An example is 404, for a \"Not Found\" response. For generic errors from the client, you can just use 400. 500 and above are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes. Tip To know more about each status code and which code is for what, check the MDN documentation about HTTP status codes. Shortcut to remember the names¬∂ Let's see the previous example again: from fastapi import FastAPI app = FastAPI() @app.post(\"/items/\", status\\_code=201) async def create\\_item(name: str): return {\"name\": name} 201 is the status code for \"Created\". But you don't have to memorize what each of these codes mean. You can use the convenience variables from fastapi.status. from fastapi import FastAPI, status app = FastAPI() @app.post(\"/items/\", status\\_code=status.HTTP\\_201\\_CREATED) async def create\\_item(name: str): return {\"name\": name} They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them: Technical Details You could also use from starlette import status. FastAPI provides the same starlette.status as fastapi.status just as a convenience for you, the developer. But it comes directly from Starlette. Changing the default¬∂ Later, in the Advanced User Guide, you will see how to return a different status code than the default you are declaring here. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Extra Models - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/extra-models/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Extra Models en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Multiple models About \\*\\*user\\_in.dict() Pydantic's .dict() Unwrapping a dict A Pydantic model from the contents of another Unwrapping a dict and extra keywords Reduce duplication Union or anyOf Union in Python 3.10 List of models Response with arbitrary dict Recap FastAPI Learn Tutorial - User Guide Extra Models¬∂ Continuing with the previous example, it will be common to have more than one related model. This is especially the case for user models, because: The input model needs to be able to have a password. The output model should not have a password. The database model would probably need to have a hashed password. Danger Never store user's plaintext passwords. Always store a \"secure hash\" that you can then verify. If you don't know, you will learn what a \"password hash\" is in the security chapters. Multiple models¬∂ Here's a general idea of how the models could look like with their password fields and the places where they are used: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full\\_name: str | None = None class UserOut(BaseModel): username: str email: EmailStr full\\_name: str | None = None class UserInDB(BaseModel): username: str hashed\\_password: str email: EmailStr full\\_name: str | None = None def fake\\_password\\_hasher(raw\\_password: str): return \"supersecret\" + raw\\_password def fake\\_save\\_user(user\\_in: UserIn): hashed\\_password = fake\\_password\\_hasher(user\\_in.password) user\\_in\\_db = UserInDB(\\*\\*user\\_in.dict(), hashed\\_password=hashed\\_password) print(\"User saved! ..not really\") return user\\_in\\_db @app.post(\"/user/\", response\\_model=UserOut) async def create\\_user(user\\_in: UserIn): user\\_saved = fake\\_save\\_user(user\\_in) return user\\_saved About \\*\\*user\\_in.dict()¬∂ Pydantic's .dict()¬∂ user\\_in is a Pydantic model of class UserIn. Pydantic models have a .dict() method that returns a dict with the model's data. So, if we create a Pydantic object user\\_in like: user\\_in = UserIn(username=\"john\", password=\"secret\", email=\"john.doe@example.com\") and then we call: user\\_dict = user\\_in.dict() we now have a dict with the data in the variable user\\_dict (it's a dict instead of a Pydantic model object). And if we call: print(user\\_dict) we would get a Python dict with: { 'username': 'john', 'password': 'secret', 'email': 'john.doe@example.com', 'full\\_name': None, } Unwrapping a dict¬∂ If we take a dict like user\\_dict and pass it to a function (or class) with \\*\\*user\\_dict, Python will \"unwrap\" it. It will pass the keys and values of the user\\_dict directly as key-value arguments. So, continuing with the user\\_dict from above, writing: UserInDB(\\*\\*user\\_dict) Would result in something equivalent to: UserInDB( username=\"john\", password=\"secret\", email=\"john.doe@example.com\", full\\_name=None, ) Or more exactly, using user\\_dict directly, with whatever contents it might have in the future: UserInDB( username = user\\_dict\\[\"username\"\\], password = user\\_dict\\[\"password\"\\], email = user\\_dict\\[\"email\"\\], full\\_name = user\\_dict\\[\"full\\_name\"\\], ) A Pydantic model from the contents of another¬∂ As in the example above we got user\\_dict from user\\_in.dict(), this code: user\\_dict = user\\_in.dict() UserInDB(\\*\\*user\\_dict) would be equivalent to: UserInDB(\\*\\*user\\_in.dict()) ...because user\\_in.dict() is a dict, and then we make Python \"unwrap\" it by passing it to UserInDB prepended with \\*\\*. So, we get a Pydantic model from the data in another Pydantic model. Unwrapping a dict and extra keywords¬∂ And then adding the extra keyword argument hashed\\_password=hashed\\_password, like in: UserInDB(\\*\\*user\\_in.dict(), hashed\\_password=hashed\\_password) ...ends up being like: UserInDB( username = user\\_dict\\[\"username\"\\], password = user\\_dict\\[\"password\"\\], email = user\\_dict\\[\"email\"\\], full\\_name = user\\_dict\\[\"full\\_name\"\\], hashed\\_password = hashed\\_password, ) Warning The supporting additional functions are just to demo a possible flow of the data, but they of course are not providing any real security. Reduce duplication¬∂ Reducing code duplication is one of the core ideas in FastAPI. As code duplication increments the chances of bugs, security issues, code desynchronization issues (when you update in one place but not in the others), etc. And these models are all sharing a lot of the data and duplicating attribute names and types. We could do better. We can declare a UserBase model that serves as a base for our other models. And then we can make subclasses of that model that inherit its attributes (type declarations, validation, etc). All the data conversion, validation, documentation, etc. will still work as normally. That way, we can declare just the differences between the models (with plaintext password, with hashed\\_password and without password): Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserBase(BaseModel): username: str email: EmailStr full\\_name: str | None = None class UserIn(UserBase): password: str class UserOut(UserBase): pass class UserInDB(UserBase): hashed\\_password: str def fake\\_password\\_hasher(raw\\_password: str): return \"supersecret\" + raw\\_password def fake\\_save\\_user(user\\_in: UserIn): hashed\\_password = fake\\_password\\_hasher(user\\_in.password) user\\_in\\_db = UserInDB(\\*\\*user\\_in.dict(), hashed\\_password=hashed\\_password) print(\"User saved! ..not really\") return user\\_in\\_db @app.post(\"/user/\", response\\_model=UserOut) async def create\\_user(user\\_in: UserIn): user\\_saved = fake\\_save\\_user(user\\_in) return user\\_saved Union or anyOf¬∂ You can declare a response to be the Union of two types, that means, that the response would be any of the two. It will be defined in OpenAPI with anyOf. To do that, use the standard Python type hint typing.Union: Note When defining a Union, include the most specific type first, followed by the less specific type. In the example below, the more specific PlaneItem comes before CarItem in Union\\[PlaneItem, CarItem\\]. Python 3.10+ Python 3.8+ from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class BaseItem(BaseModel): description: str type: str class CarItem(BaseItem): type: str = \"car\" class PlaneItem(BaseItem): type: str = \"plane\" size: int items = { \"item1\": {\"description\": \"All my friends drive a low rider\", \"type\": \"car\"}, \"item2\": { \"description\": \"Music is my aeroplane, it's my aeroplane\", \"type\": \"plane\", \"size\": 5, }, } @app.get(\"/items/{item\\_id}\", response\\_model=Union\\[PlaneItem, CarItem\\]) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] Union in Python 3.10¬∂ In this example we pass Union\\[PlaneItem, CarItem\\] as the value of the argument response\\_model. Because we are passing it as a value to an argument instead of putting it in a type annotation, we have to use Union even in Python 3.10. If it was in a type annotation we could have used the vertical bar, as: some\\_variable: PlaneItem | CarItem But if we put that in response\\_model=PlaneItem | CarItem we would get an error, because Python would try to perform an invalid operation between PlaneItem and CarItem instead of interpreting that as a type annotation. List of models¬∂ The same way, you can declare responses of lists of objects. For that, use the standard Python typing.List (or just list in Python 3.9 and above): Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str items = \\[ {\"name\": \"Foo\", \"description\": \"There comes my hero\"}, {\"name\": \"Red\", \"description\": \"It's my aeroplane\"}, \\] @app.get(\"/items/\", response\\_model=list\\[Item\\]) async def read\\_items(): return items Response with arbitrary dict¬∂ You can also declare a response using a plain arbitrary dict, declaring just the type of the keys and values, without using a Pydantic model. This is useful if you don't know the valid field/attribute names (that would be needed for a Pydantic model) beforehand. In this case, you can use typing.Dict (or just dict in Python 3.9 and above): Python 3.9+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/keyword-weights/\", response\\_model=dict\\[str, float\\]) async def read\\_keyword\\_weights(): return {\"foo\": 2.3, \"bar\": 3.4} Recap¬∂ Use multiple Pydantic models and inherit freely for each case. You don't need to have a single data model per entity if that entity must be able to have different \"states\". As the case with the user \"entity\" with a state including password, password\\_hash and no password. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response Model - Return Type - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/response-model/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Response Model - Return Type en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents response\\_model Parameter response\\_model Priority Return the same input data Add an output model response\\_model or Return Type Return Type and Data Filtering Type Annotations and Tooling FastAPI Data Filtering See it in the docs Other Return Type Annotations Return a Response Directly Annotate a Response Subclass Invalid Return Type Annotations Disable Response Model Response Model encoding parameters Use the response\\_model\\_exclude\\_unset parameter Data with values for fields with defaults Data with the same values as the defaults response\\_model\\_include and response\\_model\\_exclude Using lists instead of sets Recap FastAPI Learn Tutorial - User Guide Response Model - Return Type¬∂ You can declare the type used for the response by annotating the path operation function return type. You can use type annotations the same way you would for input data in function parameters, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc. Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list\\[str\\] = \\[\\] @app.post(\"/items/\") async def create\\_item(item: Item) -> Item: return item @app.get(\"/items/\") async def read\\_items() -> list\\[Item\\]: return \\[ Item(name=\"Portal Gun\", price=42.0), Item(name=\"Plumbus\", price=32.0), \\] FastAPI will use this return type to: Validate the returned data. If the data is invalid (e.g. you are missing a field), it means that your app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected. Add a JSON Schema for the response, in the OpenAPI path operation. This will be used by the automatic docs. It will also be used by automatic client code generation tools. But most importantly: It will limit and filter the output data to what is defined in the return type. This is particularly important for security, we'll see more of that below. response\\_model Parameter¬∂ There are some cases where you need or want to return some data that is not exactly what the type declares. For example, you could want to return a dictionary or a database object, but declare it as a Pydantic model. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object). If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model). In those cases, you can use the path operation decorator parameter response\\_model instead of the return type. You can use the response\\_model parameter in any of the path operations: @app.get() @app.post() @app.put() @app.delete() etc. Python 3.10+ Python 3.9+ Python 3.8+ from typing import Any from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list\\[str\\] = \\[\\] @app.post(\"/items/\", response\\_model=Item) async def create\\_item(item: Item) -> Any: return item @app.get(\"/items/\", response\\_model=list\\[Item\\]) async def read\\_items() -> Any: return \\[ {\"name\": \"Portal Gun\", \"price\": 42.0}, {\"name\": \"Plumbus\", \"price\": 32.0}, \\] Note Notice that response\\_model is a parameter of the \"decorator\" method (get, post, etc). Not of your path operation function, like all the parameters and body. response\\_model receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a list of Pydantic models, like List\\[Item\\]. FastAPI will use this response\\_model to do all the data documentation, validation, etc. and also to convert and filter the output data to its type declaration. Tip If you have strict type checks in your editor, mypy, etc, you can declare the function return type as Any. That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the response\\_model. response\\_model Priority¬∂ If you declare both a return type and a response\\_model, the response\\_model will take priority and be used by FastAPI. This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the response\\_model. You can also use response\\_model=None to disable creating a response model for that path operation, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below. Return the same input data¬∂ Here we are declaring a UserIn model, it will contain a plaintext password: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full\\_name: str | None = None # Don't do this in production! @app.post(\"/user/\") async def create\\_user(user: UserIn) -> UserIn: return user Info To use EmailStr, first install email\\_validator. E.g. pip install email-validator or pip install pydantic\\[email\\]. And we are using this model to declare our input and the same model to declare our output: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full\\_name: str | None = None # Don't do this in production! @app.post(\"/user/\") async def create\\_user(user: UserIn) -> UserIn: return user Now, whenever a browser is creating a user with a password, the API will return the same password in the response. In this case, it might not be a problem, because it's the same user sending the password. But if we use the same model for another path operation, we could be sending our user's passwords to every client. Danger Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing. Add an output model¬∂ We can instead create an input model with the plaintext password and an output model without it: Python 3.10+ Python 3.8+ from typing import Any from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full\\_name: str | None = None class UserOut(BaseModel): username: str email: EmailStr full\\_name: str | None = None @app.post(\"/user/\", response\\_model=UserOut) async def create\\_user(user: UserIn) -> Any: return user Here, even though our path operation function is returning the same input user that contains the password: Python 3.10+ Python 3.8+ from typing import Any from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full\\_name: str | None = None class UserOut(BaseModel): username: str email: EmailStr full\\_name: str | None = None @app.post(\"/user/\", response\\_model=UserOut) async def create\\_user(user: UserIn) -> Any: return user ...we declared the response\\_model to be our model UserOut, that doesn't include the password: Python 3.10+ Python 3.8+ from typing import Any from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserIn(BaseModel): username: str password: str email: EmailStr full\\_name: str | None = None class UserOut(BaseModel): username: str email: EmailStr full\\_name: str | None = None @app.post(\"/user/\", response\\_model=UserOut) async def create\\_user(user: UserIn) -> Any: return user So, FastAPI will take care of filtering out all the data that is not declared in the output model (using Pydantic). response\\_model or Return Type¬∂ In this case, because the two models are different, if we annotated the function return type as UserOut, the editor and tools would complain that we are returning an invalid type, as those are different classes. That's why in this example we have to declare it in the response\\_model parameter. ...but continue reading below to see how to overcome that. Return Type and Data Filtering¬∂ Let's continue from the previous example. We wanted to annotate the function with one type but return something that includes more data. We want FastAPI to keep filtering the data using the response model. In the previous example, because the classes were different, we had to use the response\\_model parameter. But that also means that we don't get the support from the editor and tools checking the function return type. But in most of the cases where we need to do something like this, we want the model just to filter/remove some of the data as in this example. And in those cases, we can use classes and inheritance to take advantage of function type annotations to get better support in the editor and tools, and still get the FastAPI data filtering. Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class BaseUser(BaseModel): username: str email: EmailStr full\\_name: str | None = None class UserIn(BaseUser): password: str @app.post(\"/user/\") async def create\\_user(user: UserIn) -> BaseUser: return user With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI. How does this work? Let's check that out. ü§ì Type Annotations and Tooling¬∂ First let's see how editors, mypy and other tools would see this. BaseUser has the base fields. Then UserIn inherits from BaseUser and adds the password field, so, it will include all the fields from both models. We annotate the function return type as BaseUser, but we are actually returning a UserIn instance. The editor, mypy, and other tools won't complain about this because, in typing terms, UserIn is a subclass of BaseUser, which means it's a valid type when what is expected is anything that is a BaseUser. FastAPI Data Filtering¬∂ Now, for FastAPI, it will see the return type and make sure that what you return includes only the fields that are declared in the type. FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected. This way, you can get the best of both worlds: type annotations with tooling support and data filtering. See it in the docs¬∂ When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema: And both models will be used for the interactive API documentation: Other Return Type Annotations¬∂ There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc). Return a Response Directly¬∂ The most common case would be returning a Response directly as explained later in the advanced docs. from fastapi import FastAPI, Response from fastapi.responses import JSONResponse, RedirectResponse app = FastAPI() @app.get(\"/portal\") async def get\\_portal(teleport: bool = False) -> Response: if teleport: return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\") return JSONResponse(content={\"message\": \"Here's your interdimensional portal.\"}) This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass) of Response. And tools will also be happy because both RedirectResponse and JSONResponse are subclasses of Response, so the type annotation is correct. Annotate a Response Subclass¬∂ You can also use a subclass of Response in the type annotation: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/teleport\") async def get\\_teleport() -> RedirectResponse: return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\") This will also work because RedirectResponse is a subclass of Response, and FastAPI will automatically handle this simple case. Invalid Return Type Annotations¬∂ But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail. The same would happen if you had something like a union between different types where one or more of them are not valid Pydantic types, for example this would fail üí•: Python 3.10+ Python 3.8+ from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/portal\") async def get\\_portal(teleport: bool = False) -> Response | dict: if teleport: return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\") return {\"message\": \"Here's your interdimensional portal.\"} ...this fails because the type annotation is not a Pydantic type and is not just a single Response class or subclass, it's a union (any of the two) between a Response and a dict. Disable Response Model¬∂ Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI. But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy). In this case, you can disable the response model generation by setting response\\_model=None: Python 3.10+ Python 3.8+ from fastapi import FastAPI, Response from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/portal\", response\\_model=None) async def get\\_portal(teleport: bool = False) -> Response | dict: if teleport: return RedirectResponse(url=\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\") return {\"message\": \"Here's your interdimensional portal.\"} This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. ü§ì Response Model encoding parameters¬∂ Your response model could have default values, like: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 tags: list\\[str\\] = \\[\\] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\]}, } @app.get(\"/items/{item\\_id}\", response\\_model=Item, response\\_model\\_exclude\\_unset=True) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] description: Union\\[str, None\\] = None (or str | None = None in Python 3.10) has a default of None. tax: float = 10.5 has a default of 10.5. tags: List\\[str\\] = \\[\\] as a default of an empty list: \\[\\]. but you might want to omit them from the result if they were not actually stored. For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values. Use the response\\_model\\_exclude\\_unset parameter¬∂ You can set the path operation decorator parameter response\\_model\\_exclude\\_unset=True: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 tags: list\\[str\\] = \\[\\] items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2}, \"baz\": {\"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\]}, } @app.get(\"/items/{item\\_id}\", response\\_model=Item, response\\_model\\_exclude\\_unset=True) async def read\\_item(item\\_id: str): return items\\[item\\_id\\] and those default values won't be included in the response, only the values actually set. So, if you send a request to that path operation for the item with ID foo, the response (not including default values) will be: { \"name\": \"Foo\", \"price\": 50.2 } Info FastAPI uses Pydantic model's .dict() with its exclude\\_unset parameter to achieve this. Info You can also use: response\\_model\\_exclude\\_defaults=True response\\_model\\_exclude\\_none=True as described in the Pydantic docs for exclude\\_defaults and exclude\\_none. Data with values for fields with defaults¬∂ But if your data has values for the model's fields with default values, like the item with ID bar: { \"name\": \"Bar\", \"description\": \"The bartenders\", \"price\": 62, \"tax\": 20.2 } they will be included in the response. Data with the same values as the defaults¬∂ If the data has the same values as the default ones, like the item with ID baz: { \"name\": \"Baz\", \"description\": None, \"price\": 50.2, \"tax\": 10.5, \"tags\": \\[\\] } FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though description, tax, and tags have the same values as the defaults, they were set explicitly (instead of taken from the defaults). So, they will be included in the JSON response. Tip Notice that the default values can be anything, not only None. They can be a list (\\[\\]), a float of 10.5, etc. response\\_model\\_include and response\\_model\\_exclude¬∂ You can also use the path operation decorator parameters response\\_model\\_include and response\\_model\\_exclude. They take a set of str with the name of the attributes to include (omitting the rest) or to exclude (including the rest). This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output. Tip But it is still recommended to use the ideas above, using multiple classes, instead of these parameters. This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use response\\_model\\_include or response\\_model\\_exclude to omit some attributes. This also applies to response\\_model\\_by\\_alias that works similarly. Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2}, \"baz\": { \"name\": \"Baz\", \"description\": \"There goes my baz\", \"price\": 50.2, \"tax\": 10.5, }, } @app.get( \"/items/{item\\_id}/name\", response\\_model=Item, response\\_model\\_include={\"name\", \"description\"}, ) async def read\\_item\\_name(item\\_id: str): return items\\[item\\_id\\] @app.get(\"/items/{item\\_id}/public\", response\\_model=Item, response\\_model\\_exclude={\"tax\"}) async def read\\_item\\_public\\_data(item\\_id: str): return items\\[item\\_id\\] Tip The syntax {\"name\", \"description\"} creates a set with those two values. It is equivalent to set(\\[\"name\", \"description\"\\]). Using lists instead of sets¬∂ If you forget to use a set and use a list or tuple instead, FastAPI will still convert it to a set and it will work correctly: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float = 10.5 items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2}, \"baz\": { \"name\": \"Baz\", \"description\": \"There goes my baz\", \"price\": 50.2, \"tax\": 10.5, }, } @app.get( \"/items/{item\\_id}/name\", response\\_model=Item, response\\_model\\_include=\\[\"name\", \"description\"\\], ) async def read\\_item\\_name(item\\_id: str): return items\\[item\\_id\\] @app.get(\"/items/{item\\_id}/public\", response\\_model=Item, response\\_model\\_exclude=\\[\"tax\"\\]) async def read\\_item\\_public\\_data(item\\_id: str): return items\\[item\\_id\\] Recap¬∂ Use the path operation decorator's parameter response\\_model to define response models and especially to ensure private data is filtered out. Use response\\_model\\_exclude\\_unset to return only the values explicitly set. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Header Parameters - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/header-params/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Header Parameters en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import Header Declare Header parameters Automatic conversion Duplicate headers Recap FastAPI Learn Tutorial - User Guide Header Parameters¬∂ You can define Header parameters the same way you define Query, Path and Cookie parameters. Import Header¬∂ First import Header: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") async def read\\_items(user\\_agent: Annotated\\[str | None, Header()\\] = None): return {\"User-Agent\": user\\_agent} Declare Header parameters¬∂ Then declare the header parameters using the same structure as with Path, Query and Cookie. The first value is the default value, you can pass all the extra validation or annotation parameters: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") async def read\\_items(user\\_agent: Annotated\\[str | None, Header()\\] = None): return {\"User-Agent\": user\\_agent} Technical Details Header is a \"sister\" class of Path, Query and Cookie. It also inherits from the same common Param class. But remember that when you import Query, Path, Header, and others from fastapi, those are actually functions that return special classes. Info To declare headers, you need to use Header, because otherwise the parameters would be interpreted as query parameters. Automatic conversion¬∂ Header has a little extra functionality on top of what Path, Query and Cookie provide. Most of the standard headers are separated by a \"hyphen\" character, also known as the \"minus symbol\" (-). But a variable like user-agent is invalid in Python. So, by default, Header will convert the parameter names characters from underscore (\\_) to hyphen (-) to extract and document the headers. Also, HTTP headers are case-insensitive, so, you can declare them with standard Python style (also known as \"snake\\_case\"). So, you can use user\\_agent as you normally would in Python code, instead of needing to capitalize the first letters as User\\_Agent or something similar. If for some reason you need to disable automatic conversion of underscores to hyphens, set the parameter convert\\_underscores of Header to False: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") async def read\\_items( strange\\_header: Annotated\\[str | None, Header(convert\\_underscores=False)\\] = None ): return {\"strange\\_header\": strange\\_header} Warning Before setting convert\\_underscores to False, bear in mind that some HTTP proxies and servers disallow the usage of headers with underscores. Duplicate headers¬∂ It is possible to receive duplicate headers. That means, the same header with multiple values. You can define those cases using a list in the type declaration. You will receive all the values from the duplicate header as a Python list. For example, to declare a header of X-Token that can appear more than once, you can write: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") async def read\\_items(x\\_token: Annotated\\[list\\[str\\] | None, Header()\\] = None): return {\"X-Token values\": x\\_token} If you communicate with that path operation sending two HTTP headers like: X-Token: foo X-Token: bar The response would be like: { \"X-Token values\": \\[ \"bar\", \"foo\" \\] } Recap¬∂ Declare headers with Header, using the same common pattern as Query, Path and Cookie. And don't worry about underscores in your variables, FastAPI will take care of converting them. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Extra Data Types - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/extra-data-types/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Extra Data Types en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Other data types Example FastAPI Learn Tutorial - User Guide Extra Data Types¬∂ Up to now, you have been using common data types, like: int float str bool But you can also use more complex data types. And you will still have the same features as seen up to now: Great editor support. Data conversion from incoming requests. Data conversion for response data. Data validation. Automatic annotation and documentation. Other data types¬∂ Here are some of the additional data types you can use: UUID: A standard \"Universally Unique Identifier\", common as an ID in many databases and systems. In requests and responses will be represented as a str. datetime.datetime: A Python datetime.datetime. In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00. datetime.date: Python datetime.date. In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15. datetime.time: A Python datetime.time. In requests and responses will be represented as a str in ISO 8601 format, like: 14:23:55.003. datetime.timedelta: A Python datetime.timedelta. In requests and responses will be represented as a float of total seconds. Pydantic also allows representing it as a \"ISO 8601 time diff encoding\", see the docs for more info. frozenset: In requests and responses, treated the same as a set: In requests, a list will be read, eliminating duplicates and converting it to a set. In responses, the set will be converted to a list. The generated schema will specify that the set values are unique (using JSON Schema's uniqueItems). bytes: Standard Python bytes. In requests and responses will be treated as str. The generated schema will specify that it's a str with binary \"format\". Decimal: Standard Python Decimal. In requests and responses, handled the same as a float. You can check all the valid pydantic data types here: Pydantic data types. Example¬∂ Here's an example path operation with parameters using some of the above types. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, time, timedelta from typing import Annotated from uuid import UUID from fastapi import Body, FastAPI app = FastAPI() @app.put(\"/items/{item\\_id}\") async def read\\_items( item\\_id: UUID, start\\_datetime: Annotated\\[datetime | None, Body()\\] = None, end\\_datetime: Annotated\\[datetime | None, Body()\\] = None, repeat\\_at: Annotated\\[time | None, Body()\\] = None, process\\_after: Annotated\\[timedelta | None, Body()\\] = None, ): start\\_process = start\\_datetime + process\\_after duration = end\\_datetime - start\\_process return { \"item\\_id\": item\\_id, \"start\\_datetime\": start\\_datetime, \"end\\_datetime\": end\\_datetime, \"repeat\\_at\": repeat\\_at, \"process\\_after\": process\\_after, \"start\\_process\": start\\_process, \"duration\": duration, } Note that the parameters inside the function have their natural data type, and you can, for example, perform normal date manipulations, like: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, time, timedelta from typing import Annotated from uuid import UUID from fastapi import Body, FastAPI app = FastAPI() @app.put(\"/items/{item\\_id}\") async def read\\_items( item\\_id: UUID, start\\_datetime: Annotated\\[datetime | None, Body()\\] = None, end\\_datetime: Annotated\\[datetime | None, Body()\\] = None, repeat\\_at: Annotated\\[time | None, Body()\\] = None, process\\_after: Annotated\\[timedelta | None, Body()\\] = None, ): start\\_process = start\\_datetime + process\\_after duration = end\\_datetime - start\\_process return { \"item\\_id\": item\\_id, \"start\\_datetime\": start\\_datetime, \"end\\_datetime\": end\\_datetime, \"repeat\\_at\": repeat\\_at, \"process\\_after\": process\\_after, \"start\\_process\": start\\_process, \"duration\": duration, } Made with Material for MkDocs Insiders"
  },
  {
    "title": "Cookie Parameters - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/cookie-params/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Cookie Parameters en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import Cookie Declare Cookie parameters Recap FastAPI Learn Tutorial - User Guide Cookie Parameters¬∂ You can define Cookie parameters the same way you define Query and Path parameters. Import Cookie¬∂ First import Cookie: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\"/items/\") async def read\\_items(ads\\_id: Annotated\\[str | None, Cookie()\\] = None): return {\"ads\\_id\": ads\\_id} Declare Cookie parameters¬∂ Then declare the cookie parameters using the same structure as with Path and Query. The first value is the default value, you can pass all the extra validation or annotation parameters: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\"/items/\") async def read\\_items(ads\\_id: Annotated\\[str | None, Cookie()\\] = None): return {\"ads\\_id\": ads\\_id} Technical Details Cookie is a \"sister\" class of Path and Query. It also inherits from the same common Param class. But remember that when you import Query, Path, Cookie and others from fastapi, those are actually functions that return special classes. Info To declare cookies, you need to use Cookie, because otherwise the parameters would be interpreted as query parameters. Recap¬∂ Declare cookies with Cookie, using the same common pattern as Query and Path. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Declare Request Example Data - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/schema-extra-example/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Declare Request Example Data en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Extra JSON Schema data in Pydantic models Field additional arguments examples in JSON Schema - OpenAPI Body with examples Example in the docs UI Body with multiple examples OpenAPI-specific examples Using the openapi\\_examples Parameter OpenAPI Examples in the Docs UI Technical Details JSON Schema's examples field Pydantic and FastAPI examples Swagger UI and OpenAPI-specific examples Summary FastAPI Learn Tutorial - User Guide Declare Request Example Data¬∂ You can declare examples of the data your app can receive. Here are several ways to do it. Extra JSON Schema data in Pydantic models¬∂ You can declare examples for a Pydantic model that will be added to the generated JSON Schema. Python 3.10+ Pydantic v2 Python 3.10+ Pydantic v1 Python 3.8+ Pydantic v2 Python 3.8+ Pydantic v1 from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None model\\_config = { \"json\\_schema\\_extra\": { \"examples\": \\[ { \"name\": \"Foo\", \"description\": \"A very nice Item\", \"price\": 35.4, \"tax\": 3.2, } \\] } } @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results That extra info will be added as-is to the output JSON Schema for that model, and it will be used in the API docs. Pydantic v2 Pydantic v1 In Pydantic version 2, you would use the attribute model\\_config, that takes a dict as described in Pydantic's docs: Model Config. You can set \"json\\_schema\\_extra\" with a dict containing any additional data you would like to show up in the generated JSON Schema, including examples. Tip You could use the same technique to extend the JSON Schema and add your own custom extra info. For example you could use it to add metadata for a frontend user interface, etc. Info OpenAPI 3.1.0 (used since FastAPI 0.99.0) added support for examples, which is part of the JSON Schema standard. Before that, it only supported the keyword example with a single example. That is still supported by OpenAPI 3.1.0, but is deprecated and is not part of the JSON Schema standard. So you are encouraged to migrate example to examples. ü§ì You can read more at the end of this page. Field additional arguments¬∂ When using Field() with Pydantic models, you can also declare additional examples: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, Field app = FastAPI() class Item(BaseModel): name: str = Field(examples=\\[\"Foo\"\\]) description: str | None = Field(default=None, examples=\\[\"A very nice Item\"\\]) price: float = Field(examples=\\[35.4\\]) tax: float | None = Field(default=None, examples=\\[3.2\\]) @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results examples in JSON Schema - OpenAPI¬∂ When using any of: Path() Query() Header() Cookie() Body() Form() File() you can also declare a group of examples with additional information that will be added to their JSON Schemas inside of OpenAPI. Body with examples¬∂ Here we pass examples containing one example of the data expected in Body(): Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item( item\\_id: int, item: Annotated\\[ Item, Body( examples=\\[ { \"name\": \"Foo\", \"description\": \"A very nice Item\", \"price\": 35.4, \"tax\": 3.2, } \\], ), \\], ): results = {\"item\\_id\": item\\_id, \"item\": item} return results Example in the docs UI¬∂ With any of the methods above it would look like this in the /docs: Body with multiple examples¬∂ You can of course also pass multiple examples: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item( \\*, item\\_id: int, item: Annotated\\[ Item, Body( examples=\\[ { \"name\": \"Foo\", \"description\": \"A very nice Item\", \"price\": 35.4, \"tax\": 3.2, }, { \"name\": \"Bar\", \"price\": \"35.4\", }, { \"name\": \"Baz\", \"price\": \"thirty five point four\", }, \\], ), \\], ): results = {\"item\\_id\": item\\_id, \"item\": item} return results When you do this, the examples will be part of the internal JSON Schema for that body data. Nevertheless, at the time of writing this, Swagger UI, the tool in charge of showing the docs UI, doesn't support showing multiple examples for the data in JSON Schema. But read below for a workaround. OpenAPI-specific examples¬∂ Since before JSON Schema supported examples OpenAPI had support for a different field also called examples. This OpenAPI-specific examples goes in another section in the OpenAPI specification. It goes in the details for each path operation, not inside each JSON Schema. And Swagger UI has supported this particular examples field for a while. So, you can use it to show different examples in the docs UI. The shape of this OpenAPI-specific field examples is a dict with multiple examples (instead of a list), each with extra information that will be added to OpenAPI too. This doesn't go inside of each JSON Schema contained in OpenAPI, this goes outside, in the path operation directly. Using the openapi\\_examples Parameter¬∂ You can declare the OpenAPI-specific examples in FastAPI with the parameter openapi\\_examples for: Path() Query() Header() Cookie() Body() Form() File() The keys of the dict identify each example, and each value is another dict. Each specific example dict in the examples can contain: summary: Short description for the example. description: A long description that can contain Markdown text. value: This is the actual example shown, e.g. a dict. externalValue: alternative to value, a URL pointing to the example. Although this might not be supported by as many tools as value. You can use it like this: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item( \\*, item\\_id: int, item: Annotated\\[ Item, Body( openapi\\_examples={ \"normal\": { \"summary\": \"A normal example\", \"description\": \"A \\*\\*normal\\*\\* item works correctly.\", \"value\": { \"name\": \"Foo\", \"description\": \"A very nice Item\", \"price\": 35.4, \"tax\": 3.2, }, }, \"converted\": { \"summary\": \"An example with converted data\", \"description\": \"FastAPI can convert price \\`strings\\` to actual \\`numbers\\` automatically\", \"value\": { \"name\": \"Bar\", \"price\": \"35.4\", }, }, \"invalid\": { \"summary\": \"Invalid data is rejected with an error\", \"value\": { \"name\": \"Baz\", \"price\": \"thirty five point four\", }, }, }, ), \\], ): results = {\"item\\_id\": item\\_id, \"item\": item} return results OpenAPI Examples in the Docs UI¬∂ With openapi\\_examples added to Body() the /docs would look like: Technical Details¬∂ Tip If you are already using FastAPI version 0.99.0 or above, you can probably skip these details. They are more relevant for older versions, before OpenAPI 3.1.0 was available. You can consider this a brief OpenAPI and JSON Schema history lesson. ü§ì Warning These are very technical details about the standards JSON Schema and OpenAPI. If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them. Before OpenAPI 3.1.0, OpenAPI used an older and modified version of JSON Schema. JSON Schema didn't have examples, so OpenAPI added it's own example field to its own modified version. OpenAPI also added example and examples fields to other parts of the specification: Parameter Object (in the specification) that was used by FastAPI's: Path() Query() Header() Cookie() Request Body Object, in the field content, on the Media Type Object (in the specification) that was used by FastAPI's: Body() File() Form() Info This old OpenAPI-specific examples parameter is now openapi\\_examples since FastAPI 0.103.0. JSON Schema's examples field¬∂ But then JSON Schema added an examples field to a new version of the specification. And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field examples. And now this new examples field takes precedence over the old single (and custom) example field, that is now deprecated. This new examples field in JSON Schema is just a list of examples, not a dict with extra metadata as in the other places in OpenAPI (described above). Info Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 üéâ). Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0. Pydantic and FastAPI examples¬∂ When you add examples inside of a Pydantic model, using schema\\_extra or Field(examples=\\[\"something\"\\]) that example is added to the JSON Schema for that Pydantic model. And that JSON Schema of the Pydantic model is included in the OpenAPI of your API, and then it's used in the docs UI. In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used example or examples with any of the other utilities (Query(), Body(), etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the path operation declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema). But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema. Swagger UI and OpenAPI-specific examples¬∂ Now, as Swagger UI didn't support multiple JSON Schema examples (as of 2023-08-26), users didn't have a way to show multiple examples in the docs. To solve that, FastAPI 0.103.0 added support for declaring the same old OpenAPI-specific examples field with the new parameter openapi\\_examples. ü§ì Summary¬∂ I used to say I didn't like history that much... and look at me now giving \"tech history\" lessons. üòÖ In short, upgrade to FastAPI 0.99.0 or above, and things are much simpler, consistent, and intuitive, and you don't have to know all these historic details. üòé Made with Material for MkDocs Insiders"
  },
  {
    "title": "Body - Nested Models - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/body-nested-models/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Body - Nested Models en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents List fields List fields with type parameter Import typing's List Declare a list with a type parameter Set types Nested Models Define a submodel Use the submodel as a type Special types and validation Attributes with lists of submodels Deeply nested models Bodies of pure lists Editor support everywhere Bodies of arbitrary dicts Recap FastAPI Learn Tutorial - User Guide Body - Nested Models¬∂ With FastAPI, you can define, validate, document, and use arbitrarily deeply nested models (thanks to Pydantic). List fields¬∂ You can define an attribute to be a subtype. For example, a Python list: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list = \\[\\] @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results This will make tags be a list, although it doesn't declare the type of the elements of the list. List fields with type parameter¬∂ But Python has a specific way to declare lists with internal types, or \"type parameters\": Import typing's List¬∂ In Python 3.9 and above you can use the standard list to declare these type annotations as we'll see below. üí° But in Python versions before 3.9 (3.6 and above), you first need to import List from standard Python's typing module: from typing import List, Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Union\\[str, None\\] = None price: float tax: Union\\[float, None\\] = None tags: List\\[str\\] = \\[\\] @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results Declare a list with a type parameter¬∂ To declare types that have type parameters (internal types), like list, dict, tuple: If you are in a Python version lower than 3.9, import their equivalent version from the typing module Pass the internal type(s) as \"type parameters\" using square brackets: \\[ and \\] In Python 3.9 it would be: my\\_list: list\\[str\\] In versions of Python before 3.9, it would be: from typing import List my\\_list: List\\[str\\] That's all standard Python syntax for type declarations. Use that same standard syntax for model attributes with internal types. So, in our example, we can make tags be specifically a \"list of strings\": Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: list\\[str\\] = \\[\\] @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results Set types¬∂ But then we think about it, and realize that tags shouldn't repeat, they would probably be unique strings. And Python has a special data type for sets of unique items, the set. Then we can declare tags as a set of strings: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results With this, even if you receive a request with duplicate data, it will be converted to a set of unique items. And whenever you output that data, even if the source had duplicates, it will be output as a set of unique items. And it will be annotated / documented accordingly too. Nested Models¬∂ Each attribute of a Pydantic model has a type. But that type can itself be another Pydantic model. So, you can declare deeply nested JSON \"objects\" with specific attribute names, types and validations. All that, arbitrarily nested. Define a submodel¬∂ For example, we can define an Image model: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Image(BaseModel): url: str name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() image: Image | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results Use the submodel as a type¬∂ And then we can use it as the type of an attribute: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Image(BaseModel): url: str name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() image: Image | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results This would mean that FastAPI would expect a body similar to: { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2, \"tags\": \\[\"rock\", \"metal\", \"bar\"\\], \"image\": { \"url\": \"http://example.com/baz.jpg\", \"name\": \"The Foo live\" } } Again, doing just that declaration, with FastAPI you get: Editor support (completion, etc.), even for nested models Data conversion Data validation Automatic documentation Special types and validation¬∂ Apart from normal singular types like str, int, float, etc. you can use more complex singular types that inherit from str. To see all the options you have, checkout the docs for Pydantic's exotic types. You will see some examples in the next chapter. For example, as in the Image model we have a url field, we can declare it to be an instance of Pydantic's HttpUrl instead of a str: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() image: Image | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results The string will be checked to be a valid URL, and documented in JSON Schema / OpenAPI as such. Attributes with lists of submodels¬∂ You can also use Pydantic models as subtypes of list, set, etc.: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() images: list\\[Image\\] | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item): results = {\"item\\_id\": item\\_id, \"item\": item} return results This will expect (convert, validate, document, etc.) a JSON body like: { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2, \"tags\": \\[ \"rock\", \"metal\", \"bar\" \\], \"images\": \\[ { \"url\": \"http://example.com/baz.jpg\", \"name\": \"The Foo live\" }, { \"url\": \"http://example.com/dave.jpg\", \"name\": \"The Baz\" } \\] } Info Notice how the images key now has a list of image objects. Deeply nested models¬∂ You can define arbitrarily deeply nested models: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None tags: set\\[str\\] = set() images: list\\[Image\\] | None = None class Offer(BaseModel): name: str description: str | None = None price: float items: list\\[Item\\] @app.post(\"/offers/\") async def create\\_offer(offer: Offer): return offer Info Notice how Offer has a list of Items, which in turn have an optional list of Images Bodies of pure lists¬∂ If the top level value of the JSON body you expect is a JSON array (a Python list), you can declare the type in the parameter of the function, the same as in Pydantic models: images: List\\[Image\\] or in Python 3.9 and above: images: list\\[Image\\] as in: Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Image(BaseModel): url: HttpUrl name: str @app.post(\"/images/multiple/\") async def create\\_multiple\\_images(images: list\\[Image\\]): return images Editor support everywhere¬∂ And you get editor support everywhere. Even for items inside of lists: You couldn't get this kind of editor support if you were working directly with dict instead of Pydantic models. But you don't have to worry about them either, incoming dicts are converted automatically and your output is converted automatically to JSON too. Bodies of arbitrary dicts¬∂ You can also declare a body as a dict with keys of some type and values of some other type. This way, you don't have to know beforehand what the valid field/attribute names are (as would be the case with Pydantic models). This would be useful if you want to receive keys that you don't already know. Another useful case is when you want to have keys of another type (e.g., int). That's what we are going to see here. In this case, you would accept any dict as long as it has int keys with float values: Python 3.9+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.post(\"/index-weights/\") async def create\\_index\\_weights(weights: dict\\[int, float\\]): return weights Tip Have in mind that JSON only supports str as keys. But Pydantic has automatic data conversion. This means that, even though your API clients can only send strings as keys, as long as those strings contain pure integers, Pydantic will convert them and validate them. And the dict you receive as weights will actually have int keys and float values. Recap¬∂ With FastAPI you have the maximum flexibility provided by Pydantic models, while keeping your code simple, short and elegant. But with all the benefits: Editor support (completion everywhere!) Data conversion (a.k.a. parsing / serialization) Data validation Schema documentation Automatic docs Made with Material for MkDocs Insiders"
  },
  {
    "title": "Body - Fields - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/body-fields/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Body - Fields en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import Field Declare model attributes Add extra information Recap FastAPI Learn Tutorial - User Guide Body - Fields¬∂ The same way you can declare additional validation and metadata in path operation function parameters with Query, Path and Body, you can declare validation and metadata inside of Pydantic models using Pydantic's Field. Import Field¬∂ First, you have to import it: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI() class Item(BaseModel): name: str description: str | None = Field( default=None, title=\"The description of the item\", max\\_length=300 ) price: float = Field(gt=0, description=\"The price must be greater than zero\") tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Annotated\\[Item, Body(embed=True)\\]): results = {\"item\\_id\": item\\_id, \"item\": item} return results Warning Notice that Field is imported directly from pydantic, not from fastapi as are all the rest (Query, Path, Body, etc). Declare model attributes¬∂ You can then use Field with model attributes: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel, Field app = FastAPI() class Item(BaseModel): name: str description: str | None = Field( default=None, title=\"The description of the item\", max\\_length=300 ) price: float = Field(gt=0, description=\"The price must be greater than zero\") tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Annotated\\[Item, Body(embed=True)\\]): results = {\"item\\_id\": item\\_id, \"item\": item} return results Field works the same way as Query, Path and Body, it has all the same parameters, etc. Technical Details Actually, Query, Path and others you'll see next create objects of subclasses of a common Param class, which is itself a subclass of Pydantic's FieldInfo class. And Pydantic's Field returns an instance of FieldInfo as well. Body also returns objects of a subclass of FieldInfo directly. And there are others you will see later that are subclasses of the Body class. Remember that when you import Query, Path, and others from fastapi, those are actually functions that return special classes. Tip Notice how each model's attribute with a type, default value and Field has the same structure as a path operation function's parameter, with Field instead of Path, Query and Body. Add extra information¬∂ You can declare extra information in Field, Query, Body, etc. And it will be included in the generated JSON Schema. You will learn more about adding extra information later in the docs, when learning to declare examples. Warning Extra keys passed to Field will also be present in the resulting OpenAPI schema for your application. As these keys may not necessarily be part of the OpenAPI specification, some OpenAPI tools, for example the OpenAPI validator, may not work with your generated schema. Recap¬∂ You can use Pydantic's Field to declare extra validations and metadata for model attributes. You can also use the extra keyword arguments to pass additional JSON Schema metadata. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Body - Multiple Parameters - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/body-multiple-params/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Body - Multiple Parameters en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Mix Path, Query and body parameters Multiple body parameters Singular values in body Multiple body params and query Embed a single body parameter Recap FastAPI Learn Tutorial - User Guide Body - Multiple Parameters¬∂ Now that we have seen how to use Path and Query, let's see more advanced uses of request body declarations. Mix Path, Query and body parameters¬∂ First, of course, you can mix Path, Query and request body parameter declarations freely and FastAPI will know what to do. And you can also declare body parameters as optional, by setting the default to None: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Path from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\", ge=0, le=1000)\\], q: str | None = None, item: Item | None = None, ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) if item: results.update({\"item\": item}) return results Note Notice that, in this case, the item that would be taken from the body is optional. As it has a None default value. Multiple body parameters¬∂ In the previous example, the path operations would expect a JSON body with the attributes of an Item, like: { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 } But you can also declare multiple body parameters, e.g. item and user: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class User(BaseModel): username: str full\\_name: str | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Item, user: User): results = {\"item\\_id\": item\\_id, \"item\": item, \"user\": user} return results In this case, FastAPI will notice that there are more than one body parameters in the function (two parameters that are Pydantic models). So, it will then use the parameter names as keys (field names) in the body, and expect a body like: { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }, \"user\": { \"username\": \"dave\", \"full\\_name\": \"Dave Grohl\" } } Note Notice that even though the item was declared the same way as before, it is now expected to be inside of the body with a key item. FastAPI will do the automatic conversion from the request, so that the parameter item receives it's specific content and the same for user. It will perform the validation of the compound data, and will document it like that for the OpenAPI schema and automatic docs. Singular values in body¬∂ The same way there is a Query and Path to define extra data for query and path parameters, FastAPI provides an equivalent Body. For example, extending the previous model, you could decide that you want to have another key importance in the same body, besides the item and user. If you declare it as is, because it is a singular value, FastAPI will assume that it is a query parameter. But you can instruct FastAPI to treat it as another body key using Body: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class User(BaseModel): username: str full\\_name: str | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item( item\\_id: int, item: Item, user: User, importance: Annotated\\[int, Body()\\] ): results = {\"item\\_id\": item\\_id, \"item\": item, \"user\": user, \"importance\": importance} return results In this case, FastAPI will expect a body like: { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }, \"user\": { \"username\": \"dave\", \"full\\_name\": \"Dave Grohl\" }, \"importance\": 5 } Again, it will convert the data types, validate, document, etc. Multiple body params and query¬∂ Of course, you can also declare additional query parameters whenever you need, additional to any body parameters. As, by default, singular values are interpreted as query parameters, you don't have to explicitly add a Query, you can just do: q: Union\\[str, None\\] = None Or in Python 3.10 and above: q: str | None = None For example: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None class User(BaseModel): username: str full\\_name: str | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item( \\*, item\\_id: int, item: Item, user: User, importance: Annotated\\[int, Body(gt=0)\\], q: str | None = None, ): results = {\"item\\_id\": item\\_id, \"item\": item, \"user\": user, \"importance\": importance} if q: results.update({\"q\": q}) return results Info Body also has all the same extra validation and metadata parameters as Query,Path and others you will see later. Embed a single body parameter¬∂ Let's say you only have a single item body parameter from a Pydantic model Item. By default, FastAPI will then expect its body directly. But if you want it to expect a JSON with a key item and inside of it the model contents, as it does when you declare extra body parameters, you can use the special Body parameter embed: item: Item = Body(embed=True) as in: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None @app.put(\"/items/{item\\_id}\") async def update\\_item(item\\_id: int, item: Annotated\\[Item, Body(embed=True)\\]): results = {\"item\\_id\": item\\_id, \"item\": item} return results In this case FastAPI will expect a body like: { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 } } instead of: { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 } Recap¬∂ You can add multiple body parameters to your path operation function, even though a request can only have a single body. But FastAPI will handle it, give you the correct data in your function, and validate and document the correct schema in the path operation. You can also declare singular values to be received as part of the body. And you can instruct FastAPI to embed the body in a key even when there is only a single parameter declared. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Query Parameters and String Validations - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/query-params-str-validations/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Query Parameters and String Validations en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Additional validation Import Query and Annotated Use Annotated in the type for the q parameter Add Query to Annotated in the q parameter Alternative (old) Query as the default value Query as the default value or in Annotated Advantages of Annotated Add more validations Add regular expressions Pydantic v1 regex instead of pattern Default values Make it required Required with Ellipsis (...) Required with None Query parameter list / multiple values Query parameter list / multiple values with defaults Using list Declare more metadata Alias parameters Deprecating parameters Exclude from OpenAPI Recap FastAPI Learn Tutorial - User Guide Query Parameters and String Validations¬∂ FastAPI allows you to declare additional information and validation for your parameters. Let's take this application as example: Python 3.10+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: str | None = None): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results The query parameter q is of type Union\\[str, None\\] (or str | None in Python 3.10), that means that it's of type str but could also be None, and indeed, the default value is None, so FastAPI will know it's not required. Note FastAPI will know that the value of q is not required because of the default value = None. The Union in Union\\[str, None\\] will allow your editor to give you better support and detect errors. Additional validation¬∂ We are going to enforce that even though q is optional, whenever it is provided, its length doesn't exceed 50 characters. Import Query and Annotated¬∂ To achieve that, first import: Query from fastapi Annotated from typing (or from typing\\_extensions in Python below 3.9) Python 3.10+ Python 3.8+ In Python 3.9 or above, Annotated is part of the standard library, so you can import it from typing. from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str | None, Query(max\\_length=50)\\] = None): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Info FastAPI added support for Annotated (and started recommending it) in version 0.95.0. If you have an older version, you would get errors when trying to use Annotated. Make sure you Upgrade the FastAPI version to at least 0.95.1 before using Annotated. Use Annotated in the type for the q parameter¬∂ Remember I told you before that Annotated can be used to add metadata to your parameters in the Python Types Intro? Now it's the time to use it with FastAPI. üöÄ We had this type annotation: Python 3.10+ Python 3.8+ q: str | None = None What we will do is wrap that with Annotated, so it becomes: Python 3.10+ Python 3.8+ q: Annotated\\[str | None\\] = None Both of those versions mean the same thing, q is a parameter that can be a str or None, and by default, it is None. Now let's jump to the fun stuff. üéâ Add Query to Annotated in the q parameter¬∂ Now that we have this Annotated where we can put more metadata, add Query to it, and set the parameter max\\_length to 50: Python 3.10+ Python 3.8+ from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str | None, Query(max\\_length=50)\\] = None): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Notice that the default value is still None, so the parameter is still optional. But now, having Query(max\\_length=50) inside of Annotated, we are telling FastAPI that we want it to extract this value from the query parameters (this would have been the default anyway ü§∑) and that we want to have additional validation for this value (that's why we do this, to get the additional validation). üòé FastAPI will now: Validate the data making sure that the max length is 50 characters Show a clear error for the client when the data is not valid Document the parameter in the OpenAPI schema path operation (so it will show up in the automatic docs UI) Alternative (old) Query as the default value¬∂ Previous versions of FastAPI (before 0.95.0) required you to use Query as the default value of your parameter, instead of putting it in Annotated, there's a high chance that you will see code using it around, so I'll explain it to you. Tip For new code and whenever possible, use Annotated as explained above. There are multiple advantages (explained below) and no disadvantages. üç∞ This is how you would use Query() as the default value of your function parameter, setting the parameter max\\_length to 50: Python 3.10+ Python 3.8+ from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: str | None = Query(default=None, max\\_length=50)): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results As in this case (without using Annotated) we have to replace the default value None in the function with Query(), we now need to set the default value with the parameter Query(default=None), it serves the same purpose of defining that default value (at least for FastAPI). So: q: Union\\[str, None\\] = Query(default=None) ...makes the parameter optional, with a default value of None, the same as: q: Union\\[str, None\\] = None And in Python 3.10 and above: q: str | None = Query(default=None) ...makes the parameter optional, with a default value of None, the same as: q: str | None = None But it declares it explicitly as being a query parameter. Info Have in mind that the most important part to make a parameter optional is the part: = None or the: = Query(default=None) as it will use that None as the default value, and that way make the parameter not required. The Union\\[str, None\\] part allows your editor to provide better support, but it is not what tells FastAPI that this parameter is not required. Then, we can pass more parameters to Query. In this case, the max\\_length parameter that applies to strings: q: Union\\[str, None\\] = Query(default=None, max\\_length=50) This will validate the data, show a clear error when the data is not valid, and document the parameter in the OpenAPI schema path operation. Query as the default value or in Annotated¬∂ Have in mind that when using Query inside of Annotated you cannot use the default parameter for Query. Instead use the actual default value of the function parameter. Otherwise, it would be inconsistent. For example, this is not allowed: q: Annotated\\[str, Query(default=\"rick\")\\] = \"morty\" ...because it's not clear if the default value should be \"rick\" or \"morty\". So, you would use (preferably): q: Annotated\\[str, Query()\\] = \"rick\" ...or in older code bases you will find: q: str = Query(default=\"rick\") Advantages of Annotated¬∂ Using Annotated is recommended instead of the default value in function parameters, it is better for multiple reasons. ü§ì The default value of the function parameter is the actual default value, that's more intuitive with Python in general. üòå You could call that same function in other places without FastAPI, and it would work as expected. If there's a required parameter (without a default value), your editor will let you know with an error, Python will also complain if you run it without passing the required parameter. When you don't use Annotated and instead use the (old) default value style, if you call that function without FastAPI in other place, you have to remember to pass the arguments to the function for it to work correctly, otherwise the values will be different from what you expect (e.g. QueryInfo or something similar instead of str). And your editor won't complain, and Python won't complain running that function, only when the operations inside error out. Because Annotated can have more than one metadata annotation, you could now even use the same function with other tools, like Typer. üöÄ Add more validations¬∂ You can also add a parameter min\\_length: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( q: Annotated\\[str | None, Query(min\\_length=3, max\\_length=50)\\] = None ): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Add regular expressions¬∂ You can define a regular expression pattern that the parameter should match: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( q: Annotated\\[ str | None, Query(min\\_length=3, max\\_length=50, pattern=\"^fixedquery$\") \\] = None, ): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results This specific regular expression pattern checks that the received parameter value: ^: starts with the following characters, doesn't have characters before. fixedquery: has the exact value fixedquery. $: ends there, doesn't have any more characters after fixedquery. If you feel lost with all these \"regular expression\" ideas, don't worry. They are a hard topic for many people. You can still do a lot of stuff without needing regular expressions yet. But whenever you need them and go and learn them, know that you can already use them directly in FastAPI. Pydantic v1 regex instead of pattern¬∂ Before Pydantic version 2 and before FastAPI 0.100.0, the parameter was called regex instead of pattern, but it's now deprecated. You could still see some code using it: Python 3.10+ Pydantic v1 from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( q: Annotated\\[ str | None, Query(min\\_length=3, max\\_length=50, regex=\"^fixedquery$\") \\] = None, ): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results But know that this is deprecated and it should be updated to use the new parameter pattern. ü§ì Default values¬∂ You can, of course, use default values other than None. Let's say that you want to declare the q query parameter to have a min\\_length of 3, and to have a default value of \"fixedquery\": Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str, Query(min\\_length=3)\\] = \"fixedquery\"): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Note Having a default value of any type, including None, makes the parameter optional (not required). Make it required¬∂ When we don't need to declare more validations or metadata, we can make the q query parameter required just by not declaring a default value, like: q: str instead of: q: Union\\[str, None\\] = None But we are now declaring it with Query, for example like: Annotated non-Annotated q: Annotated\\[Union\\[str, None\\], Query(min\\_length=3)\\] = None So, when you need to declare a value as required while using Query, you can simply not declare a default value: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str, Query(min\\_length=3)\\]): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Required with Ellipsis (...)¬∂ There's an alternative way to explicitly declare that a value is required. You can set the default to the literal value ...: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str, Query(min\\_length=3)\\] = ...): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Info If you hadn't seen that ... before: it is a special single value, it is part of Python and is called \"Ellipsis\". It is used by Pydantic and FastAPI to explicitly declare that a value is required. This will let FastAPI know that this parameter is required. Required with None¬∂ You can declare that a parameter can accept None, but that it's still required. This would force clients to send a value, even if the value is None. To do that, you can declare that None is a valid type but still use ... as the default: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str | None, Query(min\\_length=3)\\] = ...): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Tip Pydantic, which is what powers all the data validation and serialization in FastAPI, has a special behavior when you use Optional or Union\\[Something, None\\] without a default value, you can read more about it in the Pydantic docs about Required Optional fields. Tip Remember that in most of the cases, when something is required, you can simply omit the default, so you normally don't have to use .... Query parameter list / multiple values¬∂ When you define a query parameter explicitly with Query you can also declare it to receive a list of values, or said in other way, to receive multiple values. For example, to declare a query parameter q that can appear multiple times in the URL, you can write: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[list\\[str\\] | None, Query()\\] = None): query\\_items = {\"q\": q} return query\\_items Then, with a URL like: http://localhost:8000/items/?q=foo&q=bar you would receive the multiple q query parameters' values (foo and bar) in a Python list inside your path operation function, in the function parameter q. So, the response to that URL would be: { \"q\": \\[ \"foo\", \"bar\" \\] } Tip To declare a query parameter with a type of list, like in the example above, you need to explicitly use Query, otherwise it would be interpreted as a request body. The interactive API docs will update accordingly, to allow multiple values: Query parameter list / multiple values with defaults¬∂ And you can also define a default list of values if none are provided: Python 3.9+ Python 3.8+ Python 3.9+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[list\\[str\\], Query()\\] = \\[\"foo\", \"bar\"\\]): query\\_items = {\"q\": q} return query\\_items If you go to: http://localhost:8000/items/ the default of q will be: \\[\"foo\", \"bar\"\\] and your response will be: { \"q\": \\[ \"foo\", \"bar\" \\] } Using list¬∂ You can also use list directly instead of List\\[str\\] (or list\\[str\\] in Python 3.9+): Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[list, Query()\\] = \\[\\]): query\\_items = {\"q\": q} return query\\_items Note Have in mind that in this case, FastAPI won't check the contents of the list. For example, List\\[int\\] would check (and document) that the contents of the list are integers. But list alone wouldn't. Declare more metadata¬∂ You can add more information about the parameter. That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools. Note Have in mind that different tools might have different levels of OpenAPI support. Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development. You can add a title: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( q: Annotated\\[str | None, Query(title=\"Query string\", min\\_length=3)\\] = None ): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results And a description: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( q: Annotated\\[ str | None, Query( title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min\\_length=3, ), \\] = None, ): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Alias parameters¬∂ Imagine that you want the parameter to be item-query. Like in: http://127.0.0.1:8000/items/?item-query=foobaritems But item-query is not a valid Python variable name. The closest would be item\\_query. But you still need it to be exactly item-query... Then you can declare an alias, and that alias is what will be used to find the parameter value: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items(q: Annotated\\[str | None, Query(alias=\"item-query\")\\] = None): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results Deprecating parameters¬∂ Now let's say you don't like this parameter anymore. You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as deprecated. Then pass the parameter deprecated=True to Query: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( q: Annotated\\[ str | None, Query( alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min\\_length=3, max\\_length=50, pattern=\"^fixedquery$\", deprecated=True, ), \\] = None, ): results = {\"items\": \\[{\"item\\_id\": \"Foo\"}, {\"item\\_id\": \"Bar\"}\\]} if q: results.update({\"q\": q}) return results The docs will show it like this: Exclude from OpenAPI¬∂ To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter include\\_in\\_schema of Query to False: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Query app = FastAPI() @app.get(\"/items/\") async def read\\_items( hidden\\_query: Annotated\\[str | None, Query(include\\_in\\_schema=False)\\] = None ): if hidden\\_query: return {\"hidden\\_query\": hidden\\_query} else: return {\"hidden\\_query\": \"Not found\"} Recap¬∂ You can declare additional validations and metadata for your parameters. Generic validations and metadata: alias title description deprecated Validations specific for strings: min\\_length max\\_length pattern In these examples you saw how to declare validations for str values. See the next chapters to see how to declare validations for other types, like numbers. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Path Parameters and Numeric Validations - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Path Parameters and Numeric Validations en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import Path Declare metadata Order the parameters as you need Order the parameters as you need, tricks Better with Annotated Number validations: greater than or equal Number validations: greater than and less than or equal Number validations: floats, greater than and less than Recap FastAPI Learn Tutorial - User Guide Path Parameters and Numeric Validations¬∂ In the same way that you can declare more validations and metadata for query parameters with Query, you can declare the same type of validations and metadata for path parameters with Path. Import Path¬∂ First, import Path from fastapi, and import Annotated: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\")\\], q: Annotated\\[str | None, Query(alias=\"item-query\")\\] = None, ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Info FastAPI added support for Annotated (and started recommending it) in version 0.95.0. If you have an older version, you would get errors when trying to use Annotated. Make sure you Upgrade the FastAPI version to at least 0.95.1 before using Annotated. Declare metadata¬∂ You can declare all the same parameters as for Query. For example, to declare a title metadata value for the path parameter item\\_id you can type: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\")\\], q: Annotated\\[str | None, Query(alias=\"item-query\")\\] = None, ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Note A path parameter is always required as it has to be part of the path. So, you should declare it with ... to mark it as required. Nevertheless, even if you declared it with None or set a default value, it would not affect anything, it would still be always required. Order the parameters as you need¬∂ Tip This is probably not as important or necessary if you use Annotated. Let's say that you want to declare the query parameter q as a required str. And you don't need to declare anything else for that parameter, so you don't really need to use Query. But you still need to use Path for the item\\_id path parameter. And you don't want to use Annotated for some reason. Python will complain if you put a value with a \"default\" before a value that doesn't have a \"default\". But you can re-order them, and have the value without a default (the query parameter q) first. It doesn't matter for FastAPI. It will detect the parameters by their names, types and default declarations (Query, Path, etc), it doesn't care about the order. So, you can declare your function as: Python 3.8 non-Annotated Tip Prefer to use the Annotated version if possible. from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items(q: str, item\\_id: int = Path(title=\"The ID of the item to get\")): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results But have in mind that if you use Annotated, you won't have this problem, it won't matter as you're not using the function parameter default values for Query() or Path(). Python 3.9+ Python 3.8+ from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( q: str, item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\")\\] ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Order the parameters as you need, tricks¬∂ Tip This is probably not as important or necessary if you use Annotated. Here's a small trick that can be handy, but you won't need it often. If you want to: declare the q query parameter without a Query nor any default value declare the path parameter item\\_id using Path have them in a different order not use Annotated ...Python has a little special syntax for that. Pass \\*, as the first parameter of the function. Python won't do anything with that \\*, but it will know that all the following parameters should be called as keyword arguments (key-value pairs), also known as kwargs. Even if they don't have a default value. from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items(\\*, item\\_id: int = Path(title=\"The ID of the item to get\"), q: str): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Better with Annotated¬∂ Have in mind that if you use Annotated, as you are not using function parameter default values, you won't have this problem, and you probably won't need to use \\*. Python 3.9+ Python 3.8+ from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\")\\], q: str ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Number validations: greater than or equal¬∂ With Query and Path (and others you'll see later) you can declare number constraints. Here, with ge=1, item\\_id will need to be an integer number \"greater than or equal\" to 1. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\", ge=1)\\], q: str ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Number validations: greater than and less than or equal¬∂ The same applies for: gt: greater than le: less than or equal Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Path app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\", gt=0, le=1000)\\], q: str, ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Number validations: floats, greater than and less than¬∂ Number validations also work for float values. Here's where it becomes important to be able to declare gt and not just ge. As with it you can require, for example, that a value must be greater than 0, even if it is less than 1. So, 0.5 would be a valid value. But 0.0 or 0 would not. And the same for lt. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import FastAPI, Path, Query app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_items( \\*, item\\_id: Annotated\\[int, Path(title=\"The ID of the item to get\", ge=0, le=1000)\\], q: str, size: Annotated\\[float, Query(gt=0, lt=10.5)\\], ): results = {\"item\\_id\": item\\_id} if q: results.update({\"q\": q}) return results Recap¬∂ With Query, Path (and others you haven't seen yet) you can declare metadata and string validations in the same ways as with Query Parameters and String Validations. And you can also declare numeric validations: gt: greater than ge: greater than or equal lt: less than le: less than or equal Info Query, Path, and other classes you will see later are subclasses of a common Param class. All of them share the same parameters for additional validation and metadata you have seen. Technical Details When you import Query, Path and others from fastapi, they are actually functions. That when called, return instances of classes of the same name. So, you import Query, which is a function. And when you call it, it returns an instance of a class also named Query. These functions are there (instead of just using the classes directly) so that your editor doesn't mark errors about their types. That way you can use your normal editor and coding tools without having to add custom configurations to disregard those errors. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Request Body - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/body/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Request Body en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Import Pydantic's BaseModel Create your data model Declare it as a parameter Results Automatic docs Editor support Use the model Request body + path parameters Request body + path + query parameters Without Pydantic FastAPI Learn Tutorial - User Guide Request Body¬∂ When you need to send data from a client (let's say, a browser) to your API, you send it as a request body. A request body is data sent by the client to your API. A response body is the data your API sends to the client. Your API almost always has to send a response body. But clients don't necessarily need to send request bodies all the time. To declare a request body, you use Pydantic models with all their power and benefits. Info To send data, you should use one of: POST (the more common), PUT, DELETE or PATCH. Sending a body with a GET request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases. As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using GET, and proxies in the middle might not support it. Import Pydantic's BaseModel¬∂ First, you need to import BaseModel from pydantic: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\"/items/\") async def create\\_item(item: Item): return item Create your data model¬∂ Then you declare your data model as a class that inherits from BaseModel. Use standard Python types for all the attributes: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\"/items/\") async def create\\_item(item: Item): return item The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use None to make it just optional. For example, this model above declares a JSON \"object\" (or Python dict) like: { \"name\": \"Foo\", \"description\": \"An optional description\", \"price\": 45.2, \"tax\": 3.5 } ...as description and tax are optional (with a default value of None), this JSON \"object\" would also be valid: { \"name\": \"Foo\", \"price\": 45.2 } Declare it as a parameter¬∂ To add it to your path operation, declare it the same way you declared path and query parameters: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\"/items/\") async def create\\_item(item: Item): return item ...and declare its type as the model you created, Item. Results¬∂ With just that Python type declaration, FastAPI will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data. Give you the received data in the parameter item. As you declared it in the function to be of type Item, you will also have all the editor support (completion, etc) for all of the attributes and their types. Generate JSON Schema definitions for your model, you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation UIs. Automatic docs¬∂ The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: And will be also used in the API docs inside each path operation that needs them: Editor support¬∂ In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a dict instead of a Pydantic model): You also get error checks for incorrect type operations: This is not by chance, the whole framework was built around that design. And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors. There were even some changes to Pydantic itself to support this. The previous screenshots were taken with Visual Studio Code. But you would get the same editor support with PyCharm and most of the other Python editors: Tip If you use PyCharm as your editor, you can use the Pydantic PyCharm Plugin. It improves editor support for Pydantic models, with: auto-completion type checks refactoring searching inspections Use the model¬∂ Inside of the function, you can access all the attributes of the model object directly: Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.post(\"/items/\") async def create\\_item(item: Item): item\\_dict = item.dict() if item.tax: price\\_with\\_tax = item.price + item.tax item\\_dict.update({\"price\\_with\\_tax\": price\\_with\\_tax}) return item\\_dict Request body + path parameters¬∂ You can declare path parameters and request body at the same time. FastAPI will recognize that the function parameters that match path parameters should be taken from the path, and that function parameters that are declared to be Pydantic models should be taken from the request body. Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.put(\"/items/{item\\_id}\") async def create\\_item(item\\_id: int, item: Item): return {\"item\\_id\": item\\_id, \\*\\*item.dict()} Request body + path + query parameters¬∂ You can also declare body, path and query parameters, all at the same time. FastAPI will recognize each of them and take the data from the correct place. Python 3.10+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None price: float tax: float | None = None app = FastAPI() @app.put(\"/items/{item\\_id}\") async def create\\_item(item\\_id: int, item: Item, q: str | None = None): result = {\"item\\_id\": item\\_id, \\*\\*item.dict()} if q: result.update({\"q\": q}) return result The function parameters will be recognized as follows: If the parameter is also declared in the path, it will be used as a path parameter. If the parameter is of a singular type (like int, float, str, bool, etc) it will be interpreted as a query parameter. If the parameter is declared to be of the type of a Pydantic model, it will be interpreted as a request body. Note FastAPI will know that the value of q is not required because of the default value = None. The Union in Union\\[str, None\\] is not used by FastAPI, but will allow your editor to give you better support and detect errors. Without Pydantic¬∂ If you don't want to use Pydantic models, you can also use Body parameters. See the docs for Body - Multiple Parameters: Singular values in body. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Query Parameters - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/query-params/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Query Parameters en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Defaults Optional parameters Query parameter type conversion Multiple path and query parameters Required query parameters FastAPI Learn Tutorial - User Guide Query Parameters¬∂ When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. from fastapi import FastAPI app = FastAPI() fake\\_items\\_db = \\[{\"item\\_name\": \"Foo\"}, {\"item\\_name\": \"Bar\"}, {\"item\\_name\": \"Baz\"}\\] @app.get(\"/items/\") async def read\\_item(skip: int = 0, limit: int = 10): return fake\\_items\\_db\\[skip : skip + limit\\] The query is the set of key-value pairs that go after the ? in a URL, separated by & characters. For example, in the URL: http://127.0.0.1:8000/items/?skip=0&limit=10 ...the query parameters are: skip: with a value of 0 limit: with a value of 10 As they are part of the URL, they are \"naturally\" strings. But when you declare them with Python types (in the example above, as int), they are converted to that type and validated against it. All the same process that applied for path parameters also applies for query parameters: Editor support (obviously) Data \"parsing\" Data validation Automatic documentation Defaults¬∂ As query parameters are not a fixed part of a path, they can be optional and can have default values. In the example above they have default values of skip=0 and limit=10. So, going to the URL: http://127.0.0.1:8000/items/ would be the same as going to: http://127.0.0.1:8000/items/?skip=0&limit=10 But if you go to, for example: http://127.0.0.1:8000/items/?skip=20 The parameter values in your function will be: skip=20: because you set it in the URL limit=10: because that was the default value Optional parameters¬∂ The same way, you can declare optional query parameters, by setting their default to None: Python 3.10+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: str, q: str | None = None): if q: return {\"item\\_id\": item\\_id, \"q\": q} return {\"item\\_id\": item\\_id} In this case, the function parameter q will be optional, and will be None by default. Check Also notice that FastAPI is smart enough to notice that the path parameter item\\_id is a path parameter and q is not, so, it's a query parameter. Query parameter type conversion¬∂ You can also declare bool types, and they will be converted: Python 3.10+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: str, q: str | None = None, short: bool = False): item = {\"item\\_id\": item\\_id} if q: item.update({\"q\": q}) if not short: item.update( {\"description\": \"This is an amazing item that has a long description\"} ) return item In this case, if you go to: http://127.0.0.1:8000/items/foo?short=1 or http://127.0.0.1:8000/items/foo?short=True or http://127.0.0.1:8000/items/foo?short=true or http://127.0.0.1:8000/items/foo?short=on or http://127.0.0.1:8000/items/foo?short=yes or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter short with a bool value of True. Otherwise as False. Multiple path and query parameters¬∂ You can declare multiple path parameters and query parameters at the same time, FastAPI knows which is which. And you don't have to declare them in any specific order. They will be detected by name: Python 3.10+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/users/{user\\_id}/items/{item\\_id}\") async def read\\_user\\_item( user\\_id: int, item\\_id: str, q: str | None = None, short: bool = False ): item = {\"item\\_id\": item\\_id, \"owner\\_id\": user\\_id} if q: item.update({\"q\": q}) if not short: item.update( {\"description\": \"This is an amazing item that has a long description\"} ) return item Required query parameters¬∂ When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required. If you don't want to add a specific value but just make it optional, set the default as None. But when you want to make a query parameter required, you can just not declare any default value: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_user\\_item(item\\_id: str, needy: str): item = {\"item\\_id\": item\\_id, \"needy\": needy} return item Here the query parameter needy is a required query parameter of type str. If you open in your browser a URL like: http://127.0.0.1:8000/items/foo-item ...without adding the required parameter needy, you will see an error like: { \"detail\": \\[ { \"type\": \"missing\", \"loc\": \\[ \"query\", \"needy\" \\], \"msg\": \"Field required\", \"input\": null, \"url\": \"https://errors.pydantic.dev/2.1/v/missing\" } \\] } As needy is a required parameter, you would need to set it in the URL: http://127.0.0.1:8000/items/foo-item?needy=sooooneedy ...this would work: { \"item\\_id\": \"foo-item\", \"needy\": \"sooooneedy\" } And of course, you can define some parameters as required, some as having a default value, and some entirely optional: Python 3.10+ Python 3.8+ from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_user\\_item( item\\_id: str, needy: str, skip: int = 0, limit: int | None = None ): item = {\"item\\_id\": item\\_id, \"needy\": needy, \"skip\": skip, \"limit\": limit} return item In this case, there are 3 query parameters: needy, a required str. skip, an int with a default value of 0. limit, an optional int. Tip You could also use Enums the same way as with Path Parameters. Made with Material for MkDocs Insiders"
  },
  {
    "title": "First Steps - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/first-steps/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI First Steps en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Check it Interactive API docs Alternative API docs OpenAPI \"Schema\" API \"schema\" Data \"schema\" OpenAPI and JSON Schema Check the openapi.json What is OpenAPI for Recap, step by step Step 1: import FastAPI Step 2: create a FastAPI \"instance\" Step 3: create a path operation Path Operation Define a path operation decorator Step 4: define the path operation function Step 5: return the content Recap FastAPI Learn Tutorial - User Guide First Steps¬∂ The simplest FastAPI file could look like this: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} Copy that to a file main.py. Run the live server: fast ‚Üí Note The command uvicorn main:app refers to: main: the file main.py (the Python \"module\"). app: the object created inside of main.py with the line app = FastAPI(). --reload: make the server restart after code changes. Only use for development. In the output, there's a line with something like: INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) That line shows the URL where your app is being served, in your local machine. Check it¬∂ Open your browser at http://127.0.0.1:8000. You will see the JSON response as: {\"message\": \"Hello World\"} Interactive API docs¬∂ Now go to http://127.0.0.1:8000/docs. You will see the automatic interactive API documentation (provided by Swagger UI): Alternative API docs¬∂ And now, go to http://127.0.0.1:8000/redoc. You will see the alternative automatic documentation (provided by ReDoc): OpenAPI¬∂ FastAPI generates a \"schema\" with all your API using the OpenAPI standard for defining APIs. \"Schema\"¬∂ A \"schema\" is a definition or description of something. Not the code that implements it, but just an abstract description. API \"schema\"¬∂ In this case, OpenAPI is a specification that dictates how to define a schema of your API. This schema definition includes your API paths, the possible parameters they take, etc. Data \"schema\"¬∂ The term \"schema\" might also refer to the shape of some data, like a JSON content. In that case, it would mean the JSON attributes, and data types they have, etc. OpenAPI and JSON Schema¬∂ OpenAPI defines an API schema for your API. And that schema includes definitions (or \"schemas\") of the data sent and received by your API using JSON Schema, the standard for JSON data schemas. Check the openapi.json¬∂ If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API. You can see it directly at: http://127.0.0.1:8000/openapi.json. It will show a JSON starting with something like: { \"openapi\": \"3.1.0\", \"info\": { \"title\": \"FastAPI\", \"version\": \"0.1.0\" }, \"paths\": { \"/items/\": { \"get\": { \"responses\": { \"200\": { \"description\": \"Successful Response\", \"content\": { \"application/json\": { ... What is OpenAPI for¬∂ The OpenAPI schema is what powers the two interactive documentation systems included. And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with FastAPI. You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications. Recap, step by step¬∂ Step 1: import FastAPI¬∂ from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} FastAPI is a Python class that provides all the functionality for your API. Technical Details FastAPI is a class that inherits directly from Starlette. You can use all the Starlette functionality with FastAPI too. Step 2: create a FastAPI \"instance\"¬∂ from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} Here the app variable will be an \"instance\" of the class FastAPI. This will be the main point of interaction to create all your API. This app is the same one referred by uvicorn in the command: If you create your app like: from fastapi import FastAPI my\\_awesome\\_api = FastAPI() @my\\_awesome\\_api.get(\"/\") async def root(): return {\"message\": \"Hello World\"} And put it in a file main.py, then you would call uvicorn like: Step 3: create a path operation¬∂ Path¬∂ \"Path\" here refers to the last part of the URL starting from the first /. So, in a URL like: https://example.com/items/foo ...the path would be: /items/foo Info A \"path\" is also commonly called an \"endpoint\" or a \"route\". While building an API, the \"path\" is the main way to separate \"concerns\" and \"resources\". Operation¬∂ \"Operation\" here refers to one of the HTTP \"methods\". One of: POST GET PUT DELETE ...and the more exotic ones: OPTIONS HEAD PATCH TRACE In the HTTP protocol, you can communicate to each path using one (or more) of these \"methods\". When building APIs, you normally use these specific HTTP methods to perform a specific action. Normally you use: POST: to create data. GET: to read data. PUT: to update data. DELETE: to delete data. So, in OpenAPI, each of the HTTP methods is called an \"operation\". We are going to call them \"operations\" too. Define a path operation decorator¬∂ from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} The @app.get(\"/\") tells FastAPI that the function right below is in charge of handling requests that go to: the path / using a get operation @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells FastAPI that the function below corresponds to the path / with an operation get. It is the \"path operation decorator\". You can also use the other operations: @app.post() @app.put() @app.delete() And the more exotic ones: @app.options() @app.head() @app.patch() @app.trace() Tip You are free to use each operation (HTTP method) as you wish. FastAPI doesn't enforce any specific meaning. The information here is presented as a guideline, not a requirement. For example, when using GraphQL you normally perform all the actions using only POST operations. Step 4: define the path operation function¬∂ This is our \"path operation function\": path: is /. operation: is get. function: is the function below the \"decorator\" (below @app.get(\"/\")). from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} This is a Python function. It will be called by FastAPI whenever it receives a request to the URL \"/\" using a GET operation. In this case, it is an async function. You could also define it as a normal function instead of async def: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def root(): return {\"message\": \"Hello World\"} Note If you don't know the difference, check the Async: \"In a hurry?\". Step 5: return the content¬∂ from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} You can return a dict, list, singular values as str, int, etc. You can also return Pydantic models (you'll see more about that later). There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported. Recap¬∂ Import FastAPI. Create an app instance. Write a path operation decorator (like @app.get(\"/\")). Write a path operation function (like def root(): ... above). Run the development server (like uvicorn main:app --reload). Made with Material for MkDocs Insiders"
  },
  {
    "title": "Path Parameters - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/path-params/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Path Parameters en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Path parameters with types Data conversion Data validation Documentation Standards-based benefits, alternative documentation Pydantic Order matters Predefined values Create an Enum class Declare a path parameter Check the docs Working with Python enumerations Compare enumeration members Get the enumeration value Return enumeration members Path parameters containing paths OpenAPI support Path convertor Recap FastAPI Learn Tutorial - User Guide Path Parameters¬∂ You can declare path \"parameters\" or \"variables\" with the same syntax used by Python format strings: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id): return {\"item\\_id\": item\\_id} The value of the path parameter item\\_id will be passed to your function as the argument item\\_id. So, if you run this example and go to http://127.0.0.1:8000/items/foo, you will see a response of: {\"item\\_id\":\"foo\"} Path parameters with types¬∂ You can declare the type of a path parameter in the function, using standard Python type annotations: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item\\_id}\") async def read\\_item(item\\_id: int): return {\"item\\_id\": item\\_id} In this case, item\\_id is declared to be an int. Check This will give you editor support inside of your function, with error checks, completion, etc. Data conversion¬∂ If you run this example and open your browser at http://127.0.0.1:8000/items/3, you will see a response of: {\"item\\_id\":3} Check Notice that the value your function received (and returned) is 3, as a Python int, not a string \"3\". So, with that type declaration, FastAPI gives you automatic request \"parsing\". Data validation¬∂ But if you go to the browser at http://127.0.0.1:8000/items/foo, you will see a nice HTTP error of: { \"detail\": \\[ { \"type\": \"int\\_parsing\", \"loc\": \\[ \"path\", \"item\\_id\" \\], \"msg\": \"Input should be a valid integer, unable to parse string as an integer\", \"input\": \"foo\", \"url\": \"https://errors.pydantic.dev/2.1/v/int\\_parsing\" } \\] } because the path parameter item\\_id had a value of \"foo\", which is not an int. The same error would appear if you provided a float instead of an int, as in: http://127.0.0.1:8000/items/4.2 Check So, with the same Python type declaration, FastAPI gives you data validation. Notice that the error also clearly states exactly the point where the validation didn't pass. This is incredibly helpful while developing and debugging code that interacts with your API. Documentation¬∂ And when you open your browser at http://127.0.0.1:8000/docs, you will see an automatic, interactive, API documentation like: Check Again, just with that same Python type declaration, FastAPI gives you automatic, interactive documentation (integrating Swagger UI). Notice that the path parameter is declared to be an integer. Standards-based benefits, alternative documentation¬∂ And because the generated schema is from the OpenAPI standard, there are many compatible tools. Because of this, FastAPI itself provides an alternative API documentation (using ReDoc), which you can access at http://127.0.0.1:8000/redoc: The same way, there are many compatible tools. Including code generation tools for many languages. Pydantic¬∂ All the data validation is performed under the hood by Pydantic, so you get all the benefits from it. And you know you are in good hands. You can use the same type declarations with str, float, bool and many other complex data types. Several of these are explored in the next chapters of the tutorial. Order matters¬∂ When creating path operations, you can find situations where you have a fixed path. Like /users/me, let's say that it's to get data about the current user. And then you can also have a path /users/{user\\_id} to get data about a specific user by some user ID. Because path operations are evaluated in order, you need to make sure that the path for /users/me is declared before the one for /users/{user\\_id}: from fastapi import FastAPI app = FastAPI() @app.get(\"/users/me\") async def read\\_user\\_me(): return {\"user\\_id\": \"the current user\"} @app.get(\"/users/{user\\_id}\") async def read\\_user(user\\_id: str): return {\"user\\_id\": user\\_id} Otherwise, the path for /users/{user\\_id} would match also for /users/me, \"thinking\" that it's receiving a parameter user\\_id with a value of \"me\". Similarly, you cannot redefine a path operation: from fastapi import FastAPI app = FastAPI() @app.get(\"/users\") async def read\\_users(): return \\[\"Rick\", \"Morty\"\\] @app.get(\"/users\") async def read\\_users2(): return \\[\"Bean\", \"Elfo\"\\] The first one will always be used since the path matches first. Predefined values¬∂ If you have a path operation that receives a path parameter, but you want the possible valid path parameter values to be predefined, you can use a standard Python Enum. Create an Enum class¬∂ Import Enum and create a sub-class that inherits from str and from Enum. By inheriting from str the API docs will be able to know that the values must be of type string and will be able to render correctly. Then create class attributes with fixed values, which will be the available valid values: from enum import Enum from fastapi import FastAPI class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model\\_name}\") async def get\\_model(model\\_name: ModelName): if model\\_name is ModelName.alexnet: return {\"model\\_name\": model\\_name, \"message\": \"Deep Learning FTW!\"} if model\\_name.value == \"lenet\": return {\"model\\_name\": model\\_name, \"message\": \"LeCNN all the images\"} return {\"model\\_name\": model\\_name, \"message\": \"Have some residuals\"} Info Enumerations (or enums) are available in Python since version 3.4. Tip If you are wondering, \"AlexNet\", \"ResNet\", and \"LeNet\" are just names of Machine Learning models. Declare a path parameter¬∂ Then create a path parameter with a type annotation using the enum class you created (ModelName): from enum import Enum from fastapi import FastAPI class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model\\_name}\") async def get\\_model(model\\_name: ModelName): if model\\_name is ModelName.alexnet: return {\"model\\_name\": model\\_name, \"message\": \"Deep Learning FTW!\"} if model\\_name.value == \"lenet\": return {\"model\\_name\": model\\_name, \"message\": \"LeCNN all the images\"} return {\"model\\_name\": model\\_name, \"message\": \"Have some residuals\"} Check the docs¬∂ Because the available values for the path parameter are predefined, the interactive docs can show them nicely: Working with Python enumerations¬∂ The value of the path parameter will be an enumeration member. Compare enumeration members¬∂ You can compare it with the enumeration member in your created enum ModelName: from enum import Enum from fastapi import FastAPI class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model\\_name}\") async def get\\_model(model\\_name: ModelName): if model\\_name is ModelName.alexnet: return {\"model\\_name\": model\\_name, \"message\": \"Deep Learning FTW!\"} if model\\_name.value == \"lenet\": return {\"model\\_name\": model\\_name, \"message\": \"LeCNN all the images\"} return {\"model\\_name\": model\\_name, \"message\": \"Have some residuals\"} Get the enumeration value¬∂ You can get the actual value (a str in this case) using model\\_name.value, or in general, your\\_enum\\_member.value: from enum import Enum from fastapi import FastAPI class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model\\_name}\") async def get\\_model(model\\_name: ModelName): if model\\_name is ModelName.alexnet: return {\"model\\_name\": model\\_name, \"message\": \"Deep Learning FTW!\"} if model\\_name.value == \"lenet\": return {\"model\\_name\": model\\_name, \"message\": \"LeCNN all the images\"} return {\"model\\_name\": model\\_name, \"message\": \"Have some residuals\"} Tip You could also access the value \"lenet\" with ModelName.lenet.value. Return enumeration members¬∂ You can return enum members from your path operation, even nested in a JSON body (e.g. a dict). They will be converted to their corresponding values (strings in this case) before returning them to the client: from enum import Enum from fastapi import FastAPI class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model\\_name}\") async def get\\_model(model\\_name: ModelName): if model\\_name is ModelName.alexnet: return {\"model\\_name\": model\\_name, \"message\": \"Deep Learning FTW!\"} if model\\_name.value == \"lenet\": return {\"model\\_name\": model\\_name, \"message\": \"LeCNN all the images\"} return {\"model\\_name\": model\\_name, \"message\": \"Have some residuals\"} In your client you will get a JSON response like: { \"model\\_name\": \"alexnet\", \"message\": \"Deep Learning FTW!\" } Path parameters containing paths¬∂ Let's say you have a path operation with a path /files/{file\\_path}. But you need file\\_path itself to contain a path, like home/johndoe/myfile.txt. So, the URL for that file would be something like: /files/home/johndoe/myfile.txt. OpenAPI support¬∂ OpenAPI doesn't support a way to declare a path parameter to contain a path inside, as that could lead to scenarios that are difficult to test and define. Nevertheless, you can still do it in FastAPI, using one of the internal tools from Starlette. And the docs would still work, although not adding any documentation telling that the parameter should contain a path. Path convertor¬∂ Using an option directly from Starlette you can declare a path parameter containing a path using a URL like: /files/{file\\_path:path} In this case, the name of the parameter is file\\_path, and the last part, :path, tells it that the parameter should match any path. So, you can use it with: from fastapi import FastAPI app = FastAPI() @app.get(\"/files/{file\\_path:path}\") async def read\\_file(file\\_path: str): return {\"file\\_path\": file\\_path} Tip You could need the parameter to contain /home/johndoe/myfile.txt, with a leading slash (/). In that case, the URL would be: /files//home/johndoe/myfile.txt, with a double slash (//) between files and home. Recap¬∂ With FastAPI, by using short, intuitive and standard Python type declarations, you get: Editor support: error checks, autocompletion, etc. Data \"parsing\" Data validation API annotation and automatic documentation And you only have to declare them once. That's probably the main visible advantage of FastAPI compared to alternative frameworks (apart from the raw performance). Made with Material for MkDocs Insiders"
  },
  {
    "title": "Tutorial - User Guide - FastAPI",
    "url": "https://fastapi.tiangolo.com/tutorial/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Tutorial - User Guide en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide First Steps Path Parameters Query Parameters Request Body Query Parameters and String Validations Path Parameters and Numeric Validations Body - Multiple Parameters Body - Fields Body - Nested Models Declare Request Example Data Extra Data Types Cookie Parameters Header Parameters Response Model - Return Type Extra Models Response Status Code Form Data Request Files Request Forms and Files Handling Errors Path Operation Configuration JSON Compatible Encoder Body - Updates Dependencies Security Middleware CORS (Cross-Origin Resource Sharing) SQL (Relational) Databases Bigger Applications - Multiple Files Background Tasks Metadata and Docs URLs Static Files Testing Debugging Advanced User Guide Deployment How To - Recipes Table of contents Run the code Install FastAPI Advanced User Guide FastAPI Learn Tutorial - User Guide Tutorial - User Guide¬∂ This tutorial shows you how to use FastAPI with most of its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific API needs. It is also built to work as a future reference. So you can come back and see exactly what you need. Run the code¬∂ All the code blocks can be copied and used directly (they are actually tested Python files). To run any of the examples, copy the code to a file main.py, and start uvicorn with: fast ‚Üí It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of FastAPI, seeing how little code you have to write, all the type checks, autocompletion, etc. Install FastAPI¬∂ The first step is to install FastAPI. For the tutorial, you might want to install it with all the optional dependencies and features: ...that also includes uvicorn, that you can use as the server that runs your code. Note You can also install it part by part. This is what you would probably do once you want to deploy your application to production: pip install fastapi Also install uvicorn to work as the server: pip install \"uvicorn\\[standard\\]\" And the same for each of the optional dependencies that you want to use. Advanced User Guide¬∂ There is also an Advanced User Guide that you can read later after this Tutorial - User guide. The Advanced User Guide, builds on this, uses the same concepts, and teaches you some extra features. But you should first read the Tutorial - User Guide (what you are reading right now). It's designed so that you can build a complete application with just the Tutorial - User Guide, and then extend it in different ways, depending on your needs, using some of the additional ideas from the Advanced User Guide. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Python Types Intro - FastAPI",
    "url": "https://fastapi.tiangolo.com/python-types/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Python Types Intro en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes Table of contents Motivation Edit it Add types More motivation Declaring types Simple types Generic types with type parameters Newer versions of Python List Tuple and Set Dict Union Possibly None Using Union or Optional Generic types Classes as types Pydantic models Type Hints with Metadata Annotations Type hints in FastAPI FastAPI Learn Python Types Intro¬∂ Python has support for optional \"type hints\" (also called \"type annotations\"). These \"type hints\" or annotations are a special syntax that allow declaring the type of a variable. By declaring types for your variables, editors and tools can give you better support. This is just a quick tutorial / refresher about Python type hints. It covers only the minimum necessary to use them with FastAPI... which is actually very little. FastAPI is all based on these type hints, they give it many advantages and benefits. But even if you never use FastAPI, you would benefit from learning a bit about them. Note If you are a Python expert, and you already know everything about type hints, skip to the next chapter. Motivation¬∂ Let's start with a simple example: def get\\_full\\_name(first\\_name, last\\_name): full\\_name = first\\_name.title() + \" \" + last\\_name.title() return full\\_name print(get\\_full\\_name(\"john\", \"doe\")) Calling this program outputs: John Doe The function does the following: Takes a first\\_name and last\\_name. Converts the first letter of each one to upper case with title(). Concatenates them with a space in the middle. def get\\_full\\_name(first\\_name, last\\_name): full\\_name = first\\_name.title() + \" \" + last\\_name.title() return full\\_name print(get\\_full\\_name(\"john\", \"doe\")) Edit it¬∂ It's a very simple program. But now imagine that you were writing it from scratch. At some point you would have started the definition of the function, you had the parameters ready... But then you have to call \"that method that converts the first letter to upper case\". Was it upper? Was it uppercase? first\\_uppercase? capitalize? Then, you try with the old programmer's friend, editor autocompletion. You type the first parameter of the function, first\\_name, then a dot (.) and then hit Ctrl+Space to trigger the completion. But, sadly, you get nothing useful: Add types¬∂ Let's modify a single line from the previous version. We will change exactly this fragment, the parameters of the function, from: first\\_name, last\\_name to: first\\_name: str, last\\_name: str That's it. Those are the \"type hints\": def get\\_full\\_name(first\\_name: str, last\\_name: str): full\\_name = first\\_name.title() + \" \" + last\\_name.title() return full\\_name print(get\\_full\\_name(\"john\", \"doe\")) That is not the same as declaring default values like would be with: first\\_name=\"john\", last\\_name=\"doe\" It's a different thing. We are using colons (:), not equals (=). And adding type hints normally doesn't change what happens from what would happen without them. But now, imagine you are again in the middle of creating that function, but with type hints. At the same point, you try to trigger the autocomplete with Ctrl+Space and you see: With that, you can scroll, seeing the options, until you find the one that \"rings a bell\": More motivation¬∂ Check this function, it already has type hints: def get\\_name\\_with\\_age(name: str, age: int): name\\_with\\_age = name + \" is this old: \" + age return name\\_with\\_age Because the editor knows the types of the variables, you don't only get completion, you also get error checks: Now you know that you have to fix it, convert age to a string with str(age): def get\\_name\\_with\\_age(name: str, age: int): name\\_with\\_age = name + \" is this old: \" + str(age) return name\\_with\\_age Declaring types¬∂ You just saw the main place to declare type hints. As function parameters. This is also the main place you would use them with FastAPI. Simple types¬∂ You can declare all the standard Python types, not only str. You can use, for example: int float bool bytes def get\\_items(item\\_a: str, item\\_b: int, item\\_c: float, item\\_d: bool, item\\_e: bytes): return item\\_a, item\\_b, item\\_c, item\\_d, item\\_d, item\\_e Generic types with type parameters¬∂ There are some data structures that can contain other values, like dict, list, set and tuple. And the internal values can have their own type too. These types that have internal types are called \"generic\" types. And it's possible to declare them, even with their internal types. To declare those types and the internal types, you can use the standard Python module typing. It exists specifically to support these type hints. Newer versions of Python¬∂ The syntax using typing is compatible with all versions, from Python 3.6 to the latest ones, including Python 3.9, Python 3.10, etc. As Python advances, newer versions come with improved support for these type annotations and in many cases you won't even need to import and use the typing module to declare the type annotations. If you can choose a more recent version of Python for your project, you will be able to take advantage of that extra simplicity. In all the docs there are examples compatible with each version of Python (when there's a difference). For example \"Python 3.6+\" means it's compatible with Python 3.6 or above (including 3.7, 3.8, 3.9, 3.10, etc). And \"Python 3.9+\" means it's compatible with Python 3.9 or above (including 3.10, etc). If you can use the latest versions of Python, use the examples for the latest version, those will have the best and simplest syntax, for example, \"Python 3.10+\". List¬∂ For example, let's define a variable to be a list of str. Python 3.9+ Python 3.8+ Declare the variable, with the same colon (:) syntax. As the type, put list. As the list is a type that contains some internal types, you put them in square brackets: def process\\_items(items: list\\[str\\]): for item in items: print(item) Info Those internal types in the square brackets are called \"type parameters\". In this case, str is the type parameter passed to List (or list in Python 3.9 and above). That means: \"the variable items is a list, and each of the items in this list is a str\". Tip If you use Python 3.9 or above, you don't have to import List from typing, you can use the same regular list type instead. By doing that, your editor can provide support even while processing items from the list: Without types, that's almost impossible to achieve. Notice that the variable item is one of the elements in the list items. And still, the editor knows it is a str, and provides support for that. Tuple and Set¬∂ You would do the same to declare tuples and sets: Python 3.9+ Python 3.8+ def process\\_items(items\\_t: tuple\\[int, int, str\\], items\\_s: set\\[bytes\\]): return items\\_t, items\\_s This means: The variable items\\_t is a tuple with 3 items, an int, another int, and a str. The variable items\\_s is a set, and each of its items is of type bytes. Dict¬∂ To define a dict, you pass 2 type parameters, separated by commas. The first type parameter is for the keys of the dict. The second type parameter is for the values of the dict: Python 3.9+ Python 3.8+ def process\\_items(prices: dict\\[str, float\\]): for item\\_name, item\\_price in prices.items(): print(item\\_name) print(item\\_price) This means: The variable prices is a dict: The keys of this dict are of type str (let's say, the name of each item). The values of this dict are of type float (let's say, the price of each item). Union¬∂ You can declare that a variable can be any of several types, for example, an int or a str. In Python 3.6 and above (including Python 3.10) you can use the Union type from typing and put inside the square brackets the possible types to accept. In Python 3.10 there's also a new syntax where you can put the possible types separated by a vertical bar (|). Python 3.10+ Python 3.8+ def process\\_item(item: int | str): print(item) In both cases this means that item could be an int or a str. Possibly None¬∂ You can declare that a value could have a type, like str, but that it could also be None. In Python 3.6 and above (including Python 3.10) you can declare it by importing and using Optional from the typing module. from typing import Optional def say\\_hi(name: Optional\\[str\\] = None): if name is not None: print(f\"Hey {name}!\") else: print(\"Hello World\") Using Optional\\[str\\] instead of just str will let the editor help you detecting errors where you could be assuming that a value is always a str, when it could actually be None too. Optional\\[Something\\] is actually a shortcut for Union\\[Something, None\\], they are equivalent. This also means that in Python 3.10, you can use Something | None: Python 3.10+ Python 3.8+ Python 3.8+ alternative def say\\_hi(name: str | None = None): if name is not None: print(f\"Hey {name}!\") else: print(\"Hello World\") Using Union or Optional¬∂ If you are using a Python version below 3.10, here's a tip from my very subjective point of view: üö® Avoid using Optional\\[SomeType\\] Instead ‚ú® use Union\\[SomeType, None\\] ‚ú®. Both are equivalent and underneath they are the same, but I would recommend Union instead of Optional because the word \"optional\" would seem to imply that the value is optional, and it actually means \"it can be None\", even if it's not optional and is still required. I think Union\\[SomeType, None\\] is more explicit about what it means. It's just about the words and names. But those words can affect how you and your teammates think about the code. As an example, let's take this function: from typing import Optional def say\\_hi(name: Optional\\[str\\]): print(f\"Hey {name}!\") The parameter name is defined as Optional\\[str\\], but it is not optional, you cannot call the function without the parameter: say\\_hi() # Oh, no, this throws an error! üò± The name parameter is still required (not optional) because it doesn't have a default value. Still, name accepts None as the value: say\\_hi(name=None) # This works, None is valid üéâ The good news is, once you are on Python 3.10 you won't have to worry about that, as you will be able to simply use | to define unions of types: def say\\_hi(name: str | None): print(f\"Hey {name}!\") And then you won't have to worry about names like Optional and Union. üòé Generic types¬∂ These types that take type parameters in square brackets are called Generic types or Generics, for example: Python 3.10+ Python 3.9+ Python 3.8+ You can use the same builtin types as generics (with square brackets and types inside): list tuple set dict And the same as with Python 3.8, from the typing module: Union Optional (the same as with Python 3.8) ...and others. In Python 3.10, as an alternative to using the generics Union and Optional, you can use the vertical bar (|) to declare unions of types, that's a lot better and simpler. Classes as types¬∂ You can also declare a class as the type of a variable. Let's say you have a class Person, with a name: class Person: def \\_\\_init\\_\\_(self, name: str): self.name = name def get\\_person\\_name(one\\_person: Person): return one\\_person.name Then you can declare a variable to be of type Person: class Person: def \\_\\_init\\_\\_(self, name: str): self.name = name def get\\_person\\_name(one\\_person: Person): return one\\_person.name And then, again, you get all the editor support: Notice that this means \"one\\_person is an instance of the class Person\". It doesn't mean \"one\\_person is the class called Person\". Pydantic models¬∂ Pydantic is a Python library to perform data validation. You declare the \"shape\" of the data as classes with attributes. And each attribute has a type. Then you create an instance of that class with some values and it will validate the values, convert them to the appropriate type (if that's the case) and give you an object with all the data. And you get all the editor support with that resulting object. An example from the official Pydantic docs: Python 3.10+ Python 3.9+ Python 3.8+ from datetime import datetime from pydantic import BaseModel class User(BaseModel): id: int name: str = \"John Doe\" signup\\_ts: datetime | None = None friends: list\\[int\\] = \\[\\] external\\_data = { \"id\": \"123\", \"signup\\_ts\": \"2017-06-01 12:22\", \"friends\": \\[1, \"2\", b\"3\"\\], } user = User(\\*\\*external\\_data) print(user) # > User id=123 name='John Doe' signup\\_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=\\[1, 2, 3\\] print(user.id) # > 123 Info To learn more about Pydantic, check its docs. FastAPI is all based on Pydantic. You will see a lot more of all this in practice in the Tutorial - User Guide. Tip Pydantic has a special behavior when you use Optional or Union\\[Something, None\\] without a default value, you can read more about it in the Pydantic docs about Required Optional fields. Type Hints with Metadata Annotations¬∂ Python also has a feature that allows putting additional metadata in these type hints using Annotated. Python 3.9+ Python 3.8+ In Python 3.9, Annotated is part of the standard library, so you can import it from typing. from typing import Annotated def say\\_hello(name: Annotated\\[str, \"this is just metadata\"\\]) -> str: return f\"Hello {name}\" Python itself doesn't do anything with this Annotated. And for editors and other tools, the type is still str. But you can use this space in Annotated to provide FastAPI with additional metadata about how you want your application to behave. The important thing to remember is that the first type parameter you pass to Annotated is the actual type. The rest, is just metadata for other tools. For now, you just need to know that Annotated exists, and that it's standard Python. üòé Later you will see how powerful it can be. Tip The fact that this is standard Python means that you will still get the best possible developer experience in your editor, with the tools you use to analyze and refactor your code, etc. ‚ú® And also that your code will be very compatible with many other Python tools and libraries. üöÄ Type hints in FastAPI¬∂ FastAPI takes advantage of these type hints to do several things. With FastAPI you declare parameters with type hints and you get: Editor support. Type checks. ...and FastAPI uses the same declarations to: Define requirements: from request path parameters, query parameters, headers, bodies, dependencies, etc. Convert data: from the request to the required type. Validate data: coming from each request: Generating automatic errors returned to the client when the data is invalid. Document the API using OpenAPI: which is then used by the automatic interactive documentation user interfaces. This might all sound abstract. Don't worry. You'll see all this in action in the Tutorial - User Guide. The important thing is that by using standard Python types, in a single place (instead of adding more classes, decorators, etc), FastAPI will do a lot of the work for you. Info If you already went through all the tutorial and came back to see more about types, a good resource is the \"cheat sheet\" from mypy. Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/custom-request-and-route/middleware.md#gzipmiddleware",
    "html": "Follow @fastapi on Twitter to stay updated sponsor FastAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes 404 - Not found Made with Material for MkDocs Insiders"
  },
  {
    "title": "Configure Swagger UI - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/configure-swagger-ui/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Configure Swagger UI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Disable Syntax Highlighting Change the Theme Change Default Swagger UI Parameters Other Swagger UI Parameters JavaScript-only settings FastAPI Learn How To - Recipes Configure Swagger UI¬∂ You can configure some extra Swagger UI parameters. To configure them, pass the swagger\\_ui\\_parameters argument when creating the FastAPI() app object or to the get\\_swagger\\_ui\\_html() function. swagger\\_ui\\_parameters receives a dictionary with the configurations passed to Swagger UI directly. FastAPI converts the configurations to JSON to make them compatible with JavaScript, as that's what Swagger UI needs. Disable Syntax Highlighting¬∂ For example, you could disable syntax highlighting in Swagger UI. Without changing the settings, syntax highlighting is enabled by default: But you can disable it by setting syntaxHighlight to False: from fastapi import FastAPI app = FastAPI(swagger\\_ui\\_parameters={\"syntaxHighlight\": False}) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} ...and then Swagger UI won't show the syntax highlighting anymore: Change the Theme¬∂ The same way you could set the syntax highlighting theme with the key \"syntaxHighlight.theme\" (notice that it has a dot in the middle): from fastapi import FastAPI app = FastAPI(swagger\\_ui\\_parameters={\"syntaxHighlight.theme\": \"obsidian\"}) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} That configuration would change the syntax highlighting color theme: Change Default Swagger UI Parameters¬∂ FastAPI includes some default configuration parameters appropriate for most of the use cases. It includes these default configurations: swagger\\_ui\\_default\\_parameters: Annotated\\[ Dict\\[str, Any\\], Doc( \"\"\" Default configurations for Swagger UI. You can override any of them by setting a different value in the argument swagger\\_ui\\_parameters. For example, to disable deepLinking you could pass these settings to swagger\\_ui\\_parameters: from fastapi import FastAPI app = FastAPI(swagger\\_ui\\_parameters={\"deepLinking\": False}) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Other Swagger UI Parameters¬∂ To see all the other possible configurations you can use, read the official docs for Swagger UI parameters. JavaScript-only settings¬∂ Swagger UI also allows other configurations to be JavaScript-only objects (for example, JavaScript functions). FastAPI also includes these JavaScript-only presets settings: presets: \\[ SwaggerUIBundle.presets.apis, SwaggerUIBundle.SwaggerUIStandalonePreset \\] These are JavaScript objects, not strings, so you can't pass them from Python code directly. If you need to use JavaScript-only configurations like those, you can use one of the methods above. Override all the Swagger UI path operation and manually write any JavaScript you need. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Docs UI Static Assets (Self-Hosting) - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/custom-docs-ui-assets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Custom Docs UI Static Assets (Self-Hosting) en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Custom CDN for JavaScript and CSS Disable the automatic docs Include the custom docs Create a path operation to test it Test it Self-hosting JavaScript and CSS for docs Project file structure Download the files Serve the static files Test the static files Disable the automatic docs for static files Include the custom docs for static files Create a path operation to test static files Test Static Files UI FastAPI Learn How To - Recipes Custom Docs UI Static Assets (Self-Hosting)¬∂ The API docs use Swagger UI and ReDoc, and each of those need some JavaScript and CSS files. By default, those files are served from a CDN. But it's possible to customize it, you can set a specific CDN, or serve the files yourself. Custom CDN for JavaScript and CSS¬∂ Let's say that you want to use a different CDN, for example you want to use https://unpkg.com/. This could be useful if for example you live in a country that restricts some URLs. Disable the automatic docs¬∂ The first step is to disable the automatic docs, as by default, those use the default CDN. To disable them, set their URLs to None when creating your FastAPI app: from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) app = FastAPI(docs\\_url=None, redoc\\_url=None) @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger\\_css\\_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"https://unpkg.com/redoc@next/bundles/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Include the custom docs¬∂ Now you can create the path operations for the custom docs. You can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments: openapi\\_url: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi\\_url. title: the title of your API. oauth2\\_redirect\\_url: you can use app.swagger\\_ui\\_oauth2\\_redirect\\_url here to use the default. swagger\\_js\\_url: the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the custom CDN URL. swagger\\_css\\_url: the URL where the HTML for your Swagger UI docs can get the CSS file. This is the custom CDN URL. And similarly for ReDoc... from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) app = FastAPI(docs\\_url=None, redoc\\_url=None) @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger\\_css\\_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"https://unpkg.com/redoc@next/bundles/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Tip The path operation for swagger\\_ui\\_redirect is a helper for when you use OAuth2. If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication. Swagger UI will handle it behind the scenes for you, but it needs this \"redirect\" helper. Create a path operation to test it¬∂ Now, to be able to test that everything works, create a path operation: from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) app = FastAPI(docs\\_url=None, redoc\\_url=None) @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js\", swagger\\_css\\_url=\"https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"https://unpkg.com/redoc@next/bundles/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Test it¬∂ Now, you should be able to go to your docs at http://127.0.0.1:8000/docs, and reload the page, it will load those assets from the new CDN. Self-hosting JavaScript and CSS for docs¬∂ Self-hosting the JavaScript and CSS could be useful if, for example, you need your app to keep working even while offline, without open Internet access, or in a local network. Here you'll see how to serve those files yourself, in the same FastAPI app, and configure the docs to use them. Project file structure¬∂ Let's say your project file structure looks like this: . ‚îú‚îÄ‚îÄ app ‚îÇ ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ ‚îú‚îÄ‚îÄ main.py Now create a directory to store those static files. Your new file structure could look like this: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ static/ Download the files¬∂ Download the static files needed for the docs and put them on that static/ directory. You can probably right-click each link and select an option similar to Save link as.... Swagger UI uses the files: swagger-ui-bundle.js swagger-ui.css And ReDoc uses the file: redoc.standalone.js After that, your file structure could look like: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ static ‚îú‚îÄ‚îÄ redoc.standalone.js ‚îú‚îÄ‚îÄ swagger-ui-bundle.js ‚îî‚îÄ‚îÄ swagger-ui.css Serve the static files¬∂ Import StaticFiles. \"Mount\" a StaticFiles() instance in a specific path. from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs\\_url=None, redoc\\_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"/static/swagger-ui-bundle.js\", swagger\\_css\\_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Test the static files¬∂ Start your application and go to http://127.0.0.1:8000/static/redoc.standalone.js. You should see a very long JavaScript file for ReDoc. It could start with something like: /\\*! \\* ReDoc - OpenAPI/Swagger-generated API Reference Documentation \\* ------------------------------------------------------------- \\* Version: \"2.0.0-rc.18\" \\* Repo: https://github.com/Redocly/redoc \\*/ !function(e,t){\"object\"==typeof exports&&\"object\"==typeof m ... That confirms that you are being able to serve static files from your app, and that you placed the static files for the docs in the correct place. Now we can configure the app to use those static files for the docs. Disable the automatic docs for static files¬∂ The same as when using a custom CDN, the first step is to disable the automatic docs, as those use the CDN by default. To disable them, set their URLs to None when creating your FastAPI app: from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs\\_url=None, redoc\\_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"/static/swagger-ui-bundle.js\", swagger\\_css\\_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Include the custom docs for static files¬∂ And the same way as with a custom CDN, now you can create the path operations for the custom docs. Again, you can re-use FastAPI's internal functions to create the HTML pages for the docs, and pass them the needed arguments: openapi\\_url: the URL where the HTML page for the docs can get the OpenAPI schema for your API. You can use here the attribute app.openapi\\_url. title: the title of your API. oauth2\\_redirect\\_url: you can use app.swagger\\_ui\\_oauth2\\_redirect\\_url here to use the default. swagger\\_js\\_url: the URL where the HTML for your Swagger UI docs can get the JavaScript file. This is the one that your own app is now serving. swagger\\_css\\_url: the URL where the HTML for your Swagger UI docs can get the CSS file. This is the one that your own app is now serving. And similarly for ReDoc... from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs\\_url=None, redoc\\_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"/static/swagger-ui-bundle.js\", swagger\\_css\\_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Tip The path operation for swagger\\_ui\\_redirect is a helper for when you use OAuth2. If you integrate your API with an OAuth2 provider, you will be able to authenticate and come back to the API docs with the acquired credentials. And interact with it using the real OAuth2 authentication. Swagger UI will handle it behind the scenes for you, but it needs this \"redirect\" helper. Create a path operation to test static files¬∂ Now, to be able to test that everything works, create a path operation: from fastapi import FastAPI from fastapi.openapi.docs import ( get\\_redoc\\_html, get\\_swagger\\_ui\\_html, get\\_swagger\\_ui\\_oauth2\\_redirect\\_html, ) from fastapi.staticfiles import StaticFiles app = FastAPI(docs\\_url=None, redoc\\_url=None) app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") @app.get(\"/docs\", include\\_in\\_schema=False) async def custom\\_swagger\\_ui\\_html(): return get\\_swagger\\_ui\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - Swagger UI\", oauth2\\_redirect\\_url=app.swagger\\_ui\\_oauth2\\_redirect\\_url, swagger\\_js\\_url=\"/static/swagger-ui-bundle.js\", swagger\\_css\\_url=\"/static/swagger-ui.css\", ) @app.get(app.swagger\\_ui\\_oauth2\\_redirect\\_url, include\\_in\\_schema=False) async def swagger\\_ui\\_redirect(): return get\\_swagger\\_ui\\_oauth2\\_redirect\\_html() @app.get(\"/redoc\", include\\_in\\_schema=False) async def redoc\\_html(): return get\\_redoc\\_html( openapi\\_url=app.openapi\\_url, title=app.title + \" - ReDoc\", redoc\\_js\\_url=\"/static/redoc.standalone.js\", ) @app.get(\"/users/{username}\") async def read\\_user(username: str): return {\"message\": f\"Hello {username}\"} Test Static Files UI¬∂ Now, you should be able to disconnect your WiFi, go to your docs at http://127.0.0.1:8000/docs, and reload the page. And even without Internet, you would be able to see the docs for your API and interact with it. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Separate OpenAPI Schemas for Input and Output or Not - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/separate-openapi-schemas/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Separate OpenAPI Schemas for Input and Output or Not en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Pydantic Models for Input and Output Model for Input Input Model in Docs Model for Output Model for Output Response Data Model for Output in Docs Model for Input and Output in Docs Do not Separate Schemas Same Schema for Input and Output Models in Docs FastAPI Learn How To - Recipes Separate OpenAPI Schemas for Input and Output or Not¬∂ When using Pydantic v2, the generated OpenAPI is a bit more exact and correct than before. üòé In fact, in some cases, it will even have two JSON Schemas in OpenAPI for the same Pydantic model, for input and output, depending on if they have default values. Let's see how that works and how to change it if you need to do that. Pydantic Models for Input and Output¬∂ Let's say you have a Pydantic model with default values, like this one: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None # Code below omitted üëá üëÄ Full file preview Model for Input¬∂ If you use this model as an input like here: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.post(\"/items/\") def create\\_item(item: Item): return item # Code below omitted üëá üëÄ Full file preview ...then the description field will not be required. Because it has a default value of None. Input Model in Docs¬∂ You can confirm that in the docs, the description field doesn't have a red asterisk, it's not marked as required: Model for Output¬∂ But if you use the same model as an output, like here: Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI() @app.post(\"/items/\") def create\\_item(item: Item): return item @app.get(\"/items/\") def read\\_items() -> list\\[Item\\]: return \\[ Item( name=\"Portal Gun\", description=\"Device to travel through the multi-rick-verse\", ), Item(name=\"Plumbus\"), \\] ...then because description has a default value, if you don't return anything for that field, it will still have that default value. Model for Output Response Data¬∂ If you interact with the docs and check the response, even though the code didn't add anything in one of the description fields, the JSON response contains the default value (null): This means that it will always have a value, it's just that sometimes the value could be None (or null in JSON). That means that, clients using your API don't have to check if the value exists or not, they can assume the field will always be there, but just that in some cases it will have the default value of None. The way to describe this in OpenAPI, is to mark that field as required, because it will always be there. Because of that, the JSON Schema for a model can be different depending on if it's used for input or output: for input the description will not be required for output it will be required (and possibly None, or in JSON terms, null) Model for Output in Docs¬∂ You can check the output model in the docs too, both name and description are marked as required with a red asterisk: Model for Input and Output in Docs¬∂ And if you check all the available Schemas (JSON Schemas) in OpenAPI, you will see that there are two, one Item-Input and one Item-Output. For Item-Input, description is not required, it doesn't have a red asterisk. But for Item-Output, description is required, it has a red asterisk. With this feature from Pydantic v2, your API documentation is more precise, and if you have autogenerated clients and SDKs, they will be more precise too, with a better developer experience and consistency. üéâ Do not Separate Schemas¬∂ Now, there are some cases where you might want to have the same schema for input and output. Probably the main use case for this is if you already have some autogenerated client code/SDKs and you don't want to update all the autogenerated client code/SDKs yet, you probably will want to do it at some point, but maybe not right now. In that case, you can disable this feature in FastAPI, with the parameter separate\\_input\\_output\\_schemas=False. Info Support for separate\\_input\\_output\\_schemas was added in FastAPI 0.102.0. ü§ì Python 3.10+ Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: str | None = None app = FastAPI(separate\\_input\\_output\\_schemas=False) @app.post(\"/items/\") def create\\_item(item: Item): return item @app.get(\"/items/\") def read\\_items() -> list\\[Item\\]: return \\[ Item( name=\"Portal Gun\", description=\"Device to travel through the multi-rick-verse\", ), Item(name=\"Plumbus\"), \\] Same Schema for Input and Output Models in Docs¬∂ And now there will be one single schema for input and output for the model, only Item, and it will have description as not required: This is the same behavior as in Pydantic v1. ü§ì Made with Material for MkDocs Insiders"
  },
  {
    "title": "Extending OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/extending-openapi/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Extending OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents The normal process Overriding the defaults Normal FastAPI Generate the OpenAPI schema Modify the OpenAPI schema Cache the OpenAPI schema Override the method Check it FastAPI Learn How To - Recipes Extending OpenAPI¬∂ There are some cases where you might need to modify the generated OpenAPI schema. In this section you will see how. The normal process¬∂ The normal (default) process, is as follows. A FastAPI application (instance) has an .openapi() method that is expected to return the OpenAPI schema. As part of the application object creation, a path operation for /openapi.json (or for whatever you set your openapi\\_url) is registered. It just returns a JSON response with the result of the application's .openapi() method. By default, what the method .openapi() does is check the property .openapi\\_schema to see if it has contents and return them. If it doesn't, it generates them using the utility function at fastapi.openapi.utils.get\\_openapi. And that function get\\_openapi() receives as parameters: title: The OpenAPI title, shown in the docs. version: The version of your API, e.g. 2.5.0. openapi\\_version: The version of the OpenAPI specification used. By default, the latest: 3.1.0. summary: A short summary of the API. description: The description of your API, this can include markdown and will be shown in the docs. routes: A list of routes, these are each of the registered path operations. They are taken from app.routes. Info The parameter summary is available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above. Overriding the defaults¬∂ Using the information above, you can use the same utility function to generate the OpenAPI schema and override each part that you need. For example, let's add ReDoc's OpenAPI extension to include a custom logo. Normal FastAPI¬∂ First, write all your FastAPI application as normally: from fastapi import FastAPI from fastapi.openapi.utils import get\\_openapi app = FastAPI() @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] def custom\\_openapi(): if app.openapi\\_schema: return app.openapi\\_schema openapi\\_schema = get\\_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom \\*\\*OpenAPI\\*\\* schema\", routes=app.routes, ) openapi\\_schema\\[\"info\"\\]\\[\"x-logo\"\\] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi\\_schema = openapi\\_schema return app.openapi\\_schema app.openapi = custom\\_openapi Generate the OpenAPI schema¬∂ Then, use the same utility function to generate the OpenAPI schema, inside a custom\\_openapi() function: from fastapi import FastAPI from fastapi.openapi.utils import get\\_openapi app = FastAPI() @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] def custom\\_openapi(): if app.openapi\\_schema: return app.openapi\\_schema openapi\\_schema = get\\_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom \\*\\*OpenAPI\\*\\* schema\", routes=app.routes, ) openapi\\_schema\\[\"info\"\\]\\[\"x-logo\"\\] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi\\_schema = openapi\\_schema return app.openapi\\_schema app.openapi = custom\\_openapi Modify the OpenAPI schema¬∂ Now you can add the ReDoc extension, adding a custom x-logo to the info \"object\" in the OpenAPI schema: from fastapi import FastAPI from fastapi.openapi.utils import get\\_openapi app = FastAPI() @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] def custom\\_openapi(): if app.openapi\\_schema: return app.openapi\\_schema openapi\\_schema = get\\_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom \\*\\*OpenAPI\\*\\* schema\", routes=app.routes, ) openapi\\_schema\\[\"info\"\\]\\[\"x-logo\"\\] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi\\_schema = openapi\\_schema return app.openapi\\_schema app.openapi = custom\\_openapi Cache the OpenAPI schema¬∂ You can use the property .openapi\\_schema as a \"cache\", to store your generated schema. That way, your application won't have to generate the schema every time a user opens your API docs. It will be generated only once, and then the same cached schema will be used for the next requests. from fastapi import FastAPI from fastapi.openapi.utils import get\\_openapi app = FastAPI() @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] def custom\\_openapi(): if app.openapi\\_schema: return app.openapi\\_schema openapi\\_schema = get\\_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom \\*\\*OpenAPI\\*\\* schema\", routes=app.routes, ) openapi\\_schema\\[\"info\"\\]\\[\"x-logo\"\\] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi\\_schema = openapi\\_schema return app.openapi\\_schema app.openapi = custom\\_openapi Override the method¬∂ Now you can replace the .openapi() method with your new function. from fastapi import FastAPI from fastapi.openapi.utils import get\\_openapi app = FastAPI() @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] def custom\\_openapi(): if app.openapi\\_schema: return app.openapi\\_schema openapi\\_schema = get\\_openapi( title=\"Custom title\", version=\"2.5.0\", summary=\"This is a very custom OpenAPI schema\", description=\"Here's a longer description of the custom \\*\\*OpenAPI\\*\\* schema\", routes=app.routes, ) openapi\\_schema\\[\"info\"\\]\\[\"x-logo\"\\] = { \"url\": \"https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png\" } app.openapi\\_schema = openapi\\_schema return app.openapi\\_schema app.openapi = custom\\_openapi Check it¬∂ Once you go to http://127.0.0.1:8000/redoc you will see that you are using your custom logo (in this example, FastAPI's logo): Made with Material for MkDocs Insiders"
  },
  {
    "title": "Conditional OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/conditional-openapi/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Conditional OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents About security, APIs, and docs Conditional OpenAPI from settings and env vars FastAPI Learn How To - Recipes Conditional OpenAPI¬∂ If you needed to, you could use settings and environment variables to configure OpenAPI conditionally depending on the environment, and even disable it entirely. About security, APIs, and docs¬∂ Hiding your documentation user interfaces in production shouldn't be the way to protect your API. That doesn't add any extra security to your API, the path operations will still be available where they are. If there's a security flaw in your code, it will still exist. Hiding the documentation just makes it more difficult to understand how to interact with your API, and could make it more difficult for you to debug it in production. It could be considered simply a form of Security through obscurity. If you want to secure your API, there are several better things you can do, for example: Make sure you have well defined Pydantic models for your request bodies and responses. Configure any required permissions and roles using dependencies. Never store plaintext passwords, only password hashes. Implement and use well-known cryptographic tools, like Passlib and JWT tokens, etc. Add more granular permission controls with OAuth2 scopes where needed. ...etc. Nevertheless, you might have a very specific use case where you really need to disable the API docs for some environment (e.g. for production) or depending on configurations from environment variables. Conditional OpenAPI from settings and env vars¬∂ You can easily use the same Pydantic settings to configure your generated OpenAPI and the docs UIs. For example: from fastapi import FastAPI from pydantic\\_settings import BaseSettings class Settings(BaseSettings): openapi\\_url: str = \"/openapi.json\" settings = Settings() app = FastAPI(openapi\\_url=settings.openapi\\_url) @app.get(\"/\") def root(): return {\"message\": \"Hello World\"} Here we declare the setting openapi\\_url with the same default of \"/openapi.json\". And then we use it when creating the FastAPI app. Then you could disable OpenAPI (including the UI docs) by setting the environment variable OPENAPI\\_URL to the empty string, like: Then if you go to the URLs at /openapi.json, /docs, or /redoc you will just get a 404 Not Found error like: { \"detail\": \"Not Found\" } Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Request and APIRoute class - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/custom-request-and-route/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Custom Request and APIRoute class en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Use cases Handling custom request body encodings Create a custom GzipRequest class Create a custom GzipRoute class Accessing the request body in an exception handler Custom APIRoute class in a router FastAPI Learn How To - Recipes Custom Request and APIRoute class¬∂ In some cases, you may want to override the logic used by the Request and APIRoute classes. In particular, this may be a good alternative to logic in a middleware. For example, if you want to read or manipulate the request body before it is processed by your application. Danger This is an \"advanced\" feature. If you are just starting with FastAPI you might want to skip this section. Use cases¬∂ Some use cases include: Converting non-JSON request bodies to JSON (e.g. msgpack). Decompressing gzip-compressed request bodies. Automatically logging all request bodies. Handling custom request body encodings¬∂ Let's see how to make use of a custom Request subclass to decompress gzip requests. And an APIRoute subclass to use that custom request class. Create a custom GzipRequest class¬∂ Tip This is a toy example to demonstrate how it works, if you need Gzip support, you can use the provided GzipMiddleware. First, we create a GzipRequest class, which will overwrite the Request.body() method to decompress the body in the presence of an appropriate header. If there's no gzip in the header, it will not try to decompress the body. That way, the same route class can handle gzip compressed or uncompressed requests. import gzip from typing import Callable, List from fastapi import Body, FastAPI, Request, Response from fastapi.routing import APIRoute class GzipRequest(Request): async def body(self) -> bytes: if not hasattr(self, \"\\_body\"): body = await super().body() if \"gzip\" in self.headers.getlist(\"Content-Encoding\"): body = gzip.decompress(body) self.\\_body = body return self.\\_body class GzipRoute(APIRoute): def get\\_route\\_handler(self) -> Callable: original\\_route\\_handler = super().get\\_route\\_handler() async def custom\\_route\\_handler(request: Request) -> Response: request = GzipRequest(request.scope, request.receive) return await original\\_route\\_handler(request) return custom\\_route\\_handler app = FastAPI() app.router.route\\_class = GzipRoute @app.post(\"/sum\") async def sum\\_numbers(numbers: List\\[int\\] = Body()): return {\"sum\": sum(numbers)} Create a custom GzipRoute class¬∂ Next, we create a custom subclass of fastapi.routing.APIRoute that will make use of the GzipRequest. This time, it will overwrite the method APIRoute.get\\_route\\_handler(). This method returns a function. And that function is what will receive a request and return a response. Here we use it to create a GzipRequest from the original request. import gzip from typing import Callable, List from fastapi import Body, FastAPI, Request, Response from fastapi.routing import APIRoute class GzipRequest(Request): async def body(self) -> bytes: if not hasattr(self, \"\\_body\"): body = await super().body() if \"gzip\" in self.headers.getlist(\"Content-Encoding\"): body = gzip.decompress(body) self.\\_body = body return self.\\_body class GzipRoute(APIRoute): def get\\_route\\_handler(self) -> Callable: original\\_route\\_handler = super().get\\_route\\_handler() async def custom\\_route\\_handler(request: Request) -> Response: request = GzipRequest(request.scope, request.receive) return await original\\_route\\_handler(request) return custom\\_route\\_handler app = FastAPI() app.router.route\\_class = GzipRoute @app.post(\"/sum\") async def sum\\_numbers(numbers: List\\[int\\] = Body()): return {\"sum\": sum(numbers)} Technical Details A Request has a request.scope attribute, that's just a Python dict containing the metadata related to the request. A Request also has a request.receive, that's a function to \"receive\" the body of the request. The scope dict and receive function are both part of the ASGI specification. And those two things, scope and receive, are what is needed to create a new Request instance. To learn more about the Request check Starlette's docs about Requests. The only thing the function returned by GzipRequest.get\\_route\\_handler does differently is convert the Request to a GzipRequest. Doing this, our GzipRequest will take care of decompressing the data (if necessary) before passing it to our path operations. After that, all of the processing logic is the same. But because of our changes in GzipRequest.body, the request body will be automatically decompressed when it is loaded by FastAPI when needed. Accessing the request body in an exception handler¬∂ Tip To solve this same problem, it's probably a lot easier to use the body in a custom handler for RequestValidationError (Handling Errors). But this example is still valid and it shows how to interact with the internal components. We can also use this same approach to access the request body in an exception handler. All we need to do is handle the request inside a try/except block: from typing import Callable, List from fastapi import Body, FastAPI, HTTPException, Request, Response from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute class ValidationErrorLoggingRoute(APIRoute): def get\\_route\\_handler(self) -> Callable: original\\_route\\_handler = super().get\\_route\\_handler() async def custom\\_route\\_handler(request: Request) -> Response: try: return await original\\_route\\_handler(request) except RequestValidationError as exc: body = await request.body() detail = {\"errors\": exc.errors(), \"body\": body.decode()} raise HTTPException(status\\_code=422, detail=detail) return custom\\_route\\_handler app = FastAPI() app.router.route\\_class = ValidationErrorLoggingRoute @app.post(\"/\") async def sum\\_numbers(numbers: List\\[int\\] = Body()): return sum(numbers) If an exception occurs, theRequest instance will still be in scope, so we can read and make use of the request body when handling the error: from typing import Callable, List from fastapi import Body, FastAPI, HTTPException, Request, Response from fastapi.exceptions import RequestValidationError from fastapi.routing import APIRoute class ValidationErrorLoggingRoute(APIRoute): def get\\_route\\_handler(self) -> Callable: original\\_route\\_handler = super().get\\_route\\_handler() async def custom\\_route\\_handler(request: Request) -> Response: try: return await original\\_route\\_handler(request) except RequestValidationError as exc: body = await request.body() detail = {\"errors\": exc.errors(), \"body\": body.decode()} raise HTTPException(status\\_code=422, detail=detail) return custom\\_route\\_handler app = FastAPI() app.router.route\\_class = ValidationErrorLoggingRoute @app.post(\"/\") async def sum\\_numbers(numbers: List\\[int\\] = Body()): return sum(numbers) Custom APIRoute class in a router¬∂ You can also set the route\\_class parameter of an APIRouter: import time from typing import Callable from fastapi import APIRouter, FastAPI, Request, Response from fastapi.routing import APIRoute class TimedRoute(APIRoute): def get\\_route\\_handler(self) -> Callable: original\\_route\\_handler = super().get\\_route\\_handler() async def custom\\_route\\_handler(request: Request) -> Response: before = time.time() response: Response = await original\\_route\\_handler(request) duration = time.time() - before response.headers\\[\"X-Response-Time\"\\] = str(duration) print(f\"route duration: {duration}\") print(f\"route response: {response}\") print(f\"route response headers: {response.headers}\") return response return custom\\_route\\_handler app = FastAPI() router = APIRouter(route\\_class=TimedRoute) @app.get(\"/\") async def not\\_timed(): return {\"message\": \"Not timed\"} @router.get(\"/timed\") async def timed(): return {\"message\": \"It's the time of my life\"} app.include\\_router(router) In this example, the path operations under the router will use the custom TimedRoute class, and will have an extra X-Response-Time header in the response with the time it took to generate the response: import time from typing import Callable from fastapi import APIRouter, FastAPI, Request, Response from fastapi.routing import APIRoute class TimedRoute(APIRoute): def get\\_route\\_handler(self) -> Callable: original\\_route\\_handler = super().get\\_route\\_handler() async def custom\\_route\\_handler(request: Request) -> Response: before = time.time() response: Response = await original\\_route\\_handler(request) duration = time.time() - before response.headers\\[\"X-Response-Time\"\\] = str(duration) print(f\"route duration: {duration}\") print(f\"route response: {response}\") print(f\"route response headers: {response.headers}\") return response return custom\\_route\\_handler app = FastAPI() router = APIRouter(route\\_class=TimedRoute) @app.get(\"/\") async def not\\_timed(): return {\"message\": \"Not timed\"} @router.get(\"/timed\") async def timed(): return {\"message\": \"It's the time of my life\"} app.include\\_router(router) Made with Material for MkDocs Insiders"
  },
  {
    "title": "NoSQL (Distributed / Big Data) Databases with Couchbase - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/nosql-databases-couchbase/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI NoSQL (Distributed / Big Data) Databases with Couchbase en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Import Couchbase components Define a constant to use as a \"document type\" Add a function to get a Bucket Create Pydantic models User model UserInDB model Get the user f-strings dict unpacking Create your FastAPI code Create the FastAPI app Create the path operation function Recap FastAPI Learn How To - Recipes NoSQL (Distributed / Big Data) Databases with Couchbase¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1. The new docs will hopefully use Pydantic v2 and will use ODMantic with MongoDB. FastAPI can also be integrated with any NoSQL. Here we'll see an example using Couchbase, a document based NoSQL database. You can adapt it to any other NoSQL database like: MongoDB Cassandra CouchDB ArangoDB ElasticSearch, etc. Tip There is an official project generator with FastAPI and Couchbase, all based on Docker, including a frontend and more tools: https://github.com/tiangolo/full-stack-fastapi-couchbase Import Couchbase components¬∂ For now, don't pay attention to the rest, only the imports: from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user Define a constant to use as a \"document type\"¬∂ We will use it later as a fixed field type in our documents. This is not required by Couchbase, but is a good practice that will help you afterwards. from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user Add a function to get a Bucket¬∂ In Couchbase, a bucket is a set of documents, that can be of different types. They are generally all related to the same application. The analogy in the relational database world would be a \"database\" (a specific database, not the database server). The analogy in MongoDB would be a \"collection\". In the code, a Bucket represents the main entrypoint of communication with the database. This utility function will: Connect to a Couchbase cluster (that might be a single machine). Set defaults for timeouts. Authenticate in the cluster. Get a Bucket instance. Set defaults for timeouts. Return it. from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user Create Pydantic models¬∂ As Couchbase \"documents\" are actually just \"JSON objects\", we can model them with Pydantic. User model¬∂ First, let's create a User model: from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user We will use this model in our path operation function, so, we don't include in it the hashed\\_password. UserInDB model¬∂ Now, let's create a UserInDB model. This will have the data that is actually stored in the database. We don't create it as a subclass of Pydantic's BaseModel but as a subclass of our own User, because it will have all the attributes in User plus a couple more: from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user Note Notice that we have a hashed\\_password and a type field that will be stored in the database. But it is not part of the general User model (the one we will return in the path operation). Get the user¬∂ Now create a function that will: Take a username. Generate a document ID from it. Get the document with that ID. Put the contents of the document in a UserInDB model. By creating a function that is only dedicated to getting your user from a username (or any other parameter) independent of your path operation function, you can more easily re-use it in multiple parts and also add unit tests for it: from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user f-strings¬∂ If you are not familiar with the f\"userprofile::{username}\", it is a Python \"f-string\". Any variable that is put inside of {} in an f-string will be expanded / injected in the string. dict unpacking¬∂ If you are not familiar with the UserInDB(\\*\\*result.value), it is using dict \"unpacking\". It will take the dict at result.value, and take each of its keys and values and pass them as key-values to UserInDB as keyword arguments. So, if the dict contains: { \"username\": \"johndoe\", \"hashed\\_password\": \"some\\_hash\", } It will be passed to UserInDB as: UserInDB(username=\"johndoe\", hashed\\_password=\"some\\_hash\") Create your FastAPI code¬∂ Create the FastAPI app¬∂ from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user Create the path operation function¬∂ As our code is calling Couchbase and we are not using the experimental Python await support, we should declare our function with normal def instead of async def. Also, Couchbase recommends not using a single Bucket object in multiple \"threads\", so, we can just get the bucket directly and pass it to our utility functions: from typing import Union from couchbase import LOCKMODE\\_WAIT from couchbase.bucket import Bucket from couchbase.cluster import Cluster, PasswordAuthenticator from fastapi import FastAPI from pydantic import BaseModel USERPROFILE\\_DOC\\_TYPE = \"userprofile\" def get\\_bucket(): cluster = Cluster( \"couchbase://couchbasehost:8091?fetch\\_mutation\\_tokens=1&operation\\_timeout=30&n1ql\\_timeout=300\" ) authenticator = PasswordAuthenticator(\"username\", \"password\") cluster.authenticate(authenticator) bucket: Bucket = cluster.open\\_bucket(\"bucket\\_name\", lockmode=LOCKMODE\\_WAIT) bucket.timeout = 30 bucket.n1ql\\_timeout = 300 return bucket class User(BaseModel): username: str email: Union\\[str, None\\] = None full\\_name: Union\\[str, None\\] = None disabled: Union\\[bool, None\\] = None class UserInDB(User): type: str = USERPROFILE\\_DOC\\_TYPE hashed\\_password: str def get\\_user(bucket: Bucket, username: str): doc\\_id = f\"userprofile::{username}\" result = bucket.get(doc\\_id, quiet=True) if not result.value: return None user = UserInDB(\\*\\*result.value) return user # FastAPI specific code app = FastAPI() @app.get(\"/users/{username}\", response\\_model=User) def read\\_user(username: str): bucket = get\\_bucket() user = get\\_user(bucket=bucket, username=username) return user Recap¬∂ You can integrate any third party NoSQL database, just using their standard packages. The same applies to any other external tool, system or API. Made with Material for MkDocs Insiders"
  },
  {
    "title": "GraphQL - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/graphql/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI GraphQL en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents GraphQL Libraries GraphQL with Strawberry Older GraphQLApp from Starlette Learn More FastAPI Learn How To - Recipes GraphQL¬∂ As FastAPI is based on the ASGI standard, it's very easy to integrate any GraphQL library also compatible with ASGI. You can combine normal FastAPI path operations with GraphQL on the same application. Tip GraphQL solves some very specific use cases. It has advantages and disadvantages when compared to common web APIs. Make sure you evaluate if the benefits for your use case compensate the drawbacks. ü§ì GraphQL Libraries¬∂ Here are some of the GraphQL libraries that have ASGI support. You could use them with FastAPI: Strawberry üçì With docs for FastAPI Ariadne With docs for Starlette (that also apply to FastAPI) Tartiflette With Tartiflette ASGI to provide ASGI integration Graphene With starlette-graphene3 GraphQL with Strawberry¬∂ If you need or want to work with GraphQL, Strawberry is the recommended library as it has the design closest to FastAPI's design, it's all based on type annotations. Depending on your use case, you might prefer to use a different library, but if you asked me, I would probably suggest you try Strawberry. Here's a small preview of how you could integrate Strawberry with FastAPI: import strawberry from fastapi import FastAPI from strawberry.asgi import GraphQL @strawberry.type class User: name: str age: int @strawberry.type class Query: @strawberry.field def user(self) -> User: return User(name=\"Patrick\", age=100) schema = strawberry.Schema(query=Query) graphql\\_app = GraphQL(schema) app = FastAPI() app.add\\_route(\"/graphql\", graphql\\_app) app.add\\_websocket\\_route(\"/graphql\", graphql\\_app) You can learn more about Strawberry in the Strawberry documentation. And also the docs about Strawberry with FastAPI. Older GraphQLApp from Starlette¬∂ Previous versions of Starlette included a GraphQLApp class to integrate with Graphene. It was deprecated from Starlette, but if you have code that used it, you can easily migrate to starlette-graphene3, that covers the same use case and has an almost identical interface. Tip If you need GraphQL, I still would recommend you check out Strawberry, as it's based on type annotations instead of custom classes and types. Learn More¬∂ You can learn more about GraphQL in the official GraphQL documentation. You can also read more about each those libraries described above in their links. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Async SQL (Relational) Databases with Encode/Databases - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/async-sql-encode-databases/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Async SQL (Relational) Databases with Encode/Databases en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Import and set up SQLAlchemy Import and set up databases Create the tables Create models Connect and disconnect Read notes Notice the response\\_model=List\\[Note\\] Create notes About {\\*\\*note.dict(), \"id\": last\\_record\\_id} Check it More info FastAPI Learn How To - Recipes Async SQL (Relational) Databases with Encode/Databases¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1. The new docs will include Pydantic v2 and will use SQLModel once it is updated to use Pydantic v2 as well. You can also use encode/databases with FastAPI to connect to databases using async and await. It is compatible with: PostgreSQL MySQL SQLite In this example, we'll use SQLite, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is. Later, for your production application, you might want to use a database server like PostgreSQL. Tip You could adopt ideas from the section about SQLAlchemy ORM (SQL (Relational) Databases), like using utility functions to perform operations in the database, independent of your FastAPI code. This section doesn't apply those ideas, to be equivalent to the counterpart in Starlette. Import and set up SQLAlchemy¬∂ Import SQLAlchemy. Create a metadata object. Create a table notes using the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} Tip Notice that all this code is pure SQLAlchemy Core. databases is not doing anything here yet. Import and set up databases¬∂ Import databases. Create a DATABASE\\_URL. Create a database object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} Tip If you were connecting to a different database (e.g. PostgreSQL), you would need to change the DATABASE\\_URL. Create the tables¬∂ In this case, we are creating the tables in the same Python file, but in production, you would probably want to create them with Alembic, integrated with migrations, etc. Here, this section would run directly, right before starting your FastAPI application. Create an engine. Create all the tables from the metadata object. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} Create models¬∂ Create Pydantic models for: Notes to be created (NoteIn). Notes to be returned (Note). from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} By creating these Pydantic models, the input data will be validated, serialized (converted), and annotated (documented). So, you will be able to see it all in the interactive API docs. Connect and disconnect¬∂ Create your FastAPI application. Create event handlers to connect and disconnect from the database. from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} Read notes¬∂ Create the path operation function to read notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} Note Notice that as we communicate with the database using await, the path operation function is declared with async. Notice the response\\_model=List\\[Note\\]¬∂ It uses typing.List. That documents (and validates, serializes, filters) the output data, as a list of Notes. Create notes¬∂ Create the path operation function to create notes: from typing import List import databases import sqlalchemy from fastapi import FastAPI from pydantic import BaseModel # SQLAlchemy specific code, as with any other app DATABASE\\_URL = \"sqlite:///./test.db\" # DATABASE\\_URL = \"postgresql://user:password@postgresserver/db\" database = databases.Database(DATABASE\\_URL) metadata = sqlalchemy.MetaData() notes = sqlalchemy.Table( \"notes\", metadata, sqlalchemy.Column(\"id\", sqlalchemy.Integer, primary\\_key=True), sqlalchemy.Column(\"text\", sqlalchemy.String), sqlalchemy.Column(\"completed\", sqlalchemy.Boolean), ) engine = sqlalchemy.create\\_engine( DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False} ) metadata.create\\_all(engine) class NoteIn(BaseModel): text: str completed: bool class Note(BaseModel): id: int text: str completed: bool app = FastAPI() @app.on\\_event(\"startup\") async def startup(): await database.connect() @app.on\\_event(\"shutdown\") async def shutdown(): await database.disconnect() @app.get(\"/notes/\", response\\_model=List\\[Note\\]) async def read\\_notes(): query = notes.select() return await database.fetch\\_all(query) @app.post(\"/notes/\", response\\_model=Note) async def create\\_note(note: NoteIn): query = notes.insert().values(text=note.text, completed=note.completed) last\\_record\\_id = await database.execute(query) return {\\*\\*note.dict(), \"id\": last\\_record\\_id} Note Notice that as we communicate with the database using await, the path operation function is declared with async. About {\\*\\*note.dict(), \"id\": last\\_record\\_id}¬∂ note is a Pydantic Note object. note.dict() returns a dict with its data, something like: { \"text\": \"Some note\", \"completed\": False, } but it doesn't have the id field. So we create a new dict, that contains the key-value pairs from note.dict() with: {\\*\\*note.dict()} \\*\\*note.dict() \"unpacks\" the key value pairs directly, so, {\\*\\*note.dict()} would be, more or less, a copy of note.dict(). And then, we extend that copy dict, adding another key-value pair: \"id\": last\\_record\\_id: {\\*\\*note.dict(), \"id\": last\\_record\\_id} So, the final result returned would be something like: { \"id\": 1, \"text\": \"Some note\", \"completed\": False, } Check it¬∂ You can copy this code as is, and see the docs at http://127.0.0.1:8000/docs. There you can see all your API documented and interact with it: More info¬∂ You can read more about encode/databases at its GitHub page. Made with Material for MkDocs Insiders"
  },
  {
    "title": "SQL (Relational) Databases with Peewee - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/sql-databases-peewee/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI SQL (Relational) Databases with Peewee en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Peewee for async The same app File structure Create the Peewee parts The standard Peewee code Note Make Peewee async-compatible PeeweeConnectionState Use the custom PeeweeConnectionState class Create the database models Create Peewee models for our data Create the Pydantic models Create the Pydantic models / schemas Create a PeeweeGetterDict for the Pydantic models / schemas CRUD utils Create all the CRUD utils Main FastAPI app Create the database tables Create a dependency Context variable sub-dependency Peewee Proxy Create your FastAPI path operations About def vs async def Testing Peewee with async What happens Fix Peewee with FastAPI Review all the files Technical Details The problem Context variables Set context variables in the async dependency reset\\_db\\_state() Set database state in the dependency get\\_db() Connect and disconnect in the dependency get\\_db() FastAPI Learn How To - Recipes SQL (Relational) Databases with Peewee¬∂ Warning If you are just starting, the tutorial SQL (Relational) Databases that uses SQLAlchemy should be enough. Feel free to skip this. Peewee is not recommended with FastAPI as it doesn't play well with anything async Python. There are several better alternatives. Info These docs assume Pydantic v1. Because Pewee doesn't play well with anything async and there are better alternatives, I won't update these docs for Pydantic v2, they are kept for now only for historical purposes. The examples here are no longer tested in CI (as they were before). If you are starting a project from scratch, you are probably better off with SQLAlchemy ORM (SQL (Relational) Databases), or any other async ORM. If you already have a code base that uses Peewee ORM, you can check here how to use it with FastAPI. Python 3.7+ required You will need Python 3.7 or above to safely use Peewee with FastAPI. Peewee for async¬∂ Peewee was not designed for async frameworks, or with them in mind. Peewee has some heavy assumptions about its defaults and about how it should be used. If you are developing an application with an older non-async framework, and can work with all its defaults, it can be a great tool. But if you need to change some of the defaults, support more than one predefined database, work with an async framework (like FastAPI), etc, you will need to add quite some complex extra code to override those defaults. Nevertheless, it's possible to do it, and here you'll see exactly what code you have to add to be able to use Peewee with FastAPI. Technical Details You can read more about Peewee's stand about async in Python in the docs, an issue, a PR. The same app¬∂ We are going to create the same application as in the SQLAlchemy tutorial (SQL (Relational) Databases). Most of the code is actually the same. So, we are going to focus only on the differences. File structure¬∂ Let's say you have a directory named my\\_super\\_project that contains a sub-directory called sql\\_app with a structure like this: . ‚îî‚îÄ‚îÄ sql\\_app ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îú‚îÄ‚îÄ crud.py ‚îú‚îÄ‚îÄ database.py ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ schemas.py This is almost the same structure as we had for the SQLAlchemy tutorial. Now let's see what each file/module does. Create the Peewee parts¬∂ Let's refer to the file sql\\_app/database.py. The standard Peewee code¬∂ Let's first check all the normal Peewee code, create a Peewee database: from contextvars import ContextVar import peewee DATABASE\\_NAME = \"test.db\" db\\_state\\_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db\\_state = ContextVar(\"db\\_state\", default=db\\_state\\_default.copy()) class PeeweeConnectionState(peewee.\\_ConnectionState): def \\_\\_init\\_\\_(self, \\*\\*kwargs): super().\\_\\_setattr\\_\\_(\"\\_state\", db\\_state) super().\\_\\_init\\_\\_(\\*\\*kwargs) def \\_\\_setattr\\_\\_(self, name, value): self.\\_state.get()\\[name\\] = value def \\_\\_getattr\\_\\_(self, name): return self.\\_state.get()\\[name\\] db = peewee.SqliteDatabase(DATABASE\\_NAME, check\\_same\\_thread=False) db.\\_state = PeeweeConnectionState() Tip Have in mind that if you wanted to use a different database, like PostgreSQL, you couldn't just change the string. You would need to use a different Peewee database class. Note¬∂ The argument: check\\_same\\_thread=False is equivalent to the one in the SQLAlchemy tutorial: connect\\_args={\"check\\_same\\_thread\": False} ...it is needed only for SQLite. Technical Details Exactly the same technical details as in SQL (Relational) Databases apply. Make Peewee async-compatible PeeweeConnectionState¬∂ The main issue with Peewee and FastAPI is that Peewee relies heavily on Python's threading.local, and it doesn't have a direct way to override it or let you handle connections/sessions directly (as is done in the SQLAlchemy tutorial). And threading.local is not compatible with the new async features of modern Python. Technical Details threading.local is used to have a \"magic\" variable that has a different value for each thread. This was useful in older frameworks designed to have one single thread per request, no more, no less. Using this, each request would have its own database connection/session, which is the actual final goal. But FastAPI, using the new async features, could handle more than one request on the same thread. And at the same time, for a single request, it could run multiple things in different threads (in a threadpool), depending on if you use async def or normal def. This is what gives all the performance improvements to FastAPI. But Python 3.7 and above provide a more advanced alternative to threading.local, that can also be used in the places where threading.local would be used, but is compatible with the new async features. We are going to use that. It's called contextvars. We are going to override the internal parts of Peewee that use threading.local and replace them with contextvars, with the corresponding updates. This might seem a bit complex (and it actually is), you don't really need to completely understand how it works to use it. We will create a PeeweeConnectionState: from contextvars import ContextVar import peewee DATABASE\\_NAME = \"test.db\" db\\_state\\_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db\\_state = ContextVar(\"db\\_state\", default=db\\_state\\_default.copy()) class PeeweeConnectionState(peewee.\\_ConnectionState): def \\_\\_init\\_\\_(self, \\*\\*kwargs): super().\\_\\_setattr\\_\\_(\"\\_state\", db\\_state) super().\\_\\_init\\_\\_(\\*\\*kwargs) def \\_\\_setattr\\_\\_(self, name, value): self.\\_state.get()\\[name\\] = value def \\_\\_getattr\\_\\_(self, name): return self.\\_state.get()\\[name\\] db = peewee.SqliteDatabase(DATABASE\\_NAME, check\\_same\\_thread=False) db.\\_state = PeeweeConnectionState() This class inherits from a special internal class used by Peewee. It has all the logic to make Peewee use contextvars instead of threading.local. contextvars works a bit differently than threading.local. But the rest of Peewee's internal code assumes that this class works with threading.local. So, we need to do some extra tricks to make it work as if it was just using threading.local. The \\_\\_init\\_\\_, \\_\\_setattr\\_\\_, and \\_\\_getattr\\_\\_ implement all the required tricks for this to be used by Peewee without knowing that it is now compatible with FastAPI. Tip This will just make Peewee behave correctly when used with FastAPI. Not randomly opening or closing connections that are being used, creating errors, etc. But it doesn't give Peewee async super-powers. You should still use normal def functions and not async def. Use the custom PeeweeConnectionState class¬∂ Now, overwrite the .\\_state internal attribute in the Peewee database db object using the new PeeweeConnectionState: from contextvars import ContextVar import peewee DATABASE\\_NAME = \"test.db\" db\\_state\\_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db\\_state = ContextVar(\"db\\_state\", default=db\\_state\\_default.copy()) class PeeweeConnectionState(peewee.\\_ConnectionState): def \\_\\_init\\_\\_(self, \\*\\*kwargs): super().\\_\\_setattr\\_\\_(\"\\_state\", db\\_state) super().\\_\\_init\\_\\_(\\*\\*kwargs) def \\_\\_setattr\\_\\_(self, name, value): self.\\_state.get()\\[name\\] = value def \\_\\_getattr\\_\\_(self, name): return self.\\_state.get()\\[name\\] db = peewee.SqliteDatabase(DATABASE\\_NAME, check\\_same\\_thread=False) db.\\_state = PeeweeConnectionState() Tip Make sure you overwrite db.\\_state after creating db. Tip You would do the same for any other Peewee database, including PostgresqlDatabase, MySQLDatabase, etc. Create the database models¬∂ Let's now see the file sql\\_app/models.py. Create Peewee models for our data¬∂ Now create the Peewee models (classes) for User and Item. This is the same you would do if you followed the Peewee tutorial and updated the models to have the same data as in the SQLAlchemy tutorial. Tip Peewee also uses the term \"model\" to refer to these classes and instances that interact with the database. But Pydantic also uses the term \"model\" to refer to something different, the data validation, conversion, and documentation classes and instances. Import db from database (the file database.py from above) and use it here. import peewee from .database import db class User(peewee.Model): email = peewee.CharField(unique=True, index=True) hashed\\_password = peewee.CharField() is\\_active = peewee.BooleanField(default=True) class Meta: database = db class Item(peewee.Model): title = peewee.CharField(index=True) description = peewee.CharField(index=True) owner = peewee.ForeignKeyField(User, backref=\"items\") class Meta: database = db Tip Peewee creates several magic attributes. It will automatically add an id attribute as an integer to be the primary key. It will chose the name of the tables based on the class names. For the Item, it will create an attribute owner\\_id with the integer ID of the User. But we don't declare it anywhere. Create the Pydantic models¬∂ Now let's check the file sql\\_app/schemas.py. Tip To avoid confusion between the Peewee models and the Pydantic models, we will have the file models.py with the Peewee models, and the file schemas.py with the Pydantic models. These Pydantic models define more or less a \"schema\" (a valid data shape). So this will help us avoiding confusion while using both. Create the Pydantic models / schemas¬∂ Create all the same Pydantic models as in the SQLAlchemy tutorial: from typing import Any, List, Union import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self.\\_obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: Union\\[str, None\\] = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True getter\\_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: List\\[Item\\] = \\[\\] class Config: orm\\_mode = True getter\\_dict = PeeweeGetterDict Tip Here we are creating the models with an id. We didn't explicitly specify an id attribute in the Peewee models, but Peewee adds one automatically. We are also adding the magic owner\\_id attribute to Item. Create a PeeweeGetterDict for the Pydantic models / schemas¬∂ When you access a relationship in a Peewee object, like in some\\_user.items, Peewee doesn't provide a list of Item. It provides a special custom object of class ModelSelect. It's possible to create a list of its items with list(some\\_user.items). But the object itself is not a list. And it's also not an actual Python generator. Because of this, Pydantic doesn't know by default how to convert it to a list of Pydantic models / schemas. But recent versions of Pydantic allow providing a custom class that inherits from pydantic.utils.GetterDict, to provide the functionality used when using the orm\\_mode = True to retrieve the values for ORM model attributes. We are going to create a custom PeeweeGetterDict class and use it in all the same Pydantic models / schemas that use orm\\_mode: from typing import Any, List, Union import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self.\\_obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: Union\\[str, None\\] = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True getter\\_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: List\\[Item\\] = \\[\\] class Config: orm\\_mode = True getter\\_dict = PeeweeGetterDict Here we are checking if the attribute that is being accessed (e.g. .items in some\\_user.items) is an instance of peewee.ModelSelect. And if that's the case, just return a list with it. And then we use it in the Pydantic models / schemas that use orm\\_mode = True, with the configuration variable getter\\_dict = PeeweeGetterDict. Tip We only need to create one PeeweeGetterDict class, and we can use it in all the Pydantic models / schemas. CRUD utils¬∂ Now let's see the file sql\\_app/crud.py. Create all the CRUD utils¬∂ Create all the same CRUD utils as in the SQLAlchemy tutorial, all the code is very similar: from . import models, schemas def get\\_user(user\\_id: int): return models.User.filter(models.User.id == user\\_id).first() def get\\_user\\_by\\_email(email: str): return models.User.filter(models.User.email == email).first() def get\\_users(skip: int = 0, limit: int = 100): return list(models.User.select().offset(skip).limit(limit)) def create\\_user(user: schemas.UserCreate): fake\\_hashed\\_password = user.password + \"notreallyhashed\" db\\_user = models.User(email=user.email, hashed\\_password=fake\\_hashed\\_password) db\\_user.save() return db\\_user def get\\_items(skip: int = 0, limit: int = 100): return list(models.Item.select().offset(skip).limit(limit)) def create\\_user\\_item(item: schemas.ItemCreate, user\\_id: int): db\\_item = models.Item(\\*\\*item.dict(), owner\\_id=user\\_id) db\\_item.save() return db\\_item There are some differences with the code for the SQLAlchemy tutorial. We don't pass a db attribute around. Instead we use the models directly. This is because the db object is a global object, that includes all the connection logic. That's why we had to do all the contextvars updates above. Aso, when returning several objects, like in get\\_users, we directly call list, like in: list(models.User.select()) This is for the same reason that we had to create a custom PeeweeGetterDict. But by returning something that is already a list instead of the peewee.ModelSelect the response\\_model in the path operation with List\\[models.User\\] (that we'll see later) will work correctly. Main FastAPI app¬∂ And now in the file sql\\_app/main.py let's integrate and use all the other parts we created before. Create the database tables¬∂ In a very simplistic way create the database tables: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db\\_state\\_default database.db.connect() database.db.create\\_tables(\\[models.User, models.Item\\]) database.db.close() app = FastAPI() sleep\\_time = 10 async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() def get\\_db(db\\_state=Depends(reset\\_db\\_state)): try: database.db.connect() yield finally: if not database.db.is\\_closed(): database.db.close() @app.post(\"/users/\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\]) def create\\_user(user: schemas.UserCreate): db\\_user = crud.get\\_user\\_by\\_email(email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(user=user) @app.get(\"/users/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_users(skip: int = 0, limit: int = 100): users = crud.get\\_users(skip=skip, limit=limit) return users @app.get( \"/users/{user\\_id}\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\] ) def read\\_user(user\\_id: int): db\\_user = crud.get\\_user(user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post( \"/users/{user\\_id}/items/\", response\\_model=schemas.Item, dependencies=\\[Depends(get\\_db)\\], ) def create\\_item\\_for\\_user(user\\_id: int, item: schemas.ItemCreate): return crud.create\\_user\\_item(item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=List\\[schemas.Item\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_items(skip: int = 0, limit: int = 100): items = crud.get\\_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\] ) def read\\_slow\\_users(skip: int = 0, limit: int = 100): global sleep\\_time sleep\\_time = max(0, sleep\\_time - 1) time.sleep(sleep\\_time) # Fake long processing request users = crud.get\\_users(skip=skip, limit=limit) return users Create a dependency¬∂ Create a dependency that will connect the database right at the beginning of a request and disconnect it at the end: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db\\_state\\_default database.db.connect() database.db.create\\_tables(\\[models.User, models.Item\\]) database.db.close() app = FastAPI() sleep\\_time = 10 async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() def get\\_db(db\\_state=Depends(reset\\_db\\_state)): try: database.db.connect() yield finally: if not database.db.is\\_closed(): database.db.close() @app.post(\"/users/\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\]) def create\\_user(user: schemas.UserCreate): db\\_user = crud.get\\_user\\_by\\_email(email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(user=user) @app.get(\"/users/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_users(skip: int = 0, limit: int = 100): users = crud.get\\_users(skip=skip, limit=limit) return users @app.get( \"/users/{user\\_id}\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\] ) def read\\_user(user\\_id: int): db\\_user = crud.get\\_user(user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post( \"/users/{user\\_id}/items/\", response\\_model=schemas.Item, dependencies=\\[Depends(get\\_db)\\], ) def create\\_item\\_for\\_user(user\\_id: int, item: schemas.ItemCreate): return crud.create\\_user\\_item(item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=List\\[schemas.Item\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_items(skip: int = 0, limit: int = 100): items = crud.get\\_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\] ) def read\\_slow\\_users(skip: int = 0, limit: int = 100): global sleep\\_time sleep\\_time = max(0, sleep\\_time - 1) time.sleep(sleep\\_time) # Fake long processing request users = crud.get\\_users(skip=skip, limit=limit) return users Here we have an empty yield because we are actually not using the database object directly. It is connecting to the database and storing the connection data in an internal variable that is independent for each request (using the contextvars tricks from above). Because the database connection is potentially I/O blocking, this dependency is created with a normal def function. And then, in each path operation function that needs to access the database we add it as a dependency. But we are not using the value given by this dependency (it actually doesn't give any value, as it has an empty yield). So, we don't add it to the path operation function but to the path operation decorator in the dependencies parameter: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db\\_state\\_default database.db.connect() database.db.create\\_tables(\\[models.User, models.Item\\]) database.db.close() app = FastAPI() sleep\\_time = 10 async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() def get\\_db(db\\_state=Depends(reset\\_db\\_state)): try: database.db.connect() yield finally: if not database.db.is\\_closed(): database.db.close() @app.post(\"/users/\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\]) def create\\_user(user: schemas.UserCreate): db\\_user = crud.get\\_user\\_by\\_email(email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(user=user) @app.get(\"/users/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_users(skip: int = 0, limit: int = 100): users = crud.get\\_users(skip=skip, limit=limit) return users @app.get( \"/users/{user\\_id}\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\] ) def read\\_user(user\\_id: int): db\\_user = crud.get\\_user(user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post( \"/users/{user\\_id}/items/\", response\\_model=schemas.Item, dependencies=\\[Depends(get\\_db)\\], ) def create\\_item\\_for\\_user(user\\_id: int, item: schemas.ItemCreate): return crud.create\\_user\\_item(item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=List\\[schemas.Item\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_items(skip: int = 0, limit: int = 100): items = crud.get\\_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\] ) def read\\_slow\\_users(skip: int = 0, limit: int = 100): global sleep\\_time sleep\\_time = max(0, sleep\\_time - 1) time.sleep(sleep\\_time) # Fake long processing request users = crud.get\\_users(skip=skip, limit=limit) return users Context variable sub-dependency¬∂ For all the contextvars parts to work, we need to make sure we have an independent value in the ContextVar for each request that uses the database, and that value will be used as the database state (connection, transactions, etc) for the whole request. For that, we need to create another async dependency reset\\_db\\_state() that is used as a sub-dependency in get\\_db(). It will set the value for the context variable (with just a default dict) that will be used as the database state for the whole request. And then the dependency get\\_db() will store in it the database state (connection, transactions, etc). import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db\\_state\\_default database.db.connect() database.db.create\\_tables(\\[models.User, models.Item\\]) database.db.close() app = FastAPI() sleep\\_time = 10 async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() def get\\_db(db\\_state=Depends(reset\\_db\\_state)): try: database.db.connect() yield finally: if not database.db.is\\_closed(): database.db.close() @app.post(\"/users/\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\]) def create\\_user(user: schemas.UserCreate): db\\_user = crud.get\\_user\\_by\\_email(email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(user=user) @app.get(\"/users/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_users(skip: int = 0, limit: int = 100): users = crud.get\\_users(skip=skip, limit=limit) return users @app.get( \"/users/{user\\_id}\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\] ) def read\\_user(user\\_id: int): db\\_user = crud.get\\_user(user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post( \"/users/{user\\_id}/items/\", response\\_model=schemas.Item, dependencies=\\[Depends(get\\_db)\\], ) def create\\_item\\_for\\_user(user\\_id: int, item: schemas.ItemCreate): return crud.create\\_user\\_item(item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=List\\[schemas.Item\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_items(skip: int = 0, limit: int = 100): items = crud.get\\_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\] ) def read\\_slow\\_users(skip: int = 0, limit: int = 100): global sleep\\_time sleep\\_time = max(0, sleep\\_time - 1) time.sleep(sleep\\_time) # Fake long processing request users = crud.get\\_users(skip=skip, limit=limit) return users For the next request, as we will reset that context variable again in the async dependency reset\\_db\\_state() and then create a new connection in the get\\_db() dependency, that new request will have its own database state (connection, transactions, etc). Tip As FastAPI is an async framework, one request could start being processed, and before finishing, another request could be received and start processing as well, and it all could be processed in the same thread. But context variables are aware of these async features, so, a Peewee database state set in the async dependency reset\\_db\\_state() will keep its own data throughout the entire request. And at the same time, the other concurrent request will have its own database state that will be independent for the whole request. Peewee Proxy¬∂ If you are using a Peewee Proxy, the actual database is at db.obj. So, you would reset it with: async def reset\\_db\\_state(): database.db.obj.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.obj.\\_state.reset() Create your FastAPI path operations¬∂ Now, finally, here's the standard FastAPI path operations code. import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db\\_state\\_default database.db.connect() database.db.create\\_tables(\\[models.User, models.Item\\]) database.db.close() app = FastAPI() sleep\\_time = 10 async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() def get\\_db(db\\_state=Depends(reset\\_db\\_state)): try: database.db.connect() yield finally: if not database.db.is\\_closed(): database.db.close() @app.post(\"/users/\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\]) def create\\_user(user: schemas.UserCreate): db\\_user = crud.get\\_user\\_by\\_email(email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(user=user) @app.get(\"/users/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_users(skip: int = 0, limit: int = 100): users = crud.get\\_users(skip=skip, limit=limit) return users @app.get( \"/users/{user\\_id}\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\] ) def read\\_user(user\\_id: int): db\\_user = crud.get\\_user(user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post( \"/users/{user\\_id}/items/\", response\\_model=schemas.Item, dependencies=\\[Depends(get\\_db)\\], ) def create\\_item\\_for\\_user(user\\_id: int, item: schemas.ItemCreate): return crud.create\\_user\\_item(item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=List\\[schemas.Item\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_items(skip: int = 0, limit: int = 100): items = crud.get\\_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\] ) def read\\_slow\\_users(skip: int = 0, limit: int = 100): global sleep\\_time sleep\\_time = max(0, sleep\\_time - 1) time.sleep(sleep\\_time) # Fake long processing request users = crud.get\\_users(skip=skip, limit=limit) return users About def vs async def¬∂ The same as with SQLAlchemy, we are not doing something like: user = await models.User.select().first() ...but instead we are using: user = models.User.select().first() So, again, we should declare the path operation functions and the dependency without async def, just with a normal def, as: # Something goes here def read\\_users(skip: int = 0, limit: int = 100): # Something goes here Testing Peewee with async¬∂ This example includes an extra path operation that simulates a long processing request with time.sleep(sleep\\_time). It will have the database connection open at the beginning and will just wait some seconds before replying back. And each new request will wait one second less. This will easily let you test that your app with Peewee and FastAPI is behaving correctly with all the stuff about threads. If you want to check how Peewee would break your app if used without modification, go the sql\\_app/database.py file and comment the line: # db.\\_state = PeeweeConnectionState() And in the file sql\\_app/main.py file, comment the body of the async dependency reset\\_db\\_state() and replace it with a pass: async def reset\\_db\\_state(): # database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) # database.db.\\_state.reset() pass Then run your app with Uvicorn: Open your browser at http://127.0.0.1:8000/docs and create a couple of users. Then open 10 tabs at http://127.0.0.1:8000/docs#/default/read\\_slow\\_users\\_slowusers\\_\\_get at the same time. Go to the path operation \"Get /slowusers/\" in all of the tabs. Use the \"Try it out\" button and execute the request in each tab, one right after the other. The tabs will wait for a bit and then some of them will show Internal Server Error. What happens¬∂ The first tab will make your app create a connection to the database and wait for some seconds before replying back and closing the database connection. Then, for the request in the next tab, your app will wait for one second less, and so on. This means that it will end up finishing some of the last tabs' requests earlier than some of the previous ones. Then one the last requests that wait less seconds will try to open a database connection, but as one of those previous requests for the other tabs will probably be handled in the same thread as the first one, it will have the same database connection that is already open, and Peewee will throw an error and you will see it in the terminal, and the response will have an Internal Server Error. This will probably happen for more than one of those tabs. If you had multiple clients talking to your app exactly at the same time, this is what could happen. And as your app starts to handle more and more clients at the same time, the waiting time in a single request needs to be shorter and shorter to trigger the error. Fix Peewee with FastAPI¬∂ Now go back to the file sql\\_app/database.py, and uncomment the line: db.\\_state = PeeweeConnectionState() And in the file sql\\_app/main.py file, uncomment the body of the async dependency reset\\_db\\_state(): async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() Terminate your running app and start it again. Repeat the same process with the 10 tabs. This time all of them will wait and you will get all the results without errors. ...You fixed it! Review all the files¬∂ Remember you should have a directory named my\\_super\\_project (or however you want) that contains a sub-directory called sql\\_app. sql\\_app should have the following files: sql\\_app/\\_\\_init\\_\\_.py: is an empty file. sql\\_app/database.py: from contextvars import ContextVar import peewee DATABASE\\_NAME = \"test.db\" db\\_state\\_default = {\"closed\": None, \"conn\": None, \"ctx\": None, \"transactions\": None} db\\_state = ContextVar(\"db\\_state\", default=db\\_state\\_default.copy()) class PeeweeConnectionState(peewee.\\_ConnectionState): def \\_\\_init\\_\\_(self, \\*\\*kwargs): super().\\_\\_setattr\\_\\_(\"\\_state\", db\\_state) super().\\_\\_init\\_\\_(\\*\\*kwargs) def \\_\\_setattr\\_\\_(self, name, value): self.\\_state.get()\\[name\\] = value def \\_\\_getattr\\_\\_(self, name): return self.\\_state.get()\\[name\\] db = peewee.SqliteDatabase(DATABASE\\_NAME, check\\_same\\_thread=False) db.\\_state = PeeweeConnectionState() sql\\_app/models.py: import peewee from .database import db class User(peewee.Model): email = peewee.CharField(unique=True, index=True) hashed\\_password = peewee.CharField() is\\_active = peewee.BooleanField(default=True) class Meta: database = db class Item(peewee.Model): title = peewee.CharField(index=True) description = peewee.CharField(index=True) owner = peewee.ForeignKeyField(User, backref=\"items\") class Meta: database = db sql\\_app/schemas.py: from typing import Any, List, Union import peewee from pydantic import BaseModel from pydantic.utils import GetterDict class PeeweeGetterDict(GetterDict): def get(self, key: Any, default: Any = None): res = getattr(self.\\_obj, key, default) if isinstance(res, peewee.ModelSelect): return list(res) return res class ItemBase(BaseModel): title: str description: Union\\[str, None\\] = None class ItemCreate(ItemBase): pass class Item(ItemBase): id: int owner\\_id: int class Config: orm\\_mode = True getter\\_dict = PeeweeGetterDict class UserBase(BaseModel): email: str class UserCreate(UserBase): password: str class User(UserBase): id: int is\\_active: bool items: List\\[Item\\] = \\[\\] class Config: orm\\_mode = True getter\\_dict = PeeweeGetterDict sql\\_app/crud.py: from . import models, schemas def get\\_user(user\\_id: int): return models.User.filter(models.User.id == user\\_id).first() def get\\_user\\_by\\_email(email: str): return models.User.filter(models.User.email == email).first() def get\\_users(skip: int = 0, limit: int = 100): return list(models.User.select().offset(skip).limit(limit)) def create\\_user(user: schemas.UserCreate): fake\\_hashed\\_password = user.password + \"notreallyhashed\" db\\_user = models.User(email=user.email, hashed\\_password=fake\\_hashed\\_password) db\\_user.save() return db\\_user def get\\_items(skip: int = 0, limit: int = 100): return list(models.Item.select().offset(skip).limit(limit)) def create\\_user\\_item(item: schemas.ItemCreate, user\\_id: int): db\\_item = models.Item(\\*\\*item.dict(), owner\\_id=user\\_id) db\\_item.save() return db\\_item sql\\_app/main.py: import time from typing import List from fastapi import Depends, FastAPI, HTTPException from . import crud, database, models, schemas from .database import db\\_state\\_default database.db.connect() database.db.create\\_tables(\\[models.User, models.Item\\]) database.db.close() app = FastAPI() sleep\\_time = 10 async def reset\\_db\\_state(): database.db.\\_state.\\_state.set(db\\_state\\_default.copy()) database.db.\\_state.reset() def get\\_db(db\\_state=Depends(reset\\_db\\_state)): try: database.db.connect() yield finally: if not database.db.is\\_closed(): database.db.close() @app.post(\"/users/\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\]) def create\\_user(user: schemas.UserCreate): db\\_user = crud.get\\_user\\_by\\_email(email=user.email) if db\\_user: raise HTTPException(status\\_code=400, detail=\"Email already registered\") return crud.create\\_user(user=user) @app.get(\"/users/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_users(skip: int = 0, limit: int = 100): users = crud.get\\_users(skip=skip, limit=limit) return users @app.get( \"/users/{user\\_id}\", response\\_model=schemas.User, dependencies=\\[Depends(get\\_db)\\] ) def read\\_user(user\\_id: int): db\\_user = crud.get\\_user(user\\_id=user\\_id) if db\\_user is None: raise HTTPException(status\\_code=404, detail=\"User not found\") return db\\_user @app.post( \"/users/{user\\_id}/items/\", response\\_model=schemas.Item, dependencies=\\[Depends(get\\_db)\\], ) def create\\_item\\_for\\_user(user\\_id: int, item: schemas.ItemCreate): return crud.create\\_user\\_item(item=item, user\\_id=user\\_id) @app.get(\"/items/\", response\\_model=List\\[schemas.Item\\], dependencies=\\[Depends(get\\_db)\\]) def read\\_items(skip: int = 0, limit: int = 100): items = crud.get\\_items(skip=skip, limit=limit) return items @app.get( \"/slowusers/\", response\\_model=List\\[schemas.User\\], dependencies=\\[Depends(get\\_db)\\] ) def read\\_slow\\_users(skip: int = 0, limit: int = 100): global sleep\\_time sleep\\_time = max(0, sleep\\_time - 1) time.sleep(sleep\\_time) # Fake long processing request users = crud.get\\_users(skip=skip, limit=limit) return users Technical Details¬∂ Warning These are very technical details that you probably don't need. The problem¬∂ Peewee uses threading.local by default to store it's database \"state\" data (connection, transactions, etc). threading.local creates a value exclusive to the current thread, but an async framework would run all the code (e.g. for each request) in the same thread, and possibly not in order. On top of that, an async framework could run some sync code in a threadpool (using asyncio.run\\_in\\_executor), but belonging to the same request. This means that, with Peewee's current implementation, multiple tasks could be using the same threading.local variable and end up sharing the same connection and data (that they shouldn't), and at the same time, if they execute sync I/O-blocking code in a threadpool (as with normal def functions in FastAPI, in path operations and dependencies), that code won't have access to the database state variables, even while it's part of the same request and it should be able to get access to the same database state. Context variables¬∂ Python 3.7 has contextvars that can create a local variable very similar to threading.local, but also supporting these async features. There are several things to have in mind. The ContextVar has to be created at the top of the module, like: some\\_var = ContextVar(\"some\\_var\", default=\"default value\") To set a value used in the current \"context\" (e.g. for the current request) use: some\\_var.set(\"new value\") To get a value anywhere inside of the context (e.g. in any part handling the current request) use: some\\_var.get() Set context variables in the async dependency reset\\_db\\_state()¬∂ If some part of the async code sets the value with some\\_var.set(\"updated in function\") (e.g. like the async dependency), the rest of the code in it and the code that goes after (including code inside of async functions called with await) will see that new value. So, in our case, if we set the Peewee state variable (with a default dict) in the async dependency, all the rest of the internal code in our app will see this value and will be able to reuse it for the whole request. And the context variable would be set again for the next request, even if they are concurrent. Set database state in the dependency get\\_db()¬∂ As get\\_db() is a normal def function, FastAPI will make it run in a threadpool, with a copy of the \"context\", holding the same value for the context variable (the dict with the reset database state). Then it can add database state to that dict, like the connection, etc. But if the value of the context variable (the default dict) was set in that normal def function, it would create a new value that would stay only in that thread of the threadpool, and the rest of the code (like the path operation functions) wouldn't have access to it. In get\\_db() we can only set values in the dict, but not the entire dict itself. So, we need to have the async dependency reset\\_db\\_state() to set the dict in the context variable. That way, all the code has access to the same dict for the database state for a single request. Connect and disconnect in the dependency get\\_db()¬∂ Then the next question would be, why not just connect and disconnect the database in the async dependency itself, instead of in get\\_db()? The async dependency has to be async for the context variable to be preserved for the rest of the request, but creating and closing the database connection is potentially blocking, so it could degrade performance if it was there. So we also need the normal def dependency get\\_db(). Made with Material for MkDocs Insiders"
  },
  {
    "title": "General - How To - Recipes - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/general/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI General - How To - Recipes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI Table of contents Filter Data - Security Documentation Tags - OpenAPI Documentation Summary and Description - OpenAPI Documentation Response description - OpenAPI Documentation Deprecate a Path Operation - OpenAPI Convert any Data to JSON-compatible OpenAPI Metadata - Docs OpenAPI Custom URL OpenAPI Docs URLs FastAPI Learn How To - Recipes General - How To - Recipes¬∂ Here are several pointers to other places in the docs, for general or frequent questions. Filter Data - Security¬∂ To ensure that you don't return more data than you should, read the docs for Tutorial - Response Model - Return Type. Documentation Tags - OpenAPI¬∂ To add tags to your path operations, and group them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Tags. Documentation Summary and Description - OpenAPI¬∂ To add a summary and description to your path operations, and show them in the docs UI, read the docs for Tutorial - Path Operation Configurations - Summary and Description. Documentation Response description - OpenAPI¬∂ To define the description of the response, shown in the docs UI, read the docs for Tutorial - Path Operation Configurations - Response description. Documentation Deprecate a Path Operation - OpenAPI¬∂ To deprecate a path operation, and show it in the docs UI, read the docs for Tutorial - Path Operation Configurations - Deprecation. Convert any Data to JSON-compatible¬∂ To convert any data to JSON-compatible, read the docs for Tutorial - JSON Compatible Encoder. OpenAPI Metadata - Docs¬∂ To add metadata to your OpenAPI schema, including a license, version, contact, etc, read the docs for Tutorial - Metadata and Docs URLs. OpenAPI Custom URL¬∂ To customize the OpenAPI URL (or remove it), read the docs for Tutorial - Metadata and Docs URLs. OpenAPI Docs URLs¬∂ To update the URLs used for the automatically generated docs user interfaces, read the docs for Tutorial - Metadata and Docs URLs. Made with Material for MkDocs Insiders"
  },
  {
    "title": "How To - Recipes - FastAPI",
    "url": "https://fastapi.tiangolo.com/how-to/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI How To - Recipes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes General - How To - Recipes SQL (Relational) Databases with Peewee Async SQL (Relational) Databases with Encode/Databases NoSQL (Distributed / Big Data) Databases with Couchbase GraphQL Custom Request and APIRoute class Conditional OpenAPI Extending OpenAPI Separate OpenAPI Schemas for Input and Output or Not Custom Docs UI Static Assets (Self-Hosting) Configure Swagger UI FastAPI Learn How To - Recipes How To - Recipes¬∂ Here you will see different recipes or \"how to\" guides for several topics. Most of these ideas would be more or less independent, and in most cases you should only need to study them if they apply directly to your project. If something seems interesting and useful to your project, go ahead and check it, but otherwise, you might probably just skip them. Tip If you want to learn FastAPI in a structured way (recommended), go and read the Tutorial - User Guide chapter by chapter instead. Made with Material for MkDocs Insiders"
  },
  {
    "title": "FastAPI in Containers - Docker - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/docker/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI FastAPI in Containers - Docker en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents What is a Container What is a Container Image Container Images Containers and Processes Build a Docker Image for FastAPI Package Requirements Create the FastAPI Code Dockerfile Behind a TLS Termination Proxy Docker Cache Build the Docker Image Start the Docker Container Check it Interactive API docs Alternative API docs Build a Docker Image with a Single-File FastAPI Deployment Concepts HTTPS Running on Startup and Restarts Replication - Number of Processes Load Balancer One Load Balancer - Multiple Worker Containers One Process per Container Containers with Multiple Processes and Special Cases A Simple App Docker Compose Prometheus and Other Reasons Memory Previous Steps Before Starting and Containers Multiple Containers Single Container Official Docker Image with Gunicorn - Uvicorn Number of Processes on the Official Docker Image Create a Dockerfile Bigger Applications When to Use Deploy the Container Image Docker Image with Poetry Behind a TLS Termination Proxy - Poetry Recap FastAPI Learn Deployment FastAPI in Containers - Docker¬∂ When deploying FastAPI applications a common approach is to build a Linux container image. It's normally done using Docker. You can then deploy that container image in one of a few possible ways. Using Linux containers has several advantages including security, replicability, simplicity, and others. Tip In a hurry and already know this stuff? Jump to the Dockerfile below üëá. Dockerfile Preview üëÄ What is a Container¬∂ Containers (mainly Linux containers) are a very lightweight way to package applications including all their dependencies and necessary files while keeping them isolated from other containers (other applications or components) in the same system. Linux containers run using the same Linux kernel of the host (machine, virtual machine, cloud server, etc). This just means that they are very lightweight (compared to full virtual machines emulating an entire operating system). This way, containers consume little resources, an amount comparable to running the processes directly (a virtual machine would consume much more). Containers also have their own isolated running processes (commonly just one process), file system, and network, simplifying deployment, security, development, etc. What is a Container Image¬∂ A container is run from a container image. A container image is a static version of all the files, environment variables, and the default command/program that should be present in a container. Static here means that the container image is not running, it's not being executed, it's only the packaged files and metadata. In contrast to a \"container image\" that is the stored static contents, a \"container\" normally refers to the running instance, the thing that is being executed. When the container is started and running (started from a container image) it could create or change files, environment variables, etc. Those changes will exist only in that container, but would not persist in the underlying container image (would not be saved to disk). A container image is comparable to the program file and contents, e.g. python and some file main.py. And the container itself (in contrast to the container image) is the actual running instance of the image, comparable to a process. In fact, a container is running only when it has a process running (and normally it's only a single process). The container stops when there's no process running in it. Container Images¬∂ Docker has been one of the main tools to create and manage container images and containers. And there's a public Docker Hub with pre-made official container images for many tools, environments, databases, and applications. For example, there's an official Python Image. And there are many other images for different things like databases, for example for: PostgreSQL MySQL MongoDB Redis, etc. By using a pre-made container image it's very easy to combine and use different tools. For example, to try out a new database. In most cases, you can use the official images, and just configure them with environment variables. That way, in many cases you can learn about containers and Docker and re-use that knowledge with many different tools and components. So, you would run multiple containers with different things, like a database, a Python application, a web server with a React frontend application, and connect them together via their internal network. All the container management systems (like Docker or Kubernetes) have these networking features integrated into them. Containers and Processes¬∂ A container image normally includes in its metadata the default program or command that should be run when the container is started and the parameters to be passed to that program. Very similar to what would be if it was in the command line. When a container is started, it will run that command/program (although you can override it and make it run a different command/program). A container is running as long as the main process (command or program) is running. A container normally has a single process, but it's also possible to start subprocesses from the main process, and that way you will have multiple processes in the same container. But it's not possible to have a running container without at least one running process. If the main process stops, the container stops. Build a Docker Image for FastAPI¬∂ Okay, let's build something now! üöÄ I'll show you how to build a Docker image for FastAPI from scratch, based on the official Python image. This is what you would want to do in most cases, for example: Using Kubernetes or similar tools When running on a Raspberry Pi Using a cloud service that would run a container image for you, etc. Package Requirements¬∂ You would normally have the package requirements for your application in some file. It would depend mainly on the tool you use to install those requirements. The most common way to do it is to have a file requirements.txt with the package names and their versions, one per line. You would of course use the same ideas you read in About FastAPI versions to set the ranges of versions. For example, your requirements.txt could look like: fastapi>=0.68.0,<0.69.0 pydantic>=1.8.0,<2.0.0 uvicorn>=0.15.0,<0.16.0 And you would normally install those package dependencies with pip, for example: Info There are other formats and tools to define and install package dependencies. I'll show you an example using Poetry later in a section below. üëá Create the FastAPI Code¬∂ Create an app directory and enter it. Create an empty file \\_\\_init\\_\\_.py. Create a main.py file with: from typing import Union from fastapi import FastAPI app = FastAPI() @app.get(\"/\") def read\\_root(): return {\"Hello\": \"World\"} @app.get(\"/items/{item\\_id}\") def read\\_item(item\\_id: int, q: Union\\[str, None\\] = None): return {\"item\\_id\": item\\_id, \"q\": q} Dockerfile¬∂ Now in the same project directory create a file Dockerfile with: # Start from the official Python base image. FROM python:3.9 # Set the current working directory to /code. This is where we'll put the requirements.txt file and the app directory. WORKDIR /code # Copy the file with the requirements to the /code directory. Copy only the file with the requirements first, not the rest of the code. As this file doesn't change often, Docker will detect it and use the cache for this step, enabling the cache for the next step too. COPY ./requirements.txt /code/requirements.txt # Install the package dependencies in the requirements file. The --no-cache-dir option tells pip to not save the downloaded packages locally, as that is only if pip was going to be run again to install the same packages, but that's not the case when working with containers. Note The --no-cache-dir is only related to pip, it has nothing to do with Docker or containers. The --upgrade option tells pip to upgrade the packages if they are already installed. Because the previous step copying the file could be detected by the Docker cache, this step will also use the Docker cache when available. Using the cache in this step will save you a lot of time when building the image again and again during development, instead of downloading and installing all the dependencies every time. RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt # Copy the ./app directory inside the /code directory. As this has all the code which is what changes most frequently the Docker cache won't be used for this or any following steps easily. So, it's important to put this near the end of the Dockerfile, to optimize the container image build times. COPY ./app /code/app # Set the command to run the uvicorn server. CMD takes a list of strings, each of these strings is what you would type in the command line separated by spaces. This command will be run from the current working directory, the same /code directory you set above with WORKDIR /code. Because the program will be started at /code and inside of it is the directory ./app with your code, Uvicorn will be able to see and import app from app.main. CMD \\[\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"\\] Tip Review what each line does by clicking each number bubble in the code. üëÜ You should now have a directory structure like: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ ‚îî‚îÄ‚îÄ main.py ‚îú‚îÄ‚îÄ Dockerfile ‚îî‚îÄ‚îÄ requirements.txt Behind a TLS Termination Proxy¬∂ If you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option --proxy-headers, this will tell Uvicorn to trust the headers sent by that proxy telling it that the application is running behind HTTPS, etc. CMD \\[\"uvicorn\", \"app.main:app\", \"--proxy-headers\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"\\] Docker Cache¬∂ There's an important trick in this Dockerfile, we first copy the file with the dependencies alone, not the rest of the code. Let me tell you why is that. COPY ./requirements.txt /code/requirements.txt Docker and other tools build these container images incrementally, adding one layer on top of the other, starting from the top of the Dockerfile and adding any files created by each of the instructions of the Dockerfile. Docker and similar tools also use an internal cache when building the image, if a file hasn't changed since the last time building the container image, then it will re-use the same layer created the last time, instead of copying the file again and creating a new layer from scratch. Just avoiding the copy of files doesn't necessarily improve things too much, but because it used the cache for that step, it can use the cache for the next step. For example, it could use the cache for the instruction that installs dependencies with: RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt The file with the package requirements won't change frequently. So, by copying only that file, Docker will be able to use the cache for that step. And then, Docker will be able to use the cache for the next step that downloads and install those dependencies. And here's where we save a lot of time. ‚ú® ...and avoid boredom waiting. üò™üòÜ Downloading and installing the package dependencies could take minutes, but using the cache would take seconds at most. And as you would be building the container image again and again during development to check that your code changes are working, there's a lot of accumulated time this would save. Then, near the end of the Dockerfile, we copy all the code. As this is what changes most frequently, we put it near the end, because almost always, anything after this step will not be able to use the cache. COPY ./app /code/app Build the Docker Image¬∂ Now that all the files are in place, let's build the container image. Go to the project directory (in where your Dockerfile is, containing your app directory). Build your FastAPI image: Tip Notice the . at the end, it's equivalent to ./, it tells Docker the directory to use to build the container image. In this case, it's the same current directory (.). Start the Docker Container¬∂ Run a container based on your image: Check it¬∂ You should be able to check it in your Docker container's URL, for example: http://192.168.99.100/items/5?q=somequery or http://127.0.0.1/items/5?q=somequery (or equivalent, using your Docker host). You will see something like: {\"item\\_id\": 5, \"q\": \"somequery\"} Interactive API docs¬∂ Now you can go to http://192.168.99.100/docs or http://127.0.0.1/docs (or equivalent, using your Docker host). You will see the automatic interactive API documentation (provided by Swagger UI): Alternative API docs¬∂ And you can also go to http://192.168.99.100/redoc or http://127.0.0.1/redoc (or equivalent, using your Docker host). You will see the alternative automatic documentation (provided by ReDoc): Build a Docker Image with a Single-File FastAPI¬∂ If your FastAPI is a single file, for example, main.py without an ./app directory, your file structure could look like this: . ‚îú‚îÄ‚îÄ Dockerfile ‚îú‚îÄ‚îÄ main.py ‚îî‚îÄ‚îÄ requirements.txt Then you would just have to change the corresponding paths to copy the file inside the Dockerfile: FROM python:3.9 WORKDIR /code COPY ./requirements.txt /code/requirements.txt RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt # Copy the main.py file to the /code directory directly (without any ./app directory). COPY ./main.py /code/ # Run Uvicorn and tell it to import the app object from main (instead of importing from app.main). CMD \\[\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"\\] Then adjust the Uvicorn command to use the new module main instead of app.main to import the FastAPI object app. Deployment Concepts¬∂ Let's talk again about some of the same Deployment Concepts in terms of containers. Containers are mainly a tool to simplify the process of building and deploying an application, but they don't enforce a particular approach to handle these deployment concepts, and there are several possible strategies. The good news is that with each different strategy there's a way to cover all of the deployment concepts. üéâ Let's review these deployment concepts in terms of containers: HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting HTTPS¬∂ If we focus just on the container image for a FastAPI application (and later the running container), HTTPS normally would be handled externally by another tool. It could be another container, for example with Traefik, handling HTTPS and automatic acquisition of certificates. Tip Traefik has integrations with Docker, Kubernetes, and others, so it's very easy to set up and configure HTTPS for your containers with it. Alternatively, HTTPS could be handled by a cloud provider as one of their services (while still running the application in a container). Running on Startup and Restarts¬∂ There is normally another tool in charge of starting and running your container. It could be Docker directly, Docker Compose, Kubernetes, a cloud service, etc. In most (or all) cases, there's a simple option to enable running the container on startup and enabling restarts on failures. For example, in Docker, it's the command line option --restart. Without using containers, making applications run on startup and with restarts can be cumbersome and difficult. But when working with containers in most cases that functionality is included by default. ‚ú® Replication - Number of Processes¬∂ If you have a cluster of machines with Kubernetes, Docker Swarm Mode, Nomad, or another similar complex system to manage distributed containers on multiple machines, then you will probably want to handle replication at the cluster level instead of using a process manager (like Gunicorn with workers) in each container. One of those distributed container management systems like Kubernetes normally has some integrated way of handling replication of containers while still supporting load balancing for the incoming requests. All at the cluster level. In those cases, you would probably want to build a Docker image from scratch as explained above, installing your dependencies, and running a single Uvicorn process instead of running something like Gunicorn with Uvicorn workers. Load Balancer¬∂ When using containers, you would normally have some component listening on the main port. It could possibly be another container that is also a TLS Termination Proxy to handle HTTPS or some similar tool. As this component would take the load of requests and distribute that among the workers in a (hopefully) balanced way, it is also commonly called a Load Balancer. Tip The same TLS Termination Proxy component used for HTTPS would probably also be a Load Balancer. And when working with containers, the same system you use to start and manage them would already have internal tools to transmit the network communication (e.g. HTTP requests) from that load balancer (that could also be a TLS Termination Proxy) to the container(s) with your app. One Load Balancer - Multiple Worker Containers¬∂ When working with Kubernetes or similar distributed container management systems, using their internal networking mechanisms would allow the single load balancer that is listening on the main port to transmit communication (requests) to possibly multiple containers running your app. Each of these containers running your app would normally have just one process (e.g. a Uvicorn process running your FastAPI application). They would all be identical containers, running the same thing, but each with its own process, memory, etc. That way you would take advantage of parallelization in different cores of the CPU, or even in different machines. And the distributed container system with the load balancer would distribute the requests to each one of the containers with your app in turns. So, each request could be handled by one of the multiple replicated containers running your app. And normally this load balancer would be able to handle requests that go to other apps in your cluster (e.g. to a different domain, or under a different URL path prefix), and would transmit that communication to the right containers for that other application running in your cluster. One Process per Container¬∂ In this type of scenario, you probably would want to have a single (Uvicorn) process per container, as you would already be handling replication at the cluster level. So, in this case, you would not want to have a process manager like Gunicorn with Uvicorn workers, or Uvicorn using its own Uvicorn workers. You would want to have just a single Uvicorn process per container (but probably multiple containers). Having another process manager inside the container (as would be with Gunicorn or Uvicorn managing Uvicorn workers) would only add unnecessary complexity that you are most probably already taking care of with your cluster system. Containers with Multiple Processes and Special Cases¬∂ Of course, there are special cases where you could want to have a container with a Gunicorn process manager starting several Uvicorn worker processes inside. In those cases, you can use the official Docker image that includes Gunicorn as a process manager running multiple Uvicorn worker processes, and some default settings to adjust the number of workers based on the current CPU cores automatically. I'll tell you more about it below in Official Docker Image with Gunicorn - Uvicorn. Here are some examples of when that could make sense: A Simple App¬∂ You could want a process manager in the container if your application is simple enough that you don't need (at least not yet) to fine-tune the number of processes too much, and you can just use an automated default (with the official Docker image), and you are running it on a single server, not a cluster. Docker Compose¬∂ You could be deploying to a single server (not a cluster) with Docker Compose, so you wouldn't have an easy way to manage replication of containers (with Docker Compose) while preserving the shared network and load balancing. Then you could want to have a single container with a process manager starting several worker processes inside. Prometheus and Other Reasons¬∂ You could also have other reasons that would make it easier to have a single container with multiple processes instead of having multiple containers with a single process in each of them. For example (depending on your setup) you could have some tool like a Prometheus exporter in the same container that should have access to each of the requests that come. In this case, if you had multiple containers, by default, when Prometheus came to read the metrics, it would get the ones for a single container each time (for the container that handled that particular request), instead of getting the accumulated metrics for all the replicated containers. Then, in that case, it could be simpler to have one container with multiple processes, and a local tool (e.g. a Prometheus exporter) on the same container collecting Prometheus metrics for all the internal processes and exposing those metrics on that single container. The main point is, none of these are rules written in stone that you have to blindly follow. You can use these ideas to evaluate your own use case and decide what is the best approach for your system, checking out how to manage the concepts of: Security - HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting Memory¬∂ If you run a single process per container you will have a more or less well-defined, stable, and limited amount of memory consumed by each of those containers (more than one if they are replicated). And then you can set those same memory limits and requirements in your configurations for your container management system (for example in Kubernetes). That way it will be able to replicate the containers in the available machines taking into account the amount of memory needed by them, and the amount available in the machines in the cluster. If your application is simple, this will probably not be a problem, and you might not need to specify hard memory limits. But if you are using a lot of memory (for example with machine learning models), you should check how much memory you are consuming and adjust the number of containers that runs in each machine (and maybe add more machines to your cluster). If you run multiple processes per container (for example with the official Docker image) you will have to make sure that the number of processes started doesn't consume more memory than what is available. Previous Steps Before Starting and Containers¬∂ If you are using containers (e.g. Docker, Kubernetes), then there are two main approaches you can use. Multiple Containers¬∂ If you have multiple containers, probably each one running a single process (for example, in a Kubernetes cluster), then you would probably want to have a separate container doing the work of the previous steps in a single container, running a single process, before running the replicated worker containers. Info If you are using Kubernetes, this would probably be an Init Container. If in your use case there's no problem in running those previous steps multiple times in parallel (for example if you are not running database migrations, but just checking if the database is ready yet), then you could also just put them in each container right before starting the main process. Single Container¬∂ If you have a simple setup, with a single container that then starts multiple worker processes (or also just one process), then you could run those previous steps in the same container, right before starting the process with the app. The official Docker image supports this internally. Official Docker Image with Gunicorn - Uvicorn¬∂ There is an official Docker image that includes Gunicorn running with Uvicorn workers, as detailed in a previous chapter: Server Workers - Gunicorn with Uvicorn. This image would be useful mainly in the situations described above in: Containers with Multiple Processes and Special Cases. tiangolo/uvicorn-gunicorn-fastapi. Warning There's a high chance that you don't need this base image or any other similar one, and would be better off by building the image from scratch as described above in: Build a Docker Image for FastAPI. This image has an auto-tuning mechanism included to set the number of worker processes based on the CPU cores available. It has sensible defaults, but you can still change and update all the configurations with environment variables or configuration files. It also supports running previous steps before starting with a script. Tip To see all the configurations and options, go to the Docker image page: tiangolo/uvicorn-gunicorn-fastapi. Number of Processes on the Official Docker Image¬∂ The number of processes on this image is computed automatically from the CPU cores available. This means that it will try to squeeze as much performance from the CPU as possible. You can also adjust it with the configurations using environment variables, etc. But it also means that as the number of processes depends on the CPU the container is running, the amount of memory consumed will also depend on that. So, if your application consumes a lot of memory (for example with machine learning models), and your server has a lot of CPU cores but little memory, then your container could end up trying to use more memory than what is available, and degrading performance a lot (or even crashing). üö® Create a Dockerfile¬∂ Here's how you would create a Dockerfile based on this image: FROM tiangolo/uvicorn-gunicorn-fastapi:python3.9 COPY ./requirements.txt /app/requirements.txt RUN pip install --no-cache-dir --upgrade -r /app/requirements.txt COPY ./app /app Bigger Applications¬∂ If you followed the section about creating Bigger Applications with Multiple Files, your Dockerfile might instead look like: FROM tiangolo/uvicorn-gunicorn-fastapi:python3.9 COPY ./requirements.txt /app/requirements.txt RUN pip install --no-cache-dir --upgrade -r /app/requirements.txt COPY ./app /app/app When to Use¬∂ You should probably not use this official base image (or any other similar one) if you are using Kubernetes (or others) and you are already setting replication at the cluster level, with multiple containers. In those cases, you are better off building an image from scratch as described above: Build a Docker Image for FastAPI. This image would be useful mainly in the special cases described above in Containers with Multiple Processes and Special Cases. For example, if your application is simple enough that setting a default number of processes based on the CPU works well, you don't want to bother with manually configuring the replication at the cluster level, and you are not running more than one container with your app. Or if you are deploying with Docker Compose, running on a single server, etc. Deploy the Container Image¬∂ After having a Container (Docker) Image there are several ways to deploy it. For example: With Docker Compose in a single server With a Kubernetes cluster With a Docker Swarm Mode cluster With another tool like Nomad With a cloud service that takes your container image and deploys it Docker Image with Poetry¬∂ If you use Poetry to manage your project's dependencies, you could use Docker multi-stage building: # This is the first stage, it is named requirements-stage. FROM python:3.9 as requirements-stage # Set /tmp as the current working directory. Here's where we will generate the file requirements.txt WORKDIR /tmp # Install Poetry in this Docker stage. RUN pip install poetry # Copy the pyproject.toml and poetry.lock files to the /tmp directory. Because it uses ./poetry.lock\\* (ending with a \\*), it won't crash if that file is not available yet. COPY ./pyproject.toml ./poetry.lock\\* /tmp/ # Generate the requirements.txt file. RUN poetry export -f requirements.txt --output requirements.txt --without-hashes # This is the final stage, anything here will be preserved in the final container image. FROM python:3.9 # Set the current working directory to /code. WORKDIR /code # Copy the requirements.txt file to the /code directory. This file only lives in the previous Docker stage, that's why we use --from-requirements-stage to copy it. COPY --from=requirements-stage /tmp/requirements.txt /code/requirements.txt # Install the package dependencies in the generated requirements.txt file. RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt # Copy the app directory to the /code directory. COPY ./app /code/app # Run the uvicorn command, telling it to use the app object imported from app.main. CMD \\[\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"\\] Tip Click the bubble numbers to see what each line does. A Docker stage is a part of a Dockerfile that works as a temporary container image that is only used to generate some files to be used later. The first stage will only be used to install Poetry and to generate the requirements.txt with your project dependencies from Poetry's pyproject.toml file. This requirements.txt file will be used with pip later in the next stage. In the final container image only the final stage is preserved. The previous stage(s) will be discarded. When using Poetry, it would make sense to use Docker multi-stage builds because you don't really need to have Poetry and its dependencies installed in the final container image, you only need to have the generated requirements.txt file to install your project dependencies. Then in the next (and final) stage you would build the image more or less in the same way as described before. Behind a TLS Termination Proxy - Poetry¬∂ Again, if you are running your container behind a TLS Termination Proxy (load balancer) like Nginx or Traefik, add the option --proxy-headers to the command: CMD \\[\"uvicorn\", \"app.main:app\", \"--proxy-headers\", \"--host\", \"0.0.0.0\", \"--port\", \"80\"\\] Recap¬∂ Using container systems (e.g. with Docker and Kubernetes) it becomes fairly straightforward to handle all the deployment concepts: HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting In most cases, you probably won't want to use any base image, and instead build a container image from scratch one based on the official Python Docker image. Taking care of the order of instructions in the Dockerfile and the Docker cache you can minimize build times, to maximize your productivity (and avoid boredom). üòé In certain special cases, you might want to use the official Docker image for FastAPI. ü§ì Made with Material for MkDocs Insiders"
  },
  {
    "title": "Server Workers - Gunicorn with Uvicorn - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/server-workers/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Server Workers - Gunicorn with Uvicorn en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents Gunicorn with Uvicorn Workers Install Gunicorn and Uvicorn Run Gunicorn with Uvicorn Workers Uvicorn with Workers Deployment Concepts Containers and Docker Recap FastAPI Learn Deployment Server Workers - Gunicorn with Uvicorn¬∂ Let's check back those deployment concepts from before: Security - HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting Up to this point, with all the tutorials in the docs, you have probably been running a server program like Uvicorn, running a single process. When deploying applications you will probably want to have some replication of processes to take advantage of multiple cores and to be able to handle more requests. As you saw in the previous chapter about Deployment Concepts, there are multiple strategies you can use. Here I'll show you how to use Gunicorn with Uvicorn worker processes. Info If you are using containers, for example with Docker or Kubernetes, I'll tell you more about that in the next chapter: FastAPI in Containers - Docker. In particular, when running on Kubernetes you will probably not want to use Gunicorn and instead run a single Uvicorn process per container, but I'll tell you about it later in that chapter. Gunicorn with Uvicorn Workers¬∂ Gunicorn is mainly an application server using the WSGI standard. That means that Gunicorn can serve applications like Flask and Django. Gunicorn by itself is not compatible with FastAPI, as FastAPI uses the newest ASGI standard. But Gunicorn supports working as a process manager and allowing users to tell it which specific worker process class to use. Then Gunicorn would start one or more worker processes using that class. And Uvicorn has a Gunicorn-compatible worker class. Using that combination, Gunicorn would act as a process manager, listening on the port and the IP. And it would transmit the communication to the worker processes running the Uvicorn class. And then the Gunicorn-compatible Uvicorn worker class would be in charge of converting the data sent by Gunicorn to the ASGI standard for FastAPI to use it. Install Gunicorn and Uvicorn¬∂ That will install both Uvicorn with the standard extra packages (to get high performance) and Gunicorn. Run Gunicorn with Uvicorn Workers¬∂ Then you can run Gunicorn with: Let's see what each of those options mean: main:app: This is the same syntax used by Uvicorn, main means the Python module named \"main\", so, a file main.py. And app is the name of the variable that is the FastAPI application. You can imagine that main:app is equivalent to a Python import statement like: from main import app So, the colon in main:app would be equivalent to the Python import part in from main import app. --workers: The number of worker processes to use, each will run a Uvicorn worker, in this case, 4 workers. --worker-class: The Gunicorn-compatible worker class to use in the worker processes. Here we pass the class that Gunicorn can import and use with: import uvicorn.workers.UvicornWorker --bind: This tells Gunicorn the IP and the port to listen to, using a colon (:) to separate the IP and the port. If you were running Uvicorn directly, instead of --bind 0.0.0.0:80 (the Gunicorn option) you would use --host 0.0.0.0 and --port 80. In the output, you can see that it shows the PID (process ID) of each process (it's just a number). You can see that: The Gunicorn process manager starts with PID 19499 (in your case it will be a different number). Then it starts Listening at: http://0.0.0.0:80. Then it detects that it has to use the worker class at uvicorn.workers.UvicornWorker. And then it starts 4 workers, each with its own PID: 19511, 19513, 19514, and 19515. Gunicorn would also take care of managing dead processes and restarting new ones if needed to keep the number of workers. So that helps in part with the restart concept from the list above. Nevertheless, you would probably also want to have something outside making sure to restart Gunicorn if necessary, and also to run it on startup, etc. Uvicorn with Workers¬∂ Uvicorn also has an option to start and run several worker processes. Nevertheless, as of now, Uvicorn's capabilities for handling worker processes are more limited than Gunicorn's. So, if you want to have a process manager at this level (at the Python level), then it might be better to try with Gunicorn as the process manager. In any case, you would run it like this: The only new option here is --workers telling Uvicorn to start 4 worker processes. You can also see that it shows the PID of each process, 27365 for the parent process (this is the process manager) and one for each worker process: 27368, 27369, 27370, and 27367. Deployment Concepts¬∂ Here you saw how to use Gunicorn (or Uvicorn) managing Uvicorn worker processes to parallelize the execution of the application, take advantage of multiple cores in the CPU, and be able to serve more requests. From the list of deployment concepts from above, using workers would mainly help with the replication part, and a little bit with the restarts, but you still need to take care of the others: Security - HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting Containers and Docker¬∂ In the next chapter about FastAPI in Containers - Docker I'll tell some strategies you could use to handle the other deployment concepts. I'll also show you the official Docker image that includes Gunicorn with Uvicorn workers and some default configurations that can be useful for simple cases. There I'll also show you how to build your own image from scratch to run a single Uvicorn process (without Gunicorn). It is a simple process and is probably what you would want to do when using a distributed container management system like Kubernetes. Recap¬∂ You can use Gunicorn (or also Uvicorn) as a process manager with Uvicorn workers to take advantage of multi-core CPUs, to run multiple processes in parallel. You could use these tools and ideas if you are setting up your own deployment system while taking care of the other deployment concepts yourself. Check out the next chapter to learn about FastAPI with containers (e.g. Docker and Kubernetes). You will see that those tools have simple ways to solve the other deployment concepts as well. ‚ú® Made with Material for MkDocs Insiders"
  },
  {
    "title": "Deploy FastAPI on Cloud Providers - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/cloud/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Deploy FastAPI on Cloud Providers en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents Cloud Providers - Sponsors FastAPI Learn Deployment Deploy FastAPI on Cloud Providers¬∂ You can use virtually any cloud provider to deploy your FastAPI application. In most of the cases, the main cloud providers have guides to deploy FastAPI with them. Cloud Providers - Sponsors¬∂ Some cloud providers ‚ú® sponsor FastAPI ‚ú®, this ensures the continued and healthy development of FastAPI and its ecosystem. And it shows their true commitment to FastAPI and its community (you), as they not only want to provide you a good service but also want to make sure you have a good and healthy framework, FastAPI. üôá You might want to try their services and follow their guides: Platform.sh Porter Deta Made with Material for MkDocs Insiders"
  },
  {
    "title": "Deployments Concepts - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/concepts/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Deployments Concepts en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents Security - HTTPS Example Tools for HTTPS Program and Process What is a Program What is a Process Running on Startup In a Remote Server Run Automatically on Startup Separate Program Example Tools to Run at Startup Restarts We Make Mistakes Small Errors Automatically Handled Bigger Errors - Crashes Restart After Crash Example Tools to Restart Automatically Replication - Processes and Memory Multiple Processes - Workers Worker Processes and Ports Memory per Process Server Memory Multiple Processes - An Example Examples of Replication Tools and Strategies Previous Steps Before Starting Examples of Previous Steps Strategies Resource Utilization Recap FastAPI Learn Deployment Deployments Concepts¬∂ When deploying a FastAPI application, or actually, any type of web API, there are several concepts that you probably care about, and using them you can find the most appropriate way to deploy your application. Some of the important concepts are: Security - HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting We'll see how they would affect deployments. In the end, the ultimate objective is to be able to serve your API clients in a way that is secure, to avoid disruptions, and to use the compute resources (for example remote servers/virtual machines) as efficiently as possible. üöÄ I'll tell you a bit more about these concepts here, and that would hopefully give you the intuition you would need to decide how to deploy your API in very different environments, possibly even in future ones that don't exist yet. By considering these concepts, you will be able to evaluate and design the best way to deploy your own APIs. In the next chapters, I'll give you more concrete recipes to deploy FastAPI applications. But for now, let's check these important conceptual ideas. These concepts also apply to any other type of web API. üí° Security - HTTPS¬∂ In the previous chapter about HTTPS we learned about how HTTPS provides encryption for your API. We also saw that HTTPS is normally provided by a component external to your application server, a TLS Termination Proxy. And there has to be something in charge of renewing the HTTPS certificates, it could be the same component or it could be something different. Example Tools for HTTPS¬∂ Some of the tools you could use as a TLS Termination Proxy are: Traefik Automatically handles certificates renewals ‚ú® Caddy Automatically handles certificates renewals ‚ú® Nginx With an external component like Certbot for certificate renewals HAProxy With an external component like Certbot for certificate renewals Kubernetes with an Ingress Controller like Nginx With an external component like cert-manager for certificate renewals Handled internally by a cloud provider as part of their services (read below üëá) Another option is that you could use a cloud service that does more of the work including setting up HTTPS. It could have some restrictions or charge you more, etc. But in that case, you wouldn't have to set up a TLS Termination Proxy yourself. I'll show you some concrete examples in the next chapters. Then the next concepts to consider are all about the program running your actual API (e.g. Uvicorn). Program and Process¬∂ We will talk a lot about the running \"process\", so it's useful to have clarity about what it means, and what's the difference with the word \"program\". What is a Program¬∂ The word program is commonly used to describe many things: The code that you write, the Python files. The file that can be executed by the operating system, for example: python, python.exe or uvicorn. A particular program while it is running on the operating system, using the CPU, and storing things on memory. This is also called a process. What is a Process¬∂ The word process is normally used in a more specific way, only referring to the thing that is running in the operating system (like in the last point above): A particular program while it is running on the operating system. This doesn't refer to the file, nor to the code, it refers specifically to the thing that is being executed and managed by the operating system. Any program, any code, can only do things when it is being executed. So, when there's a process running. The process can be terminated (or \"killed\") by you, or by the operating system. At that point, it stops running/being executed, and it can no longer do things. Each application that you have running on your computer has some process behind it, each running program, each window, etc. And there are normally many processes running at the same time while a computer is on. There can be multiple processes of the same program running at the same time. If you check out the \"task manager\" or \"system monitor\" (or similar tools) in your operating system, you will be able to see many of those processes running. And, for example, you will probably see that there are multiple processes running the same browser program (Firefox, Chrome, Edge, etc). They normally run one process per tab, plus some other extra processes. Now that we know the difference between the terms process and program, let's continue talking about deployments. Running on Startup¬∂ In most cases, when you create a web API, you want it to be always running, uninterrupted, so that your clients can always access it. This is of course, unless you have a specific reason why you want it to run only in certain situations, but most of the time you want it constantly running and available. In a Remote Server¬∂ When you set up a remote server (a cloud server, a virtual machine, etc.) the simplest thing you can do is to run Uvicorn (or similar) manually, the same way you do when developing locally. And it will work and will be useful during development. But if your connection to the server is lost, the running process will probably die. And if the server is restarted (for example after updates, or migrations from the cloud provider) you probably won't notice it. And because of that, you won't even know that you have to restart the process manually. So, your API will just stay dead. üò± Run Automatically on Startup¬∂ In general, you will probably want the server program (e.g. Uvicorn) to be started automatically on server startup, and without needing any human intervention, to have a process always running with your API (e.g. Uvicorn running your FastAPI app). Separate Program¬∂ To achieve this, you will normally have a separate program that would make sure your application is run on startup. And in many cases, it would also make sure other components or applications are also run, for example, a database. Example Tools to Run at Startup¬∂ Some examples of the tools that can do this job are: Docker Kubernetes Docker Compose Docker in Swarm Mode Systemd Supervisor Handled internally by a cloud provider as part of their services Others... I'll give you more concrete examples in the next chapters. Restarts¬∂ Similar to making sure your application is run on startup, you probably also want to make sure it is restarted after failures. We Make Mistakes¬∂ We, as humans, make mistakes, all the time. Software almost always has bugs hidden in different places. üêõ And we as developers keep improving the code as we find those bugs and as we implement new features (possibly adding new bugs too üòÖ). Small Errors Automatically Handled¬∂ When building web APIs with FastAPI, if there's an error in our code, FastAPI will normally contain it to the single request that triggered the error. üõ° The client will get a 500 Internal Server Error for that request, but the application will continue working for the next requests instead of just crashing completely. Bigger Errors - Crashes¬∂ Nevertheless, there might be cases where we write some code that crashes the entire application making Uvicorn and Python crash. üí• And still, you would probably not want the application to stay dead because there was an error in one place, you probably want it to continue running at least for the path operations that are not broken. Restart After Crash¬∂ But in those cases with really bad errors that crash the running process, you would want an external component that is in charge of restarting the process, at least a couple of times... Tip ...Although if the whole application is just crashing immediately it probably doesn't make sense to keep restarting it forever. But in those cases, you will probably notice it during development, or at least right after deployment. So let's focus on the main cases, where it could crash entirely in some particular cases in the future, and it still makes sense to restart it. You would probably want to have the thing in charge of restarting your application as an external component, because by that point, the same application with Uvicorn and Python already crashed, so there's nothing in the same code of the same app that could do anything about it. Example Tools to Restart Automatically¬∂ In most cases, the same tool that is used to run the program on startup is also used to handle automatic restarts. For example, this could be handled by: Docker Kubernetes Docker Compose Docker in Swarm Mode Systemd Supervisor Handled internally by a cloud provider as part of their services Others... Replication - Processes and Memory¬∂ With a FastAPI application, using a server program like Uvicorn, running it once in one process can serve multiple clients concurrently. But in many cases, you will want to run several worker processes at the same time. Multiple Processes - Workers¬∂ If you have more clients than what a single process can handle (for example if the virtual machine is not too big) and you have multiple cores in the server's CPU, then you could have multiple processes running with the same application at the same time, and distribute all the requests among them. When you run multiple processes of the same API program, they are commonly called workers. Worker Processes and Ports¬∂ Remember from the docs About HTTPS that only one process can be listening on one combination of port and IP address in a server? This is still true. So, to be able to have multiple processes at the same time, there has to be a single process listening on a port that then transmits the communication to each worker process in some way. Memory per Process¬∂ Now, when the program loads things in memory, for example, a machine learning model in a variable, or the contents of a large file in a variable, all that consumes a bit of the memory (RAM) of the server. And multiple processes normally don't share any memory. This means that each running process has its own things, variables, and memory. And if you are consuming a large amount of memory in your code, each process will consume an equivalent amount of memory. Server Memory¬∂ For example, if your code loads a Machine Learning model with 1 GB in size, when you run one process with your API, it will consume at least 1 GB of RAM. And if you start 4 processes (4 workers), each will consume 1 GB of RAM. So in total, your API will consume 4 GB of RAM. And if your remote server or virtual machine only has 3 GB of RAM, trying to load more than 4 GB of RAM will cause problems. üö® Multiple Processes - An Example¬∂ In this example, there's a Manager Process that starts and controls two Worker Processes. This Manager Process would probably be the one listening on the port in the IP. And it would transmit all the communication to the worker processes. Those worker processes would be the ones running your application, they would perform the main computations to receive a request and return a response, and they would load anything you put in variables in RAM. And of course, the same machine would probably have other processes running as well, apart from your application. An interesting detail is that the percentage of the CPU used by each process can vary a lot over time, but the memory (RAM) normally stays more or less stable. If you have an API that does a comparable amount of computations every time and you have a lot of clients, then the CPU utilization will probably also be stable (instead of constantly going up and down quickly). Examples of Replication Tools and Strategies¬∂ There can be several approaches to achieve this, and I'll tell you more about specific strategies in the next chapters, for example when talking about Docker and containers. The main constraint to consider is that there has to be a single component handling the port in the public IP. And then it has to have a way to transmit the communication to the replicated processes/workers. Here are some possible combinations and strategies: Gunicorn managing Uvicorn workers Gunicorn would be the process manager listening on the IP and port, the replication would be by having multiple Uvicorn worker processes Uvicorn managing Uvicorn workers One Uvicorn process manager would listen on the IP and port, and it would start multiple Uvicorn worker processes Kubernetes and other distributed container systems Something in the Kubernetes layer would listen on the IP and port. The replication would be by having multiple containers, each with one Uvicorn process running Cloud services that handle this for you The cloud service will probably handle replication for you. It would possibly let you define a process to run, or a container image to use, in any case, it would most probably be a single Uvicorn process, and the cloud service would be in charge of replicating it. Tip Don't worry if some of these items about containers, Docker, or Kubernetes don't make a lot of sense yet. I'll tell you more about container images, Docker, Kubernetes, etc. in a future chapter: FastAPI in Containers - Docker. Previous Steps Before Starting¬∂ There are many cases where you want to perform some steps before starting your application. For example, you might want to run database migrations. But in most cases, you will want to perform these steps only once. So, you will want to have a single process to perform those previous steps, before starting the application. And you will have to make sure that it's a single process running those previous steps even if afterwards, you start multiple processes (multiple workers) for the application itself. If those steps were run by multiple processes, they would duplicate the work by running it on parallel, and if the steps were something delicate like a database migration, they could cause conflicts with each other. Of course, there are some cases where there's no problem in running the previous steps multiple times, in that case, it's a lot easier to handle. Tip Also, have in mind that depending on your setup, in some cases you might not even need any previous steps before starting your application. In that case, you wouldn't have to worry about any of this. ü§∑ Examples of Previous Steps Strategies¬∂ This will depend heavily on the way you deploy your system, and it would probably be connected to the way you start programs, handling restarts, etc. Here are some possible ideas: An \"Init Container\" in Kubernetes that runs before your app container A bash script that runs the previous steps and then starts your application You would still need a way to start/restart that bash script, detect errors, etc. Tip I'll give you more concrete examples for doing this with containers in a future chapter: FastAPI in Containers - Docker. Resource Utilization¬∂ Your server(s) is (are) a resource, you can consume or utilize, with your programs, the computation time on the CPUs, and the RAM memory available. How much of the system resources do you want to be consuming/utilizing? It might be easy to think \"not much\", but in reality, you will probably want to consume as much as possible without crashing. If you are paying for 3 servers but you are using only a little bit of their RAM and CPU, you are probably wasting money üí∏, and probably wasting server electric power üåé, etc. In that case, it could be better to have only 2 servers and use a higher percentage of their resources (CPU, memory, disk, network bandwidth, etc). On the other hand, if you have 2 servers and you are using 100% of their CPU and RAM, at some point one process will ask for more memory, and the server will have to use the disk as \"memory\" (which can be thousands of times slower), or even crash. Or one process might need to do some computation and would have to wait until the CPU is free again. In this case, it would be better to get one extra server and run some processes on it so that they all have enough RAM and CPU time. There's also the chance that for some reason you have a spike of usage of your API. Maybe it went viral, or maybe some other services or bots start using it. And you might want to have extra resources to be safe in those cases. You could put an arbitrary number to target, for example, something between 50% to 90% of resource utilization. The point is that those are probably the main things you will want to measure and use to tweak your deployments. You can use simple tools like htop to see the CPU and RAM used in your server or the amount used by each process. Or you can use more complex monitoring tools, which may be distributed across servers, etc. Recap¬∂ You have been reading here some of the main concepts that you would probably need to have in mind when deciding how to deploy your application: Security - HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting Understanding these ideas and how to apply them should give you the intuition necessary to take any decisions when configuring and tweaking your deployments. ü§ì In the next sections, I'll give you more concrete examples of possible strategies you can follow. üöÄ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Run a Server Manually - Uvicorn - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/manually/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Run a Server Manually - Uvicorn en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents Server Machine and Server Program Install the Server Program Run the Server Program Hypercorn with Trio Install Hypercorn with Trio Run with Trio Deployment Concepts FastAPI Learn Deployment Run a Server Manually - Uvicorn¬∂ The main thing you need to run a FastAPI application in a remote server machine is an ASGI server program like Uvicorn. There are 3 main alternatives: Uvicorn: a high performance ASGI server. Hypercorn: an ASGI server compatible with HTTP/2 and Trio among other features. Daphne: the ASGI server built for Django Channels. Server Machine and Server Program¬∂ There's a small detail about names to have in mind. üí° The word \"server\" is commonly used to refer to both the remote/cloud computer (the physical or virtual machine) and also the program that is running on that machine (e.g. Uvicorn). Just have that in mind when you read \"server\" in general, it could refer to one of those two things. When referring to the remote machine, it's common to call it server, but also machine, VM (virtual machine), node. Those all refer to some type of remote machine, normally running Linux, where you run programs. Install the Server Program¬∂ You can install an ASGI compatible server with: Uvicorn Hypercorn Uvicorn, a lightning-fast ASGI server, built on uvloop and httptools. Tip By adding the standard, Uvicorn will install and use some recommended extra dependencies. That including uvloop, the high-performance drop-in replacement for asyncio, that provides the big concurrency performance boost. Run the Server Program¬∂ You can then run your application the same way you have done in the tutorials, but without the --reload option, e.g.: Uvicorn Hypercorn Warning Remember to remove the --reload option if you were using it. The --reload option consumes much more resources, is more unstable, etc. It helps a lot during development, but you shouldn't use it in production. Hypercorn with Trio¬∂ Starlette and FastAPI are based on AnyIO, which makes them compatible with both Python's standard library asyncio and Trio. Nevertheless, Uvicorn is currently only compatible with asyncio, and it normally uses uvloop, the high-performance drop-in replacement for asyncio. But if you want to directly use Trio, then you can use Hypercorn as it supports it. ‚ú® Install Hypercorn with Trio¬∂ First you need to install Hypercorn with Trio support: Run with Trio¬∂ Then you can pass the command line option --worker-class with the value trio: And that will start Hypercorn with your app using Trio as the backend. Now you can use Trio internally in your app. Or even better, you can use AnyIO, to keep your code compatible with both Trio and asyncio. üéâ Deployment Concepts¬∂ These examples run the server program (e.g Uvicorn), starting a single process, listening on all the IPs (0.0.0.0) on a predefined port (e.g. 80). This is the basic idea. But you will probably want to take care of some additional things, like: Security - HTTPS Running on startup Restarts Replication (the number of processes running) Memory Previous steps before starting I'll tell you more about each of these concepts, how to think about them, and some concrete examples with strategies to handle them in the next chapters. üöÄ Made with Material for MkDocs Insiders"
  },
  {
    "title": "About HTTPS - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/https/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI About HTTPS en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents Let's Encrypt HTTPS for Developers Domain Name DNS TLS Handshake Start TLS with SNI Extension HTTPS Request Decrypt the Request HTTP Response HTTPS Response Multiple Applications Certificate Renewal Recap FastAPI Learn Deployment About HTTPS¬∂ It is easy to assume that HTTPS is something that is just \"enabled\" or not. But it is way more complex than that. Tip If you are in a hurry or don't care, continue with the next sections for step by step instructions to set everything up with different techniques. To learn the basics of HTTPS, from a consumer perspective, check https://howhttps.works/. Now, from a developer's perspective, here are several things to have in mind while thinking about HTTPS: For HTTPS, the server needs to have \"certificates\" generated by a third party. Those certificates are actually acquired from the third party, not \"generated\". Certificates have a lifetime. They expire. And then they need to be renewed, acquired again from the third party. The encryption of the connection happens at the TCP level. That's one layer below HTTP. So, the certificate and encryption handling is done before HTTP. TCP doesn't know about \"domains\". Only about IP addresses. The information about the specific domain requested goes in the HTTP data. The HTTPS certificates \"certify\" a certain domain, but the protocol and encryption happen at the TCP level, before knowing which domain is being dealt with. By default, that would mean that you can only have one HTTPS certificate per IP address. No matter how big your server is or how small each application you have on it might be. There is a solution to this, however. There's an extension to the TLS protocol (the one handling the encryption at the TCP level, before HTTP) called SNI. This SNI extension allows one single server (with a single IP address) to have several HTTPS certificates and serve multiple HTTPS domains/applications. For this to work, a single component (program) running on the server, listening on the public IP address, must have all the HTTPS certificates in the server. After obtaining a secure connection, the communication protocol is still HTTP. The contents are encrypted, even though they are being sent with the HTTP protocol. It is a common practice to have one program/HTTP server running on the server (the machine, host, etc.) and managing all the HTTPS parts: receiving the encrypted HTTPS requests, sending the decrypted HTTP requests to the actual HTTP application running in the same server (the FastAPI application, in this case), take the HTTP response from the application, encrypt it using the appropriate HTTPS certificate and sending it back to the client using HTTPS. This server is often called a TLS Termination Proxy. Some of the options you could use as a TLS Termination Proxy are: Traefik (that can also handle certificate renewals) Caddy (that can also handle certificate renewals) Nginx HAProxy Let's Encrypt¬∂ Before Let's Encrypt, these HTTPS certificates were sold by trusted third parties. The process to acquire one of these certificates used to be cumbersome, require quite some paperwork and the certificates were quite expensive. But then Let's Encrypt was created. It is a project from the Linux Foundation. It provides HTTPS certificates for free, in an automated way. These certificates use all the standard cryptographic security, and are short-lived (about 3 months), so the security is actually better because of their reduced lifespan. The domains are securely verified and the certificates are generated automatically. This also allows automating the renewal of these certificates. The idea is to automate the acquisition and renewal of these certificates so that you can have secure HTTPS, for free, forever. HTTPS for Developers¬∂ Here's an example of how an HTTPS API could look like, step by step, paying attention mainly to the ideas important for developers. Domain Name¬∂ It would probably all start by you acquiring some domain name. Then, you would configure it in a DNS server (possibly your same cloud provider). You would probably get a cloud server (a virtual machine) or something similar, and it would have a fixed public IP address. In the DNS server(s) you would configure a record (an \"A record\") to point your domain to the public IP address of your server. You would probably do this just once, the first time, when setting everything up. Tip This Domain Name part is way before HTTPS, but as everything depends on the domain and the IP address, it's worth mentioning it here. DNS¬∂ Now let's focus on all the actual HTTPS parts. First, the browser would check with the DNS servers what is the IP for the domain, in this case, someapp.example.com. The DNS servers would tell the browser to use some specific IP address. That would be the public IP address used by your server, that you configured in the DNS servers. TLS Handshake Start¬∂ The browser would then communicate with that IP address on port 443 (the HTTPS port). The first part of the communication is just to establish the connection between the client and the server and to decide the cryptographic keys they will use, etc. This interaction between the client and the server to establish the TLS connection is called the TLS handshake. TLS with SNI Extension¬∂ Only one process in the server can be listening on a specific port in a specific IP address. There could be other processes listening on other ports in the same IP address, but only one for each combination of IP address and port. TLS (HTTPS) uses the specific port 443 by default. So that's the port we would need. As only one process can be listening on this port, the process that would do it would be the TLS Termination Proxy. The TLS Termination Proxy would have access to one or more TLS certificates (HTTPS certificates). Using the SNI extension discussed above, the TLS Termination Proxy would check which of the TLS (HTTPS) certificates available it should use for this connection, using the one that matches the domain expected by the client. In this case, it would use the certificate for someapp.example.com. The client already trusts the entity that generated that TLS certificate (in this case Let's Encrypt, but we'll see about that later), so it can verify that the certificate is valid. Then, using the certificate, the client and the TLS Termination Proxy decide how to encrypt the rest of the TCP communication. This completes the TLS Handshake part. After this, the client and the server have an encrypted TCP connection, this is what TLS provides. And then they can use that connection to start the actual HTTP communication. And that's what HTTPS is, it's just plain HTTP inside a secure TLS connection instead of a pure (unencrypted) TCP connection. Tip Notice that the encryption of the communication happens at the TCP level, not at the HTTP level. HTTPS Request¬∂ Now that the client and server (specifically the browser and the TLS Termination Proxy) have an encrypted TCP connection, they can start the HTTP communication. So, the client sends an HTTPS request. This is just an HTTP request through an encrypted TLS connection. Decrypt the Request¬∂ The TLS Termination Proxy would use the encryption agreed to decrypt the request, and would transmit the plain (decrypted) HTTP request to the process running the application (for example a process with Uvicorn running the FastAPI application). HTTP Response¬∂ The application would process the request and send a plain (unencrypted) HTTP response to the TLS Termination Proxy. HTTPS Response¬∂ The TLS Termination Proxy would then encrypt the response using the cryptography agreed before (that started with the certificate for someapp.example.com), and send it back to the browser. Next, the browser would verify that the response is valid and encrypted with the right cryptographic key, etc. It would then decrypt the response and process it. The client (browser) will know that the response comes from the correct server because it is using the cryptography they agreed using the HTTPS certificate before. Multiple Applications¬∂ In the same server (or servers), there could be multiple applications, for example, other API programs or a database. Only one process can be handling the specific IP and port (the TLS Termination Proxy in our example) but the other applications/processes can be running on the server(s) too, as long as they don't try to use the same combination of public IP and port. That way, the TLS Termination Proxy could handle HTTPS and certificates for multiple domains, for multiple applications, and then transmit the requests to the right application in each case. Certificate Renewal¬∂ At some point in the future, each certificate would expire (about 3 months after acquiring it). And then, there would be another program (in some cases it's another program, in some cases it could be the same TLS Termination Proxy) that would talk to Let's Encrypt, and renew the certificate(s). The TLS certificates are associated with a domain name, not with an IP address. So, to renew the certificates, the renewal program needs to prove to the authority (Let's Encrypt) that it indeed \"owns\" and controls that domain. To do that, and to accommodate different application needs, there are several ways it can do it. Some popular ways are: Modify some DNS records. For this, the renewal program needs to support the APIs of the DNS provider, so, depending on the DNS provider you are using, this might or might not be an option. Run as a server (at least during the certificate acquisition process) on the public IP address associated with the domain. As we said above, only one process can be listening on a specific IP and port. This is one of the reasons why it's very useful when the same TLS Termination Proxy also takes care of the certificate renewal process. Otherwise, you might have to stop the TLS Termination Proxy momentarily, start the renewal program to acquire the certificates, then configure them with the TLS Termination Proxy, and then restart the TLS Termination Proxy. This is not ideal, as your app(s) will not be available during the time that the TLS Termination Proxy is off. All this renewal process, while still serving the app, is one of the main reasons why you would want to have a separate system to handle HTTPS with a TLS Termination Proxy instead of just using the TLS certificates with the application server directly (e.g. Uvicorn). Recap¬∂ Having HTTPS is very important, and quite critical in most cases. Most of the effort you as a developer have to put around HTTPS is just about understanding these concepts and how they work. But once you know the basic information of HTTPS for developers you can easily combine and configure different tools to help you manage everything in a simple way. In some of the next chapters, I'll show you several concrete examples of how to set up HTTPS for FastAPI applications. üîí Made with Material for MkDocs Insiders"
  },
  {
    "title": "About FastAPI versions - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/versions/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI About FastAPI versions en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents Pin your fastapi version Available versions About versions Upgrading the FastAPI versions About Starlette About Pydantic FastAPI Learn Deployment About FastAPI versions¬∂ FastAPI is already being used in production in many applications and systems. And the test coverage is kept at 100%. But its development is still moving quickly. New features are added frequently, bugs are fixed regularly, and the code is still continuously improving. That's why the current versions are still 0.x.x, this reflects that each version could potentially have breaking changes. This follows the Semantic Versioning conventions. You can create production applications with FastAPI right now (and you have probably been doing it for some time), you just have to make sure that you use a version that works correctly with the rest of your code. Pin your fastapi version¬∂ The first thing you should do is to \"pin\" the version of FastAPI you are using to the specific latest version that you know works correctly for your application. For example, let's say you are using version 0.45.0 in your app. If you use a requirements.txt file you could specify the version with: fastapi==0.45.0 that would mean that you would use exactly the version 0.45.0. Or you could also pin it with: fastapi>=0.45.0,<0.46.0 that would mean that you would use the versions 0.45.0 or above, but less than 0.46.0, for example, a version 0.45.2 would still be accepted. If you use any other tool to manage your installations, like Poetry, Pipenv, or others, they all have a way that you can use to define specific versions for your packages. Available versions¬∂ You can see the available versions (e.g. to check what is the current latest) in the Release Notes. About versions¬∂ Following the Semantic Versioning conventions, any version below 1.0.0 could potentially add breaking changes. FastAPI also follows the convention that any \"PATCH\" version change is for bug fixes and non-breaking changes. Tip The \"PATCH\" is the last number, for example, in 0.2.3, the PATCH version is 3. So, you should be able to pin to a version like: fastapi>=0.45.0,<0.46.0 Breaking changes and new features are added in \"MINOR\" versions. Tip The \"MINOR\" is the number in the middle, for example, in 0.2.3, the MINOR version is 2. Upgrading the FastAPI versions¬∂ You should add tests for your app. With FastAPI it's very easy (thanks to Starlette), check the docs: Testing After you have tests, then you can upgrade the FastAPI version to a more recent one, and make sure that all your code is working correctly by running your tests. If everything is working, or after you make the necessary changes, and all your tests are passing, then you can pin your fastapi to that new recent version. About Starlette¬∂ You shouldn't pin the version of starlette. Different versions of FastAPI will use a specific newer version of Starlette. So, you can just let FastAPI use the correct Starlette version. About Pydantic¬∂ Pydantic includes the tests for FastAPI with its own tests, so new versions of Pydantic (above 1.0.0) are always compatible with FastAPI. You can pin Pydantic to any version above 1.0.0 that works for you and below 2.0.0. For example: pydantic>=1.2.0,<2.0.0 Made with Material for MkDocs Insiders"
  },
  {
    "title": "Deployment - FastAPI",
    "url": "https://fastapi.tiangolo.com/deployment/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Deployment en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment About FastAPI versions About HTTPS Run a Server Manually - Uvicorn Deployments Concepts Deploy FastAPI on Cloud Providers Server Workers - Gunicorn with Uvicorn FastAPI in Containers - Docker How To - Recipes Table of contents What Does Deployment Mean Deployment Strategies FastAPI Learn Deployment Deployment¬∂ Deploying a FastAPI application is relatively easy. What Does Deployment Mean¬∂ To deploy an application means to perform the necessary steps to make it available to the users. For a web API, it normally involves putting it in a remote machine, with a server program that provides good performance, stability, etc, so that your users can access the application efficiently and without interruptions or problems. This is in contrast to the development stages, where you are constantly changing the code, breaking it and fixing it, stopping and restarting the development server, etc. Deployment Strategies¬∂ There are several ways to do it depending on your specific use case and the tools that you use. You could deploy a server yourself using a combination of tools, you could use a cloud service that does part of the work for you, or other possible options. I will show you some of the main concepts you should probably have in mind when deploying a FastAPI application (although most of it applies to any other type of web application). You will see more details to have in mind and some of the techniques to do it in the next sections. ‚ú® Made with Material for MkDocs Insiders"
  },
  {
    "title": "Concurrency and async / await - FastAPI",
    "url": "https://fastapi.tiangolo.com/async/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Concurrency and async / await en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Deployment How To - Recipes Table of contents In a hurry? Technical Details Asynchronous Code Concurrency and Burgers Concurrent Burgers Parallel Burgers Burger Conclusion Is concurrency better than parallelism? Concurrency + Parallelism: Web + Machine Learning async and await More technical details Write your own async code Other forms of asynchronous code Coroutines Conclusion Very Technical Details Path operation functions Dependencies Sub-dependencies Other utility functions FastAPI Learn Concurrency and async / await¬∂ Details about the async def syntax for path operation functions and some background about asynchronous code, concurrency, and parallelism. In a hurry?¬∂ TL;DR: If you are using third party libraries that tell you to call them with await, like: results = await some\\_library() Then, declare your path operation functions with async def like: @app.get('/') async def read\\_results(): results = await some\\_library() return results Note You can only use await inside of functions created with async def. If you are using a third party library that communicates with something (a database, an API, the file system, etc.) and doesn't have support for using await, (this is currently the case for most database libraries), then declare your path operation functions as normally, with just def, like: @app.get('/') def results(): results = some\\_library() return results If your application (somehow) doesn't have to communicate with anything else and wait for it to respond, use async def. If you just don't know, use normal def. Note: You can mix def and async def in your path operation functions as much as you need and define each one using the best option for you. FastAPI will do the right thing with them. Anyway, in any of the cases above, FastAPI will still work asynchronously and be extremely fast. But by following the steps above, it will be able to do some performance optimizations. Technical Details¬∂ Modern versions of Python have support for \"asynchronous code\" using something called \"coroutines\", with async and await syntax. Let's see that phrase by parts in the sections below: Asynchronous Code async and await Coroutines Asynchronous Code¬∂ Asynchronous code just means that the language üí¨ has a way to tell the computer / program ü§ñ that at some point in the code, it ü§ñ will have to wait for something else to finish somewhere else. Let's say that something else is called \"slow-file\" üìù. So, during that time, the computer can go and do some other work, while \"slow-file\" üìù finishes. Then the computer / program ü§ñ will come back every time it has a chance because it's waiting again, or whenever it ü§ñ finished all the work it had at that point. And it ü§ñ will see if any of the tasks it was waiting for have already finished, doing whatever it had to do. Next, it ü§ñ takes the first task to finish (let's say, our \"slow-file\" üìù) and continues whatever it had to do with it. That \"wait for something else\" normally refers to I/O operations that are relatively \"slow\" (compared to the speed of the processor and the RAM memory), like waiting for: the data from the client to be sent through the network the data sent by your program to be received by the client through the network the contents of a file in the disk to be read by the system and given to your program the contents your program gave to the system to be written to disk a remote API operation a database operation to finish a database query to return the results etc. As the execution time is consumed mostly by waiting for I/O operations, they call them \"I/O bound\" operations. It's called \"asynchronous\" because the computer / program doesn't have to be \"synchronized\" with the slow task, waiting for the exact moment that the task finishes, while doing nothing, to be able to take the task result and continue the work. Instead of that, by being an \"asynchronous\" system, once finished, the task can wait in line a little bit (some microseconds) for the computer / program to finish whatever it went to do, and then come back to take the results and continue working with them. For \"synchronous\" (contrary to \"asynchronous\") they commonly also use the term \"sequential\", because the computer / program follows all the steps in sequence before switching to a different task, even if those steps involve waiting. Concurrency and Burgers¬∂ This idea of asynchronous code described above is also sometimes called \"concurrency\". It is different from \"parallelism\". Concurrency and parallelism both relate to \"different things happening more or less at the same time\". But the details between concurrency and parallelism are quite different. To see the difference, imagine the following story about burgers: Concurrent Burgers¬∂ You go with your crush to get fast food, you stand in line while the cashier takes the orders from the people in front of you. üòç Then it's your turn, you place your order of 2 very fancy burgers for your crush and you. üçîüçî The cashier says something to the cook in the kitchen so they know they have to prepare your burgers (even though they are currently preparing the ones for the previous clients). You pay. üí∏ The cashier gives you the number of your turn. While you are waiting, you go with your crush and pick a table, you sit and talk with your crush for a long time (as your burgers are very fancy and take some time to prepare). As you are sitting at the table with your crush, while you wait for the burgers, you can spend that time admiring how awesome, cute and smart your crush is ‚ú®üòç‚ú®. While waiting and talking to your crush, from time to time, you check the number displayed on the counter to see if it's your turn already. Then at some point, it finally is your turn. You go to the counter, get your burgers and come back to the table. You and your crush eat the burgers and have a nice time. ‚ú® Info Beautiful illustrations by Ketrina Thompson. üé® Imagine you are the computer / program ü§ñ in that story. While you are at the line, you are just idle üò¥, waiting for your turn, not doing anything very \"productive\". But the line is fast because the cashier is only taking the orders (not preparing them), so that's fine. Then, when it's your turn, you do actual \"productive\" work, you process the menu, decide what you want, get your crush's choice, pay, check that you give the correct bill or card, check that you are charged correctly, check that the order has the correct items, etc. But then, even though you still don't have your burgers, your work with the cashier is \"on pause\" ‚è∏, because you have to wait üïô for your burgers to be ready. But as you go away from the counter and sit at the table with a number for your turn, you can switch üîÄ your attention to your crush, and \"work\" ‚èØ ü§ì on that. Then you are again doing something very \"productive\" as is flirting with your crush üòç. Then the cashier üíÅ says \"I'm finished with doing the burgers\" by putting your number on the counter's display, but you don't jump like crazy immediately when the displayed number changes to your turn number. You know no one will steal your burgers because you have the number of your turn, and they have theirs. So you wait for your crush to finish the story (finish the current work ‚èØ / task being processed ü§ì), smile gently and say that you are going for the burgers ‚è∏. Then you go to the counter üîÄ, to the initial task that is now finished ‚èØ, pick the burgers, say thanks and take them to the table. That finishes that step / task of interaction with the counter ‚èπ. That in turn, creates a new task, of \"eating burgers\" üîÄ ‚èØ, but the previous one of \"getting burgers\" is finished ‚èπ. Parallel Burgers¬∂ Now let's imagine these aren't \"Concurrent Burgers\", but \"Parallel Burgers\". You go with your crush to get parallel fast food. You stand in line while several (let's say 8) cashiers that at the same time are cooks take the orders from the people in front of you. Everyone before you is waiting for their burgers to be ready before leaving the counter because each of the 8 cashiers goes and prepares the burger right away before getting the next order. Then it's finally your turn, you place your order of 2 very fancy burgers for your crush and you. You pay üí∏. The cashier goes to the kitchen. You wait, standing in front of the counter üïô, so that no one else takes your burgers before you do, as there are no numbers for turns. As you and your crush are busy not letting anyone get in front of you and take your burgers whenever they arrive, you cannot pay attention to your crush. üòû This is \"synchronous\" work, you are \"synchronized\" with the cashier/cook üë®‚Äçüç≥. You have to wait üïô and be there at the exact moment that the cashier/cook üë®‚Äçüç≥ finishes the burgers and gives them to you, or otherwise, someone else might take them. Then your cashier/cook üë®‚Äçüç≥ finally comes back with your burgers, after a long time waiting üïô there in front of the counter. You take your burgers and go to the table with your crush. You just eat them, and you are done. ‚èπ There was not much talk or flirting as most of the time was spent waiting üïô in front of the counter. üòû Info Beautiful illustrations by Ketrina Thompson. üé® In this scenario of the parallel burgers, you are a computer / program ü§ñ with two processors (you and your crush), both waiting üïô and dedicating their attention ‚èØ to be \"waiting on the counter\" üïô for a long time. The fast food store has 8 processors (cashiers/cooks). While the concurrent burgers store might have had only 2 (one cashier and one cook). But still, the final experience is not the best. üòû This would be the parallel equivalent story for burgers. üçî For a more \"real life\" example of this, imagine a bank. Up to recently, most of the banks had multiple cashiers üë®‚Äçüíºüë®‚Äçüíºüë®‚Äçüíºüë®‚Äçüíº and a big line üïôüïôüïôüïôüïôüïôüïôüïô. All of the cashiers doing all the work with one client after the other üë®‚Äçüíº‚èØ. And you have to wait üïô in the line for a long time or you lose your turn. You probably wouldn't want to take your crush üòç with you to do errands at the bank üè¶. Burger Conclusion¬∂ In this scenario of \"fast food burgers with your crush\", as there is a lot of waiting üïô, it makes a lot more sense to have a concurrent system ‚è∏üîÄ‚èØ. This is the case for most of the web applications. Many, many users, but your server is waiting üïô for their not-so-good connection to send their requests. And then waiting üïô again for the responses to come back. This \"waiting\" üïô is measured in microseconds, but still, summing it all, it's a lot of waiting in the end. That's why it makes a lot of sense to use asynchronous ‚è∏üîÄ‚èØ code for web APIs. This kind of asynchronicity is what made NodeJS popular (even though NodeJS is not parallel) and that's the strength of Go as a programming language. And that's the same level of performance you get with FastAPI. And as you can have parallelism and asynchronicity at the same time, you get higher performance than most of the tested NodeJS frameworks and on par with Go, which is a compiled language closer to C (all thanks to Starlette). Is concurrency better than parallelism?¬∂ Nope! That's not the moral of the story. Concurrency is different than parallelism. And it is better on specific scenarios that involve a lot of waiting. Because of that, it generally is a lot better than parallelism for web application development. But not for everything. So, to balance that out, imagine the following short story: You have to clean a big, dirty house. Yep, that's the whole story. There's no waiting üïô anywhere, just a lot of work to be done, on multiple places of the house. You could have turns as in the burgers example, first the living room, then the kitchen, but as you are not waiting üïô for anything, just cleaning and cleaning, the turns wouldn't affect anything. It would take the same amount of time to finish with or without turns (concurrency) and you would have done the same amount of work. But in this case, if you could bring the 8 ex-cashier/cooks/now-cleaners, and each one of them (plus you) could take a zone of the house to clean it, you could do all the work in parallel, with the extra help, and finish much sooner. In this scenario, each one of the cleaners (including you) would be a processor, doing their part of the job. And as most of the execution time is taken by actual work (instead of waiting), and the work in a computer is done by a CPU, they call these problems \"CPU bound\". Common examples of CPU bound operations are things that require complex math processing. For example: Audio or image processing. Computer vision: an image is composed of millions of pixels, each pixel has 3 values / colors, processing that normally requires computing something on those pixels, all at the same time. Machine Learning: it normally requires lots of \"matrix\" and \"vector\" multiplications. Think of a huge spreadsheet with numbers and multiplying all of them together at the same time. Deep Learning: this is a sub-field of Machine Learning, so, the same applies. It's just that there is not a single spreadsheet of numbers to multiply, but a huge set of them, and in many cases, you use a special processor to build and / or use those models. Concurrency + Parallelism: Web + Machine Learning¬∂ With FastAPI you can take the advantage of concurrency that is very common for web development (the same main attraction of NodeJS). But you can also exploit the benefits of parallelism and multiprocessing (having multiple processes running in parallel) for CPU bound workloads like those in Machine Learning systems. That, plus the simple fact that Python is the main language for Data Science, Machine Learning and especially Deep Learning, make FastAPI a very good match for Data Science / Machine Learning web APIs and applications (among many others). To see how to achieve this parallelism in production see the section about Deployment. async and await¬∂ Modern versions of Python have a very intuitive way to define asynchronous code. This makes it look just like normal \"sequential\" code and do the \"awaiting\" for you at the right moments. When there is an operation that will require waiting before giving the results and has support for these new Python features, you can code it like: burgers = await get\\_burgers(2) The key here is the await. It tells Python that it has to wait ‚è∏ for get\\_burgers(2) to finish doing its thing üïô before storing the results in burgers. With that, Python will know that it can go and do something else üîÄ ‚èØ in the meanwhile (like receiving another request). For await to work, it has to be inside a function that supports this asynchronicity. To do that, you just declare it with async def: async def get\\_burgers(number: int): # Do some asynchronous stuff to create the burgers return burgers ...instead of def: # This is not asynchronous def get\\_sequential\\_burgers(number: int): # Do some sequential stuff to create the burgers return burgers With async def, Python knows that, inside that function, it has to be aware of await expressions, and that it can \"pause\" ‚è∏ the execution of that function and go do something else üîÄ before coming back. When you want to call an async def function, you have to \"await\" it. So, this won't work: # This won't work, because get\\_burgers was defined with: async def burgers = get\\_burgers(2) So, if you are using a library that tells you that you can call it with await, you need to create the path operation functions that uses it with async def, like in: @app.get('/burgers') async def read\\_burgers(): burgers = await get\\_burgers(2) return burgers More technical details¬∂ You might have noticed that await can only be used inside of functions defined with async def. But at the same time, functions defined with async def have to be \"awaited\". So, functions with async def can only be called inside of functions defined with async def too. So, about the egg and the chicken, how do you call the first async function? If you are working with FastAPI you don't have to worry about that, because that \"first\" function will be your path operation function, and FastAPI will know how to do the right thing. But if you want to use async / await without FastAPI, you can do it as well. Write your own async code¬∂ Starlette (and FastAPI) are based on AnyIO, which makes it compatible with both Python's standard library asyncio and Trio. In particular, you can directly use AnyIO for your advanced concurrency use cases that require more advanced patterns in your own code. And even if you were not using FastAPI, you could also write your own async applications with AnyIO to be highly compatible and get its benefits (e.g. structured concurrency). Other forms of asynchronous code¬∂ This style of using async and await is relatively new in the language. But it makes working with asynchronous code a lot easier. This same syntax (or almost identical) was also included recently in modern versions of JavaScript (in Browser and NodeJS). But before that, handling asynchronous code was quite more complex and difficult. In previous versions of Python, you could have used threads or Gevent. But the code is way more complex to understand, debug, and think about. In previous versions of NodeJS / Browser JavaScript, you would have used \"callbacks\". Which leads to callback hell. Coroutines¬∂ Coroutine is just the very fancy term for the thing returned by an async def function. Python knows that it is something like a function that it can start and that it will end at some point, but that it might be paused ‚è∏ internally too, whenever there is an await inside of it. But all this functionality of using asynchronous code with async and await is many times summarized as using \"coroutines\". It is comparable to the main key feature of Go, the \"Goroutines\". Conclusion¬∂ Let's see the same phrase from above: Modern versions of Python have support for \"asynchronous code\" using something called \"coroutines\", with async and await syntax. That should make more sense now. ‚ú® All that is what powers FastAPI (through Starlette) and what makes it have such an impressive performance. Very Technical Details¬∂ Warning You can probably skip this. These are very technical details of how FastAPI works underneath. If you have quite some technical knowledge (co-routines, threads, blocking, etc.) and are curious about how FastAPI handles async def vs normal def, go ahead. Path operation functions¬∂ When you declare a path operation function with normal def instead of async def, it is run in an external threadpool that is then awaited, instead of being called directly (as it would block the server). If you are coming from another async framework that does not work in the way described above and you are used to defining trivial compute-only path operation functions with plain def for a tiny performance gain (about 100 nanoseconds), please note that in FastAPI the effect would be quite opposite. In these cases, it's better to use async def unless your path operation functions use code that performs blocking I/O. Still, in both situations, chances are that FastAPI will still be faster than (or at least comparable to) your previous framework. Dependencies¬∂ The same applies for dependencies. If a dependency is a standard def function instead of async def, it is run in the external threadpool. Sub-dependencies¬∂ You can have multiple dependencies and sub-dependencies requiring each other (as parameters of the function definitions), some of them might be created with async def and some with normal def. It would still work, and the ones created with normal def would be called on an external thread (from the threadpool) instead of being \"awaited\". Other utility functions¬∂ Any other utility function that you call directly can be created with normal def or async def and FastAPI won't affect the way you call it. This is in contrast to the functions that FastAPI calls for you: path operation functions and dependencies. If your utility function is a normal function with def, it will be called directly (as you write it in your code), not in a threadpool, if the function is created with async def then you should await for that function when you call it in your code. Again, these are very technical details that would probably be useful if you came searching for them. Otherwise, you should be good with the guidelines from the section above: In a hurry?. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Generate Clients - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/generate-clients/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Generate Clients en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents OpenAPI Client Generators Client and SDK Generators - Sponsor Generate a TypeScript Frontend Client API Docs Generate a TypeScript Client Install openapi-typescript-codegen Generate Client Code Try Out the Client Code FastAPI App with Tags Generate a TypeScript Client with Tags Client Method Names Custom Operation IDs and Better Method Names Custom Generate Unique ID Function Generate a TypeScript Client with Custom Operation IDs Preprocess the OpenAPI Specification for the Client Generator Generate a TypeScript Client with the Preprocessed OpenAPI Benefits FastAPI Learn Advanced User Guide Generate Clients¬∂ As FastAPI is based on the OpenAPI specification, you get automatic compatibility with many tools, including the automatic API docs (provided by Swagger UI). One particular advantage that is not necessarily obvious is that you can generate clients (sometimes called SDKs ) for your API, for many different programming languages. OpenAPI Client Generators¬∂ There are many tools to generate clients from OpenAPI. A common tool is OpenAPI Generator. If you are building a frontend, a very interesting alternative is openapi-typescript-codegen. Client and SDK Generators - Sponsor¬∂ There are also some company-backed Client and SDK generators based on OpenAPI (FastAPI), in some cases they can offer you additional features on top of high-quality generated SDKs/clients. Some of them also ‚ú® sponsor FastAPI ‚ú®, this ensures the continued and healthy development of FastAPI and its ecosystem. And it shows their true commitment to FastAPI and its community (you), as they not only want to provide you a good service but also want to make sure you have a good and healthy framework, FastAPI. üôá For example, you might want to try Speakeasy. There are also several other companies offering similar services that you can search and find online. ü§ì Generate a TypeScript Frontend Client¬∂ Let's start with a simple FastAPI application: Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str price: float class ResponseMessage(BaseModel): message: str @app.post(\"/items/\", response\\_model=ResponseMessage) async def create\\_item(item: Item): return {\"message\": \"item received\"} @app.get(\"/items/\", response\\_model=list\\[Item\\]) async def get\\_items(): return \\[ {\"name\": \"Plumbus\", \"price\": 3}, {\"name\": \"Portal Gun\", \"price\": 9001}, \\] Notice that the path operations define the models they use for request payload and response payload, using the models Item and ResponseMessage. API Docs¬∂ If you go to the API docs, you will see that it has the schemas for the data to be sent in requests and received in responses: You can see those schemas because they were declared with the models in the app. That information is available in the app's OpenAPI schema, and then shown in the API docs (by Swagger UI). And that same information from the models that is included in OpenAPI is what can be used to generate the client code. Generate a TypeScript Client¬∂ Now that we have the app with the models, we can generate the client code for the frontend. Install openapi-typescript-codegen¬∂ You can install openapi-typescript-codegen in your frontend code with: Generate Client Code¬∂ To generate the client code you can use the command line application openapi that would now be installed. Because it is installed in the local project, you probably wouldn't be able to call that command directly, but you would put it on your package.json file. It could look like this: { \"name\": \"frontend-app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"generate-client\": \"openapi --input http://localhost:8000/openapi.json --output ./src/client --client axios --useOptions --useUnionTypes\" }, \"author\": \"\", \"license\": \"\", \"devDependencies\": { \"openapi-typescript-codegen\": \"^0.20.1\", \"typescript\": \"^4.6.2\" } } After having that NPM generate-client script there, you can run it with: That command will generate code in ./src/client and will use axios (the frontend HTTP library) internally. Try Out the Client Code¬∂ Now you can import and use the client code, it could look like this, notice that you get autocompletion for the methods: You will also get autocompletion for the payload to send: Tip Notice the autocompletion for name and price, that was defined in the FastAPI application, in the Item model. You will have inline errors for the data that you send: The response object will also have autocompletion: FastAPI App with Tags¬∂ In many cases your FastAPI app will be bigger, and you will probably use tags to separate different groups of path operations. For example, you could have a section for items and another section for users, and they could be separated by tags: Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str price: float class ResponseMessage(BaseModel): message: str class User(BaseModel): username: str email: str @app.post(\"/items/\", response\\_model=ResponseMessage, tags=\\[\"items\"\\]) async def create\\_item(item: Item): return {\"message\": \"Item received\"} @app.get(\"/items/\", response\\_model=list\\[Item\\], tags=\\[\"items\"\\]) async def get\\_items(): return \\[ {\"name\": \"Plumbus\", \"price\": 3}, {\"name\": \"Portal Gun\", \"price\": 9001}, \\] @app.post(\"/users/\", response\\_model=ResponseMessage, tags=\\[\"users\"\\]) async def create\\_user(user: User): return {\"message\": \"User received\"} Generate a TypeScript Client with Tags¬∂ If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags. This way you will be able to have things ordered and grouped correctly for the client code: In this case you have: ItemsService UsersService Client Method Names¬∂ Right now the generated method names like createItemItemsPost don't look very clean: ItemsService.createItemItemsPost({name: \"Plumbus\", price: 5}) ...that's because the client generator uses the OpenAPI internal operation ID for each path operation. OpenAPI requires that each operation ID is unique across all the path operations, so FastAPI uses the function name, the path, and the HTTP method/operation to generate that operation ID, because that way it can make sure that the operation IDs are unique. But I'll show you how to improve that next. ü§ì Custom Operation IDs and Better Method Names¬∂ You can modify the way these operation IDs are generated to make them simpler and have simpler method names in the clients. In this case you will have to ensure that each operation ID is unique in some other way. For example, you could make sure that each path operation has a tag, and then generate the operation ID based on the tag and the path operation name (the function name). Custom Generate Unique ID Function¬∂ FastAPI uses a unique ID for each path operation, it is used for the operation ID and also for the names of any needed custom models, for requests or responses. You can customize that function. It takes an APIRoute and outputs a string. For example, here it is using the first tag (you will probably have only one tag) and the path operation name (the function name). You can then pass that custom function to FastAPI as the generate\\_unique\\_id\\_function parameter: Python 3.9+ Python 3.8+ from fastapi import FastAPI from fastapi.routing import APIRoute from pydantic import BaseModel def custom\\_generate\\_unique\\_id(route: APIRoute): return f\"{route.tags\\[0\\]}-{route.name}\" app = FastAPI(generate\\_unique\\_id\\_function=custom\\_generate\\_unique\\_id) class Item(BaseModel): name: str price: float class ResponseMessage(BaseModel): message: str class User(BaseModel): username: str email: str @app.post(\"/items/\", response\\_model=ResponseMessage, tags=\\[\"items\"\\]) async def create\\_item(item: Item): return {\"message\": \"Item received\"} @app.get(\"/items/\", response\\_model=list\\[Item\\], tags=\\[\"items\"\\]) async def get\\_items(): return \\[ {\"name\": \"Plumbus\", \"price\": 3}, {\"name\": \"Portal Gun\", \"price\": 9001}, \\] @app.post(\"/users/\", response\\_model=ResponseMessage, tags=\\[\"users\"\\]) async def create\\_user(user: User): return {\"message\": \"User received\"} Generate a TypeScript Client with Custom Operation IDs¬∂ Now if you generate the client again, you will see that it has the improved method names: As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation. Preprocess the OpenAPI Specification for the Client Generator¬∂ The generated code still has some duplicated information. We already know that this method is related to the items because that word is in the ItemsService (taken from the tag), but we still have the tag name prefixed in the method name too. üòï We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are unique. But for the generated client we could modify the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and cleaner. We could download the OpenAPI JSON to a file openapi.json and then we could remove that prefixed tag with a script like this: Python Node.js import json from pathlib import Path file\\_path = Path(\"./openapi.json\") openapi\\_content = json.loads(file\\_path.read\\_text()) for path\\_data in openapi\\_content\\[\"paths\"\\].values(): for operation in path\\_data.values(): tag = operation\\[\"tags\"\\]\\[0\\] operation\\_id = operation\\[\"operationId\"\\] to\\_remove = f\"{tag}-\" new\\_operation\\_id = operation\\_id\\[len(to\\_remove) :\\] operation\\[\"operationId\"\\] = new\\_operation\\_id file\\_path.write\\_text(json.dumps(openapi\\_content)) With that, the operation IDs would be renamed from things like items-get\\_items to just get\\_items, that way the client generator can generate simpler method names. Generate a TypeScript Client with the Preprocessed OpenAPI¬∂ Now as the end result is in a file openapi.json, you would modify the package.json to use that local file, for example: { \"name\": \"frontend-app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"generate-client\": \"openapi --input ./openapi.json --output ./src/client --client axios --useOptions --useUnionTypes\" }, \"author\": \"\", \"license\": \"\", \"devDependencies\": { \"openapi-typescript-codegen\": \"^0.20.1\", \"typescript\": \"^4.6.2\" } } After generating the new client, you would now have clean method names, with all the autocompletion, inline errors, etc: Benefits¬∂ When using the automatically generated clients you would autocompletion for: Methods. Request payloads in the body, query parameters, etc. Response payloads. You would also have inline errors for everything. And whenever you update the backend code, and regenerate the frontend, it would have any new path operations available as methods, the old ones removed, and any other change would be reflected on the generated code. ü§ì This also means that if something changed it will be reflected on the client code automatically. And if you build the client it will error out if you have any mismatch in the data used. So, you would detect many errors very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. ‚ú® Made with Material for MkDocs Insiders"
  },
  {
    "title": "Including WSGI - Flask, Django, others - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/wsgi/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Including WSGI - Flask, Django, others en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Using WSGIMiddleware Check it FastAPI Learn Advanced User Guide Including WSGI - Flask, Django, others¬∂ You can mount WSGI applications as you saw with Sub Applications - Mounts, Behind a Proxy. For that, you can use the WSGIMiddleware and use it to wrap your WSGI application, for example, Flask, Django, etc. Using WSGIMiddleware¬∂ You need to import WSGIMiddleware. Then wrap the WSGI (e.g. Flask) app with the middleware. And then mount that under a path. from fastapi import FastAPI from fastapi.middleware.wsgi import WSGIMiddleware from flask import Flask, request from markupsafe import escape flask\\_app = Flask(\\_\\_name\\_\\_) @flask\\_app.route(\"/\") def flask\\_main(): name = request.args.get(\"name\", \"World\") return f\"Hello, {escape(name)} from Flask!\" app = FastAPI() @app.get(\"/v2\") def read\\_main(): return {\"message\": \"Hello World\"} app.mount(\"/v1\", WSGIMiddleware(flask\\_app)) Check it¬∂ Now, every request under the path /v1/ will be handled by the Flask application. And the rest will be handled by FastAPI. If you run it with Uvicorn and go to http://localhost:8000/v1/ you will see the response from Flask: Hello, World from Flask! And if you go to http://localhost:8000/v2 you will see the response from FastAPI: { \"message\": \"Hello World\" } Made with Material for MkDocs Insiders"
  },
  {
    "title": "Settings and Environment Variables - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/settings/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Settings and Environment Variables en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Environment Variables Read env vars in Python Types and validation Pydantic Settings Install pydantic-settings Create the Settings object Use the settings Run the server Settings in another module Settings in a dependency The config file The main app file Settings and testing Reading a .env file The .env file Read settings from .env Creating the Settings only once with lru\\_cache lru\\_cache Technical Details Recap FastAPI Learn Advanced User Guide Settings and Environment Variables¬∂ In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc. Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets. For this reason it's common to provide them in environment variables that are read by the application. Environment Variables¬∂ Tip If you already know what \"environment variables\" are and how to use them, feel free to skip to the next section below. An environment variable (also known as \"env var\") is a variable that lives outside of the Python code, in the operating system, and could be read by your Python code (or by other programs as well). You can create and use environment variables in the shell, without needing Python: Linux, macOS, Windows Bash Windows PowerShell fast ‚Üí üí¨ You could create an env var MY\\_NAME with Read env vars in Python¬∂ You could also create environment variables outside of Python, in the terminal (or with any other method), and then read them in Python. For example you could have a file main.py with: import os name = os.getenv(\"MY\\_NAME\", \"World\") print(f\"Hello {name} from Python\") Tip The second argument to os.getenv() is the default value to return. If not provided, it's None by default, here we provide \"World\" as the default value to use. Then you could call that Python program: As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to git) with the rest of the files, it's common to use them for configurations or settings. You can also create an environment variable only for a specific program invocation, that is only available to that program, and only for its duration. To do that, create it right before the program itself, on the same line: Tip You can read more about it at The Twelve-Factor App: Config. Types and validation¬∂ These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS). That means that any value read in Python from an environment variable will be a str, and any conversion to a different type or validation has to be done in code. Pydantic Settings¬∂ Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with Pydantic: Settings management. Install pydantic-settings¬∂ First, install the pydantic-settings package: It also comes included when you install the all extras with: Info In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality. Create the Settings object¬∂ Import BaseSettings from Pydantic and create a sub-class, very much like with a Pydantic model. The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values. You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with Field(). Pydantic v2 Pydantic v1 from fastapi import FastAPI from pydantic\\_settings import BaseSettings class Settings(BaseSettings): app\\_name: str = \"Awesome API\" admin\\_email: str items\\_per\\_user: int = 50 settings = Settings() app = FastAPI() @app.get(\"/info\") async def info(): return { \"app\\_name\": settings.app\\_name, \"admin\\_email\": settings.admin\\_email, \"items\\_per\\_user\": settings.items\\_per\\_user, } Tip If you want something quick to copy and paste, don't use this example, use the last one below. Then, when you create an instance of that Settings class (in this case, in the settings object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable APP\\_NAME will still be read for the attribute app\\_name. Next it will convert and validate the data. So, when you use that settings object, you will have data of the types you declared (e.g. items\\_per\\_user will be an int). Use the settings¬∂ Then you can use the new settings object in your application: from fastapi import FastAPI from pydantic\\_settings import BaseSettings class Settings(BaseSettings): app\\_name: str = \"Awesome API\" admin\\_email: str items\\_per\\_user: int = 50 settings = Settings() app = FastAPI() @app.get(\"/info\") async def info(): return { \"app\\_name\": settings.app\\_name, \"admin\\_email\": settings.admin\\_email, \"items\\_per\\_user\": settings.items\\_per\\_user, } Run the server¬∂ Next, you would run the server passing the configurations as environment variables, for example you could set an ADMIN\\_EMAIL and APP\\_NAME with: Tip To set multiple env vars for a single command just separate them with a space, and put them all before the command. And then the admin\\_email setting would be set to \"deadpool@example.com\". The app\\_name would be \"ChimichangApp\". And the items\\_per\\_user would keep its default value of 50. Settings in another module¬∂ You could put those settings in another module file as you saw in Bigger Applications - Multiple Files. For example, you could have a file config.py with: from pydantic\\_settings import BaseSettings class Settings(BaseSettings): app\\_name: str = \"Awesome API\" admin\\_email: str items\\_per\\_user: int = 50 settings = Settings() And then use it in a file main.py: from fastapi import FastAPI from .config import settings app = FastAPI() @app.get(\"/info\") async def info(): return { \"app\\_name\": settings.app\\_name, \"admin\\_email\": settings.admin\\_email, \"items\\_per\\_user\": settings.items\\_per\\_user, } Tip You would also need a file \\_\\_init\\_\\_.py as you saw on Bigger Applications - Multiple Files. Settings in a dependency¬∂ In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with settings that is used everywhere. This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings. The config file¬∂ Coming from the previous example, your config.py file could look like: from pydantic\\_settings import BaseSettings class Settings(BaseSettings): app\\_name: str = \"Awesome API\" admin\\_email: str items\\_per\\_user: int = 50 Notice that now we don't create a default instance settings = Settings(). The main app file¬∂ Now we create a dependency that returns a new config.Settings(). Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from functools import lru\\_cache from typing import Annotated from fastapi import Depends, FastAPI from .config import Settings app = FastAPI() @lru\\_cache def get\\_settings(): return Settings() @app.get(\"/info\") async def info(settings: Annotated\\[Settings, Depends(get\\_settings)\\]): return { \"app\\_name\": settings.app\\_name, \"admin\\_email\": settings.admin\\_email, \"items\\_per\\_user\": settings.items\\_per\\_user, } Tip We'll discuss the @lru\\_cache in a bit. For now you can assume get\\_settings() is a normal function. And then we can require it from the path operation function as a dependency and use it anywhere we need it. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from functools import lru\\_cache from typing import Annotated from fastapi import Depends, FastAPI from .config import Settings app = FastAPI() @lru\\_cache def get\\_settings(): return Settings() @app.get(\"/info\") async def info(settings: Annotated\\[Settings, Depends(get\\_settings)\\]): return { \"app\\_name\": settings.app\\_name, \"admin\\_email\": settings.admin\\_email, \"items\\_per\\_user\": settings.items\\_per\\_user, } Settings and testing¬∂ Then it would be very easy to provide a different settings object during testing by creating a dependency override for get\\_settings: from fastapi.testclient import TestClient from .config import Settings from .main import app, get\\_settings client = TestClient(app) def get\\_settings\\_override(): return Settings(admin\\_email=\"testing\\_admin@example.com\") app.dependency\\_overrides\\[get\\_settings\\] = get\\_settings\\_override def test\\_app(): response = client.get(\"/info\") data = response.json() assert data == { \"app\\_name\": \"Awesome API\", \"admin\\_email\": \"testing\\_admin@example.com\", \"items\\_per\\_user\": 50, } In the dependency override we set a new value for the admin\\_email when creating the new Settings object, and then we return that new object. Then we can test that it is used. Reading a .env file¬∂ If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables. This practice is common enough that it has a name, these environment variables are commonly placed in a file .env, and the file is called a \"dotenv\". Tip A file starting with a dot (.) is a hidden file in Unix-like systems, like Linux and macOS. But a dotenv file doesn't really have to have that exact filename. Pydantic has support for reading from these types of files using an external library. You can read more at Pydantic Settings: Dotenv (.env) support. Tip For this to work, you need to pip install python-dotenv. The .env file¬∂ You could have a .env file with: ADMIN\\_EMAIL=\"deadpool@example.com\" APP\\_NAME=\"ChimichangApp\" Read settings from .env¬∂ And then update your config.py with: Pydantic v2 Pydantic v1 from pydantic\\_settings import BaseSettings, SettingsConfigDict class Settings(BaseSettings): app\\_name: str = \"Awesome API\" admin\\_email: str items\\_per\\_user: int = 50 model\\_config = SettingsConfigDict(env\\_file=\".env\") Tip The model\\_config attribute is used just for Pydantic configuration. You can read more at Pydantic Model Config. Info In Pydantic version 1 the configuration was done in an internal class Config, in Pydantic version 2 it's done in an attribute model\\_config. This attribute takes a dict, and to get autocompletion and inline errors you can import and use SettingsConfigDict to define that dict. Here we define the config env\\_file inside of your Pydantic Settings class, and set the value to the filename with the dotenv file we want to use. Creating the Settings only once with lru\\_cache¬∂ Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then re-use the same settings object, instead of reading it for each request. But every time we do: Settings() a new Settings object would be created, and at creation it would read the .env file again. If the dependency function was just like: def get\\_settings(): return Settings() we would create that object for each request, and we would be reading the .env file for each request. ‚ö†Ô∏è But as we are using the @lru\\_cache decorator on top, the Settings object will be created only once, the first time it's called. ‚úîÔ∏è Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from functools import lru\\_cache from fastapi import Depends, FastAPI from typing\\_extensions import Annotated from . import config app = FastAPI() @lru\\_cache def get\\_settings(): return config.Settings() @app.get(\"/info\") async def info(settings: Annotated\\[config.Settings, Depends(get\\_settings)\\]): return { \"app\\_name\": settings.app\\_name, \"admin\\_email\": settings.admin\\_email, \"items\\_per\\_user\": settings.items\\_per\\_user, } Then for any subsequent calls of get\\_settings() in the dependencies for the next requests, instead of executing the internal code of get\\_settings() and creating a new Settings object, it will return the same object that was returned on the first call, again and again. lru\\_cache Technical Details¬∂ @lru\\_cache modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time. So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments. For example, if you have a function: @lru\\_cache def say\\_hi(name: str, salutation: str = \"Ms.\"): return f\"Hello {salutation} {name}\" your program could execute like this: In the case of our dependency get\\_settings(), the function doesn't even take any arguments, so it always returns the same value. That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing. @lru\\_cache is part of functools which is part of Python's standard library, you can read more about it in the Python docs for @lru\\_cache. Recap¬∂ You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models. By using a dependency you can simplify testing. You can use .env files with it. Using @lru\\_cache lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing. Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI Webhooks - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/openapi-webhooks/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI OpenAPI Webhooks en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Webhooks steps Documenting webhooks with FastAPI and OpenAPI An app with webhooks Check the docs FastAPI Learn Advanced User Guide OpenAPI Webhooks¬∂ There are cases where you want to tell your API users that your app could call their app (sending a request) with some data, normally to notify of some type of event. This means that instead of the normal process of your users sending requests to your API, it's your API (or your app) that could send requests to their system (to their API, their app). This is normally called a webhook. Webhooks steps¬∂ The process normally is that you define in your code what is the message that you will send, the body of the request. You also define in some way at which moments your app will send those requests or events. And your users define in some way (for example in a web dashboard somewhere) the URL where your app should send those requests. All the logic about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in your own code. Documenting webhooks with FastAPI and OpenAPI¬∂ With FastAPI, using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g. POST, PUT, etc.) and the request bodies that your app would send. This can make it a lot easier for your users to implement their APIs to receive your webhook requests, they might even be able to autogenerate some of their own API code. Info Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above. An app with webhooks¬∂ When you create a FastAPI application, there is a webhooks attribute that you can use to define webhooks, the same way you would define path operations, for example with @app.webhooks.post(). from datetime import datetime from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Subscription(BaseModel): username: str monthly\\_fee: float start\\_date: datetime @app.webhooks.post(\"new-subscription\") def new\\_subscription(body: Subscription): \"\"\" When a new user subscribes to your service we'll send you a POST request with this data to the URL that you register for the event \\`new-subscription\\` in the dashboard. \"\"\" @app.get(\"/users/\") def read\\_users(): return \\[\"Rick\", \"Morty\"\\] The webhooks that you define will end up in the OpenAPI schema and the automatic docs UI. Info The app.webhooks object is actually just an APIRouter, the same type you would use when structuring your app with multiple files. Notice that with webhooks you are actually not declaring a path (like /items/), the text you pass there is just an identifier of the webhook (the name of the event), for example in @app.webhooks.post(\"new-subscription\"), the webhook name is new-subscription. This is because it is expected that your users would define the actual URL path where they want to receive the webhook request in some other way (e.g. a web dashboard). Check the docs¬∂ Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs. You will see your docs have the normal path operations and now also some webhooks: Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI Callbacks - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/openapi-callbacks/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI OpenAPI Callbacks en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents An app with callbacks The normal FastAPI app Documenting the callback Write the callback documentation code Create a callback APIRouter Create the callback path operation The callback path expression Add the callback router Check the docs FastAPI Learn Advanced User Guide OpenAPI Callbacks¬∂ You could create an API with a path operation that could trigger a request to an external API created by someone else (probably the same developer that would be using your API). The process that happens when your API app calls the external API is named a \"callback\". Because the software that the external developer wrote sends a request to your API and then your API calls back, sending a request to an external API (that was probably created by the same developer). In this case, you could want to document how that external API should look like. What path operation it should have, what body it should expect, what response it should return, etc. An app with callbacks¬∂ Let's see all this with an example. Imagine you develop an app that allows creating invoices. These invoices will have an id, title (optional), customer, and total. The user of your API (an external developer) will create an invoice in your API with a POST request. Then your API will (let's imagine): Send the invoice to some customer of the external developer. Collect the money. Send a notification back to the API user (the external developer). This will be done by sending a POST request (from your API) to some external API provided by that external developer (this is the \"callback\"). The normal FastAPI app¬∂ Let's first see how the normal API app would look like before adding the callback. It will have a path operation that will receive an Invoice body, and a query parameter callback\\_url that will contain the URL for the callback. This part is pretty normal, most of the code is probably already familiar to you: from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union\\[str, None\\] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices\\_callback\\_router = APIRouter() @invoices\\_callback\\_router.post( \"{$callback\\_url}/invoices/{$request.body.id}\", response\\_model=InvoiceEventReceived ) def invoice\\_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices\\_callback\\_router.routes) def create\\_invoice(invoice: Invoice, callback\\_url: Union\\[HttpUrl, None\\] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: \\* Send the invoice to the client. \\* Collect the money from the client. \\* Send a notification back to the API user (the external developer), as a callback. \\* At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} Tip The callback\\_url query parameter uses a Pydantic URL type. The only new thing is the callbacks=messages\\_callback\\_router.routes as an argument to the path operation decorator. We'll see what that is next. Documenting the callback¬∂ The actual callback code will depend heavily on your own API app. And it will probably vary a lot from one app to the next. It could be just one or two lines of code, like: callback\\_url = \"https://example.com/api/v1/invoices/events/\" httpx.post(callback\\_url, json={\"description\": \"Invoice paid\", \"paid\": True}) But possibly the most important part of the callback is making sure that your API user (the external developer) implements the external API correctly, according to the data that your API is going to send in the request body of the callback, etc. So, what we will do next is add the code to document how that external API should look like to receive the callback from your API. That documentation will show up in the Swagger UI at /docs in your API, and it will let external developers know how to build the external API. This example doesn't implement the callback itself (that could be just a line of code), only the documentation part. Tip The actual callback is just an HTTP request. When implementing the callback yourself, you could use something like HTTPX or Requests. Write the callback documentation code¬∂ This code won't be executed in your app, we only need it to document how that external API should look like. But, you already know how to easily create automatic documentation for an API with FastAPI. So we are going to use that same knowledge to document how the external API should look like... by creating the path operation(s) that the external API should implement (the ones your API will call). Tip When writing the code to document a callback, it might be useful to imagine that you are that external developer. And that you are currently implementing the external API, not your API. Temporarily adopting this point of view (of the external developer) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that external API. Create a callback APIRouter¬∂ First create a new APIRouter that will contain one or more callbacks. from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union\\[str, None\\] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices\\_callback\\_router = APIRouter() @invoices\\_callback\\_router.post( \"{$callback\\_url}/invoices/{$request.body.id}\", response\\_model=InvoiceEventReceived ) def invoice\\_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices\\_callback\\_router.routes) def create\\_invoice(invoice: Invoice, callback\\_url: Union\\[HttpUrl, None\\] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: \\* Send the invoice to the client. \\* Collect the money from the client. \\* Send a notification back to the API user (the external developer), as a callback. \\* At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} Create the callback path operation¬∂ To create the callback path operation use the same APIRouter you created above. It should look just like a normal FastAPI path operation: It should probably have a declaration of the body it should receive, e.g. body: InvoiceEvent. And it could also have a declaration of the response it should return, e.g. response\\_model=InvoiceEventReceived. from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union\\[str, None\\] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices\\_callback\\_router = APIRouter() @invoices\\_callback\\_router.post( \"{$callback\\_url}/invoices/{$request.body.id}\", response\\_model=InvoiceEventReceived ) def invoice\\_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices\\_callback\\_router.routes) def create\\_invoice(invoice: Invoice, callback\\_url: Union\\[HttpUrl, None\\] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: \\* Send the invoice to the client. \\* Collect the money from the client. \\* Send a notification back to the API user (the external developer), as a callback. \\* At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} There are 2 main differences from a normal path operation: It doesn't need to have any actual code, because your app will never call this code. It's only used to document the external API. So, the function could just have pass. The path can contain an OpenAPI 3 expression (see more below) where it can use variables with parameters and parts of the original request sent to your API. The callback path expression¬∂ The callback path can have an OpenAPI 3 expression that can contain parts of the original request sent to your API. In this case, it's the str: \"{$callback\\_url}/invoices/{$request.body.id}\" So, if your API user (the external developer) sends a request to your API to: https://yourapi.com/invoices/?callback\\_url=https://www.external.org/events with a JSON body of: { \"id\": \"2expen51ve\", \"customer\": \"Mr. Richie Rich\", \"total\": \"9999\" } Then your API will process the invoice, and at some point later, send a callback request to the callback\\_url (the external API): https://www.external.org/events/invoices/2expen51ve with a JSON body containing something like: { \"description\": \"Payment celebration\", \"paid\": true } and it would expect a response from that external API with a JSON body like: { \"ok\": true } Tip Notice how the callback URL used contains the URL received as a query parameter in callback\\_url (https://www.external.org/events) and also the invoice id from inside of the JSON body (2expen51ve). Add the callback router¬∂ At this point you have the callback path operation(s) needed (the one(s) that the external developer should implement in the external API) in the callback router you created above. Now use the parameter callbacks in your API's path operation decorator to pass the attribute .routes (that's actually just a list of routes/path operations) from that callback router: from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union\\[str, None\\] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices\\_callback\\_router = APIRouter() @invoices\\_callback\\_router.post( \"{$callback\\_url}/invoices/{$request.body.id}\", response\\_model=InvoiceEventReceived ) def invoice\\_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices\\_callback\\_router.routes) def create\\_invoice(invoice: Invoice, callback\\_url: Union\\[HttpUrl, None\\] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: \\* Send the invoice to the client. \\* Collect the money from the client. \\* Send a notification back to the API user (the external developer), as a callback. \\* At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} Tip Notice that you are not passing the router itself (invoices\\_callback\\_router) to callback=, but the attribute .routes, as in invoices\\_callback\\_router.routes. Check the docs¬∂ Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs. You will see your docs including a \"Callback\" section for your path operation that shows how the external API should look like: Made with Material for MkDocs Insiders"
  },
  {
    "title": "Async Tests - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/async-tests/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Async Tests en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents pytest.mark.anyio HTTPX Example Run it In Detail Other Asynchronous Function Calls FastAPI Learn Advanced User Guide Async Tests¬∂ You have already seen how to test your FastAPI applications using the provided TestClient. Up to now, you have only seen how to write synchronous tests, without using async functions. Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library. Let's look at how we can make that work. pytest.mark.anyio¬∂ If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously. HTTPX¬∂ Even if your FastAPI application uses normal def functions instead of async def, it is still an async application underneath. The TestClient does some magic inside to call the asynchronous FastAPI application in your normal def test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the TestClient inside our test functions. The TestClient is based on HTTPX, and luckily, we can use it directly to test the API. Example¬∂ For a simple example, let's consider a file structure similar to the one described in Bigger Applications and Testing: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test\\_main.py The file main.py would have: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Tomato\"} The file test\\_main.py would have the tests for main.py, it could look like this now: import pytest from httpx import AsyncClient from .main import app @pytest.mark.anyio async def test\\_root(): async with AsyncClient(app=app, base\\_url=\"http://test\") as ac: response = await ac.get(\"/\") assert response.status\\_code == 200 assert response.json() == {\"message\": \"Tomato\"} Run it¬∂ You can run your tests as usual via: In Detail¬∂ The marker @pytest.mark.anyio tells pytest that this test function should be called asynchronously: import pytest from httpx import AsyncClient from .main import app @pytest.mark.anyio async def test\\_root(): async with AsyncClient(app=app, base\\_url=\"http://test\") as ac: response = await ac.get(\"/\") assert response.status\\_code == 200 assert response.json() == {\"message\": \"Tomato\"} Tip Note that the test function is now async def instead of just def as before when using the TestClient. Then we can create an AsyncClient with the app, and send async requests to it, using await. import pytest from httpx import AsyncClient from .main import app @pytest.mark.anyio async def test\\_root(): async with AsyncClient(app=app, base\\_url=\"http://test\") as ac: response = await ac.get(\"/\") assert response.status\\_code == 200 assert response.json() == {\"message\": \"Tomato\"} This is the equivalent to: response = client.get('/') ...that we used to make our requests with the TestClient. Tip Note that we're using async/await with the new AsyncClient - the request is asynchronous. Other Asynchronous Function Calls¬∂ As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code. Tip If you encounter a RuntimeError: Task attached to a different loop when integrating asynchronous function calls in your tests (e.g. when using MongoDB's MotorClient) Remember to instantiate objects that need an event loop only within async functions, e.g. an '@app.on\\_event(\"startup\") callback. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing a Database - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-database/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Testing a Database en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Add tests for the SQL app File structure Create the new database session Create the database Dependency override Test the app FastAPI Learn Advanced User Guide Testing a Database¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1, and SQLAlchemy versions less than 2.0. The new docs will include Pydantic v2 and will use SQLModel (which is also based on SQLAlchemy) once it is updated to use Pydantic v2 as well. You can use the same dependency overrides from Testing Dependencies with Overrides to alter a database for testing. You could want to set up a different database for testing, rollback the data after the tests, pre-fill it with some testing data, etc. The main idea is exactly the same you saw in that previous chapter. Add tests for the SQL app¬∂ Let's update the example from SQL (Relational) Databases to use a testing database. All the app code is the same, you can go back to that chapter check how it was. The only changes here are in the new testing file. Your normal dependency get\\_db() would return a database session. In the test, you could use a dependency override to return your custom database session instead of the one that would be used normally. In this example we'll create a temporary database only for the tests. File structure¬∂ We create a new file at sql\\_app/tests/test\\_sql\\_app.py. So the new file structure looks like: . ‚îî‚îÄ‚îÄ sql\\_app ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îú‚îÄ‚îÄ crud.py ‚îú‚îÄ‚îÄ database.py ‚îú‚îÄ‚îÄ main.py ‚îú‚îÄ‚îÄ models.py ‚îú‚îÄ‚îÄ schemas.py ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ \\_\\_init\\_\\_.py ‚îî‚îÄ‚îÄ test\\_sql\\_app.py Create the new database session¬∂ First, we create a new database session with the new database. We'll use an in-memory database that persists during the tests instead of the local file sql\\_app.db. But the rest of the session code is more or less the same, we just copy it. from fastapi.testclient import TestClient from sqlalchemy import create\\_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get\\_db SQLALCHEMY\\_DATABASE\\_URL = \"sqlite://\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create\\_all(bind=engine) def override\\_get\\_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency\\_overrides\\[get\\_db\\] = override\\_get\\_db client = TestClient(app) def test\\_create\\_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert \"id\" in data user\\_id = data\\[\"id\"\\] response = client.get(f\"/users/{user\\_id}\") assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert data\\[\"id\"\\] == user\\_id Tip You could reduce duplication in that code by putting it in a function and using it from both database.py and tests/test\\_sql\\_app.py. For simplicity and to focus on the specific testing code, we are just copying it. Create the database¬∂ Because now we are going to use a new database in a new file, we need to make sure we create the database with: Base.metadata.create\\_all(bind=engine) That is normally called in main.py, but the line in main.py uses the database file sql\\_app.db, and we need to make sure we create test.db for the tests. So we add that line here, with the new file. from fastapi.testclient import TestClient from sqlalchemy import create\\_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get\\_db SQLALCHEMY\\_DATABASE\\_URL = \"sqlite://\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create\\_all(bind=engine) def override\\_get\\_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency\\_overrides\\[get\\_db\\] = override\\_get\\_db client = TestClient(app) def test\\_create\\_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert \"id\" in data user\\_id = data\\[\"id\"\\] response = client.get(f\"/users/{user\\_id}\") assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert data\\[\"id\"\\] == user\\_id Dependency override¬∂ Now we create the dependency override and add it to the overrides for our app. from fastapi.testclient import TestClient from sqlalchemy import create\\_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get\\_db SQLALCHEMY\\_DATABASE\\_URL = \"sqlite://\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create\\_all(bind=engine) def override\\_get\\_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency\\_overrides\\[get\\_db\\] = override\\_get\\_db client = TestClient(app) def test\\_create\\_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert \"id\" in data user\\_id = data\\[\"id\"\\] response = client.get(f\"/users/{user\\_id}\") assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert data\\[\"id\"\\] == user\\_id Tip The code for override\\_get\\_db() is almost exactly the same as for get\\_db(), but in override\\_get\\_db() we use the TestingSessionLocal for the testing database instead. Test the app¬∂ Then we can just test the app as normally. from fastapi.testclient import TestClient from sqlalchemy import create\\_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get\\_db SQLALCHEMY\\_DATABASE\\_URL = \"sqlite://\" engine = create\\_engine( SQLALCHEMY\\_DATABASE\\_URL, connect\\_args={\"check\\_same\\_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create\\_all(bind=engine) def override\\_get\\_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency\\_overrides\\[get\\_db\\] = override\\_get\\_db client = TestClient(app) def test\\_create\\_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert \"id\" in data user\\_id = data\\[\"id\"\\] response = client.get(f\"/users/{user\\_id}\") assert response.status\\_code == 200, response.text data = response.json() assert data\\[\"email\"\\] == \"deadpool@example.com\" assert data\\[\"id\"\\] == user\\_id And all the modifications we made in the database during the tests will be in the test.db database instead of the main sql\\_app.db. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing Dependencies with Overrides - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-dependencies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Testing Dependencies with Overrides en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Overriding dependencies during testing Use cases: external service Use the app.dependency\\_overrides attribute FastAPI Learn Advanced User Guide Testing Dependencies with Overrides¬∂ Overriding dependencies during testing¬∂ There are some scenarios where you might want to override a dependency during testing. You don't want the original dependency to run (nor any of the sub-dependencies it might have). Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used. Use cases: external service¬∂ An example could be that you have an external authentication provider that you need to call. You send it a token and it returns an authenticated user. This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests. You probably want to test the external provider once, but not necessarily call it for every test that runs. In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests. Use the app.dependency\\_overrides attribute¬∂ For these cases, your FastAPI application has an attribute app.dependency\\_overrides, it is a simple dict. To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function). And then FastAPI will call that override instead of the original dependency. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.testclient import TestClient app = FastAPI() async def common\\_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read\\_items(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return {\"message\": \"Hello Items!\", \"params\": commons} @app.get(\"/users/\") async def read\\_users(commons: Annotated\\[dict, Depends(common\\_parameters)\\]): return {\"message\": \"Hello Users!\", \"params\": commons} client = TestClient(app) async def override\\_dependency(q: str | None = None): return {\"q\": q, \"skip\": 5, \"limit\": 10} app.dependency\\_overrides\\[common\\_parameters\\] = override\\_dependency def test\\_override\\_in\\_items(): response = client.get(\"/items/\") assert response.status\\_code == 200 assert response.json() == { \"message\": \"Hello Items!\", \"params\": {\"q\": None, \"skip\": 5, \"limit\": 10}, } def test\\_override\\_in\\_items\\_with\\_q(): response = client.get(\"/items/?q=foo\") assert response.status\\_code == 200 assert response.json() == { \"message\": \"Hello Items!\", \"params\": {\"q\": \"foo\", \"skip\": 5, \"limit\": 10}, } def test\\_override\\_in\\_items\\_with\\_params(): response = client.get(\"/items/?q=foo&skip=100&limit=200\") assert response.status\\_code == 200 assert response.json() == { \"message\": \"Hello Items!\", \"params\": {\"q\": \"foo\", \"skip\": 5, \"limit\": 10}, } Tip You can set a dependency override for a dependency used anywhere in your FastAPI application. The original dependency could be used in a path operation function, a path operation decorator (when you don't use the return value), a .include\\_router() call, etc. FastAPI will still be able to override it. Then you can reset your overrides (remove them) by setting app.dependency\\_overrides to be an empty dict: app.dependency\\_overrides = {} Tip If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function). Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing WebSockets - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-websockets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Testing WebSockets en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes FastAPI Learn Advanced User Guide Testing WebSockets¬∂ You can use the same TestClient to test WebSockets. For this, you use the TestClient in a with statement, connecting to the WebSocket: from fastapi import FastAPI from fastapi.testclient import TestClient from fastapi.websockets import WebSocket app = FastAPI() @app.get(\"/\") async def read\\_main(): return {\"msg\": \"Hello World\"} @app.websocket(\"/ws\") async def websocket(websocket: WebSocket): await websocket.accept() await websocket.send\\_json({\"msg\": \"Hello WebSocket\"}) await websocket.close() def test\\_read\\_main(): client = TestClient(app) response = client.get(\"/\") assert response.status\\_code == 200 assert response.json() == {\"msg\": \"Hello World\"} def test\\_websocket(): client = TestClient(app) with client.websocket\\_connect(\"/ws\") as websocket: data = websocket.receive\\_json() assert data == {\"msg\": \"Hello WebSocket\"} Note For more details, check Starlette's documentation for testing WebSockets. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing Events: startup - shutdown - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-events/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Testing Events: startup - shutdown en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes FastAPI Learn Advanced User Guide Testing Events: startup - shutdown¬∂ When you need your event handlers (startup and shutdown) to run in your tests, you can use the TestClient with a with statement: from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI() items = {} @app.on\\_event(\"startup\") async def startup\\_event(): items\\[\"foo\"\\] = {\"name\": \"Fighters\"} items\\[\"bar\"\\] = {\"name\": \"Tenders\"} @app.get(\"/items/{item\\_id}\") async def read\\_items(item\\_id: str): return items\\[item\\_id\\] def test\\_read\\_items(): with TestClient(app) as client: response = client.get(\"/items/foo\") assert response.status\\_code == 200 assert response.json() == {\"name\": \"Fighters\"} Made with Material for MkDocs Insiders"
  },
  {
    "title": "Lifespan Events - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/events/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Lifespan Events en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use Case Lifespan Lifespan function Async Context Manager Alternative Events (deprecated) startup event shutdown event startup and shutdown together Technical Details Sub Applications FastAPI Learn Advanced User Guide Lifespan Events¬∂ You can define logic (code) that should be executed before the application starts up. This means that this code will be executed once, before the application starts receiving requests. The same way, you can define logic (code) that should be executed when the application is shutting down. In this case, this code will be executed once, after having handled possibly many requests. Because this code is executed before the application starts taking requests, and right after it finishes handling requests, it covers the whole application lifespan (the word \"lifespan\" will be important in a second üòâ). This can be very useful for setting up resources that you need to use for the whole app, and that are shared among requests, and/or that you need to clean up afterwards. For example, a database connection pool, or loading a shared machine learning model. Use Case¬∂ Let's start with an example use case and then see how to solve it with this. Let's imagine that you have some machine learning models that you want to use to handle requests. ü§ñ The same models are shared among requests, so, it's not one model per request, or one per user or something similar. Let's imagine that loading the model can take quite some time, because it has to read a lot of data from disk. So you don't want to do it for every request. You could load it at the top level of the module/file, but that would also mean that it would load the model even if you are just running a simple automated test, then that test would be slow because it would have to wait for the model to load before being able to run an independent part of the code. That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded. Lifespan¬∂ You can define this startup and shutdown logic using the lifespan parameter of the FastAPI app, and a \"context manager\" (I'll show you what that is in a second). Let's start with an example and then see it in detail. We create an async function lifespan() with yield like this: from contextlib import asynccontextmanager from fastapi import FastAPI def fake\\_answer\\_to\\_everything\\_ml\\_model(x: float): return x \\* 42 ml\\_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml\\_models\\[\"answer\\_to\\_everything\"\\] = fake\\_answer\\_to\\_everything\\_ml\\_model yield # Clean up the ML models and release the resources ml\\_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml\\_models\\[\"answer\\_to\\_everything\"\\](x) return {\"result\": result} Here we are simulating the expensive startup operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the yield. This code will be executed before the application starts taking requests, during the startup. And then, right after the yield, we unload the model. This code will be executed after the application finishes handling requests, right before the shutdown. This could, for example, release resources like memory or a GPU. Tip The shutdown would happen when you are stopping the application. Maybe you need to start a new version, or you just got tired of running it. ü§∑ Lifespan function¬∂ The first thing to notice, is that we are defining an async function with yield. This is very similar to Dependencies with yield. from contextlib import asynccontextmanager from fastapi import FastAPI def fake\\_answer\\_to\\_everything\\_ml\\_model(x: float): return x \\* 42 ml\\_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml\\_models\\[\"answer\\_to\\_everything\"\\] = fake\\_answer\\_to\\_everything\\_ml\\_model yield # Clean up the ML models and release the resources ml\\_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml\\_models\\[\"answer\\_to\\_everything\"\\](x) return {\"result\": result} The first part of the function, before the yield, will be executed before the application starts. And the part after the yield will be executed after the application has finished. Async Context Manager¬∂ If you check, the function is decorated with an @asynccontextmanager. That converts the function into something called an \"async context manager\". from contextlib import asynccontextmanager from fastapi import FastAPI def fake\\_answer\\_to\\_everything\\_ml\\_model(x: float): return x \\* 42 ml\\_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml\\_models\\[\"answer\\_to\\_everything\"\\] = fake\\_answer\\_to\\_everything\\_ml\\_model yield # Clean up the ML models and release the resources ml\\_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml\\_models\\[\"answer\\_to\\_everything\"\\](x) return {\"result\": result} A context manager in Python is something that you can use in a with statement, for example, open() can be used as a context manager: with open(\"file.txt\") as file: file.read() In recent versions of Python, there's also an async context manager. You would use it with async with: async with lifespan(app): await do\\_stuff() When you create a context manager or an async context manager like above, what it does is that, before entering the with block, it will execute the code before the yield, and after exiting the with block, it will execute the code after the yield. In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it. The lifespan parameter of the FastAPI app takes an async context manager, so we can pass our new lifespan async context manager to it. from contextlib import asynccontextmanager from fastapi import FastAPI def fake\\_answer\\_to\\_everything\\_ml\\_model(x: float): return x \\* 42 ml\\_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml\\_models\\[\"answer\\_to\\_everything\"\\] = fake\\_answer\\_to\\_everything\\_ml\\_model yield # Clean up the ML models and release the resources ml\\_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml\\_models\\[\"answer\\_to\\_everything\"\\](x) return {\"result\": result} Alternative Events (deprecated)¬∂ Warning The recommended way to handle the startup and shutdown is using the lifespan parameter of the FastAPI app as described above. You can probably skip this part. There's an alternative way to define this logic to be executed during startup and during shutdown. You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down. These functions can be declared with async def or normal def. startup event¬∂ To add a function that should be run before the application starts, declare it with the event \"startup\": from fastapi import FastAPI app = FastAPI() items = {} @app.on\\_event(\"startup\") async def startup\\_event(): items\\[\"foo\"\\] = {\"name\": \"Fighters\"} items\\[\"bar\"\\] = {\"name\": \"Tenders\"} @app.get(\"/items/{item\\_id}\") async def read\\_items(item\\_id: str): return items\\[item\\_id\\] In this case, the startup event handler function will initialize the items \"database\" (just a dict) with some values. You can add more than one event handler function. And your application won't start receiving requests until all the startup event handlers have completed. shutdown event¬∂ To add a function that should be run when the application is shutting down, declare it with the event \"shutdown\": from fastapi import FastAPI app = FastAPI() @app.on\\_event(\"shutdown\") def shutdown\\_event(): with open(\"log.txt\", mode=\"a\") as log: log.write(\"Application shutdown\") @app.get(\"/items/\") async def read\\_items(): return \\[{\"name\": \"Foo\"}\\] Here, the shutdown event handler function will write a text line \"Application shutdown\" to a file log.txt. Info In the open() function, the mode=\"a\" means \"append\", so, the line will be added after whatever is on that file, without overwriting the previous contents. Tip Notice that in this case we are using a standard Python open() function that interacts with a file. So, it involves I/O (input/output), that requires \"waiting\" for things to be written to disk. But open() doesn't use async and await. So, we declare the event handler function with standard def instead of async def. startup and shutdown together¬∂ There's a high chance that the logic for your startup and shutdown is connected, you might want to start something and then finish it, acquire a resource and then release it, etc. Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks. Because of that, it's now recommended to instead use the lifespan as explained above. Technical Details¬∂ Just a technical detail for the curious nerds. ü§ì Underneath, in the ASGI technical specification, this is part of the Lifespan Protocol, and it defines events called startup and shutdown. Info You can read more about the Starlette lifespan handlers in Starlette's Lifespan' docs. Including how to handle lifespan state that can be used in other areas of your code. Sub Applications¬∂ üö® Have in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for Sub Applications - Mounts. Made with Material for MkDocs Insiders"
  },
  {
    "title": "WebSockets - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/websockets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI WebSockets en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Install WebSockets WebSockets client In production Create a websocket Await for messages and send messages Try it Using Depends and others Try the WebSockets with dependencies Handling disconnections and multiple clients More info FastAPI Learn Advanced User Guide WebSockets¬∂ You can use WebSockets with FastAPI. Install WebSockets¬∂ First you need to install WebSockets: fast ‚Üí WebSockets client¬∂ In production¬∂ In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular. And to communicate using WebSockets with your backend you would probably use your frontend's utilities. Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code. Or you might have any other way to communicate with the WebSocket endpoint. But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string. This, of course, is not optimal and you wouldn't use it for production. In production you would have one of the options above. But it's the simplest way to focus on the server-side of WebSockets and have a working example: from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Send var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws\") async def websocket\\_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text(f\"Message text was: {data}\") Create a websocket¬∂ In your FastAPI application, create a websocket: from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Send var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws\") async def websocket\\_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text(f\"Message text was: {data}\") Technical Details You could also use from starlette.websockets import WebSocket. FastAPI provides the same WebSocket directly just as a convenience for you, the developer. But it comes directly from Starlette. Await for messages and send messages¬∂ In your WebSocket route you can await for messages and send messages. from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Send var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws\") async def websocket\\_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text(f\"Message text was: {data}\") You can receive and send binary, text, and JSON data. Try it¬∂ If your file is named main.py, run your application with: Open your browser at http://127.0.0.1:8000. You will see a simple page like: You can type messages in the input box, and send them: And your FastAPI application with WebSockets will respond back: You can send (and receive) many messages: And all of them will use the same WebSocket connection. Using Depends and others¬∂ In WebSocket endpoints you can import from fastapi and use: Depends Security Cookie Header Path Query They work the same way as for other FastAPI endpoints/path operations: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import ( Cookie, Depends, FastAPI, Query, WebSocket, WebSocketException, status, ) from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Item ID: Token: Connect \\\\\\\\\\\\\\* \\\\\\\\\\\\\\* \\\\\\\\\\\\\\* Message: Send var ws = null; function connect(event) { var itemId = document.getElementById(\"itemId\") var token = document.getElementById(\"token\") ws = new WebSocket(\"ws://localhost:8000/items/\" + itemId.value + \"/ws?token=\" + token.value); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; event.preventDefault() } function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) async def get\\_cookie\\_or\\_token( websocket: WebSocket, session: Annotated\\[str | None, Cookie()\\] = None, token: Annotated\\[str | None, Query()\\] = None, ): if session is None and token is None: raise WebSocketException(code=status.WS\\_1008\\_POLICY\\_VIOLATION) return session or token @app.websocket(\"/items/{item\\_id}/ws\") async def websocket\\_endpoint( \\*, websocket: WebSocket, item\\_id: str, q: int | None = None, cookie\\_or\\_token: Annotated\\[str, Depends(get\\_cookie\\_or\\_token)\\], ): await websocket.accept() while True: data = await websocket.receive\\_text() await websocket.send\\_text( f\"Session cookie or query token value is: {cookie\\_or\\_token}\" ) if q is not None: await websocket.send\\_text(f\"Query parameter q is: {q}\") await websocket.send\\_text(f\"Message text was: {data}, for item ID: {item\\_id}\") Info As this is a WebSocket it doesn't really make sense to raise an HTTPException, instead we raise a WebSocketException. You can use a closing code from the valid codes defined in the specification. Try the WebSockets with dependencies¬∂ If your file is named main.py, run your application with: Open your browser at http://127.0.0.1:8000. There you can set: The \"Item ID\", used in the path. The \"Token\" used as a query parameter. Tip Notice that the query token will be handled by a dependency. With that you can connect the WebSocket and then send and receive messages: Handling disconnections and multiple clients¬∂ When a WebSocket connection is closed, the await websocket.receive\\_text() will raise a WebSocketDisconnect exception, which you can then catch and handle like in this example. Python 3.9+ Python 3.8+ from fastapi import FastAPI, WebSocket, WebSocketDisconnect from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Your ID: -------- Send var client\\_id = Date.now() document.querySelector(\"#ws-id\").textContent = client\\_id; var ws = new WebSocket(\\`ws://localhost:8000/ws/${client\\_id}\\`); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" class ConnectionManager: def \\_\\_init\\_\\_(self): self.active\\_connections: list\\[WebSocket\\] = \\[\\] async def connect(self, websocket: WebSocket): await websocket.accept() self.active\\_connections.append(websocket) def disconnect(self, websocket: WebSocket): self.active\\_connections.remove(websocket) async def send\\_personal\\_message(self, message: str, websocket: WebSocket): await websocket.send\\_text(message) async def broadcast(self, message: str): for connection in self.active\\_connections: await connection.send\\_text(message) manager = ConnectionManager() @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws/{client\\_id}\") async def websocket\\_endpoint(websocket: WebSocket, client\\_id: int): await manager.connect(websocket) try: while True: data = await websocket.receive\\_text() await manager.send\\_personal\\_message(f\"You wrote: {data}\", websocket) await manager.broadcast(f\"Client #{client\\_id} says: {data}\") except WebSocketDisconnect: manager.disconnect(websocket) await manager.broadcast(f\"Client #{client\\_id} left the chat\") To try it out: Open the app with several browser tabs. Write messages from them. Then close one of the tabs. That will raise the WebSocketDisconnect exception, and all the other clients will receive a message like: Client #1596980209979 left the chat Tip The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections. But have in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process. If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check encode/broadcaster. More info¬∂ To learn more about the options, check Starlette's documentation for: The WebSocket class. Class-based WebSocket handling. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Templates - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/templates/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Templates en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Install dependencies Using Jinja2Templates Writing templates Templates and static files More details FastAPI Learn Advanced User Guide Templates¬∂ You can use any template engine you want with FastAPI. A common choice is Jinja2, the same one used by Flask and other tools. There are utilities to configure it easily that you can use directly in your FastAPI application (provided by Starlette). Install dependencies¬∂ Install jinja2: fast ‚Üí Using Jinja2Templates¬∂ Import Jinja2Templates. Create a templates object that you can re-use later. Declare a Request parameter in the path operation that will return a template. Use the templates you created to render and return a TemplateResponse, pass the name of the template, the request object, and a \"context\" dictionary with key-value pairs to be used inside of the Jinja2 template. from fastapi import FastAPI, Request from fastapi.responses import HTMLResponse from fastapi.staticfiles import StaticFiles from fastapi.templating import Jinja2Templates app = FastAPI() app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") templates = Jinja2Templates(directory=\"templates\") @app.get(\"/items/{id}\", response\\_class=HTMLResponse) async def read\\_item(request: Request, id: str): return templates.TemplateResponse( request=request, name=\"item.html\", context={\"id\": id} ) Note Before FastAPI 0.108.0, Starlette 0.29.0, the name was the first parameter. Also, before that, in previous versions, the request object was passed as part of the key-value pairs in the context for Jinja2. Tip By declaring response\\_class=HTMLResponse the docs UI will be able to know that the response will be HTML. Technical Details You could also use from starlette.templating import Jinja2Templates. FastAPI provides the same starlette.templating as fastapi.templating just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with Request and StaticFiles. Writing templates¬∂ Then you can write a template at templates/item.html with: Item Details Item ID: {{ id }} ================= It will show the id taken from the \"context\" dict you passed: {\"request\": request, \"id\": id} Templates and static files¬∂ You can also use url\\_for() inside of the template, and use it, for example, with the StaticFiles you mounted. Item Details Item ID: {{ id }} ================= In this example, it would link to a CSS file at static/styles.css with: h1 { color: green; } And because you are using StaticFiles, that CSS file would be served automatically by your FastAPI application at the URL /static/styles.css. More details¬∂ For more details, including how to test templates, check Starlette's docs on templates. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Behind a Proxy - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/behind-a-proxy/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Behind a Proxy en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Proxy with a stripped path prefix Providing the root\\_path Checking the current root\\_path Setting the root\\_path in the FastAPI app About root\\_path About proxies with a stripped path prefix Testing locally with Traefik Check the responses Check the docs UI Additional servers Disable automatic server from root\\_path Mounting a sub-application FastAPI Learn Advanced User Guide Behind a Proxy¬∂ In some situations, you might need to use a proxy server like Traefik or Nginx with a configuration that adds an extra path prefix that is not seen by your application. In these cases you can use root\\_path to configure your application. The root\\_path is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette). The root\\_path is used to handle these specific cases. And it's also used internally when mounting sub-applications. Proxy with a stripped path prefix¬∂ Having a proxy with a stripped path prefix, in this case, means that you could declare a path at /app in your code, but then, you add a layer on top (the proxy) that would put your FastAPI application under a path like /api/v1. In this case, the original path /app would actually be served at /api/v1/app. Even though all your code is written assuming there's just /app. And the proxy would be \"stripping\" the path prefix on the fly before transmitting the request to Uvicorn, keep your application convinced that it is serving at /app, so that you don't have to update all your code to include the prefix /api/v1. Up to here, everything would work as normally. But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at /openapi.json, instead of /api/v1/openapi.json. So, the frontend (that runs in the browser) would try to reach /openapi.json and wouldn't be able to get the OpenAPI schema. Because we have a proxy with a path prefix of /api/v1 for our app, the frontend needs to fetch the OpenAPI schema at /api/v1/openapi.json. Tip The IP 0.0.0.0 is commonly used to mean that the program listens on all the IPs available in that machine/server. The docs UI would also need the OpenAPI schema to declare that this API server is located at /api/v1 (behind the proxy). For example: { \"openapi\": \"3.1.0\", // More stuff here \"servers\": \\[ { \"url\": \"/api/v1\" } \\], \"paths\": { // More stuff here } } In this example, the \"Proxy\" could be something like Traefik. And the server would be something like Uvicorn, running your FastAPI application. Providing the root\\_path¬∂ To achieve this, you can use the command line option --root-path like: If you use Hypercorn, it also has the option --root-path. Technical Details The ASGI specification defines a root\\_path for this use case. And the --root-path command line option provides that root\\_path. Checking the current root\\_path¬∂ You can get the current root\\_path used by your application for each request, it is part of the scope dictionary (that's part of the ASGI spec). Here we are including it in the message just for demonstration purposes. from fastapi import FastAPI, Request app = FastAPI() @app.get(\"/app\") def read\\_main(request: Request): return {\"message\": \"Hello World\", \"root\\_path\": request.scope.get(\"root\\_path\")} Then, if you start Uvicorn with: The response would be something like: { \"message\": \"Hello World\", \"root\\_path\": \"/api/v1\" } Setting the root\\_path in the FastAPI app¬∂ Alternatively, if you don't have a way to provide a command line option like --root-path or equivalent, you can set the root\\_path parameter when creating your FastAPI app: from fastapi import FastAPI, Request app = FastAPI(root\\_path=\"/api/v1\") @app.get(\"/app\") def read\\_main(request: Request): return {\"message\": \"Hello World\", \"root\\_path\": request.scope.get(\"root\\_path\")} Passing the root\\_path to FastAPI would be the equivalent of passing the --root-path command line option to Uvicorn or Hypercorn. About root\\_path¬∂ Have in mind that the server (Uvicorn) won't use that root\\_path for anything else than passing it to the app. But if you go with your browser to http://127.0.0.1:8000/app you will see the normal response: { \"message\": \"Hello World\", \"root\\_path\": \"/api/v1\" } So, it won't expect to be accessed at http://127.0.0.1:8000/api/v1/app. Uvicorn will expect the proxy to access Uvicorn at http://127.0.0.1:8000/app, and then it would be the proxy's responsibility to add the extra /api/v1 prefix on top. About proxies with a stripped path prefix¬∂ Have in mind that a proxy with stripped path prefix is only one of the ways to configure it. Probably in many cases the default will be that the proxy doesn't have a stripped path prefix. In a case like that (without a stripped path prefix), the proxy would listen on something like https://myawesomeapp.com, and then if the browser goes to https://myawesomeapp.com/api/v1/app and your server (e.g. Uvicorn) listens on http://127.0.0.1:8000 the proxy (without a stripped path prefix) would access Uvicorn at the same path: http://127.0.0.1:8000/api/v1/app. Testing locally with Traefik¬∂ You can easily run the experiment locally with a stripped path prefix using Traefik. Download Traefik, it's a single binary, you can extract the compressed file and run it directly from the terminal. Then create a file traefik.toml with: \\[entryPoints\\] \\[entryPoints.http\\] address = \":9999\" \\[providers\\] \\[providers.file\\] filename = \"routes.toml\" This tells Traefik to listen on port 9999 and to use another file routes.toml. Tip We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (sudo) privileges. Now create that other file routes.toml: \\[http\\] \\[http.middlewares\\] \\[http.middlewares.api-stripprefix.stripPrefix\\] prefixes = \\[\"/api/v1\"\\] \\[http.routers\\] \\[http.routers.app-http\\] entryPoints = \\[\"http\"\\] service = \"app\" rule = \"PathPrefix(\\`/api/v1\\`)\" middlewares = \\[\"api-stripprefix\"\\] \\[http.services\\] \\[http.services.app\\] \\[http.services.app.loadBalancer\\] \\[\\[http.services.app.loadBalancer.servers\\]\\] url = \"http://127.0.0.1:8000\" This file configures Traefik to use the path prefix /api/v1. And then it will redirect its requests to your Uvicorn running on http://127.0.0.1:8000. Now start Traefik: And now start your app with Uvicorn, using the --root-path option: Check the responses¬∂ Now, if you go to the URL with the port for Uvicorn: http://127.0.0.1:8000/app, you will see the normal response: { \"message\": \"Hello World\", \"root\\_path\": \"/api/v1\" } Tip Notice that even though you are accessing it at http://127.0.0.1:8000/app it shows the root\\_path of /api/v1, taken from the option --root-path. And now open the URL with the port for Traefik, including the path prefix: http://127.0.0.1:9999/api/v1/app. We get the same response: { \"message\": \"Hello World\", \"root\\_path\": \"/api/v1\" } but this time at the URL with the prefix path provided by the proxy: /api/v1. Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix /api/v1 is the \"correct\" one. And the version without the path prefix (http://127.0.0.1:8000/app), provided by Uvicorn directly, would be exclusively for the proxy (Traefik) to access it. That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the root\\_path from the option --root-path. Check the docs UI¬∂ But here's the fun part. ‚ú® The \"official\" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy. You can check it at http://127.0.0.1:8000/docs: But if we access the docs UI at the \"official\" URL using the proxy with port 9999, at /api/v1/docs, it works correctly! üéâ You can check it at http://127.0.0.1:9999/api/v1/docs: Right as we wanted it. ‚úîÔ∏è This is because FastAPI uses this root\\_path to create the default server in OpenAPI with the URL provided by root\\_path. Additional servers¬∂ Warning This is a more advanced use case. Feel free to skip it. By default, FastAPI will create a server in the OpenAPI schema with the URL for the root\\_path. But you can also provide other alternative servers, for example if you want the same docs UI to interact with a staging and production environments. If you pass a custom list of servers and there's a root\\_path (because your API lives behind a proxy), FastAPI will insert a \"server\" with this root\\_path at the beginning of the list. For example: from fastapi import FastAPI, Request app = FastAPI( servers=\\[ {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"}, {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"}, \\], root\\_path=\"/api/v1\", ) @app.get(\"/app\") def read\\_main(request: Request): return {\"message\": \"Hello World\", \"root\\_path\": request.scope.get(\"root\\_path\")} Will generate an OpenAPI schema like: { \"openapi\": \"3.1.0\", // More stuff here \"servers\": \\[ { \"url\": \"/api/v1\" }, { \"url\": \"https://stag.example.com\", \"description\": \"Staging environment\" }, { \"url\": \"https://prod.example.com\", \"description\": \"Production environment\" } \\], \"paths\": { // More stuff here } } Tip Notice the auto-generated server with a url value of /api/v1, taken from the root\\_path. In the docs UI at http://127.0.0.1:9999/api/v1/docs it would look like: Tip The docs UI will interact with the server that you select. Disable automatic server from root\\_path¬∂ If you don't want FastAPI to include an automatic server using the root\\_path, you can use the parameter root\\_path\\_in\\_servers=False: from fastapi import FastAPI, Request app = FastAPI( servers=\\[ {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"}, {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"}, \\], root\\_path=\"/api/v1\", root\\_path\\_in\\_servers=False, ) @app.get(\"/app\") def read\\_main(request: Request): return {\"message\": \"Hello World\", \"root\\_path\": request.scope.get(\"root\\_path\")} and then it won't include it in the OpenAPI schema. Mounting a sub-application¬∂ If you need to mount a sub-application (as described in Sub Applications - Mounts) while also using a proxy with root\\_path, you can do it normally, as you would expect. FastAPI will internally use the root\\_path smartly, so it will just work. ‚ú® Made with Material for MkDocs Insiders"
  },
  {
    "title": "Sub Applications - Mounts - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/sub-applications/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Sub Applications - Mounts en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Mounting a FastAPI application Top-level application Sub-application Mount the sub-application Check the automatic API docs Technical Details: root\\_path FastAPI Learn Advanced User Guide Sub Applications - Mounts¬∂ If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and \"mount\" one (or more) sub-application(s). Mounting a FastAPI application¬∂ \"Mounting\" means adding a completely \"independent\" application in a specific path, that then takes care of handling everything under that path, with the path operations declared in that sub-application. Top-level application¬∂ First, create the main, top-level, FastAPI application, and its path operations: from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read\\_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read\\_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi) Sub-application¬∂ Then, create your sub-application, and its path operations. This sub-application is just another standard FastAPI application, but this is the one that will be \"mounted\": from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read\\_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read\\_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi) Mount the sub-application¬∂ In your top-level application, app, mount the sub-application, subapi. In this case, it will be mounted at the path /subapi: from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read\\_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read\\_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi) Check the automatic API docs¬∂ Now, run uvicorn with the main app, if your file is main.py, it would be: And open the docs at http://127.0.0.1:8000/docs. You will see the automatic API docs for the main app, including only its own path operations: And then, open the docs for the sub-application, at http://127.0.0.1:8000/subapi/docs. You will see the automatic API docs for the sub-application, including only its own path operations, all under the correct sub-path prefix /subapi: If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app. Technical Details: root\\_path¬∂ When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a root\\_path. That way, the sub-application will know to use that path prefix for the docs UI. And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these root\\_paths automatically. You will learn more about the root\\_path and how to use it explicitly in the section about Behind a Proxy. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Using Dataclasses - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/dataclasses/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Using Dataclasses en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Dataclasses in response\\_model Dataclasses in Nested Data Structures Learn More Version FastAPI Learn Advanced User Guide Using Dataclasses¬∂ FastAPI is built on top of Pydantic, and I have been showing you how to use Pydantic models to declare requests and responses. But FastAPI also supports using dataclasses the same way: from dataclasses import dataclass from typing import Union from fastapi import FastAPI @dataclass class Item: name: str price: float description: Union\\[str, None\\] = None tax: Union\\[float, None\\] = None app = FastAPI() @app.post(\"/items/\") async def create\\_item(item: Item): return item This is still supported thanks to Pydantic, as it has internal support for dataclasses. So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses. And of course, it supports the same: data validation data serialization data documentation, etc. This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic. Info Have in mind that dataclasses can't do everything Pydantic models can do. So, you might still need to use Pydantic models. But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. ü§ì Dataclasses in response\\_model¬∂ You can also use dataclasses in the response\\_model parameter: from dataclasses import dataclass, field from typing import List, Union from fastapi import FastAPI @dataclass class Item: name: str price: float tags: List\\[str\\] = field(default\\_factory=list) description: Union\\[str, None\\] = None tax: Union\\[float, None\\] = None app = FastAPI() @app.get(\"/items/next\", response\\_model=Item) async def read\\_next\\_item(): return { \"name\": \"Island In The Moon\", \"price\": 12.99, \"description\": \"A place to be be playin' and havin' fun\", \"tags\": \\[\"breater\"\\], } The dataclass will be automatically converted to a Pydantic dataclass. This way, its schema will show up in the API docs user interface: Dataclasses in Nested Data Structures¬∂ You can also combine dataclasses with other type annotations to make nested data structures. In some cases, you might still have to use Pydantic's version of dataclasses. For example, if you have errors with the automatically generated API documentation. In that case, you can simply swap the standard dataclasses with pydantic.dataclasses, which is a drop-in replacement: from dataclasses import field # We still import field from standard dataclasses. from typing import List, Union from fastapi import FastAPI from pydantic.dataclasses import dataclass # pydantic.dataclasses is a drop-in replacement for dataclasses. @dataclass class Item: name: str description: Union\\[str, None\\] = None @dataclass class Author: name: str items: List\\[Item\\] = field(default\\_factory=list) # The Author dataclass includes a list of Item dataclasses. app = FastAPI() @app.post(\"/authors/{author\\_id}/items/\", response\\_model=Author) # The Author dataclass is used as the response\\_model parameter. async def create\\_author\\_items(author\\_id: str, items: List\\[Item\\]): # You can use other standard type annotations with dataclasses as the request body. In this case, it's a list of Item dataclasses. return {\"name\": author\\_id, \"items\": items} # Here we are returning a dictionary that contains items which is a list of dataclasses. FastAPI is still capable of serializing the data to JSON. @app.get(\"/authors/\", response\\_model=List\\[Author\\]) # Here the response\\_model is using a type annotation of a list of Author dataclasses. Again, you can combine dataclasses with standard type annotations. def get\\_authors(): # Notice that this path operation function uses regular def instead of async def. As always, in FastAPI you can combine def and async def as needed. If you need a refresher about when to use which, check out the section \"In a hurry?\" in the docs about async and await. return \\[ # This path operation function is not returning dataclasses (although it could), but a list of dictionaries with internal data. FastAPI will use the response\\_model parameter (that includes dataclasses) to convert the response. { \"name\": \"Breaters\", \"items\": \\[ { \"name\": \"Island In The Moon\", \"description\": \"A place to be be playin' and havin' fun\", }, {\"name\": \"Holy Buddies\"}, \\], }, { \"name\": \"System of an Up\", \"items\": \\[ { \"name\": \"Salt\", \"description\": \"The kombucha mushroom people's favorite\", }, {\"name\": \"Pad Thai\"}, { \"name\": \"Lonely Night\", \"description\": \"The mostests lonliest nightiest of allest\", }, \\], }, \\] You can combine dataclasses with other type annotations in many different combinations to form complex data structures. Check the in-code annotation tips above to see more specific details. Learn More¬∂ You can also combine dataclasses with other Pydantic models, inherit from them, include them in your own models, etc. To learn more, check the Pydantic docs about dataclasses. Version¬∂ This is available since FastAPI version 0.67.0. üîñ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced Middleware - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/middleware/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Advanced Middleware en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Adding ASGI middlewares Integrated middlewares HTTPSRedirectMiddleware TrustedHostMiddleware GZipMiddleware Other middlewares FastAPI Learn Advanced User Guide Advanced Middleware¬∂ In the main tutorial you read how to add Custom Middleware to your application. And then you also read how to handle CORS with the CORSMiddleware. In this section we'll see how to use other middlewares. Adding ASGI middlewares¬∂ As FastAPI is based on Starlette and implements the ASGI specification, you can use any ASGI middleware. A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec. In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument. So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like: from unicorn import UnicornMiddleware app = SomeASGIApp() new\\_app = UnicornMiddleware(app, some\\_config=\"rainbow\") But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares to handle server errors and custom exception handlers work properly. For that, you use app.add\\_middleware() (as in the example for CORS). from fastapi import FastAPI from unicorn import UnicornMiddleware app = FastAPI() app.add\\_middleware(UnicornMiddleware, some\\_config=\"rainbow\") app.add\\_middleware() receives a middleware class as the first argument and any additional arguments to be passed to the middleware. Integrated middlewares¬∂ FastAPI includes several middlewares for common use cases, we'll see next how to use them. Technical Details For the next examples, you could also use from starlette.middleware.something import SomethingMiddleware. FastAPI provides several middlewares in fastapi.middleware just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette. HTTPSRedirectMiddleware¬∂ Enforces that all incoming requests must either be https or wss. Any incoming requests to http or ws will be redirected to the secure scheme instead. from fastapi import FastAPI from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware app = FastAPI() app.add\\_middleware(HTTPSRedirectMiddleware) @app.get(\"/\") async def main(): return {\"message\": \"Hello World\"} TrustedHostMiddleware¬∂ Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from fastapi import FastAPI from fastapi.middleware.trustedhost import TrustedHostMiddleware app = FastAPI() app.add\\_middleware( TrustedHostMiddleware, allowed\\_hosts=\\[\"example.com\", \"\\*.example.com\"\\] ) @app.get(\"/\") async def main(): return {\"message\": \"Hello World\"} The following arguments are supported: allowed\\_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as \\*.example.com are supported for matching subdomains. To allow any hostname either use allowed\\_hosts=\\[\"\\*\"\\] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. GZipMiddleware¬∂ Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware app = FastAPI() app.add\\_middleware(GZipMiddleware, minimum\\_size=1000) @app.get(\"/\") async def main(): return \"somebigcontent\" The following arguments are supported: minimum\\_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500. Other middlewares¬∂ There are many other ASGI middlewares. For example: Sentry Uvicorn's ProxyHeadersMiddleware MessagePack To see other available middlewares check Starlette's Middleware docs and the ASGI Awesome List. Made with Material for MkDocs Insiders"
  },
  {
    "title": "OAuth2 scopes - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI OAuth2 scopes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents OAuth2 scopes and OpenAPI Global view OAuth2 Security scheme JWT token with scopes Declare scopes in path operations and dependencies Use SecurityScopes Use the scopes Verify the username and data shape Verify the scopes Dependency tree and scopes More details about SecurityScopes Check it About third party integrations Security in decorator dependencies FastAPI Learn Advanced User Guide Advanced Security OAuth2 scopes¬∂ You can use OAuth2 scopes directly with FastAPI, they are integrated to work seamlessly. This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs). OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. They use it to provide specific permissions to users and applications. Every time you \"log in with\" Facebook, Google, GitHub, Microsoft, Twitter, that application is using OAuth2 with scopes. In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your FastAPI application. Warning This is a more or less advanced section. If you are just starting, you can skip it. You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want. But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs. Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code. In many cases, OAuth2 with scopes can be an overkill. But if you know you need it, or you are curious, keep reading. OAuth2 scopes and OpenAPI¬∂ The OAuth2 specification defines \"scopes\" as a list of strings separated by spaces. The content of each of these strings can have any format, but should not contain spaces. These scopes represent \"permissions\". In OpenAPI (e.g. the API docs), you can define \"security schemes\". When one of these security schemes uses OAuth2, you can also declare and use scopes. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram\\_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings. Global view¬∂ First, let's quickly see the parts that change from the examples in the main Tutorial - User Guide for OAuth2 with Password (and hashing), Bearer with JWT tokens. Now using OAuth2 scopes: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Now let's review those changes step by step. OAuth2 Security scheme¬∂ The first change is that now we are declaring the OAuth2 security scheme with two available scopes, me and items. The scopes parameter receives a dict with each scope as a key and the description as the value: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize. And you will be able to select which scopes you want to give access to: me and items. This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc: JWT token with scopes¬∂ Now, modify the token path operation to return the scopes requested. We are still using the same OAuth2PasswordRequestForm. It includes a property scopes with a list of str, with each scope it received in the request. And we return the scopes as part of the JWT token. Danger For simplicity, here we are just adding the scopes received directly to the token. But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Declare scopes in path operations and dependencies¬∂ Now we declare that the path operation for /users/me/items/ requires the scope items. For this, we import and use Security from fastapi. You can use Security to declare dependencies (just like Depends), but Security also receives a parameter scopes with a list of scopes (strings). In this case, we pass a dependency function get\\_current\\_active\\_user to Security (the same way we would do with Depends). But we also pass a list of scopes, in this case with just one scope: items (it could have more). And the dependency function get\\_current\\_active\\_user can also declare sub-dependencies, not only with Depends but also with Security. Declaring its own sub-dependency function (get\\_current\\_user), and more scope requirements. In this case, it requires the scope me (it could require more than one scope). Note You don't necessarily need to add different scopes in different places. We are doing it here to demonstrate how FastAPI handles scopes declared at different levels. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Technical Details Security is actually a subclass of Depends, and it has just one extra parameter that we'll see later. But by using Security instead of Depends, FastAPI will know that it can declare security scopes, use them internally, and document the API with OpenAPI. But when you import Query, Path, Depends, Security and others from fastapi, those are actually functions that return special classes. Use SecurityScopes¬∂ Now update the dependency get\\_current\\_user. This is the one used by the dependencies above. Here's were we are using the same OAuth2 scheme we created before, declaring it as a dependency: oauth2\\_scheme. Because this dependency function doesn't have any scope requirements itself, we can use Depends with oauth2\\_scheme, we don't have to use Security when we don't need to specify security scopes. We also declare a special parameter of type SecurityScopes, imported from fastapi.security. This SecurityScopes class is similar to Request (Request was used to get the request object directly). Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Use the scopes¬∂ The parameter security\\_scopes will be of type SecurityScopes. It will have a property scopes with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the \"dependants\"... this might sound confusing, it is explained again later below. The security\\_scopes object (of class SecurityScopes) also provides a scope\\_str attribute with a single string, containing those scopes separated by spaces (we are going to use it). We create an HTTPException that we can re-use (raise) later at several points. In this exception, we include the scopes required (if any) as a string separated by spaces (using scope\\_str). We put that string containing the scopes in the WWW-Authenticate header (this is part of the spec). Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Verify the username and data shape¬∂ We verify that we get a username, and extract the scopes. And then we validate that data with the Pydantic model (catching the ValidationError exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the HTTPException we created before. For that, we update the Pydantic model TokenData with a new property scopes. By validating the data with Pydantic we can make sure that we have, for example, exactly a list of str with the scopes and a str with the username. Instead of, for example, a dict, or something else, as it could break the application at some point later, making it a security risk. We also verify that we have a user with that username, and if not, we raise that same exception we created before. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Verify the scopes¬∂ We now verify that all the scopes required, by this dependency and all the dependants (including path operations), are included in the scopes provided in the token received, otherwise raise an HTTPException. For this, we use security\\_scopes.scopes, that contains a list with all these scopes as str. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET\\_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES = 30 fake\\_users\\_db = { \"johndoe\": { \"username\": \"johndoe\", \"full\\_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed\\_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full\\_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed\\_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access\\_token: str token\\_type: str class TokenData(BaseModel): username: str | None = None scopes: list\\[str\\] = \\[\\] class User(BaseModel): username: str email: str | None = None full\\_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed\\_password: str pwd\\_context = CryptContext(schemes=\\[\"bcrypt\"\\], deprecated=\"auto\") oauth2\\_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify\\_password(plain\\_password, hashed\\_password): return pwd\\_context.verify(plain\\_password, hashed\\_password) def get\\_password\\_hash(password): return pwd\\_context.hash(password) def get\\_user(db, username: str): if username in db: user\\_dict = db\\[username\\] return UserInDB(\\*\\*user\\_dict) def authenticate\\_user(fake\\_db, username: str, password: str): user = get\\_user(fake\\_db, username) if not user: return False if not verify\\_password(password, user.hashed\\_password): return False return user def create\\_access\\_token(data: dict, expires\\_delta: timedelta | None = None): to\\_encode = data.copy() if expires\\_delta: expire = datetime.utcnow() + expires\\_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to\\_encode.update({\"exp\": expire}) encoded\\_jwt = jwt.encode(to\\_encode, SECRET\\_KEY, algorithm=ALGORITHM) return encoded\\_jwt async def get\\_current\\_user( security\\_scopes: SecurityScopes, token: Annotated\\[str, Depends(oauth2\\_scheme)\\] ): if security\\_scopes.scopes: authenticate\\_value = f'Bearer scope=\"{security\\_scopes.scope\\_str}\"' else: authenticate\\_value = \"Bearer\" credentials\\_exception = HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) try: payload = jwt.decode(token, SECRET\\_KEY, algorithms=\\[ALGORITHM\\]) username: str = payload.get(\"sub\") if username is None: raise credentials\\_exception token\\_scopes = payload.get(\"scopes\", \\[\\]) token\\_data = TokenData(scopes=token\\_scopes, username=username) except (JWTError, ValidationError): raise credentials\\_exception user = get\\_user(fake\\_users\\_db, username=token\\_data.username) if user is None: raise credentials\\_exception for scope in security\\_scopes.scopes: if scope not in token\\_data.scopes: raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate\\_value}, ) return user async def get\\_current\\_active\\_user( current\\_user: Annotated\\[User, Security(get\\_current\\_user, scopes=\\[\"me\"\\])\\] ): if current\\_user.disabled: raise HTTPException(status\\_code=400, detail=\"Inactive user\") return current\\_user @app.post(\"/token\", response\\_model=Token) async def login\\_for\\_access\\_token( form\\_data: Annotated\\[OAuth2PasswordRequestForm, Depends()\\] ): user = authenticate\\_user(fake\\_users\\_db, form\\_data.username, form\\_data.password) if not user: raise HTTPException(status\\_code=400, detail=\"Incorrect username or password\") access\\_token\\_expires = timedelta(minutes=ACCESS\\_TOKEN\\_EXPIRE\\_MINUTES) access\\_token = create\\_access\\_token( data={\"sub\": user.username, \"scopes\": form\\_data.scopes}, expires\\_delta=access\\_token\\_expires, ) return {\"access\\_token\": access\\_token, \"token\\_type\": \"bearer\"} @app.get(\"/users/me/\", response\\_model=User) async def read\\_users\\_me( current\\_user: Annotated\\[User, Depends(get\\_current\\_active\\_user)\\] ): return current\\_user @app.get(\"/users/me/items/\") async def read\\_own\\_items( current\\_user: Annotated\\[User, Security(get\\_current\\_active\\_user, scopes=\\[\"items\"\\])\\] ): return \\[{\"item\\_id\": \"Foo\", \"owner\": current\\_user.username}\\] @app.get(\"/status/\") async def read\\_system\\_status(current\\_user: Annotated\\[User, Depends(get\\_current\\_user)\\]): return {\"status\": \"ok\"} Dependency tree and scopes¬∂ Let's review again this dependency tree and the scopes. As the get\\_current\\_active\\_user dependency has as a sub-dependency on get\\_current\\_user, the scope \"me\" declared at get\\_current\\_active\\_user will be included in the list of required scopes in the security\\_scopes.scopes passed to get\\_current\\_user. The path operation itself also declares a scope, \"items\", so this will also be in the list of security\\_scopes.scopes passed to get\\_current\\_user. Here's how the hierarchy of dependencies and scopes looks like: The path operation read\\_own\\_items has: Required scopes \\[\"items\"\\] with the dependency: get\\_current\\_active\\_user: The dependency function get\\_current\\_active\\_user has: Required scopes \\[\"me\"\\] with the dependency: get\\_current\\_user: The dependency function get\\_current\\_user has: No scopes required by itself. A dependency using oauth2\\_scheme. A security\\_scopes parameter of type SecurityScopes: This security\\_scopes parameter has a property scopes with a list containing all these scopes declared above, so: security\\_scopes.scopes will contain \\[\"me\", \"items\"\\] for the path operation read\\_own\\_items. security\\_scopes.scopes will contain \\[\"me\"\\] for the path operation read\\_users\\_me, because it is declared in the dependency get\\_current\\_active\\_user. security\\_scopes.scopes will contain \\[\\] (nothing) for the path operation read\\_system\\_status, because it didn't declare any Security with scopes, and its dependency, get\\_current\\_user, doesn't declare any scope either. Tip The important and \"magic\" thing here is that get\\_current\\_user will have a different list of scopes to check for each path operation. All depending on the scopes declared in each path operation and each dependency in the dependency tree for that specific path operation. More details about SecurityScopes¬∂ You can use SecurityScopes at any point, and in multiple places, it doesn't have to be at the \"root\" dependency. It will always have the security scopes declared in the current Security dependencies and all the dependants for that specific path operation and that specific dependency tree. Because the SecurityScopes will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different path operations. They will be checked independently for each path operation. Check it¬∂ If you open the API docs, you can authenticate and specify which scopes you want to authorize. If you don't select any scope, you will be \"authenticated\", but when you try to access /users/me/ or /users/me/items/ you will get an error saying that you don't have enough permissions. You will still be able to access /status/. And if you select the scope me but not the scope items, you will be able to access /users/me/ but not /users/me/items/. That's what would happen to a third party application that tried to access one of these path operations with a token provided by a user, depending on how many permissions the user gave the application. About third party integrations¬∂ In this example we are using the OAuth2 \"password\" flow. This is appropriate when we are logging in to our own application, probably with our own frontend. Because we can trust it to receive the username and password, as we control it. But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows. The most common is the implicit flow. The most secure is the code flow, but is more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow. Note It's common that each authentication provider names their flows in a different way, to make it part of their brand. But in the end, they are implementing the same OAuth2 standard. FastAPI includes utilities for all these OAuth2 authentication flows in fastapi.security.oauth2. Security in decorator dependencies¬∂ The same way you can define a list of Depends in the decorator's dependencies parameter (as explained in Dependencies in path operation decorators), you could also use Security with scopes there. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Using the Request Directly - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/using-request-directly/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Using the Request Directly en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Details about the Request object Use the Request object directly Request documentation FastAPI Learn Advanced User Guide Using the Request Directly¬∂ Up to now, you have been declaring the parts of the request that you need with their types. Taking data from: The path as parameters. Headers. Cookies. etc. And by doing so, FastAPI is validating that data, converting it and generating documentation for your API automatically. But there are situations where you might need to access the Request object directly. Details about the Request object¬∂ As FastAPI is actually Starlette underneath, with a layer of several tools on top, you can use Starlette's Request object directly when you need to. It would also mean that if you get data from the Request object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI. Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc. But there are specific cases where it's useful to get the Request object. Use the Request object directly¬∂ Let's imagine you want to get the client's IP address/host inside of your path operation function. For that you need to access the request directly. from fastapi import FastAPI, Request app = FastAPI() @app.get(\"/items/{item\\_id}\") def read\\_root(item\\_id: str, request: Request): client\\_host = request.client.host return {\"client\\_host\": client\\_host, \"item\\_id\": item\\_id} By declaring a path operation function parameter with the type being the Request FastAPI will know to pass the Request in that parameter. Tip Note that in this case, we are declaring a path parameter beside the request parameter. So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI. The same way, you can declare any other parameter as normally, and additionally, get the Request too. Request documentation¬∂ You can read more details about the Request object in the official Starlette documentation site. Technical Details You could also use from starlette.requests import Request. FastAPI provides it directly just as a convenience for you, the developer. But it comes directly from Starlette. Made with Material for MkDocs Insiders"
  },
  {
    "title": "HTTP Basic Auth - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/security/http-basic-auth/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI HTTP Basic Auth en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Simple HTTP Basic Auth Check the username Timing Attacks The time to answer helps the attackers A \"professional\" attack Fix it with secrets.compare\\_digest() Return the error FastAPI Learn Advanced User Guide Advanced Security HTTP Basic Auth¬∂ For the simplest cases, you can use HTTP Basic Auth. In HTTP Basic Auth, the application expects a header that contains a username and a password. If it doesn't receive it, it returns an HTTP 401 \"Unauthorized\" error. And returns a header WWW-Authenticate with a value of Basic, and an optional realm parameter. That tells the browser to show the integrated prompt for a username and password. Then, when you type that username and password, the browser sends them in the header automatically. Simple HTTP Basic Auth¬∂ Import HTTPBasic and HTTPBasicCredentials. Create a \"security scheme\" using HTTPBasic. Use that security with a dependency in your path operation. It returns an object of type HTTPBasicCredentials: It contains the username and password sent. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() @app.get(\"/users/me\") def read\\_current\\_user(credentials: Annotated\\[HTTPBasicCredentials, Depends(security)\\]): return {\"username\": credentials.username, \"password\": credentials.password} When you try to open the URL for the first time (or click the \"Execute\" button in the docs) the browser will ask you for your username and password: Check the username¬∂ Here's a more complete example. Use a dependency to check if the username and password are correct. For this, use the Python standard module secrets to check the username and password. secrets.compare\\_digest() needs to take bytes or a str that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like √°, as in Sebasti√°n. To handle that, we first convert the username and password to bytes encoding them with UTF-8. Then we can use secrets.compare\\_digest() to ensure that credentials.username is \"stanleyjobson\", and that credentials.password is \"swordfish\". Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated import secrets from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() def get\\_current\\_username( credentials: Annotated\\[HTTPBasicCredentials, Depends(security)\\] ): current\\_username\\_bytes = credentials.username.encode(\"utf8\") correct\\_username\\_bytes = b\"stanleyjobson\" is\\_correct\\_username = secrets.compare\\_digest( current\\_username\\_bytes, correct\\_username\\_bytes ) current\\_password\\_bytes = credentials.password.encode(\"utf8\") correct\\_password\\_bytes = b\"swordfish\" is\\_correct\\_password = secrets.compare\\_digest( current\\_password\\_bytes, correct\\_password\\_bytes ) if not (is\\_correct\\_username and is\\_correct\\_password): raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Incorrect email or password\", headers={\"WWW-Authenticate\": \"Basic\"}, ) return credentials.username @app.get(\"/users/me\") def read\\_current\\_user(username: Annotated\\[str, Depends(get\\_current\\_username)\\]): return {\"username\": username} This would be similar to: if not (credentials.username == \"stanleyjobson\") or not (credentials.password == \"swordfish\"): # Return some error ... But by using the secrets.compare\\_digest() it will be secure against a type of attacks called \"timing attacks\". Timing Attacks¬∂ But what's a \"timing attack\"? Let's imagine some attackers are trying to guess the username and password. And they send a request with a username johndoe and a password love123. Then the Python code in your application would be equivalent to something like: if \"johndoe\" == \"stanleyjobson\" and \"love123\" == \"swordfish\": ... But right at the moment Python compares the first j in johndoe to the first s in stanleyjobson, it will return False, because it already knows that those two strings are not the same, thinking that \"there's no need to waste more computation comparing the rest of the letters\". And your application will say \"incorrect user or password\". But then the attackers try with username stanleyjobsox and password love123. And your application code does something like: if \"stanleyjobsox\" == \"stanleyjobson\" and \"love123\" == \"swordfish\": ... Python will have to compare the whole stanleyjobso in both stanleyjobsox and stanleyjobson before realizing that both strings are not the same. So it will take some extra microseconds to reply back \"incorrect user or password\". The time to answer helps the attackers¬∂ At that point, by noticing that the server took some microseconds longer to send the \"incorrect user or password\" response, the attackers will know that they got something right, some of the initial letters were right. And then they can try again knowing that it's probably something more similar to stanleyjobsox than to johndoe. A \"professional\" attack¬∂ Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And would get just one extra correct letter at a time. But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the \"help\" of our application, just using the time taken to answer. Fix it with secrets.compare\\_digest()¬∂ But in our code we are actually using secrets.compare\\_digest(). In short, it will take the same time to compare stanleyjobsox to stanleyjobson than it takes to compare johndoe to stanleyjobson. And the same for the password. That way, using secrets.compare\\_digest() in your application code, it will be safe against this whole range of security attacks. Return the error¬∂ After detecting that the credentials are incorrect, return an HTTPException with a status code 401 (the same returned when no credentials are provided) and add the header WWW-Authenticate to make the browser show the login prompt again: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated import secrets from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() def get\\_current\\_username( credentials: Annotated\\[HTTPBasicCredentials, Depends(security)\\] ): current\\_username\\_bytes = credentials.username.encode(\"utf8\") correct\\_username\\_bytes = b\"stanleyjobson\" is\\_correct\\_username = secrets.compare\\_digest( current\\_username\\_bytes, correct\\_username\\_bytes ) current\\_password\\_bytes = credentials.password.encode(\"utf8\") correct\\_password\\_bytes = b\"swordfish\" is\\_correct\\_password = secrets.compare\\_digest( current\\_password\\_bytes, correct\\_password\\_bytes ) if not (is\\_correct\\_username and is\\_correct\\_password): raise HTTPException( status\\_code=status.HTTP\\_401\\_UNAUTHORIZED, detail=\"Incorrect email or password\", headers={\"WWW-Authenticate\": \"Basic\"}, ) return credentials.username @app.get(\"/users/me\") def read\\_current\\_user(username: Annotated\\[str, Depends(get\\_current\\_username)\\]): return {\"username\": username} Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced Dependencies - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/advanced-dependencies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Advanced Dependencies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Parameterized dependencies A \"callable\" instance Parameterize the instance Create an instance Use the instance as a dependency FastAPI Learn Advanced User Guide Advanced Dependencies¬∂ Parameterized dependencies¬∂ All the dependencies we have seen are a fixed function or class. But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes. Let's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content. But we want to be able to parameterize that fixed content. A \"callable\" instance¬∂ In Python there's a way to make an instance of a class a \"callable\". Not the class itself (which is already a callable), but an instance of that class. To do that, we declare a method \\_\\_call\\_\\_: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def \\_\\_init\\_\\_(self, fixed\\_content: str): self.fixed\\_content = fixed\\_content def \\_\\_call\\_\\_(self, q: str = \"\"): if q: return self.fixed\\_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read\\_query\\_check(fixed\\_content\\_included: Annotated\\[bool, Depends(checker)\\]): return {\"fixed\\_content\\_in\\_query\": fixed\\_content\\_included} In this case, this \\_\\_call\\_\\_ is what FastAPI will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your path operation function later. Parameterize the instance¬∂ And now, we can use \\_\\_init\\_\\_ to declare the parameters of the instance that we can use to \"parameterize\" the dependency: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def \\_\\_init\\_\\_(self, fixed\\_content: str): self.fixed\\_content = fixed\\_content def \\_\\_call\\_\\_(self, q: str = \"\"): if q: return self.fixed\\_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read\\_query\\_check(fixed\\_content\\_included: Annotated\\[bool, Depends(checker)\\]): return {\"fixed\\_content\\_in\\_query\": fixed\\_content\\_included} In this case, FastAPI won't ever touch or care about \\_\\_init\\_\\_, we will use it directly in our code. Create an instance¬∂ We could create an instance of this class with: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def \\_\\_init\\_\\_(self, fixed\\_content: str): self.fixed\\_content = fixed\\_content def \\_\\_call\\_\\_(self, q: str = \"\"): if q: return self.fixed\\_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read\\_query\\_check(fixed\\_content\\_included: Annotated\\[bool, Depends(checker)\\]): return {\"fixed\\_content\\_in\\_query\": fixed\\_content\\_included} And that way we are able to \"parameterize\" our dependency, that now has \"bar\" inside of it, as the attribute checker.fixed\\_content. Use the instance as a dependency¬∂ Then, we could use this checker in a Depends(checker), instead of Depends(FixedContentQueryChecker), because the dependency is the instance, checker, not the class itself. And when solving the dependency, FastAPI will call this checker like: checker(q=\"somequery\") ...and pass whatever that returns as the value of the dependency in our path operation function as the parameter fixed\\_content\\_included: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def \\_\\_init\\_\\_(self, fixed\\_content: str): self.fixed\\_content = fixed\\_content def \\_\\_call\\_\\_(self, q: str = \"\"): if q: return self.fixed\\_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read\\_query\\_check(fixed\\_content\\_included: Annotated\\[bool, Depends(checker)\\]): return {\"fixed\\_content\\_in\\_query\": fixed\\_content\\_included} Tip All this might seem contrived. And it might not be very clear how is it useful yet. These examples are intentionally simple, but show how it all works. In the chapters about security, there are utility functions that are implemented in this same way. If you understood all this, you already know how those utility tools for security work underneath. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced Security - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/security/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Advanced Security en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional Features Read the Tutorial first FastAPI Learn Advanced User Guide Advanced Security Advanced Security¬∂ Additional Features¬∂ There are some extra features to handle security apart from the ones covered in the Tutorial - User Guide: Security. Tip The next sections are not necessarily \"advanced\". And it's possible that for your use case, the solution is in one of them. Read the Tutorial first¬∂ The next sections assume you already read the main Tutorial - User Guide: Security. They are all based on the same concepts, but allow some extra functionalities. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response Headers - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-headers/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Response Headers en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use a Response parameter Return a Response directly Custom Headers FastAPI Learn Advanced User Guide Response Headers¬∂ Use a Response parameter¬∂ You can declare a parameter of type Response in your path operation function (as you can do for cookies). And then you can set headers in that temporal response object. from fastapi import FastAPI, Response app = FastAPI() @app.get(\"/headers-and-object/\") def get\\_headers(response: Response): response.headers\\[\"X-Cat-Dog\"\\] = \"alone in the world\" return {\"message\": \"Hello World\"} And then you can return any object you need, as you normally would (a dict, a database model, etc). And if you declared a response\\_model, it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any response\\_model. You can also declare the Response parameter in dependencies, and set headers (and cookies) in them. Return a Response directly¬∂ You can also add headers when you return a Response directly. Create a response as described in Return a Response Directly and pass the headers as an additional parameter: from fastapi import FastAPI from fastapi.responses import JSONResponse app = FastAPI() @app.get(\"/headers/\") def get\\_headers(): content = {\"message\": \"Hello World\"} headers = {\"X-Cat-Dog\": \"alone in the world\", \"Content-Language\": \"en-US\"} return JSONResponse(content=content, headers=headers) Technical Details You could also use from starlette.responses import Response or from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. And as the Response can be used frequently to set headers and cookies, FastAPI also provides it at fastapi.Response. Custom Headers¬∂ Have in mind that custom proprietary headers can be added using the 'X-' prefix. But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in CORS (Cross-Origin Resource Sharing)), using the parameter expose\\_headers documented in Starlette's CORS docs. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response - Change Status Code - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-change-status-code/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Response - Change Status Code en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use case Use a Response parameter FastAPI Learn Advanced User Guide Response - Change Status Code¬∂ You probably read before that you can set a default Response Status Code. But in some cases you need to return a different status code than the default. Use case¬∂ For example, imagine that you want to return an HTTP status code of \"OK\" 200 by default. But if the data didn't exist, you want to create it, and return an HTTP status code of \"CREATED\" 201. But you still want to be able to filter and convert the data you return with a response\\_model. For those cases, you can use a Response parameter. Use a Response parameter¬∂ You can declare a parameter of type Response in your path operation function (as you can do for cookies and headers). And then you can set the status\\_code in that temporal response object. from fastapi import FastAPI, Response, status app = FastAPI() tasks = {\"foo\": \"Listen to the Bar Fighters\"} @app.put(\"/get-or-create-task/{task\\_id}\", status\\_code=200) def get\\_or\\_create\\_task(task\\_id: str, response: Response): if task\\_id not in tasks: tasks\\[task\\_id\\] = \"This didn't exist before\" response.status\\_code = status.HTTP\\_201\\_CREATED return tasks\\[task\\_id\\] And then you can return any object you need, as you normally would (a dict, a database model, etc). And if you declared a response\\_model, it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any response\\_model. You can also declare the Response parameter in dependencies, and set the status code in them. But have in mind that the last one to be set will win. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response Cookies - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-cookies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Response Cookies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use a Response parameter Return a Response directly More info FastAPI Learn Advanced User Guide Response Cookies¬∂ Use a Response parameter¬∂ You can declare a parameter of type Response in your path operation function. And then you can set cookies in that temporal response object. from fastapi import FastAPI, Response app = FastAPI() @app.post(\"/cookie-and-object/\") def create\\_cookie(response: Response): response.set\\_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\") return {\"message\": \"Come to the dark side, we have cookies\"} And then you can return any object you need, as you normally would (a dict, a database model, etc). And if you declared a response\\_model, it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any response\\_model. You can also declare the Response parameter in dependencies, and set cookies (and headers) in them. Return a Response directly¬∂ You can also create cookies when returning a Response directly in your code. To do that, you can create a response as described in Return a Response Directly. Then set Cookies in it, and then return it: from fastapi import FastAPI from fastapi.responses import JSONResponse app = FastAPI() @app.post(\"/cookie/\") def create\\_cookie(): content = {\"message\": \"Come to the dark side, we have cookies\"} response = JSONResponse(content=content) response.set\\_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\") return response Tip Have in mind that if you return a response directly instead of using the Response parameter, FastAPI will return it directly. So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a JSONResponse. And also that you are not sending any data that should have been filtered by a response\\_model. More info¬∂ Technical Details You could also use from starlette.responses import Response or from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. And as the Response can be used frequently to set headers and cookies, FastAPI also provides it at fastapi.Response. To see all the available parameters and options, check the documentation in Starlette. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Additional Responses in OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/additional-responses/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Additional Responses in OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional Response with model Additional media types for the main response Combining information Combine predefined responses and custom ones More information about OpenAPI responses FastAPI Learn Advanced User Guide Additional Responses in OpenAPI¬∂ Warning This is a rather advanced topic. If you are starting with FastAPI, you might not need this. You can declare additional responses, with additional status codes, media types, descriptions, etc. Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs. But for those additional responses you have to make sure you return a Response like JSONResponse directly, with your status code and content. Additional Response with model¬∂ You can pass to your path operation decorators a parameter responses. It receives a dict, the keys are status codes for each response, like 200, and the values are other dicts with the information for each of them. Each of those response dicts can have a key model, containing a Pydantic model, just like response\\_model. FastAPI will take that model, generate its JSON Schema and include it in the correct place in OpenAPI. For example, to declare another response with a status code 404 and a Pydantic model Message, you can write: from fastapi import FastAPI from fastapi.responses import JSONResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str class Message(BaseModel): message: str app = FastAPI() @app.get(\"/items/{item\\_id}\", response\\_model=Item, responses={404: {\"model\": Message}}) async def read\\_item(item\\_id: str): if item\\_id == \"foo\": return {\"id\": \"foo\", \"value\": \"there goes my hero\"} return JSONResponse(status\\_code=404, content={\"message\": \"Item not found\"}) Note Have in mind that you have to return the JSONResponse directly. Info The model key is not part of OpenAPI. FastAPI will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place. The correct place is: In the key content, that has as value another JSON object (dict) that contains: A key with the media type, e.g. application/json, that contains as value another JSON object, that contains: A key schema, that has as the value the JSON Schema from the model, here's the correct place. FastAPI adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc. The generated responses in the OpenAPI for this path operation will be: { \"responses\": { \"404\": { \"description\": \"Additional Response\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/Message\" } } } }, \"200\": { \"description\": \"Successful Response\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/Item\" } } } }, \"422\": { \"description\": \"Validation Error\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/HTTPValidationError\" } } } } } } The schemas are referenced to another place inside the OpenAPI schema: { \"components\": { \"schemas\": { \"Message\": { \"title\": \"Message\", \"required\": \\[ \"message\" \\], \"type\": \"object\", \"properties\": { \"message\": { \"title\": \"Message\", \"type\": \"string\" } } }, \"Item\": { \"title\": \"Item\", \"required\": \\[ \"id\", \"value\" \\], \"type\": \"object\", \"properties\": { \"id\": { \"title\": \"Id\", \"type\": \"string\" }, \"value\": { \"title\": \"Value\", \"type\": \"string\" } } }, \"ValidationError\": { \"title\": \"ValidationError\", \"required\": \\[ \"loc\", \"msg\", \"type\" \\], \"type\": \"object\", \"properties\": { \"loc\": { \"title\": \"Location\", \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"msg\": { \"title\": \"Message\", \"type\": \"string\" }, \"type\": { \"title\": \"Error Type\", \"type\": \"string\" } } }, \"HTTPValidationError\": { \"title\": \"HTTPValidationError\", \"type\": \"object\", \"properties\": { \"detail\": { \"title\": \"Detail\", \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/ValidationError\" } } } } } } } Additional media types for the main response¬∂ You can use this same responses parameter to add different media types for the same main response. For example, you can add an additional media type of image/png, declaring that your path operation can return a JSON object (with media type application/json) or a PNG image: from typing import Union from fastapi import FastAPI from fastapi.responses import FileResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str app = FastAPI() @app.get( \"/items/{item\\_id}\", response\\_model=Item, responses={ 200: { \"content\": {\"image/png\": {}}, \"description\": \"Return the JSON item or an image.\", } }, ) async def read\\_item(item\\_id: str, img: Union\\[bool, None\\] = None): if img: return FileResponse(\"image.png\", media\\_type=\"image/png\") else: return {\"id\": \"foo\", \"value\": \"there goes my hero\"} Note Notice that you have to return the image using a FileResponse directly. Info Unless you specify a different media type explicitly in your responses parameter, FastAPI will assume the response has the same media type as the main response class (default application/json). But if you have specified a custom response class with None as its media type, FastAPI will use application/json for any additional response that has an associated model. Combining information¬∂ You can also combine response information from multiple places, including the response\\_model, status\\_code, and responses parameters. You can declare a response\\_model, using the default status code 200 (or a custom one if you need), and then declare additional information for that same response in responses, directly in the OpenAPI schema. FastAPI will keep the additional information from responses, and combine it with the JSON Schema from your model. For example, you can declare a response with a status code 404 that uses a Pydantic model and has a custom description. And a response with a status code 200 that uses your response\\_model, but includes a custom example: from fastapi import FastAPI from fastapi.responses import JSONResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str class Message(BaseModel): message: str app = FastAPI() @app.get( \"/items/{item\\_id}\", response\\_model=Item, responses={ 404: {\"model\": Message, \"description\": \"The item was not found\"}, 200: { \"description\": \"Item requested by ID\", \"content\": { \"application/json\": { \"example\": {\"id\": \"bar\", \"value\": \"The bar tenders\"} } }, }, }, ) async def read\\_item(item\\_id: str): if item\\_id == \"foo\": return {\"id\": \"foo\", \"value\": \"there goes my hero\"} else: return JSONResponse(status\\_code=404, content={\"message\": \"Item not found\"}) It will all be combined and included in your OpenAPI, and shown in the API docs: Combine predefined responses and custom ones¬∂ You might want to have some predefined responses that apply to many path operations, but you want to combine them with custom responses needed by each path operation. For those cases, you can use the Python technique of \"unpacking\" a dict with \\*\\*dict\\_to\\_unpack: old\\_dict = { \"old key\": \"old value\", \"second old key\": \"second old value\", } new\\_dict = {\\*\\*old\\_dict, \"new key\": \"new value\"} Here, new\\_dict will contain all the key-value pairs from old\\_dict plus the new key-value pair: { \"old key\": \"old value\", \"second old key\": \"second old value\", \"new key\": \"new value\", } You can use that technique to re-use some predefined responses in your path operations and combine them with additional custom ones. For example: from typing import Union from fastapi import FastAPI from fastapi.responses import FileResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str responses = { 404: {\"description\": \"Item not found\"}, 302: {\"description\": \"The item was moved\"}, 403: {\"description\": \"Not enough privileges\"}, } app = FastAPI() @app.get( \"/items/{item\\_id}\", response\\_model=Item, responses={\\*\\*responses, 200: {\"content\": {\"image/png\": {}}}}, ) async def read\\_item(item\\_id: str, img: Union\\[bool, None\\] = None): if img: return FileResponse(\"image.png\", media\\_type=\"image/png\") else: return {\"id\": \"foo\", \"value\": \"there goes my hero\"} More information about OpenAPI responses¬∂ To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification: OpenAPI Responses Object, it includes the Response Object. OpenAPI Response Object, you can include anything from this directly in each response inside your responses parameter. Including description, headers, content (inside of this is that you declare different media types and JSON Schemas), and links. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Response - HTML, Stream, File, others - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/custom-response/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Custom Response - HTML, Stream, File, others en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use ORJSONResponse HTML Response Return a Response Document in OpenAPI and override Response Return an HTMLResponse directly Available responses Response HTMLResponse PlainTextResponse JSONResponse ORJSONResponse UJSONResponse RedirectResponse StreamingResponse Using StreamingResponse with file-like objects FileResponse Custom response class Default response class Additional documentation FastAPI Learn Advanced User Guide Custom Response - HTML, Stream, File, others¬∂ By default, FastAPI will return the responses using JSONResponse. You can override it by returning a Response directly as seen in Return a Response directly. But if you return a Response directly, the data won't be automatically converted, and the documentation won't be automatically generated (for example, including the specific \"media type\", in the HTTP header Content-Type as part of the generated OpenAPI). But you can also declare the Response that you want to be used, in the path operation decorator. The contents that you return from your path operation function will be put inside of that Response. And if that Response has a JSON media type (application/json), like is the case with the JSONResponse and UJSONResponse, the data you return will be automatically converted (and filtered) with any Pydantic response\\_model that you declared in the path operation decorator. Note If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs. Use ORJSONResponse¬∂ For example, if you are squeezing performance, you can install and use orjson and set the response to be ORJSONResponse. Import the Response class (sub-class) you want to use and declare it in the path operation decorator. For large responses, returning a Response directly is much faster than returning a dictionary. This is because by default, FastAPI will inspect every item inside and make sure it is serializable with JSON, using the same JSON Compatible Encoder explained in the tutorial. This is what allows you to return arbitrary objects, for example database models. But if you are certain that the content that you are returning is serializable with JSON, you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the jsonable\\_encoder before passing it to the response class. from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI() @app.get(\"/items/\", response\\_class=ORJSONResponse) async def read\\_items(): return ORJSONResponse(\\[{\"item\\_id\": \"Foo\"}\\]) Info The parameter response\\_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to application/json. And it will be documented as such in OpenAPI. Tip The ORJSONResponse is currently only available in FastAPI, not in Starlette. HTML Response¬∂ To return a response with HTML directly from FastAPI, use HTMLResponse. Import HTMLResponse. Pass HTMLResponse as the parameter response\\_class of your path operation decorator. from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI() @app.get(\"/items/\", response\\_class=HTMLResponse) async def read\\_items(): return \"\"\" Some HTML in here Look ma! HTML! ============== \"\"\" Info The parameter response\\_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to text/html. And it will be documented as such in OpenAPI. Return a Response¬∂ As seen in Return a Response directly, you can also override the response directly in your path operation, by returning it. The same example from above, returning an HTMLResponse, could look like: from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI() @app.get(\"/items/\") async def read\\_items(): html\\_content = \"\"\" Some HTML in here Look ma! HTML! ============== \"\"\" return HTMLResponse(content=html\\_content, status\\_code=200) Warning A Response returned directly by your path operation function won't be documented in OpenAPI (for example, the Content-Type won't be documented) and won't be visible in the automatic interactive docs. Info Of course, the actual Content-Type header, status code, etc, will come from the Response object your returned. Document in OpenAPI and override Response¬∂ If you want to override the response from inside of the function but at the same time document the \"media type\" in OpenAPI, you can use the response\\_class parameter AND return a Response object. The response\\_class will then be used only to document the OpenAPI path operation, but your Response will be used as is. Return an HTMLResponse directly¬∂ For example, it could be something like: from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI() def generate\\_html\\_response(): html\\_content = \"\"\" Some HTML in here Look ma! HTML! ============== \"\"\" return HTMLResponse(content=html\\_content, status\\_code=200) @app.get(\"/items/\", response\\_class=HTMLResponse) async def read\\_items(): return generate\\_html\\_response() In this example, the function generate\\_html\\_response() already generates and returns a Response instead of returning the HTML in a str. By returning the result of calling generate\\_html\\_response(), you are already returning a Response that will override the default FastAPI behavior. But as you passed the HTMLResponse in the response\\_class too, FastAPI will know how to document it in OpenAPI and the interactive docs as HTML with text/html: Available responses¬∂ Here are some of the available responses. Have in mind that you can use Response to return anything else, or even create a custom sub-class. Technical Details You could also use from starlette.responses import HTMLResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. Response¬∂ The main Response class, all the other responses inherit from it. You can return it directly. It accepts the following parameters: content - A str or bytes. status\\_code - An int HTTP status code. headers - A dict of strings. media\\_type - A str giving the media type. E.g. \"text/html\". FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the media\\_type and appending a charset for text types. from fastapi import FastAPI, Response app = FastAPI() @app.get(\"/legacy/\") def get\\_legacy\\_data(): data = \"\"\"Apply shampoo here. You'll have to use soap here. \"\"\" return Response(content=data, media\\_type=\"application/xml\") HTMLResponse¬∂ Takes some text or bytes and returns an HTML response, as you read above. PlainTextResponse¬∂ Takes some text or bytes and returns an plain text response. from fastapi import FastAPI from fastapi.responses import PlainTextResponse app = FastAPI() @app.get(\"/\", response\\_class=PlainTextResponse) async def main(): return \"Hello World\" JSONResponse¬∂ Takes some data and returns an application/json encoded response. This is the default response used in FastAPI, as you read above. ORJSONResponse¬∂ A fast alternative JSON response using orjson, as you read above. UJSONResponse¬∂ An alternative JSON response using ujson. Warning ujson is less careful than Python's built-in implementation in how it handles some edge-cases. from fastapi import FastAPI from fastapi.responses import UJSONResponse app = FastAPI() @app.get(\"/items/\", response\\_class=UJSONResponse) async def read\\_items(): return \\[{\"item\\_id\": \"Foo\"}\\] Tip It's possible that ORJSONResponse might be a faster alternative. RedirectResponse¬∂ Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default. You can return a RedirectResponse directly: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/typer\") async def redirect\\_typer(): return RedirectResponse(\"https://typer.tiangolo.com\") Or you can use it in the response\\_class parameter: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/fastapi\", response\\_class=RedirectResponse) async def redirect\\_fastapi(): return \"https://fastapi.tiangolo.com\" If you do that, then you can return the URL directly from your path operation function. In this case, the status\\_code used will be the default one for the RedirectResponse, which is 307. You can also use the status\\_code parameter combined with the response\\_class parameter: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/pydantic\", response\\_class=RedirectResponse, status\\_code=302) async def redirect\\_pydantic(): return \"https://pydantic-docs.helpmanual.io/\" StreamingResponse¬∂ Takes an async generator or a normal generator/iterator and streams the response body. from fastapi import FastAPI from fastapi.responses import StreamingResponse app = FastAPI() async def fake\\_video\\_streamer(): for i in range(10): yield b\"some fake video bytes\" @app.get(\"/\") async def main(): return StreamingResponse(fake\\_video\\_streamer()) Using StreamingResponse with file-like objects¬∂ If you have a file-like object (e.g. the object returned by open()), you can create a generator function to iterate over that file-like object. That way, you don't have to read it all first in memory, and you can pass that generator function to the StreamingResponse, and return it. This includes many libraries to interact with cloud storage, video processing, and others. from fastapi import FastAPI from fastapi.responses import StreamingResponse some\\_file\\_path = \"large-video-file.mp4\" app = FastAPI() @app.get(\"/\") def main(): def iterfile(): # This is the generator function. It's a \"generator function\" because it contains yield statements inside. with open(some\\_file\\_path, mode=\"rb\") as file\\_like: # By using a with block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response. yield from file\\_like # This yield from tells the function to iterate over that thing named file\\_like. And then, for each part iterated, yield that part as coming from this generator function. So, it is a generator function that transfers the \"generating\" work to something else internally. By doing it this way, we can put it in a with block, and that way, ensure that it is closed after finishing. return StreamingResponse(iterfile(), media\\_type=\"video/mp4\") Tip Notice that here as we are using standard open() that doesn't support async and await, we declare the path operation with normal def. FileResponse¬∂ Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media\\_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition. File responses will include appropriate Content-Length, Last-Modified and ETag headers. from fastapi import FastAPI from fastapi.responses import FileResponse some\\_file\\_path = \"large-video-file.mp4\" app = FastAPI() @app.get(\"/\") async def main(): return FileResponse(some\\_file\\_path) You can also use the response\\_class parameter: from fastapi import FastAPI from fastapi.responses import FileResponse some\\_file\\_path = \"large-video-file.mp4\" app = FastAPI() @app.get(\"/\", response\\_class=FileResponse) async def main(): return some\\_file\\_path In this case, you can return the file path directly from your path operation function. Custom response class¬∂ You can create your own custom response class, inheriting from Response and using it. For example, let's say that you want to use orjson, but with some custom settings not used in the included ORJSONResponse class. Let's say you want it to return indented and formatted JSON, so you want to use the orjson option orjson.OPT\\_INDENT\\_2. You could create a CustomORJSONResponse. The main thing you have to do is create a Response.render(content) method that returns the content as bytes: from typing import Any import orjson from fastapi import FastAPI, Response app = FastAPI() class CustomORJSONResponse(Response): media\\_type = \"application/json\" def render(self, content: Any) -> bytes: assert orjson is not None, \"orjson must be installed\" return orjson.dumps(content, option=orjson.OPT\\_INDENT\\_2) @app.get(\"/\", response\\_class=CustomORJSONResponse) async def main(): return {\"message\": \"Hello World\"} Now instead of returning: {\"message\": \"Hello World\"} ...this response will return: { \"message\": \"Hello World\" } Of course, you will probably find much better ways to take advantage of this than formatting JSON. üòâ Default response class¬∂ When creating a FastAPI class instance or an APIRouter you can specify which response class to use by default. The parameter that defines this is default\\_response\\_class. In the example below, FastAPI will use ORJSONResponse by default, in all path operations, instead of JSONResponse. from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default\\_response\\_class=ORJSONResponse) @app.get(\"/items/\") async def read\\_items(): return \\[{\"item\\_id\": \"Foo\"}\\] Tip You can still override response\\_class in path operations as before. Additional documentation¬∂ You can also declare the media type and many other details in OpenAPI using responses: Additional Responses in OpenAPI. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Return a Response Directly - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-directly/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Return a Response Directly en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Return a Response Using the jsonable\\_encoder in a Response Returning a custom Response Notes FastAPI Learn Advanced User Guide Return a Response Directly¬∂ When you create a FastAPI path operation you can normally return any data from it: a dict, a list, a Pydantic model, a database model, etc. By default, FastAPI would automatically convert that return value to JSON using the jsonable\\_encoder explained in JSON Compatible Encoder. Then, behind the scenes, it would put that JSON-compatible data (e.g. a dict) inside of a JSONResponse that would be used to send the response to the client. But you can return a JSONResponse directly from your path operations. It might be useful, for example, to return custom headers or cookies. Return a Response¬∂ In fact, you can return any Response or any sub-class of it. Tip JSONResponse itself is a sub-class of Response. And when you return a Response, FastAPI will pass it directly. It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc. This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc. Using the jsonable\\_encoder in a Response¬∂ Because FastAPI doesn't do any change to a Response you return, you have to make sure it's contents are ready for it. For example, you cannot put a Pydantic model in a JSONResponse without first converting it to a dict with all the data types (like datetime, UUID, etc) converted to JSON-compatible types. For those cases, you can use the jsonable\\_encoder to convert your data before passing it to a response: from datetime import datetime from typing import Union from fastapi import FastAPI from fastapi.encoders import jsonable\\_encoder from fastapi.responses import JSONResponse from pydantic import BaseModel class Item(BaseModel): title: str timestamp: datetime description: Union\\[str, None\\] = None app = FastAPI() @app.put(\"/items/{id}\") def update\\_item(id: str, item: Item): json\\_compatible\\_item\\_data = jsonable\\_encoder(item) return JSONResponse(content=json\\_compatible\\_item\\_data) Technical Details You could also use from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. Returning a custom Response¬∂ The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the item directly, and FastAPI would put it in a JSONResponse for you, converting it to a dict, etc. All that by default. Now, let's see how you could use that to return a custom response. Let's say that you want to return an XML response. You could put your XML content in a string, put it in a Response, and return it: from fastapi import FastAPI, Response app = FastAPI() @app.get(\"/legacy/\") def get\\_legacy\\_data(): data = \"\"\"Apply shampoo here. You'll have to use soap here. \"\"\" return Response(content=data, media\\_type=\"application/xml\") Notes¬∂ When you return a Response directly its data is not validated, converted (serialized), nor documented automatically. But you can still document it as described in Additional Responses in OpenAPI. You can see in later sections how to use/declare these custom Responses while still having automatic data conversion, documentation, etc. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Path Operation Advanced Configuration - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Path Operation Advanced Configuration en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents OpenAPI operationId Using the path operation function name as the operationId Exclude from OpenAPI Advanced description from docstring Additional Responses OpenAPI Extra OpenAPI Extensions Custom OpenAPI path operation schema Custom OpenAPI content type FastAPI Learn Advanced User Guide Path Operation Advanced Configuration¬∂ OpenAPI operationId¬∂ Warning If you are not an \"expert\" in OpenAPI, you probably don't need this. You can set the OpenAPI operationId to be used in your path operation with the parameter operation\\_id. You would have to make sure that it is unique for each operation. from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", operation\\_id=\"some\\_specific\\_id\\_you\\_define\") async def read\\_items(): return \\[{\"item\\_id\": \"Foo\"}\\] Using the path operation function name as the operationId¬∂ If you want to use your APIs' function names as operationIds, you can iterate over all of them and override each path operation's operation\\_id using their APIRoute.name. You should do it after adding all your path operations. from fastapi import FastAPI from fastapi.routing import APIRoute app = FastAPI() @app.get(\"/items/\") async def read\\_items(): return \\[{\"item\\_id\": \"Foo\"}\\] def use\\_route\\_names\\_as\\_operation\\_ids(app: FastAPI) -> None: \"\"\" Simplify operation IDs so that generated API clients have simpler function names. Should be called only after all routes have been added. \"\"\" for route in app.routes: if isinstance(route, APIRoute): route.operation\\_id = route.name # in this case, 'read\\_items' use\\_route\\_names\\_as\\_operation\\_ids(app) Tip If you manually call app.openapi(), you should update the operationIds before that. Warning If you do this, you have to make sure each one of your path operation functions has a unique name. Even if they are in different modules (Python files). Exclude from OpenAPI¬∂ To exclude a path operation from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter include\\_in\\_schema and set it to False: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", include\\_in\\_schema=False) async def read\\_items(): return \\[{\"item\\_id\": \"Foo\"}\\] Advanced description from docstring¬∂ You can limit the lines used from the docstring of a path operation function for OpenAPI. Adding an \\\\f (an escaped \"form feed\" character) causes FastAPI to truncate the output used for OpenAPI at this point. It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest. from typing import Set, Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Union\\[str, None\\] = None price: float tax: Union\\[float, None\\] = None tags: Set\\[str\\] = set() @app.post(\"/items/\", response\\_model=Item, summary=\"Create an item\") async def create\\_item(item: Item): \"\"\" Create an item with all the information: - \\*\\*name\\*\\*: each item must have a name - \\*\\*description\\*\\*: a long description - \\*\\*price\\*\\*: required - \\*\\*tax\\*\\*: if the item doesn't have tax, you can omit this - \\*\\*tags\\*\\*: a set of unique tag strings for this item \\\\f :param item: User input. \"\"\" return item Additional Responses¬∂ You probably have seen how to declare the response\\_model and status\\_code for a path operation. That defines the metadata about the main response of a path operation. You can also declare additional responses with their models, status codes, etc. There's a whole chapter here in the documentation about it, you can read it at Additional Responses in OpenAPI. OpenAPI Extra¬∂ When you declare a path operation in your application, FastAPI automatically generates the relevant metadata about that path operation to be included in the OpenAPI schema. Technical details In the OpenAPI specification it is called the Operation Object. It has all the information about the path operation and is used to generate the automatic documentation. It includes the tags, parameters, requestBody, responses, etc. This path operation-specific OpenAPI schema is normally generated automatically by FastAPI, but you can also extend it. Tip This is a low level extension point. If you only need to declare additional responses, a more convenient way to do it is with Additional Responses in OpenAPI. You can extend the OpenAPI schema for a path operation using the parameter openapi\\_extra. OpenAPI Extensions¬∂ This openapi\\_extra can be helpful, for example, to declare OpenAPI Extensions: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", openapi\\_extra={\"x-aperture-labs-portal\": \"blue\"}) async def read\\_items(): return \\[{\"item\\_id\": \"portal-gun\"}\\] If you open the automatic API docs, your extension will show up at the bottom of the specific path operation. And if you see the resulting OpenAPI (at /openapi.json in your API), you will see your extension as part of the specific path operation too: { \"openapi\": \"3.1.0\", \"info\": { \"title\": \"FastAPI\", \"version\": \"0.1.0\" }, \"paths\": { \"/items/\": { \"get\": { \"summary\": \"Read Items\", \"operationId\": \"read\\_items\\_items\\_\\_get\", \"responses\": { \"200\": { \"description\": \"Successful Response\", \"content\": { \"application/json\": { \"schema\": {} } } } }, \"x-aperture-labs-portal\": \"blue\" } } } } Custom OpenAPI path operation schema¬∂ The dictionary in openapi\\_extra will be deeply merged with the automatically generated OpenAPI schema for the path operation. So, you could add additional data to the automatically generated schema. For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema. You could do that with openapi\\_extra: from fastapi import FastAPI, Request app = FastAPI() def magic\\_data\\_reader(raw\\_body: bytes): return { \"size\": len(raw\\_body), \"content\": { \"name\": \"Maaaagic\", \"price\": 42, \"description\": \"Just kiddin', no magic here. ‚ú®\", }, } @app.post( \"/items/\", openapi\\_extra={ \"requestBody\": { \"content\": { \"application/json\": { \"schema\": { \"required\": \\[\"name\", \"price\"\\], \"type\": \"object\", \"properties\": { \"name\": {\"type\": \"string\"}, \"price\": {\"type\": \"number\"}, \"description\": {\"type\": \"string\"}, }, } } }, \"required\": True, }, }, ) async def create\\_item(request: Request): raw\\_body = await request.body() data = magic\\_data\\_reader(raw\\_body) return data In this example, we didn't declare any Pydantic model. In fact, the request body is not even parsed as JSON, it is read directly as bytes, and the function magic\\_data\\_reader() would be in charge of parsing it in some way. Nevertheless, we can declare the expected schema for the request body. Custom OpenAPI content type¬∂ Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the path operation. And you could do this even if the data type in the request is not JSON. For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON: Pydantic v2 Pydantic v1 from typing import List import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError app = FastAPI() class Item(BaseModel): name: str tags: List\\[str\\] @app.post( \"/items/\", openapi\\_extra={ \"requestBody\": { \"content\": {\"application/x-yaml\": {\"schema\": Item.model\\_json\\_schema()}}, \"required\": True, }, }, ) async def create\\_item(request: Request): raw\\_body = await request.body() try: data = yaml.safe\\_load(raw\\_body) except yaml.YAMLError: raise HTTPException(status\\_code=422, detail=\"Invalid YAML\") try: item = Item.model\\_validate(data) except ValidationError as e: raise HTTPException(status\\_code=422, detail=e.errors()) return item Info In Pydantic version 1 the method to get the JSON Schema for a model was called Item.schema(), in Pydantic version 2, the method is called Item.model\\_schema\\_json(). Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML. Then we use the request directly, and extract the body as bytes. This means that FastAPI won't even try to parse the request payload as JSON. And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content: Pydantic v2 Pydantic v1 from typing import List import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError app = FastAPI() class Item(BaseModel): name: str tags: List\\[str\\] @app.post( \"/items/\", openapi\\_extra={ \"requestBody\": { \"content\": {\"application/x-yaml\": {\"schema\": Item.model\\_json\\_schema()}}, \"required\": True, }, }, ) async def create\\_item(request: Request): raw\\_body = await request.body() try: data = yaml.safe\\_load(raw\\_body) except yaml.YAMLError: raise HTTPException(status\\_code=422, detail=\"Invalid YAML\") try: item = Item.model\\_validate(data) except ValidationError as e: raise HTTPException(status\\_code=422, detail=e.errors()) return item Info In Pydantic version 1 the method to parse and validate an object was Item.parse\\_obj(), in Pydantic version 2, the method is called Item.model\\_validate(). Tip Here we re-use the same Pydantic model. But the same way, we could have validated it in some other way. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Additional Status Codes - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/additional-status-codes/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Additional Status Codes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional status codes OpenAPI and API docs FastAPI Learn Advanced User Guide Additional Status Codes¬∂ By default, FastAPI will return the responses using a JSONResponse, putting the content you return from your path operation inside of that JSONResponse. It will use the default status code or the one you set in your path operation. Additional status codes¬∂ If you want to return additional status codes apart from the main one, you can do that by returning a Response directly, like a JSONResponse, and set the additional status code directly. For example, let's say that you want to have a path operation that allows to update items, and returns HTTP status codes of 200 \"OK\" when successful. But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 \"Created\". To achieve that, import JSONResponse, and return your content there directly, setting the status\\_code that you want: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse app = FastAPI() items = {\"foo\": {\"name\": \"Fighters\", \"size\": 6}, \"bar\": {\"name\": \"Tenders\", \"size\": 3}} @app.put(\"/items/{item\\_id}\") async def upsert\\_item( item\\_id: str, name: Annotated\\[str | None, Body()\\] = None, size: Annotated\\[int | None, Body()\\] = None, ): if item\\_id in items: item = items\\[item\\_id\\] item\\[\"name\"\\] = name item\\[\"size\"\\] = size return item else: item = {\"name\": name, \"size\": size} items\\[item\\_id\\] = item return JSONResponse(status\\_code=status.HTTP\\_201\\_CREATED, content=item) Warning When you return a Response directly, like in the example above, it will be returned directly. It won't be serialized with a model, etc. Make sure it has the data you want it to have, and that the values are valid JSON (if you are using JSONResponse). Technical Details You could also use from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with status. OpenAPI and API docs¬∂ If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return. But you can document that in your code, using: Additional Responses. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced User Guide - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Advanced User Guide en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional Features Read the Tutorial first External Courses FastAPI Learn Advanced User Guide Advanced User Guide¬∂ Additional Features¬∂ The main Tutorial - User Guide should be enough to give you a tour through all the main features of FastAPI. In the next sections you will see other options, configurations, and additional features. Tip The next sections are not necessarily \"advanced\". And it's possible that for your use case, the solution is in one of them. Read the Tutorial first¬∂ You could still use most of the features in FastAPI with the knowledge from the main Tutorial - User Guide. And the next sections assume you already read it, and assume that you know those main ideas. External Courses¬∂ Although the Tutorial - User Guide and this Advanced User Guide are written as a guided tutorial (like a book) and should be enough for you to learn FastAPI, you might want to complement it with additional courses. Or it might be the case that you just prefer to take other courses because they adapt better to your learning style. Some course providers ‚ú® sponsor FastAPI ‚ú®, this ensures the continued and healthy development of FastAPI and its ecosystem. And it shows their true commitment to FastAPI and its community (you), as they not only want to provide you a good learning experience but also want to make sure you have a good and healthy framework, FastAPI. üôá You might want to try their courses: Talk Python Training Test-Driven Development Made with Material for MkDocs Insiders"
  }
]