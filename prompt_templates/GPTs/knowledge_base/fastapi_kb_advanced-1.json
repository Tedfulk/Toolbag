[
  {
    "title": "Generate Clients - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/generate-clients/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Generate Clients en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents OpenAPI Client Generators Client and SDK Generators - Sponsor Generate a TypeScript Frontend Client API Docs Generate a TypeScript Client Install openapi-typescript-codegen Generate Client Code Try Out the Client Code FastAPI App with Tags Generate a TypeScript Client with Tags Client Method Names Custom Operation IDs and Better Method Names Custom Generate Unique ID Function Generate a TypeScript Client with Custom Operation IDs Preprocess the OpenAPI Specification for the Client Generator Generate a TypeScript Client with the Preprocessed OpenAPI Benefits FastAPI Learn Advanced User Guide Generate Clients¬∂ As FastAPI is based on the OpenAPI specification, you get automatic compatibility with many tools, including the automatic API docs (provided by Swagger UI). One particular advantage that is not necessarily obvious is that you can generate clients (sometimes called SDKs ) for your API, for many different programming languages. OpenAPI Client Generators¬∂ There are many tools to generate clients from OpenAPI. A common tool is OpenAPI Generator. If you are building a frontend, a very interesting alternative is openapi-typescript-codegen. Client and SDK Generators - Sponsor¬∂ There are also some company-backed Client and SDK generators based on OpenAPI (FastAPI), in some cases they can offer you additional features on top of high-quality generated SDKs/clients. Some of them also ‚ú® sponsor FastAPI ‚ú®, this ensures the continued and healthy development of FastAPI and its ecosystem. And it shows their true commitment to FastAPI and its community (you), as they not only want to provide you a good service but also want to make sure you have a good and healthy framework, FastAPI. üôá For example, you might want to try Speakeasy. There are also several other companies offering similar services that you can search and find online. ü§ì Generate a TypeScript Frontend Client¬∂ Let's start with a simple FastAPI application: Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str price: float class ResponseMessage(BaseModel): message: str @app.post(\"/items/\", response_model=ResponseMessage) async def create_item(item: Item): return {\"message\": \"item received\"} @app.get(\"/items/\", response_model=list[Item]) async def get_items(): return [ {\"name\": \"Plumbus\", \"price\": 3}, {\"name\": \"Portal Gun\", \"price\": 9001}, ] Notice that the path operations define the models they use for request payload and response payload, using the models Item and ResponseMessage. API Docs¬∂ If you go to the API docs, you will see that it has the schemas for the data to be sent in requests and received in responses: You can see those schemas because they were declared with the models in the app. That information is available in the app's OpenAPI schema, and then shown in the API docs (by Swagger UI). And that same information from the models that is included in OpenAPI is what can be used to generate the client code. Generate a TypeScript Client¬∂ Now that we have the app with the models, we can generate the client code for the frontend. Install openapi-typescript-codegen¬∂ You can install openapi-typescript-codegen in your frontend code with: Generate Client Code¬∂ To generate the client code you can use the command line application openapi that would now be installed. Because it is installed in the local project, you probably wouldn't be able to call that command directly, but you would put it on your package.json file. It could look like this: { \"name\": \"frontend-app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"generate-client\": \"openapi --input http://localhost:8000/openapi.json --output ./src/client --client axios --useOptions --useUnionTypes\" }, \"author\": \"\", \"license\": \"\", \"devDependencies\": { \"openapi-typescript-codegen\": \"^0.20.1\", \"typescript\": \"^4.6.2\" } } After having that NPM generate-client script there, you can run it with: That command will generate code in ./src/client and will use axios (the frontend HTTP library) internally. Try Out the Client Code¬∂ Now you can import and use the client code, it could look like this, notice that you get autocompletion for the methods: You will also get autocompletion for the payload to send: Tip Notice the autocompletion for name and price, that was defined in the FastAPI application, in the Item model. You will have inline errors for the data that you send: The response object will also have autocompletion: FastAPI App with Tags¬∂ In many cases your FastAPI app will be bigger, and you will probably use tags to separate different groups of path operations. For example, you could have a section for items and another section for users, and they could be separated by tags: Python 3.9+ Python 3.8+ from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str price: float class ResponseMessage(BaseModel): message: str class User(BaseModel): username: str email: str @app.post(\"/items/\", response_model=ResponseMessage, tags=[\"items\"]) async def create_item(item: Item): return {\"message\": \"Item received\"} @app.get(\"/items/\", response_model=list[Item], tags=[\"items\"]) async def get_items(): return [ {\"name\": \"Plumbus\", \"price\": 3}, {\"name\": \"Portal Gun\", \"price\": 9001}, ] @app.post(\"/users/\", response_model=ResponseMessage, tags=[\"users\"]) async def create_user(user: User): return {\"message\": \"User received\"} Generate a TypeScript Client with Tags¬∂ If you generate a client for a FastAPI app using tags, it will normally also separate the client code based on the tags. This way you will be able to have things ordered and grouped correctly for the client code: In this case you have: ItemsService UsersService Client Method Names¬∂ Right now the generated method names like createItemItemsPost don't look very clean: ItemsService.createItemItemsPost({name: \"Plumbus\", price: 5}) ...that's because the client generator uses the OpenAPI internal operation ID for each path operation. OpenAPI requires that each operation ID is unique across all the path operations, so FastAPI uses the function name, the path, and the HTTP method/operation to generate that operation ID, because that way it can make sure that the operation IDs are unique. But I'll show you how to improve that next. ü§ì Custom Operation IDs and Better Method Names¬∂ You can modify the way these operation IDs are generated to make them simpler and have simpler method names in the clients. In this case you will have to ensure that each operation ID is unique in some other way. For example, you could make sure that each path operation has a tag, and then generate the operation ID based on the tag and the path operation name (the function name). Custom Generate Unique ID Function¬∂ FastAPI uses a unique ID for each path operation, it is used for the operation ID and also for the names of any needed custom models, for requests or responses. You can customize that function. It takes an APIRoute and outputs a string. For example, here it is using the first tag (you will probably have only one tag) and the path operation name (the function name). You can then pass that custom function to FastAPI as the generate_unique_id_function parameter: Python 3.9+ Python 3.8+ from fastapi import FastAPI from fastapi.routing import APIRoute from pydantic import BaseModel def custom_generate_unique_id(route: APIRoute): return f\"{route.tags[0]}-{route.name}\" app = FastAPI(generate_unique_id_function=custom_generate_unique_id) class Item(BaseModel): name: str price: float class ResponseMessage(BaseModel): message: str class User(BaseModel): username: str email: str @app.post(\"/items/\", response_model=ResponseMessage, tags=[\"items\"]) async def create_item(item: Item): return {\"message\": \"Item received\"} @app.get(\"/items/\", response_model=list[Item], tags=[\"items\"]) async def get_items(): return [ {\"name\": \"Plumbus\", \"price\": 3}, {\"name\": \"Portal Gun\", \"price\": 9001}, ] @app.post(\"/users/\", response_model=ResponseMessage, tags=[\"users\"]) async def create_user(user: User): return {\"message\": \"User received\"} Generate a TypeScript Client with Custom Operation IDs¬∂ Now if you generate the client again, you will see that it has the improved method names: As you see, the method names now have the tag and then the function name, now they don't include information from the URL path and the HTTP operation. Preprocess the OpenAPI Specification for the Client Generator¬∂ The generated code still has some duplicated information. We already know that this method is related to the items because that word is in the ItemsService (taken from the tag), but we still have the tag name prefixed in the method name too. üòï We will probably still want to keep it for OpenAPI in general, as that will ensure that the operation IDs are unique. But for the generated client we could modify the OpenAPI operation IDs right before generating the clients, just to make those method names nicer and cleaner. We could download the OpenAPI JSON to a file openapi.json and then we could remove that prefixed tag with a script like this: Python Node.js import json from pathlib import Path file_path = Path(\"./openapi.json\") openapi_content = json.loads(file_path.read_text()) for path_data in openapi_content[\"paths\"].values(): for operation in path_data.values(): tag = operation[\"tags\"][0] operation_id = operation[\"operationId\"] to_remove = f\"{tag}-\" new_operation_id = operation_id[len(to_remove) :] operation[\"operationId\"] = new_operation_id file_path.write_text(json.dumps(openapi_content)) With that, the operation IDs would be renamed from things like items-get_items to just get_items, that way the client generator can generate simpler method names. Generate a TypeScript Client with the Preprocessed OpenAPI¬∂ Now as the end result is in a file openapi.json, you would modify the package.json to use that local file, for example: { \"name\": \"frontend-app\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"generate-client\": \"openapi --input ./openapi.json --output ./src/client --client axios --useOptions --useUnionTypes\" }, \"author\": \"\", \"license\": \"\", \"devDependencies\": { \"openapi-typescript-codegen\": \"^0.20.1\", \"typescript\": \"^4.6.2\" } } After generating the new client, you would now have clean method names, with all the autocompletion, inline errors, etc: Benefits¬∂ When using the automatically generated clients you would autocompletion for: Methods. Request payloads in the body, query parameters, etc. Response payloads. You would also have inline errors for everything. And whenever you update the backend code, and regenerate the frontend, it would have any new path operations available as methods, the old ones removed, and any other change would be reflected on the generated code. ü§ì This also means that if something changed it will be reflected on the client code automatically. And if you build the client it will error out if you have any mismatch in the data used. So, you would detect many errors very early in the development cycle instead of having to wait for the errors to show up to your final users in production and then trying to debug where the problem is. ‚ú® Made with Material for MkDocs Insiders"
  },
  {
    "title": "Including WSGI - Flask, Django, others - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/wsgi/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Including WSGI - Flask, Django, others en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Using WSGIMiddleware Check it FastAPI Learn Advanced User Guide Including WSGI - Flask, Django, others¬∂ You can mount WSGI applications as you saw with Sub Applications - Mounts, Behind a Proxy. For that, you can use the WSGIMiddleware and use it to wrap your WSGI application, for example, Flask, Django, etc. Using WSGIMiddleware¬∂ You need to import WSGIMiddleware. Then wrap the WSGI (e.g. Flask) app with the middleware. And then mount that under a path. from fastapi import FastAPI from fastapi.middleware.wsgi import WSGIMiddleware from flask import Flask, request from markupsafe import escape flask_app = Flask(__name__) @flask_app.route(\"/\") def flask_main(): name = request.args.get(\"name\", \"World\") return f\"Hello, {escape(name)} from Flask!\" app = FastAPI() @app.get(\"/v2\") def read_main(): return {\"message\": \"Hello World\"} app.mount(\"/v1\", WSGIMiddleware(flask_app)) Check it¬∂ Now, every request under the path /v1/ will be handled by the Flask application. And the rest will be handled by FastAPI. If you run it with Uvicorn and go to http://localhost:8000/v1/ you will see the response from Flask: Hello, World from Flask! And if you go to http://localhost:8000/v2 you will see the response from FastAPI: { \"message\": \"Hello World\" } Made with Material for MkDocs Insiders"
  },
  {
    "title": "Settings and Environment Variables - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/settings/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Settings and Environment Variables en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Environment Variables Read env vars in Python Types and validation Pydantic Settings Install pydantic-settings Create the Settings object Use the settings Run the server Settings in another module Settings in a dependency The config file The main app file Settings and testing Reading a .env file The .env file Read settings from .env Creating the Settings only once with lru_cache lru_cache Technical Details Recap FastAPI Learn Advanced User Guide Settings and Environment Variables¬∂ In many cases your application could need some external settings or configurations, for example secret keys, database credentials, credentials for email services, etc. Most of these settings are variable (can change), like database URLs. And many could be sensitive, like secrets. For this reason it's common to provide them in environment variables that are read by the application. Environment Variables¬∂ Tip If you already know what \"environment variables\" are and how to use them, feel free to skip to the next section below. An environment variable (also known as \"env var\") is a variable that lives outside of the Python code, in the operating system, and could be read by your Python code (or by other programs as well). You can create and use environment variables in the shell, without needing Python: Linux, macOS, Windows Bash Windows PowerShell fast ‚Üí üí¨ You could create an env var MY_NAME with Read env vars in Python¬∂ You could also create environment variables outside of Python, in the terminal (or with any other method), and then read them in Python. For example you could have a file main.py with: import os name = os.getenv(\"MY_NAME\", \"World\") print(f\"Hello {name} from Python\") Tip The second argument to os.getenv() is the default value to return. If not provided, it's None by default, here we provide \"World\" as the default value to use. Then you could call that Python program: As environment variables can be set outside of the code, but can be read by the code, and don't have to be stored (committed to git) with the rest of the files, it's common to use them for configurations or settings. You can also create an environment variable only for a specific program invocation, that is only available to that program, and only for its duration. To do that, create it right before the program itself, on the same line: Tip You can read more about it at The Twelve-Factor App: Config. Types and validation¬∂ These environment variables can only handle text strings, as they are external to Python and have to be compatible with other programs and the rest of the system (and even with different operating systems, as Linux, Windows, macOS). That means that any value read in Python from an environment variable will be a str, and any conversion to a different type or validation has to be done in code. Pydantic Settings¬∂ Fortunately, Pydantic provides a great utility to handle these settings coming from environment variables with Pydantic: Settings management. Install pydantic-settings¬∂ First, install the pydantic-settings package: It also comes included when you install the all extras with: Info In Pydantic v1 it came included with the main package. Now it is distributed as this independent package so that you can choose to install it or not if you don't need that functionality. Create the Settings object¬∂ Import BaseSettings from Pydantic and create a sub-class, very much like with a Pydantic model. The same way as with Pydantic models, you declare class attributes with type annotations, and possibly default values. You can use all the same validation features and tools you use for Pydantic models, like different data types and additional validations with Field(). Pydantic v2 Pydantic v1 from fastapi import FastAPI from pydantic_settings import BaseSettings class Settings(BaseSettings): app_name: str = \"Awesome API\" admin_email: str items_per_user: int = 50 settings = Settings() app = FastAPI() @app.get(\"/info\") async def info(): return { \"app_name\": settings.app_name, \"admin_email\": settings.admin_email, \"items_per_user\": settings.items_per_user, } Tip If you want something quick to copy and paste, don't use this example, use the last one below. Then, when you create an instance of that Settings class (in this case, in the settings object), Pydantic will read the environment variables in a case-insensitive way, so, an upper-case variable APP_NAME will still be read for the attribute app_name. Next it will convert and validate the data. So, when you use that settings object, you will have data of the types you declared (e.g. items_per_user will be an int). Use the settings¬∂ Then you can use the new settings object in your application: from fastapi import FastAPI from pydantic_settings import BaseSettings class Settings(BaseSettings): app_name: str = \"Awesome API\" admin_email: str items_per_user: int = 50 settings = Settings() app = FastAPI() @app.get(\"/info\") async def info(): return { \"app_name\": settings.app_name, \"admin_email\": settings.admin_email, \"items_per_user\": settings.items_per_user, } Run the server¬∂ Next, you would run the server passing the configurations as environment variables, for example you could set an ADMIN_EMAIL and APP_NAME with: Tip To set multiple env vars for a single command just separate them with a space, and put them all before the command. And then the admin_email setting would be set to \"deadpool@example.com\". The app_name would be \"ChimichangApp\". And the items_per_user would keep its default value of 50. Settings in another module¬∂ You could put those settings in another module file as you saw in Bigger Applications - Multiple Files. For example, you could have a file config.py with: from pydantic_settings import BaseSettings class Settings(BaseSettings): app_name: str = \"Awesome API\" admin_email: str items_per_user: int = 50 settings = Settings() And then use it in a file main.py: from fastapi import FastAPI from .config import settings app = FastAPI() @app.get(\"/info\") async def info(): return { \"app_name\": settings.app_name, \"admin_email\": settings.admin_email, \"items_per_user\": settings.items_per_user, } Tip You would also need a file __init__.py as you saw on Bigger Applications - Multiple Files. Settings in a dependency¬∂ In some occasions it might be useful to provide the settings from a dependency, instead of having a global object with settings that is used everywhere. This could be especially useful during testing, as it's very easy to override a dependency with your own custom settings. The config file¬∂ Coming from the previous example, your config.py file could look like: from pydantic_settings import BaseSettings class Settings(BaseSettings): app_name: str = \"Awesome API\" admin_email: str items_per_user: int = 50 Notice that now we don't create a default instance settings = Settings(). The main app file¬∂ Now we create a dependency that returns a new config.Settings(). Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from functools import lru_cache from typing import Annotated from fastapi import Depends, FastAPI from .config import Settings app = FastAPI() @lru_cache def get_settings(): return Settings() @app.get(\"/info\") async def info(settings: Annotated[Settings, Depends(get_settings)]): return { \"app_name\": settings.app_name, \"admin_email\": settings.admin_email, \"items_per_user\": settings.items_per_user, } Tip We'll discuss the @lru_cache in a bit. For now you can assume get_settings() is a normal function. And then we can require it from the path operation function as a dependency and use it anywhere we need it. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from functools import lru_cache from typing import Annotated from fastapi import Depends, FastAPI from .config import Settings app = FastAPI() @lru_cache def get_settings(): return Settings() @app.get(\"/info\") async def info(settings: Annotated[Settings, Depends(get_settings)]): return { \"app_name\": settings.app_name, \"admin_email\": settings.admin_email, \"items_per_user\": settings.items_per_user, } Settings and testing¬∂ Then it would be very easy to provide a different settings object during testing by creating a dependency override for get_settings: from fastapi.testclient import TestClient from .config import Settings from .main import app, get_settings client = TestClient(app) def get_settings_override(): return Settings(admin_email=\"testing_admin@example.com\") app.dependency_overrides[get_settings] = get_settings_override def test_app(): response = client.get(\"/info\") data = response.json() assert data == { \"app_name\": \"Awesome API\", \"admin_email\": \"testing_admin@example.com\", \"items_per_user\": 50, } In the dependency override we set a new value for the admin_email when creating the new Settings object, and then we return that new object. Then we can test that it is used. Reading a .env file¬∂ If you have many settings that possibly change a lot, maybe in different environments, it might be useful to put them on a file and then read them from it as if they were environment variables. This practice is common enough that it has a name, these environment variables are commonly placed in a file .env, and the file is called a \"dotenv\". Tip A file starting with a dot (.) is a hidden file in Unix-like systems, like Linux and macOS. But a dotenv file doesn't really have to have that exact filename. Pydantic has support for reading from these types of files using an external library. You can read more at Pydantic Settings: Dotenv (.env) support. Tip For this to work, you need to pip install python-dotenv. The .env file¬∂ You could have a .env file with: ADMIN_EMAIL=\"deadpool@example.com\" APP_NAME=\"ChimichangApp\" Read settings from .env¬∂ And then update your config.py with: Pydantic v2 Pydantic v1 from pydantic_settings import BaseSettings, SettingsConfigDict class Settings(BaseSettings): app_name: str = \"Awesome API\" admin_email: str items_per_user: int = 50 model_config = SettingsConfigDict(env_file=\".env\") Tip The model_config attribute is used just for Pydantic configuration. You can read more at Pydantic Model Config. Info In Pydantic version 1 the configuration was done in an internal class Config, in Pydantic version 2 it's done in an attribute model_config. This attribute takes a dict, and to get autocompletion and inline errors you can import and use SettingsConfigDict to define that dict. Here we define the config env_file inside of your Pydantic Settings class, and set the value to the filename with the dotenv file we want to use. Creating the Settings only once with lru_cache¬∂ Reading a file from disk is normally a costly (slow) operation, so you probably want to do it only once and then re-use the same settings object, instead of reading it for each request. But every time we do: Settings() a new Settings object would be created, and at creation it would read the .env file again. If the dependency function was just like: def get_settings(): return Settings() we would create that object for each request, and we would be reading the .env file for each request. ‚ö†Ô∏è But as we are using the @lru_cache decorator on top, the Settings object will be created only once, the first time it's called. ‚úîÔ∏è Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from functools import lru_cache from fastapi import Depends, FastAPI from typing_extensions import Annotated from . import config app = FastAPI() @lru_cache def get_settings(): return config.Settings() @app.get(\"/info\") async def info(settings: Annotated[config.Settings, Depends(get_settings)]): return { \"app_name\": settings.app_name, \"admin_email\": settings.admin_email, \"items_per_user\": settings.items_per_user, } Then for any subsequent calls of get_settings() in the dependencies for the next requests, instead of executing the internal code of get_settings() and creating a new Settings object, it will return the same object that was returned on the first call, again and again. lru_cache Technical Details¬∂ @lru_cache modifies the function it decorates to return the same value that was returned the first time, instead of computing it again, executing the code of the function every time. So, the function below it will be executed once for each combination of arguments. And then the values returned by each of those combinations of arguments will be used again and again whenever the function is called with exactly the same combination of arguments. For example, if you have a function: @lru_cache def say_hi(name: str, salutation: str = \"Ms.\"): return f\"Hello {salutation} {name}\" your program could execute like this: In the case of our dependency get_settings(), the function doesn't even take any arguments, so it always returns the same value. That way, it behaves almost as if it was just a global variable. But as it uses a dependency function, then we can override it easily for testing. @lru_cache is part of functools which is part of Python's standard library, you can read more about it in the Python docs for @lru_cache. Recap¬∂ You can use Pydantic Settings to handle the settings or configurations for your application, with all the power of Pydantic models. By using a dependency you can simplify testing. You can use .env files with it. Using @lru_cache lets you avoid reading the dotenv file again and again for each request, while allowing you to override it during testing. Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI Webhooks - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/openapi-webhooks/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI OpenAPI Webhooks en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Webhooks steps Documenting webhooks with FastAPI and OpenAPI An app with webhooks Check the docs FastAPI Learn Advanced User Guide OpenAPI Webhooks¬∂ There are cases where you want to tell your API users that your app could call their app (sending a request) with some data, normally to notify of some type of event. This means that instead of the normal process of your users sending requests to your API, it's your API (or your app) that could send requests to their system (to their API, their app). This is normally called a webhook. Webhooks steps¬∂ The process normally is that you define in your code what is the message that you will send, the body of the request. You also define in some way at which moments your app will send those requests or events. And your users define in some way (for example in a web dashboard somewhere) the URL where your app should send those requests. All the logic about how to register the URLs for webhooks and the code to actually send those requests is up to you. You write it however you want to in your own code. Documenting webhooks with FastAPI and OpenAPI¬∂ With FastAPI, using OpenAPI, you can define the names of these webhooks, the types of HTTP operations that your app can send (e.g. POST, PUT, etc.) and the request bodies that your app would send. This can make it a lot easier for your users to implement their APIs to receive your webhook requests, they might even be able to autogenerate some of their own API code. Info Webhooks are available in OpenAPI 3.1.0 and above, supported by FastAPI 0.99.0 and above. An app with webhooks¬∂ When you create a FastAPI application, there is a webhooks attribute that you can use to define webhooks, the same way you would define path operations, for example with @app.webhooks.post(). from datetime import datetime from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Subscription(BaseModel): username: str monthly_fee: float start_date: datetime @app.webhooks.post(\"new-subscription\") def new_subscription(body: Subscription): \"\"\" When a new user subscribes to your service we'll send you a POST request with this data to the URL that you register for the event `new-subscription` in the dashboard. \"\"\" @app.get(\"/users/\") def read_users(): return [\"Rick\", \"Morty\"] The webhooks that you define will end up in the OpenAPI schema and the automatic docs UI. Info The app.webhooks object is actually just an APIRouter, the same type you would use when structuring your app with multiple files. Notice that with webhooks you are actually not declaring a path (like /items/), the text you pass there is just an identifier of the webhook (the name of the event), for example in @app.webhooks.post(\"new-subscription\"), the webhook name is new-subscription. This is because it is expected that your users would define the actual URL path where they want to receive the webhook request in some other way (e.g. a web dashboard). Check the docs¬∂ Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs. You will see your docs have the normal path operations and now also some webhooks: Made with Material for MkDocs Insiders"
  },
  {
    "title": "OpenAPI Callbacks - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/openapi-callbacks/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI OpenAPI Callbacks en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents An app with callbacks The normal FastAPI app Documenting the callback Write the callback documentation code Create a callback APIRouter Create the callback path operation The callback path expression Add the callback router Check the docs FastAPI Learn Advanced User Guide OpenAPI Callbacks¬∂ You could create an API with a path operation that could trigger a request to an external API created by someone else (probably the same developer that would be using your API). The process that happens when your API app calls the external API is named a \"callback\". Because the software that the external developer wrote sends a request to your API and then your API calls back, sending a request to an external API (that was probably created by the same developer). In this case, you could want to document how that external API should look like. What path operation it should have, what body it should expect, what response it should return, etc. An app with callbacks¬∂ Let's see all this with an example. Imagine you develop an app that allows creating invoices. These invoices will have an id, title (optional), customer, and total. The user of your API (an external developer) will create an invoice in your API with a POST request. Then your API will (let's imagine): Send the invoice to some customer of the external developer. Collect the money. Send a notification back to the API user (the external developer). This will be done by sending a POST request (from your API) to some external API provided by that external developer (this is the \"callback\"). The normal FastAPI app¬∂ Let's first see how the normal API app would look like before adding the callback. It will have a path operation that will receive an Invoice body, and a query parameter callback_url that will contain the URL for the callback. This part is pretty normal, most of the code is probably already familiar to you: from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union[str, None] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices_callback_router = APIRouter() @invoices_callback_router.post( \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} Tip The callback_url query parameter uses a Pydantic URL type. The only new thing is the callbacks=messages_callback_router.routes as an argument to the path operation decorator. We'll see what that is next. Documenting the callback¬∂ The actual callback code will depend heavily on your own API app. And it will probably vary a lot from one app to the next. It could be just one or two lines of code, like: callback_url = \"https://example.com/api/v1/invoices/events/\" httpx.post(callback_url, json={\"description\": \"Invoice paid\", \"paid\": True}) But possibly the most important part of the callback is making sure that your API user (the external developer) implements the external API correctly, according to the data that your API is going to send in the request body of the callback, etc. So, what we will do next is add the code to document how that external API should look like to receive the callback from your API. That documentation will show up in the Swagger UI at /docs in your API, and it will let external developers know how to build the external API. This example doesn't implement the callback itself (that could be just a line of code), only the documentation part. Tip The actual callback is just an HTTP request. When implementing the callback yourself, you could use something like HTTPX or Requests. Write the callback documentation code¬∂ This code won't be executed in your app, we only need it to document how that external API should look like. But, you already know how to easily create automatic documentation for an API with FastAPI. So we are going to use that same knowledge to document how the external API should look like... by creating the path operation(s) that the external API should implement (the ones your API will call). Tip When writing the code to document a callback, it might be useful to imagine that you are that external developer. And that you are currently implementing the external API, not your API. Temporarily adopting this point of view (of the external developer) can help you feel like it's more obvious where to put the parameters, the Pydantic model for the body, for the response, etc. for that external API. Create a callback APIRouter¬∂ First create a new APIRouter that will contain one or more callbacks. from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union[str, None] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices_callback_router = APIRouter() @invoices_callback_router.post( \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} Create the callback path operation¬∂ To create the callback path operation use the same APIRouter you created above. It should look just like a normal FastAPI path operation: It should probably have a declaration of the body it should receive, e.g. body: InvoiceEvent. And it could also have a declaration of the response it should return, e.g. response_model=InvoiceEventReceived. from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union[str, None] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices_callback_router = APIRouter() @invoices_callback_router.post( \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} There are 2 main differences from a normal path operation: It doesn't need to have any actual code, because your app will never call this code. It's only used to document the external API. So, the function could just have pass. The path can contain an OpenAPI 3 expression (see more below) where it can use variables with parameters and parts of the original request sent to your API. The callback path expression¬∂ The callback path can have an OpenAPI 3 expression that can contain parts of the original request sent to your API. In this case, it's the str: \"{$callback_url}/invoices/{$request.body.id}\" So, if your API user (the external developer) sends a request to your API to: https://yourapi.com/invoices/?callback_url=https://www.external.org/events with a JSON body of: { \"id\": \"2expen51ve\", \"customer\": \"Mr. Richie Rich\", \"total\": \"9999\" } Then your API will process the invoice, and at some point later, send a callback request to the callback_url (the external API): https://www.external.org/events/invoices/2expen51ve with a JSON body containing something like: { \"description\": \"Payment celebration\", \"paid\": true } and it would expect a response from that external API with a JSON body like: { \"ok\": true } Tip Notice how the callback URL used contains the URL received as a query parameter in callback_url (https://www.external.org/events) and also the invoice id from inside of the JSON body (2expen51ve). Add the callback router¬∂ At this point you have the callback path operation(s) needed (the one(s) that the external developer should implement in the external API) in the callback router you created above. Now use the parameter callbacks in your API's path operation decorator to pass the attribute .routes (that's actually just a list of routes/path operations) from that callback router: from typing import Union from fastapi import APIRouter, FastAPI from pydantic import BaseModel, HttpUrl app = FastAPI() class Invoice(BaseModel): id: str title: Union[str, None] = None customer: str total: float class InvoiceEvent(BaseModel): description: str paid: bool class InvoiceEventReceived(BaseModel): ok: bool invoices_callback_router = APIRouter() @invoices_callback_router.post( \"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived ) def invoice_notification(body: InvoiceEvent): pass @app.post(\"/invoices/\", callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None): \"\"\" Create an invoice. This will (let's imagine) let the API user (some external developer) create an invoice. And this path operation will: * Send the invoice to the client. * Collect the money from the client. * Send a notification back to the API user (the external developer), as a callback. * At this point is that the API will somehow send a POST request to the external API with the notification of the invoice event (e.g. \"payment successful\"). \"\"\" # Send the invoice, collect the money, send the notification (the callback) return {\"msg\": \"Invoice received\"} Tip Notice that you are not passing the router itself (invoices_callback_router) to callback=, but the attribute .routes, as in invoices_callback_router.routes. Check the docs¬∂ Now you can start your app with Uvicorn and go to http://127.0.0.1:8000/docs. You will see your docs including a \"Callback\" section for your path operation that shows how the external API should look like: Made with Material for MkDocs Insiders"
  },
  {
    "title": "Async Tests - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/async-tests/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Async Tests en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents pytest.mark.anyio HTTPX Example Run it In Detail Other Asynchronous Function Calls FastAPI Learn Advanced User Guide Async Tests¬∂ You have already seen how to test your FastAPI applications using the provided TestClient. Up to now, you have only seen how to write synchronous tests, without using async functions. Being able to use asynchronous functions in your tests could be useful, for example, when you're querying your database asynchronously. Imagine you want to test sending requests to your FastAPI application and then verify that your backend successfully wrote the correct data in the database, while using an async database library. Let's look at how we can make that work. pytest.mark.anyio¬∂ If we want to call asynchronous functions in our tests, our test functions have to be asynchronous. AnyIO provides a neat plugin for this, that allows us to specify that some test functions are to be called asynchronously. HTTPX¬∂ Even if your FastAPI application uses normal def functions instead of async def, it is still an async application underneath. The TestClient does some magic inside to call the asynchronous FastAPI application in your normal def test functions, using standard pytest. But that magic doesn't work anymore when we're using it inside asynchronous functions. By running our tests asynchronously, we can no longer use the TestClient inside our test functions. The TestClient is based on HTTPX, and luckily, we can use it directly to test the API. Example¬∂ For a simple example, let's consider a file structure similar to the one described in Bigger Applications and Testing: . ‚îú‚îÄ‚îÄ app ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py The file main.py would have: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def root(): return {\"message\": \"Tomato\"} The file test_main.py would have the tests for main.py, it could look like this now: import pytest from httpx import AsyncClient from .main import app @pytest.mark.anyio async def test_root(): async with AsyncClient(app=app, base_url=\"http://test\") as ac: response = await ac.get(\"/\") assert response.status_code == 200 assert response.json() == {\"message\": \"Tomato\"} Run it¬∂ You can run your tests as usual via: In Detail¬∂ The marker @pytest.mark.anyio tells pytest that this test function should be called asynchronously: import pytest from httpx import AsyncClient from .main import app @pytest.mark.anyio async def test_root(): async with AsyncClient(app=app, base_url=\"http://test\") as ac: response = await ac.get(\"/\") assert response.status_code == 200 assert response.json() == {\"message\": \"Tomato\"} Tip Note that the test function is now async def instead of just def as before when using the TestClient. Then we can create an AsyncClient with the app, and send async requests to it, using await. import pytest from httpx import AsyncClient from .main import app @pytest.mark.anyio async def test_root(): async with AsyncClient(app=app, base_url=\"http://test\") as ac: response = await ac.get(\"/\") assert response.status_code == 200 assert response.json() == {\"message\": \"Tomato\"} This is the equivalent to: response = client.get('/') ...that we used to make our requests with the TestClient. Tip Note that we're using async/await with the new AsyncClient - the request is asynchronous. Other Asynchronous Function Calls¬∂ As the testing function is now asynchronous, you can now also call (and await) other async functions apart from sending requests to your FastAPI application in your tests, exactly as you would call them anywhere else in your code. Tip If you encounter a RuntimeError: Task attached to a different loop when integrating asynchronous function calls in your tests (e.g. when using MongoDB's MotorClient) Remember to instantiate objects that need an event loop only within async functions, e.g. an '@app.on_event(\"startup\") callback. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing a Database - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-database/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Testing a Database en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Add tests for the SQL app File structure Create the new database session Create the database Dependency override Test the app FastAPI Learn Advanced User Guide Testing a Database¬∂ Info These docs are about to be updated. üéâ The current version assumes Pydantic v1, and SQLAlchemy versions less than 2.0. The new docs will include Pydantic v2 and will use SQLModel (which is also based on SQLAlchemy) once it is updated to use Pydantic v2 as well. You can use the same dependency overrides from Testing Dependencies with Overrides to alter a database for testing. You could want to set up a different database for testing, rollback the data after the tests, pre-fill it with some testing data, etc. The main idea is exactly the same you saw in that previous chapter. Add tests for the SQL app¬∂ Let's update the example from SQL (Relational) Databases to use a testing database. All the app code is the same, you can go back to that chapter check how it was. The only changes here are in the new testing file. Your normal dependency get_db() would return a database session. In the test, you could use a dependency override to return your custom database session instead of the one that would be used normally. In this example we'll create a temporary database only for the tests. File structure¬∂ We create a new file at sql_app/tests/test_sql_app.py. So the new file structure looks like: . ‚îî‚îÄ‚îÄ sql_app ‚îú‚îÄ‚îÄ __init__.py ‚îú‚îÄ‚îÄ crud.py ‚îú‚îÄ‚îÄ database.py ‚îú‚îÄ‚îÄ main.py ‚îú‚îÄ‚îÄ models.py ‚îú‚îÄ‚îÄ schemas.py ‚îî‚îÄ‚îÄ tests ‚îú‚îÄ‚îÄ __init__.py ‚îî‚îÄ‚îÄ test_sql_app.py Create the new database session¬∂ First, we create a new database session with the new database. We'll use an in-memory database that persists during the tests instead of the local file sql_app.db. But the rest of the session code is more or less the same, we just copy it. from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get_db SQLALCHEMY_DATABASE_URL = \"sqlite://\" engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create_all(bind=engine) def override_get_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency_overrides[get_db] = override_get_db client = TestClient(app) def test_create_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert \"id\" in data user_id = data[\"id\"] response = client.get(f\"/users/{user_id}\") assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert data[\"id\"] == user_id Tip You could reduce duplication in that code by putting it in a function and using it from both database.py and tests/test_sql_app.py. For simplicity and to focus on the specific testing code, we are just copying it. Create the database¬∂ Because now we are going to use a new database in a new file, we need to make sure we create the database with: Base.metadata.create_all(bind=engine) That is normally called in main.py, but the line in main.py uses the database file sql_app.db, and we need to make sure we create test.db for the tests. So we add that line here, with the new file. from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get_db SQLALCHEMY_DATABASE_URL = \"sqlite://\" engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create_all(bind=engine) def override_get_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency_overrides[get_db] = override_get_db client = TestClient(app) def test_create_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert \"id\" in data user_id = data[\"id\"] response = client.get(f\"/users/{user_id}\") assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert data[\"id\"] == user_id Dependency override¬∂ Now we create the dependency override and add it to the overrides for our app. from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get_db SQLALCHEMY_DATABASE_URL = \"sqlite://\" engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create_all(bind=engine) def override_get_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency_overrides[get_db] = override_get_db client = TestClient(app) def test_create_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert \"id\" in data user_id = data[\"id\"] response = client.get(f\"/users/{user_id}\") assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert data[\"id\"] == user_id Tip The code for override_get_db() is almost exactly the same as for get_db(), but in override_get_db() we use the TestingSessionLocal for the testing database instead. Test the app¬∂ Then we can just test the app as normally. from fastapi.testclient import TestClient from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.pool import StaticPool from ..database import Base from ..main import app, get_db SQLALCHEMY_DATABASE_URL = \"sqlite://\" engine = create_engine( SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}, poolclass=StaticPool, ) TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) Base.metadata.create_all(bind=engine) def override_get_db(): try: db = TestingSessionLocal() yield db finally: db.close() app.dependency_overrides[get_db] = override_get_db client = TestClient(app) def test_create_user(): response = client.post( \"/users/\", json={\"email\": \"deadpool@example.com\", \"password\": \"chimichangas4life\"}, ) assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert \"id\" in data user_id = data[\"id\"] response = client.get(f\"/users/{user_id}\") assert response.status_code == 200, response.text data = response.json() assert data[\"email\"] == \"deadpool@example.com\" assert data[\"id\"] == user_id And all the modifications we made in the database during the tests will be in the test.db database instead of the main sql_app.db. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing Dependencies with Overrides - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-dependencies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Testing Dependencies with Overrides en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Overriding dependencies during testing Use cases: external service Use the app.dependency_overrides attribute FastAPI Learn Advanced User Guide Testing Dependencies with Overrides¬∂ Overriding dependencies during testing¬∂ There are some scenarios where you might want to override a dependency during testing. You don't want the original dependency to run (nor any of the sub-dependencies it might have). Instead, you want to provide a different dependency that will be used only during tests (possibly only some specific tests), and will provide a value that can be used where the value of the original dependency was used. Use cases: external service¬∂ An example could be that you have an external authentication provider that you need to call. You send it a token and it returns an authenticated user. This provider might be charging you per request, and calling it might take some extra time than if you had a fixed mock user for tests. You probably want to test the external provider once, but not necessarily call it for every test that runs. In this case, you can override the dependency that calls that provider, and use a custom dependency that returns a mock user, only for your tests. Use the app.dependency_overrides attribute¬∂ For these cases, your FastAPI application has an attribute app.dependency_overrides, it is a simple dict. To override a dependency for testing, you put as a key the original dependency (a function), and as the value, your dependency override (another function). And then FastAPI will call that override instead of the original dependency. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.testclient import TestClient app = FastAPI() async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read_items(commons: Annotated[dict, Depends(common_parameters)]): return {\"message\": \"Hello Items!\", \"params\": commons} @app.get(\"/users/\") async def read_users(commons: Annotated[dict, Depends(common_parameters)]): return {\"message\": \"Hello Users!\", \"params\": commons} client = TestClient(app) async def override_dependency(q: str | None = None): return {\"q\": q, \"skip\": 5, \"limit\": 10} app.dependency_overrides[common_parameters] = override_dependency def test_override_in_items(): response = client.get(\"/items/\") assert response.status_code == 200 assert response.json() == { \"message\": \"Hello Items!\", \"params\": {\"q\": None, \"skip\": 5, \"limit\": 10}, } def test_override_in_items_with_q(): response = client.get(\"/items/?q=foo\") assert response.status_code == 200 assert response.json() == { \"message\": \"Hello Items!\", \"params\": {\"q\": \"foo\", \"skip\": 5, \"limit\": 10}, } def test_override_in_items_with_params(): response = client.get(\"/items/?q=foo&skip=100&limit=200\") assert response.status_code == 200 assert response.json() == { \"message\": \"Hello Items!\", \"params\": {\"q\": \"foo\", \"skip\": 5, \"limit\": 10}, } Tip You can set a dependency override for a dependency used anywhere in your FastAPI application. The original dependency could be used in a path operation function, a path operation decorator (when you don't use the return value), a .include_router() call, etc. FastAPI will still be able to override it. Then you can reset your overrides (remove them) by setting app.dependency_overrides to be an empty dict: app.dependency_overrides = {} Tip If you want to override a dependency only during some tests, you can set the override at the beginning of the test (inside the test function) and reset it at the end (at the end of the test function). Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing WebSockets - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-websockets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Testing WebSockets en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes FastAPI Learn Advanced User Guide Testing WebSockets¬∂ You can use the same TestClient to test WebSockets. For this, you use the TestClient in a with statement, connecting to the WebSocket: from fastapi import FastAPI from fastapi.testclient import TestClient from fastapi.websockets import WebSocket app = FastAPI() @app.get(\"/\") async def read_main(): return {\"msg\": \"Hello World\"} @app.websocket(\"/ws\") async def websocket(websocket: WebSocket): await websocket.accept() await websocket.send_json({\"msg\": \"Hello WebSocket\"}) await websocket.close() def test_read_main(): client = TestClient(app) response = client.get(\"/\") assert response.status_code == 200 assert response.json() == {\"msg\": \"Hello World\"} def test_websocket(): client = TestClient(app) with client.websocket_connect(\"/ws\") as websocket: data = websocket.receive_json() assert data == {\"msg\": \"Hello WebSocket\"} Note For more details, check Starlette's documentation for testing WebSockets. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Testing Events: startup - shutdown - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/testing-events/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Testing Events: startup - shutdown en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes FastAPI Learn Advanced User Guide Testing Events: startup - shutdown¬∂ When you need your event handlers (startup and shutdown) to run in your tests, you can use the TestClient with a with statement: from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI() items = {} @app.on_event(\"startup\") async def startup_event(): items[\"foo\"] = {\"name\": \"Fighters\"} items[\"bar\"] = {\"name\": \"Tenders\"} @app.get(\"/items/{item_id}\") async def read_items(item_id: str): return items[item_id] def test_read_items(): with TestClient(app) as client: response = client.get(\"/items/foo\") assert response.status_code == 200 assert response.json() == {\"name\": \"Fighters\"} Made with Material for MkDocs Insiders"
  },
  {
    "title": "Lifespan Events - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/events/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Lifespan Events en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use Case Lifespan Lifespan function Async Context Manager Alternative Events (deprecated) startup event shutdown event startup and shutdown together Technical Details Sub Applications FastAPI Learn Advanced User Guide Lifespan Events¬∂ You can define logic (code) that should be executed before the application starts up. This means that this code will be executed once, before the application starts receiving requests. The same way, you can define logic (code) that should be executed when the application is shutting down. In this case, this code will be executed once, after having handled possibly many requests. Because this code is executed before the application starts taking requests, and right after it finishes handling requests, it covers the whole application lifespan (the word \"lifespan\" will be important in a second üòâ). This can be very useful for setting up resources that you need to use for the whole app, and that are shared among requests, and/or that you need to clean up afterwards. For example, a database connection pool, or loading a shared machine learning model. Use Case¬∂ Let's start with an example use case and then see how to solve it with this. Let's imagine that you have some machine learning models that you want to use to handle requests. ü§ñ The same models are shared among requests, so, it's not one model per request, or one per user or something similar. Let's imagine that loading the model can take quite some time, because it has to read a lot of data from disk. So you don't want to do it for every request. You could load it at the top level of the module/file, but that would also mean that it would load the model even if you are just running a simple automated test, then that test would be slow because it would have to wait for the model to load before being able to run an independent part of the code. That's what we'll solve, let's load the model before the requests are handled, but only right before the application starts receiving requests, not while the code is being loaded. Lifespan¬∂ You can define this startup and shutdown logic using the lifespan parameter of the FastAPI app, and a \"context manager\" (I'll show you what that is in a second). Let's start with an example and then see it in detail. We create an async function lifespan() with yield like this: from contextlib import asynccontextmanager from fastapi import FastAPI def fake_answer_to_everything_ml_model(x: float): return x * 42 ml_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model yield # Clean up the ML models and release the resources ml_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml_models[\"answer_to_everything\"](x) return {\"result\": result} Here we are simulating the expensive startup operation of loading the model by putting the (fake) model function in the dictionary with machine learning models before the yield. This code will be executed before the application starts taking requests, during the startup. And then, right after the yield, we unload the model. This code will be executed after the application finishes handling requests, right before the shutdown. This could, for example, release resources like memory or a GPU. Tip The shutdown would happen when you are stopping the application. Maybe you need to start a new version, or you just got tired of running it. ü§∑ Lifespan function¬∂ The first thing to notice, is that we are defining an async function with yield. This is very similar to Dependencies with yield. from contextlib import asynccontextmanager from fastapi import FastAPI def fake_answer_to_everything_ml_model(x: float): return x * 42 ml_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model yield # Clean up the ML models and release the resources ml_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml_models[\"answer_to_everything\"](x) return {\"result\": result} The first part of the function, before the yield, will be executed before the application starts. And the part after the yield will be executed after the application has finished. Async Context Manager¬∂ If you check, the function is decorated with an @asynccontextmanager. That converts the function into something called an \"async context manager\". from contextlib import asynccontextmanager from fastapi import FastAPI def fake_answer_to_everything_ml_model(x: float): return x * 42 ml_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model yield # Clean up the ML models and release the resources ml_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml_models[\"answer_to_everything\"](x) return {\"result\": result} A context manager in Python is something that you can use in a with statement, for example, open() can be used as a context manager: with open(\"file.txt\") as file: file.read() In recent versions of Python, there's also an async context manager. You would use it with async with: async with lifespan(app): await do_stuff() When you create a context manager or an async context manager like above, what it does is that, before entering the with block, it will execute the code before the yield, and after exiting the with block, it will execute the code after the yield. In our code example above, we don't use it directly, but we pass it to FastAPI for it to use it. The lifespan parameter of the FastAPI app takes an async context manager, so we can pass our new lifespan async context manager to it. from contextlib import asynccontextmanager from fastapi import FastAPI def fake_answer_to_everything_ml_model(x: float): return x * 42 ml_models = {} @asynccontextmanager async def lifespan(app: FastAPI): # Load the ML model ml_models[\"answer_to_everything\"] = fake_answer_to_everything_ml_model yield # Clean up the ML models and release the resources ml_models.clear() app = FastAPI(lifespan=lifespan) @app.get(\"/predict\") async def predict(x: float): result = ml_models[\"answer_to_everything\"](x) return {\"result\": result} Alternative Events (deprecated)¬∂ Warning The recommended way to handle the startup and shutdown is using the lifespan parameter of the FastAPI app as described above. You can probably skip this part. There's an alternative way to define this logic to be executed during startup and during shutdown. You can define event handlers (functions) that need to be executed before the application starts up, or when the application is shutting down. These functions can be declared with async def or normal def. startup event¬∂ To add a function that should be run before the application starts, declare it with the event \"startup\": from fastapi import FastAPI app = FastAPI() items = {} @app.on_event(\"startup\") async def startup_event(): items[\"foo\"] = {\"name\": \"Fighters\"} items[\"bar\"] = {\"name\": \"Tenders\"} @app.get(\"/items/{item_id}\") async def read_items(item_id: str): return items[item_id] In this case, the startup event handler function will initialize the items \"database\" (just a dict) with some values. You can add more than one event handler function. And your application won't start receiving requests until all the startup event handlers have completed. shutdown event¬∂ To add a function that should be run when the application is shutting down, declare it with the event \"shutdown\": from fastapi import FastAPI app = FastAPI() @app.on_event(\"shutdown\") def shutdown_event(): with open(\"log.txt\", mode=\"a\") as log: log.write(\"Application shutdown\") @app.get(\"/items/\") async def read_items(): return [{\"name\": \"Foo\"}] Here, the shutdown event handler function will write a text line \"Application shutdown\" to a file log.txt. Info In the open() function, the mode=\"a\" means \"append\", so, the line will be added after whatever is on that file, without overwriting the previous contents. Tip Notice that in this case we are using a standard Python open() function that interacts with a file. So, it involves I/O (input/output), that requires \"waiting\" for things to be written to disk. But open() doesn't use async and await. So, we declare the event handler function with standard def instead of async def. startup and shutdown together¬∂ There's a high chance that the logic for your startup and shutdown is connected, you might want to start something and then finish it, acquire a resource and then release it, etc. Doing that in separated functions that don't share logic or variables together is more difficult as you would need to store values in global variables or similar tricks. Because of that, it's now recommended to instead use the lifespan as explained above. Technical Details¬∂ Just a technical detail for the curious nerds. ü§ì Underneath, in the ASGI technical specification, this is part of the Lifespan Protocol, and it defines events called startup and shutdown. Info You can read more about the Starlette lifespan handlers in Starlette's Lifespan' docs. Including how to handle lifespan state that can be used in other areas of your code. Sub Applications¬∂ üö® Have in mind that these lifespan events (startup and shutdown) will only be executed for the main application, not for Sub Applications - Mounts. Made with Material for MkDocs Insiders"
  },
  {
    "title": "WebSockets - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/websockets/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI WebSockets en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Install WebSockets WebSockets client In production Create a websocket Await for messages and send messages Try it Using Depends and others Try the WebSockets with dependencies Handling disconnections and multiple clients More info FastAPI Learn Advanced User Guide WebSockets¬∂ You can use WebSockets with FastAPI. Install WebSockets¬∂ First you need to install WebSockets: fast ‚Üí WebSockets client¬∂ In production¬∂ In your production system, you probably have a frontend created with a modern framework like React, Vue.js or Angular. And to communicate using WebSockets with your backend you would probably use your frontend's utilities. Or you might have a native mobile application that communicates with your WebSocket backend directly, in native code. Or you might have any other way to communicate with the WebSocket endpoint. But for this example, we'll use a very simple HTML document with some JavaScript, all inside a long string. This, of course, is not optimal and you wouldn't use it for production. In production you would have one of the options above. But it's the simplest way to focus on the server-side of WebSockets and have a working example: from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Send var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws\") async def websocket_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive_text() await websocket.send_text(f\"Message text was: {data}\") Create a websocket¬∂ In your FastAPI application, create a websocket: from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Send var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws\") async def websocket_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive_text() await websocket.send_text(f\"Message text was: {data}\") Technical Details You could also use from starlette.websockets import WebSocket. FastAPI provides the same WebSocket directly just as a convenience for you, the developer. But it comes directly from Starlette. Await for messages and send messages¬∂ In your WebSocket route you can await for messages and send messages. from fastapi import FastAPI, WebSocket from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Send var ws = new WebSocket(\"ws://localhost:8000/ws\"); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws\") async def websocket_endpoint(websocket: WebSocket): await websocket.accept() while True: data = await websocket.receive_text() await websocket.send_text(f\"Message text was: {data}\") You can receive and send binary, text, and JSON data. Try it¬∂ If your file is named main.py, run your application with: Open your browser at http://127.0.0.1:8000. You will see a simple page like: You can type messages in the input box, and send them: And your FastAPI application with WebSockets will respond back: You can send (and receive) many messages: And all of them will use the same WebSocket connection. Using Depends and others¬∂ In WebSocket endpoints you can import from fastapi and use: Depends Security Cookie Header Path Query They work the same way as for other FastAPI endpoints/path operations: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import ( Cookie, Depends, FastAPI, Query, WebSocket, WebSocketException, status, ) from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Item ID: Token: Connect * * * Message: Send var ws = null; function connect(event) { var itemId = document.getElementById(\"itemId\") var token = document.getElementById(\"token\") ws = new WebSocket(\"ws://localhost:8000/items/\" + itemId.value + \"/ws?token=\" + token.value); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; event.preventDefault() } function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" @app.get(\"/\") async def get(): return HTMLResponse(html) async def get_cookie_or_token( websocket: WebSocket, session: Annotated[str | None, Cookie()] = None, token: Annotated[str | None, Query()] = None, ): if session is None and token is None: raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION) return session or token @app.websocket(\"/items/{item_id}/ws\") async def websocket_endpoint( *, websocket: WebSocket, item_id: str, q: int | None = None, cookie_or_token: Annotated[str, Depends(get_cookie_or_token)], ): await websocket.accept() while True: data = await websocket.receive_text() await websocket.send_text( f\"Session cookie or query token value is: {cookie_or_token}\" ) if q is not None: await websocket.send_text(f\"Query parameter q is: {q}\") await websocket.send_text(f\"Message text was: {data}, for item ID: {item_id}\") Info As this is a WebSocket it doesn't really make sense to raise an HTTPException, instead we raise a WebSocketException. You can use a closing code from the valid codes defined in the specification. Try the WebSockets with dependencies¬∂ If your file is named main.py, run your application with: Open your browser at http://127.0.0.1:8000. There you can set: The \"Item ID\", used in the path. The \"Token\" used as a query parameter. Tip Notice that the query token will be handled by a dependency. With that you can connect the WebSocket and then send and receive messages: Handling disconnections and multiple clients¬∂ When a WebSocket connection is closed, the await websocket.receive_text() will raise a WebSocketDisconnect exception, which you can then catch and handle like in this example. Python 3.9+ Python 3.8+ from fastapi import FastAPI, WebSocket, WebSocketDisconnect from fastapi.responses import HTMLResponse app = FastAPI() html = \"\"\" Chat WebSocket Chat ============== Your ID: -------- Send var client_id = Date.now() document.querySelector(\"#ws-id\").textContent = client_id; var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`); ws.onmessage = function(event) { var messages = document.getElementById('messages') var message = document.createElement('li') var content = document.createTextNode(event.data) message.appendChild(content) messages.appendChild(message) }; function sendMessage(event) { var input = document.getElementById(\"messageText\") ws.send(input.value) input.value = '' event.preventDefault() } \"\"\" class ConnectionManager: def __init__(self): self.active_connections: list[WebSocket] = [] async def connect(self, websocket: WebSocket): await websocket.accept() self.active_connections.append(websocket) def disconnect(self, websocket: WebSocket): self.active_connections.remove(websocket) async def send_personal_message(self, message: str, websocket: WebSocket): await websocket.send_text(message) async def broadcast(self, message: str): for connection in self.active_connections: await connection.send_text(message) manager = ConnectionManager() @app.get(\"/\") async def get(): return HTMLResponse(html) @app.websocket(\"/ws/{client_id}\") async def websocket_endpoint(websocket: WebSocket, client_id: int): await manager.connect(websocket) try: while True: data = await websocket.receive_text() await manager.send_personal_message(f\"You wrote: {data}\", websocket) await manager.broadcast(f\"Client #{client_id} says: {data}\") except WebSocketDisconnect: manager.disconnect(websocket) await manager.broadcast(f\"Client #{client_id} left the chat\") To try it out: Open the app with several browser tabs. Write messages from them. Then close one of the tabs. That will raise the WebSocketDisconnect exception, and all the other clients will receive a message like: Client #1596980209979 left the chat Tip The app above is a minimal and simple example to demonstrate how to handle and broadcast messages to several WebSocket connections. But have in mind that, as everything is handled in memory, in a single list, it will only work while the process is running, and will only work with a single process. If you need something easy to integrate with FastAPI but that is more robust, supported by Redis, PostgreSQL or others, check encode/broadcaster. More info¬∂ To learn more about the options, check Starlette's documentation for: The WebSocket class. Class-based WebSocket handling. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Templates - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/templates/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Templates en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Install dependencies Using Jinja2Templates Writing templates Templates and static files More details FastAPI Learn Advanced User Guide Templates¬∂ You can use any template engine you want with FastAPI. A common choice is Jinja2, the same one used by Flask and other tools. There are utilities to configure it easily that you can use directly in your FastAPI application (provided by Starlette). Install dependencies¬∂ Install jinja2: fast ‚Üí Using Jinja2Templates¬∂ Import Jinja2Templates. Create a templates object that you can re-use later. Declare a Request parameter in the path operation that will return a template. Use the templates you created to render and return a TemplateResponse, pass the name of the template, the request object, and a \"context\" dictionary with key-value pairs to be used inside of the Jinja2 template. from fastapi import FastAPI, Request from fastapi.responses import HTMLResponse from fastapi.staticfiles import StaticFiles from fastapi.templating import Jinja2Templates app = FastAPI() app.mount(\"/static\", StaticFiles(directory=\"static\"), name=\"static\") templates = Jinja2Templates(directory=\"templates\") @app.get(\"/items/{id}\", response_class=HTMLResponse) async def read_item(request: Request, id: str): return templates.TemplateResponse( request=request, name=\"item.html\", context={\"id\": id} ) Note Before FastAPI 0.108.0, Starlette 0.29.0, the name was the first parameter. Also, before that, in previous versions, the request object was passed as part of the key-value pairs in the context for Jinja2. Tip By declaring response_class=HTMLResponse the docs UI will be able to know that the response will be HTML. Technical Details You could also use from starlette.templating import Jinja2Templates. FastAPI provides the same starlette.templating as fastapi.templating just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with Request and StaticFiles. Writing templates¬∂ Then you can write a template at templates/item.html with: Item Details Item ID: {{ id }} ================= It will show the id taken from the \"context\" dict you passed: {\"request\": request, \"id\": id} Templates and static files¬∂ You can also use url_for() inside of the template, and use it, for example, with the StaticFiles you mounted. Item Details Item ID: {{ id }} ================= In this example, it would link to a CSS file at static/styles.css with: h1 { color: green; } And because you are using StaticFiles, that CSS file would be served automatically by your FastAPI application at the URL /static/styles.css. More details¬∂ For more details, including how to test templates, check Starlette's docs on templates. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Behind a Proxy - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/behind-a-proxy/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Behind a Proxy en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Proxy with a stripped path prefix Providing the root_path Checking the current root_path Setting the root_path in the FastAPI app About root_path About proxies with a stripped path prefix Testing locally with Traefik Check the responses Check the docs UI Additional servers Disable automatic server from root_path Mounting a sub-application FastAPI Learn Advanced User Guide Behind a Proxy¬∂ In some situations, you might need to use a proxy server like Traefik or Nginx with a configuration that adds an extra path prefix that is not seen by your application. In these cases you can use root_path to configure your application. The root_path is a mechanism provided by the ASGI specification (that FastAPI is built on, through Starlette). The root_path is used to handle these specific cases. And it's also used internally when mounting sub-applications. Proxy with a stripped path prefix¬∂ Having a proxy with a stripped path prefix, in this case, means that you could declare a path at /app in your code, but then, you add a layer on top (the proxy) that would put your FastAPI application under a path like /api/v1. In this case, the original path /app would actually be served at /api/v1/app. Even though all your code is written assuming there's just /app. And the proxy would be \"stripping\" the path prefix on the fly before transmitting the request to Uvicorn, keep your application convinced that it is serving at /app, so that you don't have to update all your code to include the prefix /api/v1. Up to here, everything would work as normally. But then, when you open the integrated docs UI (the frontend), it would expect to get the OpenAPI schema at /openapi.json, instead of /api/v1/openapi.json. So, the frontend (that runs in the browser) would try to reach /openapi.json and wouldn't be able to get the OpenAPI schema. Because we have a proxy with a path prefix of /api/v1 for our app, the frontend needs to fetch the OpenAPI schema at /api/v1/openapi.json. Tip The IP 0.0.0.0 is commonly used to mean that the program listens on all the IPs available in that machine/server. The docs UI would also need the OpenAPI schema to declare that this API server is located at /api/v1 (behind the proxy). For example: { \"openapi\": \"3.1.0\", // More stuff here \"servers\": [ { \"url\": \"/api/v1\" } ], \"paths\": { // More stuff here } } In this example, the \"Proxy\" could be something like Traefik. And the server would be something like Uvicorn, running your FastAPI application. Providing the root_path¬∂ To achieve this, you can use the command line option --root-path like: If you use Hypercorn, it also has the option --root-path. Technical Details The ASGI specification defines a root_path for this use case. And the --root-path command line option provides that root_path. Checking the current root_path¬∂ You can get the current root_path used by your application for each request, it is part of the scope dictionary (that's part of the ASGI spec). Here we are including it in the message just for demonstration purposes. from fastapi import FastAPI, Request app = FastAPI() @app.get(\"/app\") def read_main(request: Request): return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")} Then, if you start Uvicorn with: The response would be something like: { \"message\": \"Hello World\", \"root_path\": \"/api/v1\" } Setting the root_path in the FastAPI app¬∂ Alternatively, if you don't have a way to provide a command line option like --root-path or equivalent, you can set the root_path parameter when creating your FastAPI app: from fastapi import FastAPI, Request app = FastAPI(root_path=\"/api/v1\") @app.get(\"/app\") def read_main(request: Request): return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")} Passing the root_path to FastAPI would be the equivalent of passing the --root-path command line option to Uvicorn or Hypercorn. About root_path¬∂ Have in mind that the server (Uvicorn) won't use that root_path for anything else than passing it to the app. But if you go with your browser to http://127.0.0.1:8000/app you will see the normal response: { \"message\": \"Hello World\", \"root_path\": \"/api/v1\" } So, it won't expect to be accessed at http://127.0.0.1:8000/api/v1/app. Uvicorn will expect the proxy to access Uvicorn at http://127.0.0.1:8000/app, and then it would be the proxy's responsibility to add the extra /api/v1 prefix on top. About proxies with a stripped path prefix¬∂ Have in mind that a proxy with stripped path prefix is only one of the ways to configure it. Probably in many cases the default will be that the proxy doesn't have a stripped path prefix. In a case like that (without a stripped path prefix), the proxy would listen on something like https://myawesomeapp.com, and then if the browser goes to https://myawesomeapp.com/api/v1/app and your server (e.g. Uvicorn) listens on http://127.0.0.1:8000 the proxy (without a stripped path prefix) would access Uvicorn at the same path: http://127.0.0.1:8000/api/v1/app. Testing locally with Traefik¬∂ You can easily run the experiment locally with a stripped path prefix using Traefik. Download Traefik, it's a single binary, you can extract the compressed file and run it directly from the terminal. Then create a file traefik.toml with: [entryPoints] [entryPoints.http] address = \":9999\" [providers] [providers.file] filename = \"routes.toml\" This tells Traefik to listen on port 9999 and to use another file routes.toml. Tip We are using port 9999 instead of the standard HTTP port 80 so that you don't have to run it with admin (sudo) privileges. Now create that other file routes.toml: [http] [http.middlewares] [http.middlewares.api-stripprefix.stripPrefix] prefixes = [\"/api/v1\"] [http.routers] [http.routers.app-http] entryPoints = [\"http\"] service = \"app\" rule = \"PathPrefix(`/api/v1`)\" middlewares = [\"api-stripprefix\"] [http.services] [http.services.app] [http.services.app.loadBalancer] [[http.services.app.loadBalancer.servers]] url = \"http://127.0.0.1:8000\" This file configures Traefik to use the path prefix /api/v1. And then it will redirect its requests to your Uvicorn running on http://127.0.0.1:8000. Now start Traefik: And now start your app with Uvicorn, using the --root-path option: Check the responses¬∂ Now, if you go to the URL with the port for Uvicorn: http://127.0.0.1:8000/app, you will see the normal response: { \"message\": \"Hello World\", \"root_path\": \"/api/v1\" } Tip Notice that even though you are accessing it at http://127.0.0.1:8000/app it shows the root_path of /api/v1, taken from the option --root-path. And now open the URL with the port for Traefik, including the path prefix: http://127.0.0.1:9999/api/v1/app. We get the same response: { \"message\": \"Hello World\", \"root_path\": \"/api/v1\" } but this time at the URL with the prefix path provided by the proxy: /api/v1. Of course, the idea here is that everyone would access the app through the proxy, so the version with the path prefix /api/v1 is the \"correct\" one. And the version without the path prefix (http://127.0.0.1:8000/app), provided by Uvicorn directly, would be exclusively for the proxy (Traefik) to access it. That demonstrates how the Proxy (Traefik) uses the path prefix and how the server (Uvicorn) uses the root_path from the option --root-path. Check the docs UI¬∂ But here's the fun part. ‚ú® The \"official\" way to access the app would be through the proxy with the path prefix that we defined. So, as we would expect, if you try the docs UI served by Uvicorn directly, without the path prefix in the URL, it won't work, because it expects to be accessed through the proxy. You can check it at http://127.0.0.1:8000/docs: But if we access the docs UI at the \"official\" URL using the proxy with port 9999, at /api/v1/docs, it works correctly! üéâ You can check it at http://127.0.0.1:9999/api/v1/docs: Right as we wanted it. ‚úîÔ∏è This is because FastAPI uses this root_path to create the default server in OpenAPI with the URL provided by root_path. Additional servers¬∂ Warning This is a more advanced use case. Feel free to skip it. By default, FastAPI will create a server in the OpenAPI schema with the URL for the root_path. But you can also provide other alternative servers, for example if you want the same docs UI to interact with a staging and production environments. If you pass a custom list of servers and there's a root_path (because your API lives behind a proxy), FastAPI will insert a \"server\" with this root_path at the beginning of the list. For example: from fastapi import FastAPI, Request app = FastAPI( servers=[ {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"}, {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"}, ], root_path=\"/api/v1\", ) @app.get(\"/app\") def read_main(request: Request): return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")} Will generate an OpenAPI schema like: { \"openapi\": \"3.1.0\", // More stuff here \"servers\": [ { \"url\": \"/api/v1\" }, { \"url\": \"https://stag.example.com\", \"description\": \"Staging environment\" }, { \"url\": \"https://prod.example.com\", \"description\": \"Production environment\" } ], \"paths\": { // More stuff here } } Tip Notice the auto-generated server with a url value of /api/v1, taken from the root_path. In the docs UI at http://127.0.0.1:9999/api/v1/docs it would look like: Tip The docs UI will interact with the server that you select. Disable automatic server from root_path¬∂ If you don't want FastAPI to include an automatic server using the root_path, you can use the parameter root_path_in_servers=False: from fastapi import FastAPI, Request app = FastAPI( servers=[ {\"url\": \"https://stag.example.com\", \"description\": \"Staging environment\"}, {\"url\": \"https://prod.example.com\", \"description\": \"Production environment\"}, ], root_path=\"/api/v1\", root_path_in_servers=False, ) @app.get(\"/app\") def read_main(request: Request): return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")} and then it won't include it in the OpenAPI schema. Mounting a sub-application¬∂ If you need to mount a sub-application (as described in Sub Applications - Mounts) while also using a proxy with root_path, you can do it normally, as you would expect. FastAPI will internally use the root_path smartly, so it will just work. ‚ú® Made with Material for MkDocs Insiders"
  },
  {
    "title": "Sub Applications - Mounts - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/sub-applications/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Sub Applications - Mounts en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Mounting a FastAPI application Top-level application Sub-application Mount the sub-application Check the automatic API docs Technical Details: root_path FastAPI Learn Advanced User Guide Sub Applications - Mounts¬∂ If you need to have two independent FastAPI applications, with their own independent OpenAPI and their own docs UIs, you can have a main app and \"mount\" one (or more) sub-application(s). Mounting a FastAPI application¬∂ \"Mounting\" means adding a completely \"independent\" application in a specific path, that then takes care of handling everything under that path, with the path operations declared in that sub-application. Top-level application¬∂ First, create the main, top-level, FastAPI application, and its path operations: from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi) Sub-application¬∂ Then, create your sub-application, and its path operations. This sub-application is just another standard FastAPI application, but this is the one that will be \"mounted\": from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi) Mount the sub-application¬∂ In your top-level application, app, mount the sub-application, subapi. In this case, it will be mounted at the path /subapi: from fastapi import FastAPI app = FastAPI() @app.get(\"/app\") def read_main(): return {\"message\": \"Hello World from main app\"} subapi = FastAPI() @subapi.get(\"/sub\") def read_sub(): return {\"message\": \"Hello World from sub API\"} app.mount(\"/subapi\", subapi) Check the automatic API docs¬∂ Now, run uvicorn with the main app, if your file is main.py, it would be: And open the docs at http://127.0.0.1:8000/docs. You will see the automatic API docs for the main app, including only its own path operations: And then, open the docs for the sub-application, at http://127.0.0.1:8000/subapi/docs. You will see the automatic API docs for the sub-application, including only its own path operations, all under the correct sub-path prefix /subapi: If you try interacting with any of the two user interfaces, they will work correctly, because the browser will be able to talk to each specific app or sub-app. Technical Details: root_path¬∂ When you mount a sub-application as described above, FastAPI will take care of communicating the mount path for the sub-application using a mechanism from the ASGI specification called a root_path. That way, the sub-application will know to use that path prefix for the docs UI. And the sub-application could also have its own mounted sub-applications and everything would work correctly, because FastAPI handles all these root_paths automatically. You will learn more about the root_path and how to use it explicitly in the section about Behind a Proxy. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Using Dataclasses - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/dataclasses/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Using Dataclasses en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Dataclasses in response_model Dataclasses in Nested Data Structures Learn More Version FastAPI Learn Advanced User Guide Using Dataclasses¬∂ FastAPI is built on top of Pydantic, and I have been showing you how to use Pydantic models to declare requests and responses. But FastAPI also supports using dataclasses the same way: from dataclasses import dataclass from typing import Union from fastapi import FastAPI @dataclass class Item: name: str price: float description: Union[str, None] = None tax: Union[float, None] = None app = FastAPI() @app.post(\"/items/\") async def create_item(item: Item): return item This is still supported thanks to Pydantic, as it has internal support for dataclasses. So, even with the code above that doesn't use Pydantic explicitly, FastAPI is using Pydantic to convert those standard dataclasses to Pydantic's own flavor of dataclasses. And of course, it supports the same: data validation data serialization data documentation, etc. This works the same way as with Pydantic models. And it is actually achieved in the same way underneath, using Pydantic. Info Have in mind that dataclasses can't do everything Pydantic models can do. So, you might still need to use Pydantic models. But if you have a bunch of dataclasses laying around, this is a nice trick to use them to power a web API using FastAPI. ü§ì Dataclasses in response_model¬∂ You can also use dataclasses in the response_model parameter: from dataclasses import dataclass, field from typing import List, Union from fastapi import FastAPI @dataclass class Item: name: str price: float tags: List[str] = field(default_factory=list) description: Union[str, None] = None tax: Union[float, None] = None app = FastAPI() @app.get(\"/items/next\", response_model=Item) async def read_next_item(): return { \"name\": \"Island In The Moon\", \"price\": 12.99, \"description\": \"A place to be be playin' and havin' fun\", \"tags\": [\"breater\"], } The dataclass will be automatically converted to a Pydantic dataclass. This way, its schema will show up in the API docs user interface: Dataclasses in Nested Data Structures¬∂ You can also combine dataclasses with other type annotations to make nested data structures. In some cases, you might still have to use Pydantic's version of dataclasses. For example, if you have errors with the automatically generated API documentation. In that case, you can simply swap the standard dataclasses with pydantic.dataclasses, which is a drop-in replacement: from dataclasses import field # We still import field from standard dataclasses. from typing import List, Union from fastapi import FastAPI from pydantic.dataclasses import dataclass # pydantic.dataclasses is a drop-in replacement for dataclasses. @dataclass class Item: name: str description: Union[str, None] = None @dataclass class Author: name: str items: List[Item] = field(default_factory=list) # The Author dataclass includes a list of Item dataclasses. app = FastAPI() @app.post(\"/authors/{author_id}/items/\", response_model=Author) # The Author dataclass is used as the response_model parameter. async def create_author_items(author_id: str, items: List[Item]): # You can use other standard type annotations with dataclasses as the request body. In this case, it's a list of Item dataclasses. return {\"name\": author_id, \"items\": items} # Here we are returning a dictionary that contains items which is a list of dataclasses. FastAPI is still capable of serializing the data to JSON. @app.get(\"/authors/\", response_model=List[Author]) # Here the response_model is using a type annotation of a list of Author dataclasses. Again, you can combine dataclasses with standard type annotations. def get_authors(): # Notice that this path operation function uses regular def instead of async def. As always, in FastAPI you can combine def and async def as needed. If you need a refresher about when to use which, check out the section \"In a hurry?\" in the docs about async and await. return [ # This path operation function is not returning dataclasses (although it could), but a list of dictionaries with internal data. FastAPI will use the response_model parameter (that includes dataclasses) to convert the response. { \"name\": \"Breaters\", \"items\": [ { \"name\": \"Island In The Moon\", \"description\": \"A place to be be playin' and havin' fun\", }, {\"name\": \"Holy Buddies\"}, ], }, { \"name\": \"System of an Up\", \"items\": [ { \"name\": \"Salt\", \"description\": \"The kombucha mushroom people's favorite\", }, {\"name\": \"Pad Thai\"}, { \"name\": \"Lonely Night\", \"description\": \"The mostests lonliest nightiest of allest\", }, ], }, ] You can combine dataclasses with other type annotations in many different combinations to form complex data structures. Check the in-code annotation tips above to see more specific details. Learn More¬∂ You can also combine dataclasses with other Pydantic models, inherit from them, include them in your own models, etc. To learn more, check the Pydantic docs about dataclasses. Version¬∂ This is available since FastAPI version 0.67.0. üîñ Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced Middleware - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/middleware/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Advanced Middleware en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Adding ASGI middlewares Integrated middlewares HTTPSRedirectMiddleware TrustedHostMiddleware GZipMiddleware Other middlewares FastAPI Learn Advanced User Guide Advanced Middleware¬∂ In the main tutorial you read how to add Custom Middleware to your application. And then you also read how to handle CORS with the CORSMiddleware. In this section we'll see how to use other middlewares. Adding ASGI middlewares¬∂ As FastAPI is based on Starlette and implements the ASGI specification, you can use any ASGI middleware. A middleware doesn't have to be made for FastAPI or Starlette to work, as long as it follows the ASGI spec. In general, ASGI middlewares are classes that expect to receive an ASGI app as the first argument. So, in the documentation for third-party ASGI middlewares they will probably tell you to do something like: from unicorn import UnicornMiddleware app = SomeASGIApp() new_app = UnicornMiddleware(app, some_config=\"rainbow\") But FastAPI (actually Starlette) provides a simpler way to do it that makes sure that the internal middlewares to handle server errors and custom exception handlers work properly. For that, you use app.add_middleware() (as in the example for CORS). from fastapi import FastAPI from unicorn import UnicornMiddleware app = FastAPI() app.add_middleware(UnicornMiddleware, some_config=\"rainbow\") app.add_middleware() receives a middleware class as the first argument and any additional arguments to be passed to the middleware. Integrated middlewares¬∂ FastAPI includes several middlewares for common use cases, we'll see next how to use them. Technical Details For the next examples, you could also use from starlette.middleware.something import SomethingMiddleware. FastAPI provides several middlewares in fastapi.middleware just as a convenience for you, the developer. But most of the available middlewares come directly from Starlette. HTTPSRedirectMiddleware¬∂ Enforces that all incoming requests must either be https or wss. Any incoming requests to http or ws will be redirected to the secure scheme instead. from fastapi import FastAPI from fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware app = FastAPI() app.add_middleware(HTTPSRedirectMiddleware) @app.get(\"/\") async def main(): return {\"message\": \"Hello World\"} TrustedHostMiddleware¬∂ Enforces that all incoming requests have a correctly set Host header, in order to guard against HTTP Host Header attacks. from fastapi import FastAPI from fastapi.middleware.trustedhost import TrustedHostMiddleware app = FastAPI() app.add_middleware( TrustedHostMiddleware, allowed_hosts=[\"example.com\", \"*.example.com\"] ) @app.get(\"/\") async def main(): return {\"message\": \"Hello World\"} The following arguments are supported: allowed_hosts - A list of domain names that should be allowed as hostnames. Wildcard domains such as *.example.com are supported for matching subdomains. To allow any hostname either use allowed_hosts=[\"*\"] or omit the middleware. If an incoming request does not validate correctly then a 400 response will be sent. GZipMiddleware¬∂ Handles GZip responses for any request that includes \"gzip\" in the Accept-Encoding header. The middleware will handle both standard and streaming responses. from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware app = FastAPI() app.add_middleware(GZipMiddleware, minimum_size=1000) @app.get(\"/\") async def main(): return \"somebigcontent\" The following arguments are supported: minimum_size - Do not GZip responses that are smaller than this minimum size in bytes. Defaults to 500. Other middlewares¬∂ There are many other ASGI middlewares. For example: Sentry Uvicorn's ProxyHeadersMiddleware MessagePack To see other available middlewares check Starlette's Middleware docs and the ASGI Awesome List. Made with Material for MkDocs Insiders"
  },
  {
    "title": "OAuth2 scopes - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI OAuth2 scopes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents OAuth2 scopes and OpenAPI Global view OAuth2 Security scheme JWT token with scopes Declare scopes in path operations and dependencies Use SecurityScopes Use the scopes Verify the username and data shape Verify the scopes Dependency tree and scopes More details about SecurityScopes Check it About third party integrations Security in decorator dependencies FastAPI Learn Advanced User Guide Advanced Security OAuth2 scopes¬∂ You can use OAuth2 scopes directly with FastAPI, they are integrated to work seamlessly. This would allow you to have a more fine-grained permission system, following the OAuth2 standard, integrated into your OpenAPI application (and the API docs). OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. They use it to provide specific permissions to users and applications. Every time you \"log in with\" Facebook, Google, GitHub, Microsoft, Twitter, that application is using OAuth2 with scopes. In this section you will see how to manage authentication and authorization with the same OAuth2 with scopes in your FastAPI application. Warning This is a more or less advanced section. If you are just starting, you can skip it. You don't necessarily need OAuth2 scopes, and you can handle authentication and authorization however you want. But OAuth2 with scopes can be nicely integrated into your API (with OpenAPI) and your API docs. Nevertheless, you still enforce those scopes, or any other security/authorization requirement, however you need, in your code. In many cases, OAuth2 with scopes can be an overkill. But if you know you need it, or you are curious, keep reading. OAuth2 scopes and OpenAPI¬∂ The OAuth2 specification defines \"scopes\" as a list of strings separated by spaces. The content of each of these strings can have any format, but should not contain spaces. These scopes represent \"permissions\". In OpenAPI (e.g. the API docs), you can define \"security schemes\". When one of these security schemes uses OAuth2, you can also declare and use scopes. Each \"scope\" is just a string (without spaces). They are normally used to declare specific security permissions, for example: users:read or users:write are common examples. instagram_basic is used by Facebook / Instagram. https://www.googleapis.com/auth/drive is used by Google. Info In OAuth2 a \"scope\" is just a string that declares a specific permission required. It doesn't matter if it has other characters like : or if it is a URL. Those details are implementation specific. For OAuth2 they are just strings. Global view¬∂ First, let's quickly see the parts that change from the examples in the main Tutorial - User Guide for OAuth2 with Password (and hashing), Bearer with JWT tokens. Now using OAuth2 scopes: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Now let's review those changes step by step. OAuth2 Security scheme¬∂ The first change is that now we are declaring the OAuth2 security scheme with two available scopes, me and items. The scopes parameter receives a dict with each scope as a key and the description as the value: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Because we are now declaring those scopes, they will show up in the API docs when you log-in/authorize. And you will be able to select which scopes you want to give access to: me and items. This is the same mechanism used when you give permissions while logging in with Facebook, Google, GitHub, etc: JWT token with scopes¬∂ Now, modify the token path operation to return the scopes requested. We are still using the same OAuth2PasswordRequestForm. It includes a property scopes with a list of str, with each scope it received in the request. And we return the scopes as part of the JWT token. Danger For simplicity, here we are just adding the scopes received directly to the token. But in your application, for security, you should make sure you only add the scopes that the user is actually able to have, or the ones you have predefined. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Declare scopes in path operations and dependencies¬∂ Now we declare that the path operation for /users/me/items/ requires the scope items. For this, we import and use Security from fastapi. You can use Security to declare dependencies (just like Depends), but Security also receives a parameter scopes with a list of scopes (strings). In this case, we pass a dependency function get_current_active_user to Security (the same way we would do with Depends). But we also pass a list of scopes, in this case with just one scope: items (it could have more). And the dependency function get_current_active_user can also declare sub-dependencies, not only with Depends but also with Security. Declaring its own sub-dependency function (get_current_user), and more scope requirements. In this case, it requires the scope me (it could require more than one scope). Note You don't necessarily need to add different scopes in different places. We are doing it here to demonstrate how FastAPI handles scopes declared at different levels. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Technical Details Security is actually a subclass of Depends, and it has just one extra parameter that we'll see later. But by using Security instead of Depends, FastAPI will know that it can declare security scopes, use them internally, and document the API with OpenAPI. But when you import Query, Path, Depends, Security and others from fastapi, those are actually functions that return special classes. Use SecurityScopes¬∂ Now update the dependency get_current_user. This is the one used by the dependencies above. Here's were we are using the same OAuth2 scheme we created before, declaring it as a dependency: oauth2_scheme. Because this dependency function doesn't have any scope requirements itself, we can use Depends with oauth2_scheme, we don't have to use Security when we don't need to specify security scopes. We also declare a special parameter of type SecurityScopes, imported from fastapi.security. This SecurityScopes class is similar to Request (Request was used to get the request object directly). Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Use the scopes¬∂ The parameter security_scopes will be of type SecurityScopes. It will have a property scopes with a list containing all the scopes required by itself and all the dependencies that use this as a sub-dependency. That means, all the \"dependants\"... this might sound confusing, it is explained again later below. The security_scopes object (of class SecurityScopes) also provides a scope_str attribute with a single string, containing those scopes separated by spaces (we are going to use it). We create an HTTPException that we can re-use (raise) later at several points. In this exception, we include the scopes required (if any) as a string separated by spaces (using scope_str). We put that string containing the scopes in the WWW-Authenticate header (this is part of the spec). Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Verify the username and data shape¬∂ We verify that we get a username, and extract the scopes. And then we validate that data with the Pydantic model (catching the ValidationError exception), and if we get an error reading the JWT token or validating the data with Pydantic, we raise the HTTPException we created before. For that, we update the Pydantic model TokenData with a new property scopes. By validating the data with Pydantic we can make sure that we have, for example, exactly a list of str with the scopes and a str with the username. Instead of, for example, a dict, or something else, as it could break the application at some point later, making it a security risk. We also verify that we have a user with that username, and if not, we raise that same exception we created before. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Verify the scopes¬∂ We now verify that all the scopes required, by this dependency and all the dependants (including path operations), are included in the scopes provided in the token received, otherwise raise an HTTPException. For this, we use security_scopes.scopes, that contains a list with all these scopes as str. Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.9+ non-Annotated Python 3.8+ non-Annotated from datetime import datetime, timedelta from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, Security, status from fastapi.security import ( OAuth2PasswordBearer, OAuth2PasswordRequestForm, SecurityScopes, ) from jose import JWTError, jwt from passlib.context import CryptContext from pydantic import BaseModel, ValidationError # to get a string like this run: # openssl rand -hex 32 SECRET_KEY = \"09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7\" ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 30 fake_users_db = { \"johndoe\": { \"username\": \"johndoe\", \"full_name\": \"John Doe\", \"email\": \"johndoe@example.com\", \"hashed_password\": \"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW\", \"disabled\": False, }, \"alice\": { \"username\": \"alice\", \"full_name\": \"Alice Chains\", \"email\": \"alicechains@example.com\", \"hashed_password\": \"$2b$12$gSvqqUPvlXP2tfVFaWK1Be7DlH.PKZbv5H8KnzzVgXXbVxpva.pFm\", \"disabled\": True, }, } class Token(BaseModel): access_token: str token_type: str class TokenData(BaseModel): username: str | None = None scopes: list[str] = [] class User(BaseModel): username: str email: str | None = None full_name: str | None = None disabled: bool | None = None class UserInDB(User): hashed_password: str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\", scopes={\"me\": \"Read information about the current user.\", \"items\": \"Read items.\"}, ) app = FastAPI() def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password) def get_password_hash(password): return pwd_context.hash(password) def get_user(db, username: str): if username in db: user_dict = db[username] return UserInDB(**user_dict) def authenticate_user(fake_db, username: str, password: str): user = get_user(fake_db, username) if not user: return False if not verify_password(password, user.hashed_password): return False return user def create_access_token(data: dict, expires_delta: timedelta | None = None): to_encode = data.copy() if expires_delta: expire = datetime.utcnow() + expires_delta else: expire = datetime.utcnow() + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) return encoded_jwt async def get_current_user( security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)] ): if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Could not validate credentials\", headers={\"WWW-Authenticate\": authenticate_value}, ) try: payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\", []) token_data = TokenData(scopes=token_scopes, username=username) except (JWTError, ValidationError): raise credentials_exception user = get_user(fake_users_db, username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not enough permissions\", headers={\"WWW-Authenticate\": authenticate_value}, ) return user async def get_current_active_user( current_user: Annotated[User, Security(get_current_user, scopes=[\"me\"])] ): if current_user.disabled: raise HTTPException(status_code=400, detail=\"Inactive user\") return current_user @app.post(\"/token\", response_model=Token) async def login_for_access_token( form_data: Annotated[OAuth2PasswordRequestForm, Depends()] ): user = authenticate_user(fake_users_db, form_data.username, form_data.password) if not user: raise HTTPException(status_code=400, detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token( data={\"sub\": user.username, \"scopes\": form_data.scopes}, expires_delta=access_token_expires, ) return {\"access_token\": access_token, \"token_type\": \"bearer\"} @app.get(\"/users/me/\", response_model=User) async def read_users_me( current_user: Annotated[User, Depends(get_current_active_user)] ): return current_user @app.get(\"/users/me/items/\") async def read_own_items( current_user: Annotated[User, Security(get_current_active_user, scopes=[\"items\"])] ): return [{\"item_id\": \"Foo\", \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User, Depends(get_current_user)]): return {\"status\": \"ok\"} Dependency tree and scopes¬∂ Let's review again this dependency tree and the scopes. As the get_current_active_user dependency has as a sub-dependency on get_current_user, the scope \"me\" declared at get_current_active_user will be included in the list of required scopes in the security_scopes.scopes passed to get_current_user. The path operation itself also declares a scope, \"items\", so this will also be in the list of security_scopes.scopes passed to get_current_user. Here's how the hierarchy of dependencies and scopes looks like: The path operation read_own_items has: Required scopes [\"items\"] with the dependency: get_current_active_user: The dependency function get_current_active_user has: Required scopes [\"me\"] with the dependency: get_current_user: The dependency function get_current_user has: No scopes required by itself. A dependency using oauth2_scheme. A security_scopes parameter of type SecurityScopes: This security_scopes parameter has a property scopes with a list containing all these scopes declared above, so: security_scopes.scopes will contain [\"me\", \"items\"] for the path operation read_own_items. security_scopes.scopes will contain [\"me\"] for the path operation read_users_me, because it is declared in the dependency get_current_active_user. security_scopes.scopes will contain [] (nothing) for the path operation read_system_status, because it didn't declare any Security with scopes, and its dependency, get_current_user, doesn't declare any scope either. Tip The important and \"magic\" thing here is that get_current_user will have a different list of scopes to check for each path operation. All depending on the scopes declared in each path operation and each dependency in the dependency tree for that specific path operation. More details about SecurityScopes¬∂ You can use SecurityScopes at any point, and in multiple places, it doesn't have to be at the \"root\" dependency. It will always have the security scopes declared in the current Security dependencies and all the dependants for that specific path operation and that specific dependency tree. Because the SecurityScopes will have all the scopes declared by dependants, you can use it to verify that a token has the required scopes in a central dependency function, and then declare different scope requirements in different path operations. They will be checked independently for each path operation. Check it¬∂ If you open the API docs, you can authenticate and specify which scopes you want to authorize. If you don't select any scope, you will be \"authenticated\", but when you try to access /users/me/ or /users/me/items/ you will get an error saying that you don't have enough permissions. You will still be able to access /status/. And if you select the scope me but not the scope items, you will be able to access /users/me/ but not /users/me/items/. That's what would happen to a third party application that tried to access one of these path operations with a token provided by a user, depending on how many permissions the user gave the application. About third party integrations¬∂ In this example we are using the OAuth2 \"password\" flow. This is appropriate when we are logging in to our own application, probably with our own frontend. Because we can trust it to receive the username and password, as we control it. But if you are building an OAuth2 application that others would connect to (i.e., if you are building an authentication provider equivalent to Facebook, Google, GitHub, etc.) you should use one of the other flows. The most common is the implicit flow. The most secure is the code flow, but is more complex to implement as it requires more steps. As it is more complex, many providers end up suggesting the implicit flow. Note It's common that each authentication provider names their flows in a different way, to make it part of their brand. But in the end, they are implementing the same OAuth2 standard. FastAPI includes utilities for all these OAuth2 authentication flows in fastapi.security.oauth2. Security in decorator dependencies¬∂ The same way you can define a list of Depends in the decorator's dependencies parameter (as explained in Dependencies in path operation decorators), you could also use Security with scopes there. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Using the Request Directly - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/using-request-directly/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Using the Request Directly en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Details about the Request object Use the Request object directly Request documentation FastAPI Learn Advanced User Guide Using the Request Directly¬∂ Up to now, you have been declaring the parts of the request that you need with their types. Taking data from: The path as parameters. Headers. Cookies. etc. And by doing so, FastAPI is validating that data, converting it and generating documentation for your API automatically. But there are situations where you might need to access the Request object directly. Details about the Request object¬∂ As FastAPI is actually Starlette underneath, with a layer of several tools on top, you can use Starlette's Request object directly when you need to. It would also mean that if you get data from the Request object directly (for example, read the body) it won't be validated, converted or documented (with OpenAPI, for the automatic API user interface) by FastAPI. Although any other parameter declared normally (for example, the body with a Pydantic model) would still be validated, converted, annotated, etc. But there are specific cases where it's useful to get the Request object. Use the Request object directly¬∂ Let's imagine you want to get the client's IP address/host inside of your path operation function. For that you need to access the request directly. from fastapi import FastAPI, Request app = FastAPI() @app.get(\"/items/{item_id}\") def read_root(item_id: str, request: Request): client_host = request.client.host return {\"client_host\": client_host, \"item_id\": item_id} By declaring a path operation function parameter with the type being the Request FastAPI will know to pass the Request in that parameter. Tip Note that in this case, we are declaring a path parameter beside the request parameter. So, the path parameter will be extracted, validated, converted to the specified type and annotated with OpenAPI. The same way, you can declare any other parameter as normally, and additionally, get the Request too. Request documentation¬∂ You can read more details about the Request object in the official Starlette documentation site. Technical Details You could also use from starlette.requests import Request. FastAPI provides it directly just as a convenience for you, the developer. But it comes directly from Starlette. Made with Material for MkDocs Insiders"
  },
  {
    "title": "HTTP Basic Auth - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/security/http-basic-auth/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI HTTP Basic Auth en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Simple HTTP Basic Auth Check the username Timing Attacks The time to answer helps the attackers A \"professional\" attack Fix it with secrets.compare_digest() Return the error FastAPI Learn Advanced User Guide Advanced Security HTTP Basic Auth¬∂ For the simplest cases, you can use HTTP Basic Auth. In HTTP Basic Auth, the application expects a header that contains a username and a password. If it doesn't receive it, it returns an HTTP 401 \"Unauthorized\" error. And returns a header WWW-Authenticate with a value of Basic, and an optional realm parameter. That tells the browser to show the integrated prompt for a username and password. Then, when you type that username and password, the browser sends them in the header automatically. Simple HTTP Basic Auth¬∂ Import HTTPBasic and HTTPBasicCredentials. Create a \"security scheme\" using HTTPBasic. Use that security with a dependency in your path operation. It returns an object of type HTTPBasicCredentials: It contains the username and password sent. Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() @app.get(\"/users/me\") def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]): return {\"username\": credentials.username, \"password\": credentials.password} When you try to open the URL for the first time (or click the \"Execute\" button in the docs) the browser will ask you for your username and password: Check the username¬∂ Here's a more complete example. Use a dependency to check if the username and password are correct. For this, use the Python standard module secrets to check the username and password. secrets.compare_digest() needs to take bytes or a str that only contains ASCII characters (the ones in English), this means it wouldn't work with characters like √°, as in Sebasti√°n. To handle that, we first convert the username and password to bytes encoding them with UTF-8. Then we can use secrets.compare_digest() to ensure that credentials.username is \"stanleyjobson\", and that credentials.password is \"swordfish\". Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated import secrets from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() def get_current_username( credentials: Annotated[HTTPBasicCredentials, Depends(security)] ): current_username_bytes = credentials.username.encode(\"utf8\") correct_username_bytes = b\"stanleyjobson\" is_correct_username = secrets.compare_digest( current_username_bytes, correct_username_bytes ) current_password_bytes = credentials.password.encode(\"utf8\") correct_password_bytes = b\"swordfish\" is_correct_password = secrets.compare_digest( current_password_bytes, correct_password_bytes ) if not (is_correct_username and is_correct_password): raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Incorrect email or password\", headers={\"WWW-Authenticate\": \"Basic\"}, ) return credentials.username @app.get(\"/users/me\") def read_current_user(username: Annotated[str, Depends(get_current_username)]): return {\"username\": username} This would be similar to: if not (credentials.username == \"stanleyjobson\") or not (credentials.password == \"swordfish\"): # Return some error ... But by using the secrets.compare_digest() it will be secure against a type of attacks called \"timing attacks\". Timing Attacks¬∂ But what's a \"timing attack\"? Let's imagine some attackers are trying to guess the username and password. And they send a request with a username johndoe and a password love123. Then the Python code in your application would be equivalent to something like: if \"johndoe\" == \"stanleyjobson\" and \"love123\" == \"swordfish\": ... But right at the moment Python compares the first j in johndoe to the first s in stanleyjobson, it will return False, because it already knows that those two strings are not the same, thinking that \"there's no need to waste more computation comparing the rest of the letters\". And your application will say \"incorrect user or password\". But then the attackers try with username stanleyjobsox and password love123. And your application code does something like: if \"stanleyjobsox\" == \"stanleyjobson\" and \"love123\" == \"swordfish\": ... Python will have to compare the whole stanleyjobso in both stanleyjobsox and stanleyjobson before realizing that both strings are not the same. So it will take some extra microseconds to reply back \"incorrect user or password\". The time to answer helps the attackers¬∂ At that point, by noticing that the server took some microseconds longer to send the \"incorrect user or password\" response, the attackers will know that they got something right, some of the initial letters were right. And then they can try again knowing that it's probably something more similar to stanleyjobsox than to johndoe. A \"professional\" attack¬∂ Of course, the attackers would not try all this by hand, they would write a program to do it, possibly with thousands or millions of tests per second. And would get just one extra correct letter at a time. But doing that, in some minutes or hours the attackers would have guessed the correct username and password, with the \"help\" of our application, just using the time taken to answer. Fix it with secrets.compare_digest()¬∂ But in our code we are actually using secrets.compare_digest(). In short, it will take the same time to compare stanleyjobsox to stanleyjobson than it takes to compare johndoe to stanleyjobson. And the same for the password. That way, using secrets.compare_digest() in your application code, it will be safe against this whole range of security attacks. Return the error¬∂ After detecting that the credentials are incorrect, return an HTTPException with a status code 401 (the same returned when no credentials are provided) and add the header WWW-Authenticate to make the browser show the login prompt again: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated import secrets from typing import Annotated from fastapi import Depends, FastAPI, HTTPException, status from fastapi.security import HTTPBasic, HTTPBasicCredentials app = FastAPI() security = HTTPBasic() def get_current_username( credentials: Annotated[HTTPBasicCredentials, Depends(security)] ): current_username_bytes = credentials.username.encode(\"utf8\") correct_username_bytes = b\"stanleyjobson\" is_correct_username = secrets.compare_digest( current_username_bytes, correct_username_bytes ) current_password_bytes = credentials.password.encode(\"utf8\") correct_password_bytes = b\"swordfish\" is_correct_password = secrets.compare_digest( current_password_bytes, correct_password_bytes ) if not (is_correct_username and is_correct_password): raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Incorrect email or password\", headers={\"WWW-Authenticate\": \"Basic\"}, ) return credentials.username @app.get(\"/users/me\") def read_current_user(username: Annotated[str, Depends(get_current_username)]): return {\"username\": username} Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced Dependencies - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/advanced-dependencies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Advanced Dependencies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Parameterized dependencies A \"callable\" instance Parameterize the instance Create an instance Use the instance as a dependency FastAPI Learn Advanced User Guide Advanced Dependencies¬∂ Parameterized dependencies¬∂ All the dependencies we have seen are a fixed function or class. But there could be cases where you want to be able to set parameters on the dependency, without having to declare many different functions or classes. Let's imagine that we want to have a dependency that checks if the query parameter q contains some fixed content. But we want to be able to parameterize that fixed content. A \"callable\" instance¬∂ In Python there's a way to make an instance of a class a \"callable\". Not the class itself (which is already a callable), but an instance of that class. To do that, we declare a method __call__: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def __init__(self, fixed_content: str): self.fixed_content = fixed_content def __call__(self, q: str = \"\"): if q: return self.fixed_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]): return {\"fixed_content_in_query\": fixed_content_included} In this case, this __call__ is what FastAPI will use to check for additional parameters and sub-dependencies, and this is what will be called to pass a value to the parameter in your path operation function later. Parameterize the instance¬∂ And now, we can use __init__ to declare the parameters of the instance that we can use to \"parameterize\" the dependency: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def __init__(self, fixed_content: str): self.fixed_content = fixed_content def __call__(self, q: str = \"\"): if q: return self.fixed_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]): return {\"fixed_content_in_query\": fixed_content_included} In this case, FastAPI won't ever touch or care about __init__, we will use it directly in our code. Create an instance¬∂ We could create an instance of this class with: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def __init__(self, fixed_content: str): self.fixed_content = fixed_content def __call__(self, q: str = \"\"): if q: return self.fixed_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]): return {\"fixed_content_in_query\": fixed_content_included} And that way we are able to \"parameterize\" our dependency, that now has \"bar\" inside of it, as the attribute checker.fixed_content. Use the instance as a dependency¬∂ Then, we could use this checker in a Depends(checker), instead of Depends(FixedContentQueryChecker), because the dependency is the instance, checker, not the class itself. And when solving the dependency, FastAPI will call this checker like: checker(q=\"somequery\") ...and pass whatever that returns as the value of the dependency in our path operation function as the parameter fixed_content_included: Python 3.9+ Python 3.8+ Python 3.8+ non-Annotated from typing import Annotated from fastapi import Depends, FastAPI app = FastAPI() class FixedContentQueryChecker: def __init__(self, fixed_content: str): self.fixed_content = fixed_content def __call__(self, q: str = \"\"): if q: return self.fixed_content in q return False checker = FixedContentQueryChecker(\"bar\") @app.get(\"/query-checker/\") async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]): return {\"fixed_content_in_query\": fixed_content_included} Tip All this might seem contrived. And it might not be very clear how is it useful yet. These examples are intentionally simple, but show how it all works. In the chapters about security, there are utility functions that are implemented in this same way. If you understood all this, you already know how those utility tools for security work underneath. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced Security - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/security/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Advanced Security en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security OAuth2 scopes HTTP Basic Auth Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional Features Read the Tutorial first FastAPI Learn Advanced User Guide Advanced Security Advanced Security¬∂ Additional Features¬∂ There are some extra features to handle security apart from the ones covered in the Tutorial - User Guide: Security. Tip The next sections are not necessarily \"advanced\". And it's possible that for your use case, the solution is in one of them. Read the Tutorial first¬∂ The next sections assume you already read the main Tutorial - User Guide: Security. They are all based on the same concepts, but allow some extra functionalities. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response Headers - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-headers/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Response Headers en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use a Response parameter Return a Response directly Custom Headers FastAPI Learn Advanced User Guide Response Headers¬∂ Use a Response parameter¬∂ You can declare a parameter of type Response in your path operation function (as you can do for cookies). And then you can set headers in that temporal response object. from fastapi import FastAPI, Response app = FastAPI() @app.get(\"/headers-and-object/\") def get_headers(response: Response): response.headers[\"X-Cat-Dog\"] = \"alone in the world\" return {\"message\": \"Hello World\"} And then you can return any object you need, as you normally would (a dict, a database model, etc). And if you declared a response_model, it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the headers (also cookies and status code), and will put them in the final response that contains the value you returned, filtered by any response_model. You can also declare the Response parameter in dependencies, and set headers (and cookies) in them. Return a Response directly¬∂ You can also add headers when you return a Response directly. Create a response as described in Return a Response Directly and pass the headers as an additional parameter: from fastapi import FastAPI from fastapi.responses import JSONResponse app = FastAPI() @app.get(\"/headers/\") def get_headers(): content = {\"message\": \"Hello World\"} headers = {\"X-Cat-Dog\": \"alone in the world\", \"Content-Language\": \"en-US\"} return JSONResponse(content=content, headers=headers) Technical Details You could also use from starlette.responses import Response or from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. And as the Response can be used frequently to set headers and cookies, FastAPI also provides it at fastapi.Response. Custom Headers¬∂ Have in mind that custom proprietary headers can be added using the 'X-' prefix. But if you have custom headers that you want a client in a browser to be able to see, you need to add them to your CORS configurations (read more in CORS (Cross-Origin Resource Sharing)), using the parameter expose_headers documented in Starlette's CORS docs. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response - Change Status Code - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-change-status-code/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Response - Change Status Code en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use case Use a Response parameter FastAPI Learn Advanced User Guide Response - Change Status Code¬∂ You probably read before that you can set a default Response Status Code. But in some cases you need to return a different status code than the default. Use case¬∂ For example, imagine that you want to return an HTTP status code of \"OK\" 200 by default. But if the data didn't exist, you want to create it, and return an HTTP status code of \"CREATED\" 201. But you still want to be able to filter and convert the data you return with a response_model. For those cases, you can use a Response parameter. Use a Response parameter¬∂ You can declare a parameter of type Response in your path operation function (as you can do for cookies and headers). And then you can set the status_code in that temporal response object. from fastapi import FastAPI, Response, status app = FastAPI() tasks = {\"foo\": \"Listen to the Bar Fighters\"} @app.put(\"/get-or-create-task/{task_id}\", status_code=200) def get_or_create_task(task_id: str, response: Response): if task_id not in tasks: tasks[task_id] = \"This didn't exist before\" response.status_code = status.HTTP_201_CREATED return tasks[task_id] And then you can return any object you need, as you normally would (a dict, a database model, etc). And if you declared a response_model, it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the status code (also cookies and headers), and will put them in the final response that contains the value you returned, filtered by any response_model. You can also declare the Response parameter in dependencies, and set the status code in them. But have in mind that the last one to be set will win. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Response Cookies - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-cookies/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Response Cookies en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use a Response parameter Return a Response directly More info FastAPI Learn Advanced User Guide Response Cookies¬∂ Use a Response parameter¬∂ You can declare a parameter of type Response in your path operation function. And then you can set cookies in that temporal response object. from fastapi import FastAPI, Response app = FastAPI() @app.post(\"/cookie-and-object/\") def create_cookie(response: Response): response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\") return {\"message\": \"Come to the dark side, we have cookies\"} And then you can return any object you need, as you normally would (a dict, a database model, etc). And if you declared a response_model, it will still be used to filter and convert the object you returned. FastAPI will use that temporal response to extract the cookies (also headers and status code), and will put them in the final response that contains the value you returned, filtered by any response_model. You can also declare the Response parameter in dependencies, and set cookies (and headers) in them. Return a Response directly¬∂ You can also create cookies when returning a Response directly in your code. To do that, you can create a response as described in Return a Response Directly. Then set Cookies in it, and then return it: from fastapi import FastAPI from fastapi.responses import JSONResponse app = FastAPI() @app.post(\"/cookie/\") def create_cookie(): content = {\"message\": \"Come to the dark side, we have cookies\"} response = JSONResponse(content=content) response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\") return response Tip Have in mind that if you return a response directly instead of using the Response parameter, FastAPI will return it directly. So, you will have to make sure your data is of the correct type. E.g. it is compatible with JSON, if you are returning a JSONResponse. And also that you are not sending any data that should have been filtered by a response_model. More info¬∂ Technical Details You could also use from starlette.responses import Response or from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. And as the Response can be used frequently to set headers and cookies, FastAPI also provides it at fastapi.Response. To see all the available parameters and options, check the documentation in Starlette. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Additional Responses in OpenAPI - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/additional-responses/",
    "html": "Skip to content Follow @fastapi on Twitter to stay updated sponsor FastAPI Additional Responses in OpenAPI en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Type to start searching tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional Response with model Additional media types for the main response Combining information Combine predefined responses and custom ones More information about OpenAPI responses FastAPI Learn Advanced User Guide Additional Responses in OpenAPI¬∂ Warning This is a rather advanced topic. If you are starting with FastAPI, you might not need this. You can declare additional responses, with additional status codes, media types, descriptions, etc. Those additional responses will be included in the OpenAPI schema, so they will also appear in the API docs. But for those additional responses you have to make sure you return a Response like JSONResponse directly, with your status code and content. Additional Response with model¬∂ You can pass to your path operation decorators a parameter responses. It receives a dict, the keys are status codes for each response, like 200, and the values are other dicts with the information for each of them. Each of those response dicts can have a key model, containing a Pydantic model, just like response_model. FastAPI will take that model, generate its JSON Schema and include it in the correct place in OpenAPI. For example, to declare another response with a status code 404 and a Pydantic model Message, you can write: from fastapi import FastAPI from fastapi.responses import JSONResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str class Message(BaseModel): message: str app = FastAPI() @app.get(\"/items/{item_id}\", response_model=Item, responses={404: {\"model\": Message}}) async def read_item(item_id: str): if item_id == \"foo\": return {\"id\": \"foo\", \"value\": \"there goes my hero\"} return JSONResponse(status_code=404, content={\"message\": \"Item not found\"}) Note Have in mind that you have to return the JSONResponse directly. Info The model key is not part of OpenAPI. FastAPI will take the Pydantic model from there, generate the JSON Schema, and put it in the correct place. The correct place is: In the key content, that has as value another JSON object (dict) that contains: A key with the media type, e.g. application/json, that contains as value another JSON object, that contains: A key schema, that has as the value the JSON Schema from the model, here's the correct place. FastAPI adds a reference here to the global JSON Schemas in another place in your OpenAPI instead of including it directly. This way, other applications and clients can use those JSON Schemas directly, provide better code generation tools, etc. The generated responses in the OpenAPI for this path operation will be: { \"responses\": { \"404\": { \"description\": \"Additional Response\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/Message\" } } } }, \"200\": { \"description\": \"Successful Response\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/Item\" } } } }, \"422\": { \"description\": \"Validation Error\", \"content\": { \"application/json\": { \"schema\": { \"$ref\": \"#/components/schemas/HTTPValidationError\" } } } } } } The schemas are referenced to another place inside the OpenAPI schema: { \"components\": { \"schemas\": { \"Message\": { \"title\": \"Message\", \"required\": [ \"message\" ], \"type\": \"object\", \"properties\": { \"message\": { \"title\": \"Message\", \"type\": \"string\" } } }, \"Item\": { \"title\": \"Item\", \"required\": [ \"id\", \"value\" ], \"type\": \"object\", \"properties\": { \"id\": { \"title\": \"Id\", \"type\": \"string\" }, \"value\": { \"title\": \"Value\", \"type\": \"string\" } } }, \"ValidationError\": { \"title\": \"ValidationError\", \"required\": [ \"loc\", \"msg\", \"type\" ], \"type\": \"object\", \"properties\": { \"loc\": { \"title\": \"Location\", \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"msg\": { \"title\": \"Message\", \"type\": \"string\" }, \"type\": { \"title\": \"Error Type\", \"type\": \"string\" } } }, \"HTTPValidationError\": { \"title\": \"HTTPValidationError\", \"type\": \"object\", \"properties\": { \"detail\": { \"title\": \"Detail\", \"type\": \"array\", \"items\": { \"$ref\": \"#/components/schemas/ValidationError\" } } } } } } } Additional media types for the main response¬∂ You can use this same responses parameter to add different media types for the same main response. For example, you can add an additional media type of image/png, declaring that your path operation can return a JSON object (with media type application/json) or a PNG image: from typing import Union from fastapi import FastAPI from fastapi.responses import FileResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str app = FastAPI() @app.get( \"/items/{item_id}\", response_model=Item, responses={ 200: { \"content\": {\"image/png\": {}}, \"description\": \"Return the JSON item or an image.\", } }, ) async def read_item(item_id: str, img: Union[bool, None] = None): if img: return FileResponse(\"image.png\", media_type=\"image/png\") else: return {\"id\": \"foo\", \"value\": \"there goes my hero\"} Note Notice that you have to return the image using a FileResponse directly. Info Unless you specify a different media type explicitly in your responses parameter, FastAPI will assume the response has the same media type as the main response class (default application/json). But if you have specified a custom response class with None as its media type, FastAPI will use application/json for any additional response that has an associated model. Combining information¬∂ You can also combine response information from multiple places, including the response_model, status_code, and responses parameters. You can declare a response_model, using the default status code 200 (or a custom one if you need), and then declare additional information for that same response in responses, directly in the OpenAPI schema. FastAPI will keep the additional information from responses, and combine it with the JSON Schema from your model. For example, you can declare a response with a status code 404 that uses a Pydantic model and has a custom description. And a response with a status code 200 that uses your response_model, but includes a custom example: from fastapi import FastAPI from fastapi.responses import JSONResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str class Message(BaseModel): message: str app = FastAPI() @app.get( \"/items/{item_id}\", response_model=Item, responses={ 404: {\"model\": Message, \"description\": \"The item was not found\"}, 200: { \"description\": \"Item requested by ID\", \"content\": { \"application/json\": { \"example\": {\"id\": \"bar\", \"value\": \"The bar tenders\"} } }, }, }, ) async def read_item(item_id: str): if item_id == \"foo\": return {\"id\": \"foo\", \"value\": \"there goes my hero\"} else: return JSONResponse(status_code=404, content={\"message\": \"Item not found\"}) It will all be combined and included in your OpenAPI, and shown in the API docs: Combine predefined responses and custom ones¬∂ You might want to have some predefined responses that apply to many path operations, but you want to combine them with custom responses needed by each path operation. For those cases, you can use the Python technique of \"unpacking\" a dict with **dict_to_unpack: old_dict = { \"old key\": \"old value\", \"second old key\": \"second old value\", } new_dict = {**old_dict, \"new key\": \"new value\"} Here, new_dict will contain all the key-value pairs from old_dict plus the new key-value pair: { \"old key\": \"old value\", \"second old key\": \"second old value\", \"new key\": \"new value\", } You can use that technique to re-use some predefined responses in your path operations and combine them with additional custom ones. For example: from typing import Union from fastapi import FastAPI from fastapi.responses import FileResponse from pydantic import BaseModel class Item(BaseModel): id: str value: str responses = { 404: {\"description\": \"Item not found\"}, 302: {\"description\": \"The item was moved\"}, 403: {\"description\": \"Not enough privileges\"}, } app = FastAPI() @app.get( \"/items/{item_id}\", response_model=Item, responses={**responses, 200: {\"content\": {\"image/png\": {}}}}, ) async def read_item(item_id: str, img: Union[bool, None] = None): if img: return FileResponse(\"image.png\", media_type=\"image/png\") else: return {\"id\": \"foo\", \"value\": \"there goes my hero\"} More information about OpenAPI responses¬∂ To see what exactly you can include in the responses, you can check these sections in the OpenAPI specification: OpenAPI Responses Object, it includes the Response Object. OpenAPI Response Object, you can include anything from this directly in each response inside your responses parameter. Including description, headers, content (inside of this is that you declare different media types and JSON Schemas), and links. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Custom Response - HTML, Stream, File, others - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/custom-response/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Custom Response - HTML, Stream, File, others en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Use ORJSONResponse HTML Response Return a Response Document in OpenAPI and override Response Return an HTMLResponse directly Available responses Response HTMLResponse PlainTextResponse JSONResponse ORJSONResponse UJSONResponse RedirectResponse StreamingResponse Using StreamingResponse with file-like objects FileResponse Custom response class Default response class Additional documentation FastAPI Learn Advanced User Guide Custom Response - HTML, Stream, File, others¬∂ By default, FastAPI will return the responses using JSONResponse. You can override it by returning a Response directly as seen in Return a Response directly. But if you return a Response directly, the data won't be automatically converted, and the documentation won't be automatically generated (for example, including the specific \"media type\", in the HTTP header Content-Type as part of the generated OpenAPI). But you can also declare the Response that you want to be used, in the path operation decorator. The contents that you return from your path operation function will be put inside of that Response. And if that Response has a JSON media type (application/json), like is the case with the JSONResponse and UJSONResponse, the data you return will be automatically converted (and filtered) with any Pydantic response_model that you declared in the path operation decorator. Note If you use a response class with no media type, FastAPI will expect your response to have no content, so it will not document the response format in its generated OpenAPI docs. Use ORJSONResponse¬∂ For example, if you are squeezing performance, you can install and use orjson and set the response to be ORJSONResponse. Import the Response class (sub-class) you want to use and declare it in the path operation decorator. For large responses, returning a Response directly is much faster than returning a dictionary. This is because by default, FastAPI will inspect every item inside and make sure it is serializable with JSON, using the same JSON Compatible Encoder explained in the tutorial. This is what allows you to return arbitrary objects, for example database models. But if you are certain that the content that you are returning is serializable with JSON, you can pass it directly to the response class and avoid the extra overhead that FastAPI would have by passing your return content through the jsonable_encoder before passing it to the response class. from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI() @app.get(\"/items/\", response_class=ORJSONResponse) async def read_items(): return ORJSONResponse([{\"item_id\": \"Foo\"}]) Info The parameter response_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to application/json. And it will be documented as such in OpenAPI. Tip The ORJSONResponse is currently only available in FastAPI, not in Starlette. HTML Response¬∂ To return a response with HTML directly from FastAPI, use HTMLResponse. Import HTMLResponse. Pass HTMLResponse as the parameter response_class of your path operation decorator. from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI() @app.get(\"/items/\", response_class=HTMLResponse) async def read_items(): return \"\"\" Some HTML in here Look ma! HTML! ============== \"\"\" Info The parameter response_class will also be used to define the \"media type\" of the response. In this case, the HTTP header Content-Type will be set to text/html. And it will be documented as such in OpenAPI. Return a Response¬∂ As seen in Return a Response directly, you can also override the response directly in your path operation, by returning it. The same example from above, returning an HTMLResponse, could look like: from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI() @app.get(\"/items/\") async def read_items(): html_content = \"\"\" Some HTML in here Look ma! HTML! ============== \"\"\" return HTMLResponse(content=html_content, status_code=200) Warning A Response returned directly by your path operation function won't be documented in OpenAPI (for example, the Content-Type won't be documented) and won't be visible in the automatic interactive docs. Info Of course, the actual Content-Type header, status code, etc, will come from the Response object your returned. Document in OpenAPI and override Response¬∂ If you want to override the response from inside of the function but at the same time document the \"media type\" in OpenAPI, you can use the response_class parameter AND return a Response object. The response_class will then be used only to document the OpenAPI path operation, but your Response will be used as is. Return an HTMLResponse directly¬∂ For example, it could be something like: from fastapi import FastAPI from fastapi.responses import HTMLResponse app = FastAPI() def generate_html_response(): html_content = \"\"\" Some HTML in here Look ma! HTML! ============== \"\"\" return HTMLResponse(content=html_content, status_code=200) @app.get(\"/items/\", response_class=HTMLResponse) async def read_items(): return generate_html_response() In this example, the function generate_html_response() already generates and returns a Response instead of returning the HTML in a str. By returning the result of calling generate_html_response(), you are already returning a Response that will override the default FastAPI behavior. But as you passed the HTMLResponse in the response_class too, FastAPI will know how to document it in OpenAPI and the interactive docs as HTML with text/html: Available responses¬∂ Here are some of the available responses. Have in mind that you can use Response to return anything else, or even create a custom sub-class. Technical Details You could also use from starlette.responses import HTMLResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. Response¬∂ The main Response class, all the other responses inherit from it. You can return it directly. It accepts the following parameters: content - A str or bytes. status_code - An int HTTP status code. headers - A dict of strings. media_type - A str giving the media type. E.g. \"text/html\". FastAPI (actually Starlette) will automatically include a Content-Length header. It will also include a Content-Type header, based on the media_type and appending a charset for text types. from fastapi import FastAPI, Response app = FastAPI() @app.get(\"/legacy/\") def get_legacy_data(): data = \"\"\"Apply shampoo here. You'll have to use soap here. \"\"\" return Response(content=data, media_type=\"application/xml\") HTMLResponse¬∂ Takes some text or bytes and returns an HTML response, as you read above. PlainTextResponse¬∂ Takes some text or bytes and returns an plain text response. from fastapi import FastAPI from fastapi.responses import PlainTextResponse app = FastAPI() @app.get(\"/\", response_class=PlainTextResponse) async def main(): return \"Hello World\" JSONResponse¬∂ Takes some data and returns an application/json encoded response. This is the default response used in FastAPI, as you read above. ORJSONResponse¬∂ A fast alternative JSON response using orjson, as you read above. UJSONResponse¬∂ An alternative JSON response using ujson. Warning ujson is less careful than Python's built-in implementation in how it handles some edge-cases. from fastapi import FastAPI from fastapi.responses import UJSONResponse app = FastAPI() @app.get(\"/items/\", response_class=UJSONResponse) async def read_items(): return [{\"item_id\": \"Foo\"}] Tip It's possible that ORJSONResponse might be a faster alternative. RedirectResponse¬∂ Returns an HTTP redirect. Uses a 307 status code (Temporary Redirect) by default. You can return a RedirectResponse directly: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/typer\") async def redirect_typer(): return RedirectResponse(\"https://typer.tiangolo.com\") Or you can use it in the response_class parameter: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/fastapi\", response_class=RedirectResponse) async def redirect_fastapi(): return \"https://fastapi.tiangolo.com\" If you do that, then you can return the URL directly from your path operation function. In this case, the status_code used will be the default one for the RedirectResponse, which is 307. You can also use the status_code parameter combined with the response_class parameter: from fastapi import FastAPI from fastapi.responses import RedirectResponse app = FastAPI() @app.get(\"/pydantic\", response_class=RedirectResponse, status_code=302) async def redirect_pydantic(): return \"https://pydantic-docs.helpmanual.io/\" StreamingResponse¬∂ Takes an async generator or a normal generator/iterator and streams the response body. from fastapi import FastAPI from fastapi.responses import StreamingResponse app = FastAPI() async def fake_video_streamer(): for i in range(10): yield b\"some fake video bytes\" @app.get(\"/\") async def main(): return StreamingResponse(fake_video_streamer()) Using StreamingResponse with file-like objects¬∂ If you have a file-like object (e.g. the object returned by open()), you can create a generator function to iterate over that file-like object. That way, you don't have to read it all first in memory, and you can pass that generator function to the StreamingResponse, and return it. This includes many libraries to interact with cloud storage, video processing, and others. from fastapi import FastAPI from fastapi.responses import StreamingResponse some_file_path = \"large-video-file.mp4\" app = FastAPI() @app.get(\"/\") def main(): def iterfile(): # This is the generator function. It's a \"generator function\" because it contains yield statements inside. with open(some_file_path, mode=\"rb\") as file_like: # By using a with block, we make sure that the file-like object is closed after the generator function is done. So, after it finishes sending the response. yield from file_like # This yield from tells the function to iterate over that thing named file_like. And then, for each part iterated, yield that part as coming from this generator function. So, it is a generator function that transfers the \"generating\" work to something else internally. By doing it this way, we can put it in a with block, and that way, ensure that it is closed after finishing. return StreamingResponse(iterfile(), media_type=\"video/mp4\") Tip Notice that here as we are using standard open() that doesn't support async and await, we declare the path operation with normal def. FileResponse¬∂ Asynchronously streams a file as the response. Takes a different set of arguments to instantiate than the other response types: path - The filepath to the file to stream. headers - Any custom headers to include, as a dictionary. media_type - A string giving the media type. If unset, the filename or path will be used to infer a media type. filename - If set, this will be included in the response Content-Disposition. File responses will include appropriate Content-Length, Last-Modified and ETag headers. from fastapi import FastAPI from fastapi.responses import FileResponse some_file_path = \"large-video-file.mp4\" app = FastAPI() @app.get(\"/\") async def main(): return FileResponse(some_file_path) You can also use the response_class parameter: from fastapi import FastAPI from fastapi.responses import FileResponse some_file_path = \"large-video-file.mp4\" app = FastAPI() @app.get(\"/\", response_class=FileResponse) async def main(): return some_file_path In this case, you can return the file path directly from your path operation function. Custom response class¬∂ You can create your own custom response class, inheriting from Response and using it. For example, let's say that you want to use orjson, but with some custom settings not used in the included ORJSONResponse class. Let's say you want it to return indented and formatted JSON, so you want to use the orjson option orjson.OPT_INDENT_2. You could create a CustomORJSONResponse. The main thing you have to do is create a Response.render(content) method that returns the content as bytes: from typing import Any import orjson from fastapi import FastAPI, Response app = FastAPI() class CustomORJSONResponse(Response): media_type = \"application/json\" def render(self, content: Any) -> bytes: assert orjson is not None, \"orjson must be installed\" return orjson.dumps(content, option=orjson.OPT_INDENT_2) @app.get(\"/\", response_class=CustomORJSONResponse) async def main(): return {\"message\": \"Hello World\"} Now instead of returning: {\"message\": \"Hello World\"} ...this response will return: { \"message\": \"Hello World\" } Of course, you will probably find much better ways to take advantage of this than formatting JSON. üòâ Default response class¬∂ When creating a FastAPI class instance or an APIRouter you can specify which response class to use by default. The parameter that defines this is default_response_class. In the example below, FastAPI will use ORJSONResponse by default, in all path operations, instead of JSONResponse. from fastapi import FastAPI from fastapi.responses import ORJSONResponse app = FastAPI(default_response_class=ORJSONResponse) @app.get(\"/items/\") async def read_items(): return [{\"item_id\": \"Foo\"}] Tip You can still override response_class in path operations as before. Additional documentation¬∂ You can also declare the media type and many other details in OpenAPI using responses: Additional Responses in OpenAPI. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Return a Response Directly - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/response-directly/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Return a Response Directly en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Return a Response Using the jsonable_encoder in a Response Returning a custom Response Notes FastAPI Learn Advanced User Guide Return a Response Directly¬∂ When you create a FastAPI path operation you can normally return any data from it: a dict, a list, a Pydantic model, a database model, etc. By default, FastAPI would automatically convert that return value to JSON using the jsonable_encoder explained in JSON Compatible Encoder. Then, behind the scenes, it would put that JSON-compatible data (e.g. a dict) inside of a JSONResponse that would be used to send the response to the client. But you can return a JSONResponse directly from your path operations. It might be useful, for example, to return custom headers or cookies. Return a Response¬∂ In fact, you can return any Response or any sub-class of it. Tip JSONResponse itself is a sub-class of Response. And when you return a Response, FastAPI will pass it directly. It won't do any data conversion with Pydantic models, it won't convert the contents to any type, etc. This gives you a lot of flexibility. You can return any data type, override any data declaration or validation, etc. Using the jsonable_encoder in a Response¬∂ Because FastAPI doesn't do any change to a Response you return, you have to make sure it's contents are ready for it. For example, you cannot put a Pydantic model in a JSONResponse without first converting it to a dict with all the data types (like datetime, UUID, etc) converted to JSON-compatible types. For those cases, you can use the jsonable_encoder to convert your data before passing it to a response: from datetime import datetime from typing import Union from fastapi import FastAPI from fastapi.encoders import jsonable_encoder from fastapi.responses import JSONResponse from pydantic import BaseModel class Item(BaseModel): title: str timestamp: datetime description: Union[str, None] = None app = FastAPI() @app.put(\"/items/{id}\") def update_item(id: str, item: Item): json_compatible_item_data = jsonable_encoder(item) return JSONResponse(content=json_compatible_item_data) Technical Details You could also use from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. Returning a custom Response¬∂ The example above shows all the parts you need, but it's not very useful yet, as you could have just returned the item directly, and FastAPI would put it in a JSONResponse for you, converting it to a dict, etc. All that by default. Now, let's see how you could use that to return a custom response. Let's say that you want to return an XML response. You could put your XML content in a string, put it in a Response, and return it: from fastapi import FastAPI, Response app = FastAPI() @app.get(\"/legacy/\") def get_legacy_data(): data = \"\"\"Apply shampoo here. You'll have to use soap here. \"\"\" return Response(content=data, media_type=\"application/xml\") Notes¬∂ When you return a Response directly its data is not validated, converted (serialized), nor documented automatically. But you can still document it as described in Additional Responses in OpenAPI. You can see in later sections how to use/declare these custom Responses while still having automatic data conversion, documentation, etc. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Path Operation Advanced Configuration - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/path-operation-advanced-configuration/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Path Operation Advanced Configuration en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents OpenAPI operationId Using the path operation function name as the operationId Exclude from OpenAPI Advanced description from docstring Additional Responses OpenAPI Extra OpenAPI Extensions Custom OpenAPI path operation schema Custom OpenAPI content type FastAPI Learn Advanced User Guide Path Operation Advanced Configuration¬∂ OpenAPI operationId¬∂ Warning If you are not an \"expert\" in OpenAPI, you probably don't need this. You can set the OpenAPI operationId to be used in your path operation with the parameter operation_id. You would have to make sure that it is unique for each operation. from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", operation_id=\"some_specific_id_you_define\") async def read_items(): return [{\"item_id\": \"Foo\"}] Using the path operation function name as the operationId¬∂ If you want to use your APIs' function names as operationIds, you can iterate over all of them and override each path operation's operation_id using their APIRoute.name. You should do it after adding all your path operations. from fastapi import FastAPI from fastapi.routing import APIRoute app = FastAPI() @app.get(\"/items/\") async def read_items(): return [{\"item_id\": \"Foo\"}] def use_route_names_as_operation_ids(app: FastAPI) -> None: \"\"\" Simplify operation IDs so that generated API clients have simpler function names. Should be called only after all routes have been added. \"\"\" for route in app.routes: if isinstance(route, APIRoute): route.operation_id = route.name # in this case, 'read_items' use_route_names_as_operation_ids(app) Tip If you manually call app.openapi(), you should update the operationIds before that. Warning If you do this, you have to make sure each one of your path operation functions has a unique name. Even if they are in different modules (Python files). Exclude from OpenAPI¬∂ To exclude a path operation from the generated OpenAPI schema (and thus, from the automatic documentation systems), use the parameter include_in_schema and set it to False: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", include_in_schema=False) async def read_items(): return [{\"item_id\": \"Foo\"}] Advanced description from docstring¬∂ You can limit the lines used from the docstring of a path operation function for OpenAPI. Adding an f (an escaped \"form feed\" character) causes FastAPI to truncate the output used for OpenAPI at this point. It won't show up in the documentation, but other tools (such as Sphinx) will be able to use the rest. from typing import Set, Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Union[str, None] = None price: float tax: Union[float, None] = None tags: Set[str] = set() @app.post(\"/items/\", response_model=Item, summary=\"Create an item\") async def create_item(item: Item): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item f :param item: User input. \"\"\" return item Additional Responses¬∂ You probably have seen how to declare the response_model and status_code for a path operation. That defines the metadata about the main response of a path operation. You can also declare additional responses with their models, status codes, etc. There's a whole chapter here in the documentation about it, you can read it at Additional Responses in OpenAPI. OpenAPI Extra¬∂ When you declare a path operation in your application, FastAPI automatically generates the relevant metadata about that path operation to be included in the OpenAPI schema. Technical details In the OpenAPI specification it is called the Operation Object. It has all the information about the path operation and is used to generate the automatic documentation. It includes the tags, parameters, requestBody, responses, etc. This path operation-specific OpenAPI schema is normally generated automatically by FastAPI, but you can also extend it. Tip This is a low level extension point. If you only need to declare additional responses, a more convenient way to do it is with Additional Responses in OpenAPI. You can extend the OpenAPI schema for a path operation using the parameter openapi_extra. OpenAPI Extensions¬∂ This openapi_extra can be helpful, for example, to declare OpenAPI Extensions: from fastapi import FastAPI app = FastAPI() @app.get(\"/items/\", openapi_extra={\"x-aperture-labs-portal\": \"blue\"}) async def read_items(): return [{\"item_id\": \"portal-gun\"}] If you open the automatic API docs, your extension will show up at the bottom of the specific path operation. And if you see the resulting OpenAPI (at /openapi.json in your API), you will see your extension as part of the specific path operation too: { \"openapi\": \"3.1.0\", \"info\": { \"title\": \"FastAPI\", \"version\": \"0.1.0\" }, \"paths\": { \"/items/\": { \"get\": { \"summary\": \"Read Items\", \"operationId\": \"read_items_items__get\", \"responses\": { \"200\": { \"description\": \"Successful Response\", \"content\": { \"application/json\": { \"schema\": {} } } } }, \"x-aperture-labs-portal\": \"blue\" } } } } Custom OpenAPI path operation schema¬∂ The dictionary in openapi_extra will be deeply merged with the automatically generated OpenAPI schema for the path operation. So, you could add additional data to the automatically generated schema. For example, you could decide to read and validate the request with your own code, without using the automatic features of FastAPI with Pydantic, but you could still want to define the request in the OpenAPI schema. You could do that with openapi_extra: from fastapi import FastAPI, Request app = FastAPI() def magic_data_reader(raw_body: bytes): return { \"size\": len(raw_body), \"content\": { \"name\": \"Maaaagic\", \"price\": 42, \"description\": \"Just kiddin', no magic here. ‚ú®\", }, } @app.post( \"/items/\", openapi_extra={ \"requestBody\": { \"content\": { \"application/json\": { \"schema\": { \"required\": [\"name\", \"price\"], \"type\": \"object\", \"properties\": { \"name\": {\"type\": \"string\"}, \"price\": {\"type\": \"number\"}, \"description\": {\"type\": \"string\"}, }, } } }, \"required\": True, }, }, ) async def create_item(request: Request): raw_body = await request.body() data = magic_data_reader(raw_body) return data In this example, we didn't declare any Pydantic model. In fact, the request body is not even parsed as JSON, it is read directly as bytes, and the function magic_data_reader() would be in charge of parsing it in some way. Nevertheless, we can declare the expected schema for the request body. Custom OpenAPI content type¬∂ Using this same trick, you could use a Pydantic model to define the JSON Schema that is then included in the custom OpenAPI schema section for the path operation. And you could do this even if the data type in the request is not JSON. For example, in this application we don't use FastAPI's integrated functionality to extract the JSON Schema from Pydantic models nor the automatic validation for JSON. In fact, we are declaring the request content type as YAML, not JSON: Pydantic v2 Pydantic v1 from typing import List import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError app = FastAPI() class Item(BaseModel): name: str tags: List[str] @app.post( \"/items/\", openapi_extra={ \"requestBody\": { \"content\": {\"application/x-yaml\": {\"schema\": Item.model_json_schema()}}, \"required\": True, }, }, ) async def create_item(request: Request): raw_body = await request.body() try: data = yaml.safe_load(raw_body) except yaml.YAMLError: raise HTTPException(status_code=422, detail=\"Invalid YAML\") try: item = Item.model_validate(data) except ValidationError as e: raise HTTPException(status_code=422, detail=e.errors()) return item Info In Pydantic version 1 the method to get the JSON Schema for a model was called Item.schema(), in Pydantic version 2, the method is called Item.model_schema_json(). Nevertheless, although we are not using the default integrated functionality, we are still using a Pydantic model to manually generate the JSON Schema for the data that we want to receive in YAML. Then we use the request directly, and extract the body as bytes. This means that FastAPI won't even try to parse the request payload as JSON. And then in our code, we parse that YAML content directly, and then we are again using the same Pydantic model to validate the YAML content: Pydantic v2 Pydantic v1 from typing import List import yaml from fastapi import FastAPI, HTTPException, Request from pydantic import BaseModel, ValidationError app = FastAPI() class Item(BaseModel): name: str tags: List[str] @app.post( \"/items/\", openapi_extra={ \"requestBody\": { \"content\": {\"application/x-yaml\": {\"schema\": Item.model_json_schema()}}, \"required\": True, }, }, ) async def create_item(request: Request): raw_body = await request.body() try: data = yaml.safe_load(raw_body) except yaml.YAMLError: raise HTTPException(status_code=422, detail=\"Invalid YAML\") try: item = Item.model_validate(data) except ValidationError as e: raise HTTPException(status_code=422, detail=e.errors()) return item Info In Pydantic version 1 the method to parse and validate an object was Item.parse_obj(), in Pydantic version 2, the method is called Item.model_validate(). Tip Here we re-use the same Pydantic model. But the same way, we could have validated it in some other way. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Additional Status Codes - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/additional-status-codes/",
    "html": "Skip to content You can now sponsor FastAPI üç∞ sponsor FastAPI Additional Status Codes en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional status codes OpenAPI and API docs FastAPI Learn Advanced User Guide Additional Status Codes¬∂ By default, FastAPI will return the responses using a JSONResponse, putting the content you return from your path operation inside of that JSONResponse. It will use the default status code or the one you set in your path operation. Additional status codes¬∂ If you want to return additional status codes apart from the main one, you can do that by returning a Response directly, like a JSONResponse, and set the additional status code directly. For example, let's say that you want to have a path operation that allows to update items, and returns HTTP status codes of 200 \"OK\" when successful. But you also want it to accept new items. And when the items didn't exist before, it creates them, and returns an HTTP status code of 201 \"Created\". To achieve that, import JSONResponse, and return your content there directly, setting the status_code that you want: Python 3.10+ Python 3.9+ Python 3.8+ Python 3.10+ non-Annotated Python 3.8+ non-Annotated from typing import Annotated from fastapi import Body, FastAPI, status from fastapi.responses import JSONResponse app = FastAPI() items = {\"foo\": {\"name\": \"Fighters\", \"size\": 6}, \"bar\": {\"name\": \"Tenders\", \"size\": 3}} @app.put(\"/items/{item_id}\") async def upsert_item( item_id: str, name: Annotated[str | None, Body()] = None, size: Annotated[int | None, Body()] = None, ): if item_id in items: item = items[item_id] item[\"name\"] = name item[\"size\"] = size return item else: item = {\"name\": name, \"size\": size} items[item_id] = item return JSONResponse(status_code=status.HTTP_201_CREATED, content=item) Warning When you return a Response directly, like in the example above, it will be returned directly. It won't be serialized with a model, etc. Make sure it has the data you want it to have, and that the values are valid JSON (if you are using JSONResponse). Technical Details You could also use from starlette.responses import JSONResponse. FastAPI provides the same starlette.responses as fastapi.responses just as a convenience for you, the developer. But most of the available responses come directly from Starlette. The same with status. OpenAPI and API docs¬∂ If you return additional status codes and responses directly, they won't be included in the OpenAPI schema (the API docs), because FastAPI doesn't have a way to know beforehand what you are going to return. But you can document that in your code, using: Additional Responses. Made with Material for MkDocs Insiders"
  },
  {
    "title": "Advanced User Guide - FastAPI",
    "url": "https://fastapi.tiangolo.com/advanced/",
    "html": "Skip to content Subscribe to the FastAPI and friends newsletter üéâ sponsor FastAPI Advanced User Guide en - English de üòâ es - espa√±ol fa fr - fran√ßais he id ja - Êó•Êú¨Ë™û ko - ÌïúÍµ≠Ïñ¥ pl pt - portugu√™s ru - —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ tr - T√ºrk√ße uk ur vi - Ti·∫øng Vi·ªát yo - Yor√πb√° zh - Ê±âËØ≠ Initializing search tiangolo/fastapi FastAPI Features Learn Reference - Code API FastAPI People Resources About Help Release Notes Learn Python Types Intro Concurrency and async / await Tutorial - User Guide Advanced User Guide Path Operation Advanced Configuration Additional Status Codes Return a Response Directly Custom Response - HTML, Stream, File, others Additional Responses in OpenAPI Response Cookies Response Headers Response - Change Status Code Advanced Dependencies Advanced Security Using the Request Directly Using Dataclasses Advanced Middleware Sub Applications - Mounts Behind a Proxy Templates WebSockets Lifespan Events Testing WebSockets Testing Events: startup - shutdown Testing Dependencies with Overrides Testing a Database Async Tests Settings and Environment Variables OpenAPI Callbacks OpenAPI Webhooks Including WSGI - Flask, Django, others Generate Clients Deployment How To - Recipes Table of contents Additional Features Read the Tutorial first External Courses FastAPI Learn Advanced User Guide Advanced User Guide¬∂ Additional Features¬∂ The main Tutorial - User Guide should be enough to give you a tour through all the main features of FastAPI. In the next sections you will see other options, configurations, and additional features. Tip The next sections are not necessarily \"advanced\". And it's possible that for your use case, the solution is in one of them. Read the Tutorial first¬∂ You could still use most of the features in FastAPI with the knowledge from the main Tutorial - User Guide. And the next sections assume you already read it, and assume that you know those main ideas. External Courses¬∂ Although the Tutorial - User Guide and this Advanced User Guide are written as a guided tutorial (like a book) and should be enough for you to learn FastAPI, you might want to complement it with additional courses. Or it might be the case that you just prefer to take other courses because they adapt better to your learning style. Some course providers ‚ú® sponsor FastAPI ‚ú®, this ensures the continued and healthy development of FastAPI and its ecosystem. And it shows their true commitment to FastAPI and its community (you), as they not only want to provide you a good learning experience but also want to make sure you have a good and healthy framework, FastAPI. üôá You might want to try their courses: Talk Python Training Test-Driven Development Made with Material for MkDocs Insiders"
  }
]